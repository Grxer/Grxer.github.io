<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="基本上每天一个文件吧 RTFSC有makefile https:&#x2F;&#x2F;github.com&#x2F;cyysu&#x2F;linux0.11&#x2F;tree&#x2F;master无makefile https:&#x2F;&#x2F;github.com&#x2F;beride&#x2F;linux0.11-1 可编译调试的 https:&#x2F;&#x2F;github.com&#x2F;yuan-xy&#x2F;Linux-0.11 从服务器启动qemu无图形界面: -curses(在教室开虚拟机太耗">
<meta property="og:type" content="article">
<meta property="og:title" content="linux0.11内核源码阅读">
<meta property="og:url" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/index.html">
<meta property="og:site_name" content="Grxer&#39;s Blog">
<meta property="og:description" content="基本上每天一个文件吧 RTFSC有makefile https:&#x2F;&#x2F;github.com&#x2F;cyysu&#x2F;linux0.11&#x2F;tree&#x2F;master无makefile https:&#x2F;&#x2F;github.com&#x2F;beride&#x2F;linux0.11-1 可编译调试的 https:&#x2F;&#x2F;github.com&#x2F;yuan-xy&#x2F;Linux-0.11 从服务器启动qemu无图形界面: -curses(在教室开虚拟机太耗">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231123112231893.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231123215714223.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231123215220376.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231124110911039.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231124170448393.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231130125348019.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231202124200694.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231202124403747.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231202125100060.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231204095432853.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231228231131848.png">
<meta property="og:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20240227200219711.png">
<meta property="article:published_time" content="2024-02-22T08:10:28.000Z">
<meta property="article:modified_time" content="2024-03-24T09:10:39.268Z">
<meta property="article:author" content="bxz">
<meta property="article:tag" content="RTFSC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/image-20231123112231893.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>linux0.11内核源码阅读</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 lrt">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/12/windows-kernel-x64/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/11/27/open-vt/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&text=linux0.11内核源码阅读"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&is_video=false&description=linux0.11内核源码阅读"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=linux0.11内核源码阅读&body=Check out this article: https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&name=linux0.11内核源码阅读&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&t=linux0.11内核源码阅读"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RTFSC"><span class="toc-number">1.</span> <span class="toc-text">RTFSC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#boot"><span class="toc-number">2.</span> <span class="toc-text">boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bootsect-s"><span class="toc-number">2.1.</span> <span class="toc-text">bootsect.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-s"><span class="toc-number">2.2.</span> <span class="toc-text">setup.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#head-s"><span class="toc-number">2.3.</span> <span class="toc-text">head.s</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init"><span class="toc-number">3.</span> <span class="toc-text">init</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main-c"><span class="toc-number">3.1.</span> <span class="toc-text">main.c</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel"><span class="toc-number">4.</span> <span class="toc-text">kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#asm-s"><span class="toc-number">4.1.</span> <span class="toc-text">asm.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trap-s"><span class="toc-number">4.2.</span> <span class="toc-text">trap.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system-call-s"><span class="toc-number">4.3.</span> <span class="toc-text">system_call.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sched-c"><span class="toc-number">4.4.</span> <span class="toc-text">sched.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#signal-c"><span class="toc-number">4.5.</span> <span class="toc-text">signal.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exit-c"><span class="toc-number">4.6.</span> <span class="toc-text">exit.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-c"><span class="toc-number">4.7.</span> <span class="toc-text">fork.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-c"><span class="toc-number">4.8.</span> <span class="toc-text">sys.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vsprintf-c"><span class="toc-number">4.9.</span> <span class="toc-text">vsprintf.c</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-blk-drv"><span class="toc-number">5.</span> <span class="toc-text">kernel blk_drv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm"><span class="toc-number">6.</span> <span class="toc-text">mm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-c"><span class="toc-number">6.1.</span> <span class="toc-text">memory.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-s"><span class="toc-number">6.2.</span> <span class="toc-text">page.s</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fs"><span class="toc-number">7.</span> <span class="toc-text">fs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer-c"><span class="toc-number">7.1.</span> <span class="toc-text">buffer.c</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        linux0.11内核源码阅读
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">bxz</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-02-22T08:10:28.000Z" itemprop="datePublished">2024-02-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/RTFSC/" rel="tag">RTFSC</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p> 基本上每天一个文件吧</p>
<h1 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h1><p>有makefile <a target="_blank" rel="noopener" href="https://github.com/cyysu/linux0.11/tree/master">https://github.com/cyysu/linux0.11/tree/master</a><br>无makefile <a target="_blank" rel="noopener" href="https://github.com/beride/linux0.11-1">https://github.com/beride/linux0.11-1</a></p>
<p>可编译调试的 <a target="_blank" rel="noopener" href="https://github.com/yuan-xy/Linux-0.11">https://github.com/yuan-xy/Linux-0.11</a></p>
<p>从服务器启动qemu无图形界面: -curses(在教室开虚拟机太耗电了，只能开云服务器,学校的网还卡艹)</p>
<ul>
<li>alt 2切换到监视 alt 1切换会模拟界面</li>
<li>esc 2和esc 1 同样效果</li>
</ul>
<p>vscode配置</p>
<p>launch.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/tools/system&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>tasks.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make ; and make debug &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h1 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h1><h2 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h2><p>8086汇编 <code>ljmp   0x7c0:5</code>将cs&#x3D;0x7c0 ip&#x3D;5 跳转到新的代码段和偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ok1_read:</span><br><span class="line">;// 计算和验证当前磁道需要读取的扇区数，放在ax寄存器中。</span><br><span class="line">;// 根据当前磁道还未读取的扇区数以及段内数据字节开始偏移位置，计算如果全部读取这些</span><br><span class="line">;// 未读扇区，所读总字节数是否会超过64KB段长度的限制。若会超过，则根据此次最多能读</span><br><span class="line">;// 入的字节数（64KB - 段内偏移位置），反算出此次需要读取的扇区数。</span><br><span class="line">;//    seg cs</span><br><span class="line">    mov ax,cs:sectors		;// 取每磁道扇区数。</span><br><span class="line">    sub ax,sread		;// 减去当前磁道已读扇区数。</span><br><span class="line">    mov dx,ax			;// ax = 当前磁道未读扇区数。</span><br><span class="line">    mov cl,9</span><br><span class="line">    shl dx,cl			;// dx = ax * 512 字节。</span><br><span class="line">    add dx,bx			;// dx = dx + 段内当前偏移值（bx）</span><br><span class="line">                        ;//    = 此次读操作后，段内共读入的字节数。</span><br><span class="line">    jnc ok2_read		;// 若没有超过64KB字节，则跳转至ok2_read处执行。</span><br><span class="line">    je ok2_read</span><br><span class="line">    xor ax,ax			;// 若加上此次将读磁道上所有未读扇区时会超过64KB，则计算</span><br><span class="line">    sub ax,bx			;// 此时最多能读入的字节数（64KB － 段内读偏移位置），再转换</span><br><span class="line">    shr ax,cl			;// 成需要读取的扇区数。</span><br></pre></td></tr></table></figure>

<p>因为实模式下寄存器最多寻址64kb，所以需要判断是否需要修改段寄存器,这里我觉得比较有意思的是直接用0减去段内偏移，再把结果当作无符号数做运算得到需要读取扇区数</p>
<p><code>sub ax,bx</code>ax为0时相当于得到bx的补码也就相当于做了无符号运算0x1 0000-bx，由于寄存器位数限制无法直接操作0x1 0000，感觉这种方法确实好</p>
<h2 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h2><p>准备进入保护模式前先关了中断，这是因为此时idtr寄存器指向0，即bios的中断向量表，后面setup把system移动到0x0处，会覆盖掉这个表，中断也就g了</p>
<p>然后加载中断描述符表和全局描述符表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lidt fword ptr idt_48            ;// 加载中断描述符表(idt)寄存器，idt_48 是6 字节操作数的位置</span><br><span class="line">;// 前2 字节表示idt 表的限长，后4 字节表示idt 表所处的基地址。</span><br><span class="line">lgdt fword ptr gdt_48            ;// 加载全局描述符表(gdt)寄存器，gdt_48 是6 字节操作数的位置</span><br></pre></td></tr></table></figure>

<p>lidt lgdt 前两个字节是描述符表的长度限制，后四个字节是描述符表的线性基地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idt_48:</span><br><span class="line">    dw	0			;// idt limit=0</span><br><span class="line">    dw	0,0			;// idt base=0L </span><br><span class="line">gdt_48:</span><br><span class="line">    dw	800h		;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项 所以表中共可有256 项。</span><br><span class="line">    dw	512+gdt,9h	;// 小端序，4个字节构成的内存线性地址：0009&lt;&lt;16 + 0200+gdt 也即90200 + gdt标号。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    dw	0,0,0,0		;// 第0 个描述符，不用。</span><br><span class="line">;// 这里在gdt 表中的偏移量为08，当加载代码段寄存器(段选择符)时，使用的是这个偏移值。</span><br><span class="line">    dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    dw	0000h		;// base address=0</span><br><span class="line">    dw	9A00h		;// code read/exec</span><br><span class="line">    dw	00C0h		;// granularity=4096, 386</span><br><span class="line">;// 这里在gdt 表中的偏移量是10，当加载数据段寄存器(如ds 等)时，使用的是这个偏移值。</span><br><span class="line">    dw	07FFh		;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    dw	0000h		;// base address=0</span><br><span class="line">    dw	9200h		;// data read/write</span><br><span class="line">    dw	00C0h		;// granularity=4096, 386</span><br></pre></td></tr></table></figure>

<p>第1个描述符00C0 9A00 0000 07FF 代码段描述符 基地址:0x0000 0000 DPL&#x3D;0 非一致性代码段 </p>
<p>第2个描述符00C0 9200 0000 07FF 数据段描述符 基地址:0x0000 0000 DPL&#x3D;0 向上扩展的数据段 </p>
<p>lmsw来给cr0的PE赋值启用保护模式标志，lmsw是为了兼容80286，386及以上推荐用mov cr0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    ax,0001h	;// 保护模式比特位(PE)。</span><br><span class="line">lmsw ax            ;// 就这样加载机器状态字</span><br><span class="line">jmp 8:0          ;// 跳转至cs 段8，偏移0 处。执行system 中的代码</span><br></pre></td></tr></table></figure>

<p>cs段选择子为8即000000001 0 00 </p>
<ul>
<li>TI位为0 表示是全局描述符里的1个描述符</li>
<li>RPL&#x3D;0</li>
</ul>
<p>跳转到0地址处system模块执行</p>
<h2 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h2><p>程序所在物理地址为0，而且此时还没开启分页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lss esp,_stack_start    ;<span class="comment">// 表示_stack_start -&gt; ss:esp，设置系统堆栈。</span></span><br></pre></td></tr></table></figure>

<p>_stack_start定义在kernel&#x2F;sched.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>];    <span class="comment">// 定义系统堆栈指针，4K。指针指在最后一项。</span></span><br><span class="line">stack_start = &#123;&amp;user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>], <span class="number">0x10</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>lss指令把stack_start 前四字节装入ESP寄存器，后两字节装入SS</p>
</blockquote>
<p>重新设置了idt表和gdt表后(只是把表长变为了16M),因为前面0地址处的代码已经执行完了就没用了，所以用来做了页目录表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_pg_dir:        ;<span class="comment">// 页目录将会存放在这里。</span></span><br></pre></td></tr></table></figure>

<p>并且在后面设置了4个页表来描述16M的物理内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org 1000h        ;// 从偏移0x1000 处开始是第1 个页表（偏移0 开始处将存放页表目录）。</span><br><span class="line">pg0:</span><br><span class="line"></span><br><span class="line">org 2000h</span><br><span class="line">pg1:</span><br><span class="line"></span><br><span class="line">org 3000h</span><br><span class="line">pg2:</span><br><span class="line"></span><br><span class="line">org 4000h</span><br><span class="line">pg3:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>stosb, stosw, stosd。这三个指令把al ax eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少</p>
</blockquote>
<p>设置页目录项和页表具体操作是先把这5个表清零，然后把页目录表项前四项填上值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,_pg_dir</span><br><span class="line">mov [eax],pg0+7    ;页目录项，前20位表示页表基址，后面的12位为7表示了属性:在物理内存 普通用户可读可写	</span><br><span class="line">mov [eax+4],pg1+7        </span><br><span class="line">mov [eax+8],pg2+7        </span><br><span class="line">mov [eax+12],pg3+7        </span><br></pre></td></tr></table></figure>

<p>设置页表项时倒叙从pag3最后一项开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edi,pg3+4092        ;// edi -&gt; 最后一页的最后一项。</span><br><span class="line">mov eax,00fff007h        ;/*  16Mb - 4096 + 7 (r/w user,p) */</span><br><span class="line">;4092-4096是最后一个页表项，此处填写00fff007h来描述16M物理地址最后一个4k属性为在物理内存 普通用户可读可写</span><br></pre></td></tr></table></figure>

<p>把页目录的前四项这样去映射说明了这个任务的前16M线性地址等于物理地址</p>
<p>最后设置cr3指向物理地址0即页目录，然后设置cr0 pg位开启分页保护 ret到main函数</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231123112231893.png" alt="image-20231123112231893"></p>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>linux0.11管理的最大物理内存是16M，对于不同大小的内存的区域划分是不一样的，以16M物理内存来说</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231123215714223.png" alt="image-20231123215714223"></p>
<p>mem_map用来管理除了内核外的15M内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存映射字节图(1 字节代表1 页内存)，每个页面对应的字节用于标志页面当前被引用（占用）次数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="number">0</span>,&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>mem_init</strong>函数过后把3M缓冲区和虚拟盘所在的mem_map字节置为<strong>USED</strong>宏表示<em>页面被占用标志</em>，主内存区mem_map置为0</p>
<p><strong>trap_init</strong>函数初始化了中断描述符表，中断描述符TYPE位均为1111即为陷阱门，目标代码段描述符选择子均为8(RPL&#x3D;0，TI&#x3D;0,索引&#x3D;1)，，其中<em>3-5</em>号中断描述符的dpl设置为3，其余为0</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231123215220376.png" alt="image-20231123215220376"></p>
<blockquote>
<p>调用INT3 int n INTO等指令产生的中断或异常检测要求</p>
<ul>
<li>先检测当前特权级CPL&lt;&#x3D;中断描述符里的DPL</li>
<li>再检测中断描述符里代码段描述符选择子的RPL &lt; 当前特权级CPL</li>
</ul>
<p>由硬件产生的中断或处理器检测到的异常检测要求</p>
<ul>
<li>中断描述符里代码段描述符选择子的RPL &lt; 当前特权级CPL</li>
</ul>
<p>陷阱门和中断门唯一区别就是中断门处理时会把IF位清零(关中断)，陷阱门不会</p>
</blockquote>
<p><strong>sched_init</strong>初始化了任务0在全局描述符表gdt的tss和ldt分别为0x00008901f4480068	0x00008201f4300068</p>
<p>0x00008901f4480068: S&#x3D;0 TYPE:1001 为tss段描述符</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231124110911039.png" alt="image-20231124110911039"></p>
<p>0x00008201f4300068 : S&#x3D;0 TYPE:0010 为 ldt描述符</p>
<p>tss和ldt描述符的基地址都是该任务task_struct结构体里的成员的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ..............</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后把task数组除了第一个任务都清空，再把其余gdt表项都清空，把eflags寄存器的NT位置零，防止后面在iret到用户态时时进行任务切换，把tr寄存器设置为任务0的tss</p>
<p>对于寻找tss的宏一般人都会这样写<code>#define _TSS2(n) (FIRST_TSS_ENTRY+2*n)&lt;&lt;3</code></p>
<p>linus的写法<code>#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))</code>感觉对于当时性能可能会高些，但是现在编译器优化的bt程度可能性能上没有差别</p>
<blockquote>
<p>ltr val指令会把gdt里索引val tss描述符基地址和段限长加载，并把TYPE的B置1，表示任务正忙</p>
</blockquote>
<p>设置ldtr寄存器指向任务0的ldt</p>
<p>设置并允许时钟中断处理，设置系统调用中断0x80(陷阱门，DPL&#x3D;3)</p>
<p>TODO</p>
<p>利用iret中断返回切换到用户态</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231124170448393.png" alt="image-20231124170448393"></p>
<p>init_task的ldt为<strong>INIT_TASK</strong>宏里ldt[1]&#x3D;0x00c0fa000000009f ldt[2]&#x3D;0x00c0f2000000009f</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ldt[3]*/</span>    &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, \</span><br><span class="line">    &#123;<span class="number">0x9f</span>, <span class="number">0xc0fa00</span>&#125;, <span class="comment">/* 代码长640K，基址0x0，G=1，D=1，DPL=3，P=1 TYPE=0x0a*/</span>  \</span><br><span class="line">    &#123; <span class="number">0x9f</span>, <span class="number">0xc0f200</span>&#125;,&#125;, <span class="comment">/* 数据长640K，基址0x0，G=1，D=1，DPL=3，P=1 TYPE=0x02*/</span>   \</span><br></pre></td></tr></table></figure>

<p>堆栈段选择符SS:0x17:00010 1 11 代码段选择符为0xf:1 1 11分别对应ldt里的第二项和第一项</p>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h2 id="asm-s"><a href="#asm-s" class="headerlink" title="asm.s"></a>asm.s</h2><p>at&amp;t语法差别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xchgl %eax,(%esp) eax和esp栈顶里的值交互</span><br><span class="line">lea 44(%esp),%edx edx=esp+44</span><br><span class="line">call *%eax 调用eax寄存器里的地址 eip=eax，相当于intel的call eax</span><br><span class="line">*  https://stackoverflow.com/questions/62813954/warning-indirect-call-without</span><br></pre></td></tr></table></figure>

<p>对于无错误码的中断压入0作为默认错误码，这样统一起来处理比较简单(保存现场，传递两个参数old_esp就是cpu帮我们压入几个寄存器的eip的位置,和error_code)</p>
<h2 id="trap-s"><a href="#trap-s" class="headerlink" title="trap.s"></a>trap.s</h2><p>疑惑的点大多是gcc的“语法”和一些不常见的asm inst</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_seg_long(seg,addr) (&#123; \</span></span><br><span class="line"><span class="meta">register unsigned long __res; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs&quot;</span> \</span></span><br><span class="line"><span class="meta">    :<span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//表示asm块执行完后把eax值给到__res变量</span></span></span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (seg),<span class="string">&quot;m&quot;</span> (*(addr))); \</span><br><span class="line">    <span class="comment">//0表示使用与上一个位置相同的寄存器但是seg的编号仍然是%1，所以&quot;0&quot; (seg)表示asm块里语句执行前把seg加载进eax</span></span><br><span class="line">    <span class="comment">//&quot;m&quot; (*(addr)) 表示一个内存偏移地址值</span></span><br><span class="line">__res;&#125;)<span class="comment">//返回值为__res</span></span><br></pre></td></tr></table></figure>

<p>首先就是({…})的语句块，语义上这个语句块等于一条语句，语句块的局部变量随语句块结束失效，语句块最后一个表达式就是这个语句块的返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v = x+(&#123;<span class="built_in">puts</span>(<span class="string">&quot;gr&quot;</span>);z+<span class="number">3</span>;&#125;)+y 等价于 v= x+z+<span class="number">3</span>+y</span><br></pre></td></tr></table></figure>

<p>lsl指令 load segment limit</p>
<p>str指令 store task regist</p>
<p>TODO 暂时没读懂的点: die里str(i)如何获取任务号</p>
<h2 id="system-call-s"><a href="#system-call-s" class="headerlink" title="system_call.s"></a>system_call.s</h2><p>syscall的时候fs寄存器保持了三环状态，可以用来访问用户数据</p>
<p>用push和jmp模拟可指定返回地址的call</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pushl $ret_from_sys_call</span><br><span class="line">jmp schedule</span><br></pre></td></tr></table></figure>

<p>sys_execve和sys_fork是个系统调用不是中断，用了ret而不是iret，(可能是不想单独再开个asm文件写)</p>
<h2 id="sched-c"><a href="#sched-c" class="headerlink" title="sched.c"></a>sched.c</h2><p>**show_task()**函数</p>
<p>要理解j &#x3D; 4096-sizeof(struct task_struct);需要看下面的联合体 可以看出j就是栈的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span></span></span><br><span class="line"><span class="class">&#123;</span>                <span class="comment">// 定义任务联合(任务结构成员和stack 字符数组程序成员)。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span>	<span class="comment">// 因为一个任务数据结构与其堆栈放在同一内存页中，所以</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];	<span class="comment">// 从堆栈段寄存器ss 可以获得其数据段选择符。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后面就是(p + 1)也就是跳过这个结构体，去得到未使用的栈大小，因为栈是从高地址往低地址长的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; !((<span class="type">char</span> *) (p + <span class="number">1</span>))[i])    <span class="comment">// 检测指定任务数据结构以后等于0 的字节数。</span></span><br><span class="line">    i++;</span><br></pre></td></tr></table></figure>

<p>**schedule()**函数</p>
<p>里首先比较了每个任务的task_struct-&gt;alarm和全局的滴答数字jiffies，小于则设置SIGALRM信号，jiffies是从开机到现在的滴答数，10ms一次的时钟中断用<strong>sys_call.s里的_timer_interrupt中断处理会把jiffies+1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">_BLOCKABLE宏展开是<span class="number">0xfffbfeff</span> 再&amp;上block取非 再 &amp;信号 相当于取了信号位图中除被阻塞的信号外的其它信号</span><br></pre></td></tr></table></figure>

<p>然后比较得到任务中最大的时间片task-&gt;count，switch_to函数切换到该任务(使用ljmp tss切换的，会把当前寄存器现场写到当前tss段（也就是说switch_to函数在下次该任务调度前不会返回)，然后恢复ljmp指定tss的现场执行)</p>
<p>如果时间片都为0则用counter &#x3D; counter &#x2F;2 + priority赋值时间片，再次循环</p>
<p><strong>sleep_on函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span> <span class="params">(<span class="keyword">struct</span> task_struct **p)</span><span class="comment">//*p是因为正在等待某个资源而睡眠的任务的队列链表的头部</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span><span class="comment">//栈上形成的临时节点，就相当于链表的next指针啦</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若指针无效，则退出。（指针所指的对象可以是NULL，但指针本身不会为0)。</span></span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (current == &amp;(init_task.task))	<span class="comment">// 如果当前任务是任务0，则死机(impossible!)。</span></span><br><span class="line">        panic (<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">    tmp = *p;			<span class="comment">// 让tmp 指向已经在等待队列上的任务(如果有的话)。</span></span><br><span class="line">    *p = current;			<span class="comment">// 当前任务调用了，所有将睡眠队列头的等待指针指向当前任务。</span></span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE;	<span class="comment">// 将当前任务置为不可中断的等待状态。</span></span><br><span class="line">    schedule ();			<span class="comment">// 重新调度。</span></span><br><span class="line"><span class="comment">// 只有当这个等待任务被唤醒时，调度程序才又返回到这里，则表示进程已被明确地唤醒。</span></span><br><span class="line"><span class="comment">// 既然大家都在等待同样的资源，那么在资源可用时，就有必要唤醒所有等待该资源的进程。该函数</span></span><br><span class="line"><span class="comment">// 嵌套调用，也会嵌套唤醒所有等待该资源的进程。然后系统会根据这些进程的优先条件，重新调度</span></span><br><span class="line"><span class="comment">// 应该由哪个进程首先使用资源。也即让这些进程竞争上岗。</span></span><br><span class="line">    <span class="keyword">if</span> (tmp)			<span class="comment">// 若还存在等待的任务，则也将其置为就绪状态（唤醒）。</span></span><br><span class="line">        tmp-&gt;state = TASK_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p可以类似于是<code>static struct task_struct *wait_motor[4] = &#123; NULL, NULL, NULL, NULL &#125;;</code>，这个数组就相当于四个链表头</p>
<p>*p和当前任务的栈上的tmp指针就会形成下面等待某一个资源的任务链表<img src="/2024/02/22/RTFSC-linux-11/image-20231130125348019.png" alt="image-20231130125348019"></p>
<p>当资源可以被抢占后，上图中的*p指向的”当前任务“返回执行调度前的代码,就可以从当前栈上访问到tmp了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tmp)            <span class="comment">// 若还存在等待的任务，则也将其置为就绪状态（唤醒）。</span></span><br><span class="line">        tmp-&gt;state = TASK_RUNNING;</span><br></pre></td></tr></table></figure>

<p>也就是把task2的state置为可调度状态，task2被调度执行时，task2重复“当前任务”上面的过程，把task1的state置为可调度，task1的tmp&#x3D;0，说明他是第一个等待该资源的任务，没用上一个了</p>
<p><strong>interruptible_sleep_on()函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">repeat:    current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;<span class="comment">//先唤醒当前任务进入等待队列链表之后进入的任务</span></span><br><span class="line">        (**p).state = TASK_RUNNING;</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    *p=tmp;<span class="comment">//执行到这里说明*p=current，下面几句代码就可以把等待链表里的任务FIFO的方式被调度</span></span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">        tmp-&gt;state=TASK_RUNNING;</span><br></pre></td></tr></table></figure>

<h2 id="signal-c"><a href="#signal-c" class="headerlink" title="signal.c"></a>signal.c</h2><p>首先是signal.h里的一个难理解的函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> _signr, <span class="type">void</span> (*_handle)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//这里void (*和后面的(int)是声明signal的返回值是一个void(*func)(int)类型的函数指针</span></span><br></pre></td></tr></table></figure>

<p>写成下面的方式更容易理解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">sigfun</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">sigfun *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> signr,sigfun *handle)</span></span><br></pre></td></tr></table></figure>

<p><strong>do_signal()函数</strong></p>
<p>do_signal函数是在system_call.s中ret_from_sys_call检测到current-&gt;signal有信号时被调用，do_signal的参数也是在那里压入栈的</p>
<p>do_signal里巧妙处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(&amp;eip) = sa_handler;<span class="comment">//改掉进入中断时处理器帮助我们压入的eip，这样返回到ret_from_sys_call里iret时就会执行用户态的信号处理函数</span></span><br><span class="line">longs = (sa-&gt;sa_flags &amp; SA_NOMASK)?<span class="number">7</span>:<span class="number">8</span>;<span class="comment">//和下面if判断有关</span></span><br><span class="line">*(&amp;esp) -= longs;<span class="comment">//构造堆栈控制执行流</span></span><br><span class="line">verify_area(esp,longs*<span class="number">4</span>);</span><br><span class="line">tmp_esp=esp;</span><br><span class="line">put_fs_long((<span class="type">long</span>) sa-&gt;sa_restorer,tmp_esp++);<span class="comment">//相当于sa_handler的返回地址</span></span><br><span class="line">put_fs_long(signr,tmp_esp++);<span class="comment">//sa_handler的第一个参数</span></span><br><span class="line"><span class="keyword">if</span> (!(sa-&gt;sa_flags &amp; SA_NOMASK))<span class="comment">//没有设置SA_NOMASK即不允许信号自己的处理句柄收到信号自己</span></span><br><span class="line">    put_fs_long(current-&gt;blocked,tmp_esp++);</span><br><span class="line">put_fs_long(eax,tmp_esp++);<span class="comment">//保护系统调用返回值</span></span><br><span class="line">put_fs_long(ecx,tmp_esp++);<span class="comment">//保护寄存器</span></span><br><span class="line">put_fs_long(edx,tmp_esp++);<span class="comment">//保护寄存器</span></span><br><span class="line">put_fs_long(eflags,tmp_esp++);<span class="comment">//保护寄存器</span></span><br><span class="line">put_fs_long(old_eip,tmp_esp++);<span class="comment">//处理完信号用来返回到用户程序处继续执行</span></span><br><span class="line">current-&gt;blocked |= sa-&gt;sa_mask;</span><br></pre></td></tr></table></figure>

<p>此时栈的情况</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231202124200694.png" alt="image-20231202124200694"></p>
<p>要理解<code>if (!(sa-&gt;sa_flags &amp; SA_NOMASK))//没有设置SA_NOMASK即允许信号自己的处理句柄收到信号自己</code>需要看下面的<strong>sys_sigaction</strong>函数里的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current-&gt;sigaction[signum - <span class="number">1</span>].sa_flags &amp; SA_NOMASK)</span><br><span class="line">    current-&gt;sigaction[signum - <span class="number">1</span>].sa_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    current-&gt;sigaction[signum - <span class="number">1</span>].sa_mask |= (<span class="number">1</span> &lt;&lt; (signum - <span class="number">1</span>));<span class="comment">//没有设置SA_NOMASK会设置屏蔽码</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>do_signal最后一句<code>current-&gt;blocked |= sa-&gt;sa_mask;设置阻塞当前信号</code>，这里<code>put_fs_long(current-&gt;blocked,tmp_esp++);</code>保存主要是为了信号处理完后恢复阻塞，从而避免了传统sys_signal的问题</p>
<p>sa_restorer也根据是否设置SA_NOMASK分为下面两种情况</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231202124403747.png" alt="image-20231202124403747"></p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231202125100060.png" alt="image-20231202125100060"></p>
<p>此时设置了SA_NOMASK会调用signal.c的<strong>sys_ssetmask</strong> (int newmask)恢复</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ssetmask</span> <span class="params">(<span class="type">int</span> newmask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> old = current-&gt;blocked;</span><br><span class="line"></span><br><span class="line">    current-&gt;blocked = newmask &amp; ~(<span class="number">1</span> &lt;&lt; (SIGKILL - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进行add esp的外平栈，再pop，再ret到old_eip</p>
<h2 id="exit-c"><a href="#exit-c" class="headerlink" title="exit.c"></a>exit.c</h2><p>TODO <strong>do_exit</strong>里文件，目录和tty相关的没读懂，</p>
<p><strong>sys_close</strong> (i);</p>
<p><strong>iput</strong> (current-&gt;pwd);</p>
<p>tty_table[current-&gt;tty].pgrp &#x3D; 0;</p>
<h2 id="fork-c"><a href="#fork-c" class="headerlink" title="fork.c"></a>fork.c</h2><p>复习下内存管理，每个任务逻辑空间是64M</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231204095432853.png" alt="image-20231204095432853"></p>
<p>所有操作系统管理所有任务共用0地址处的页目录表即可</p>
<p><strong>verify_area()函数</strong>用来copy on write，在写某个地址addr之前调用，addr可写就直接返回了，否则会复制该页到新物理页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">verify_area</span> <span class="params">(<span class="type">void</span> *addr, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line">    start = (<span class="type">unsigned</span> <span class="type">long</span>) addr;<span class="comment">//此时start是当前进程空间中的虚拟地址。</span></span><br><span class="line">    size += start &amp; <span class="number">0xfff</span>;<span class="comment">//加上之前没有4k对齐的大小</span></span><br><span class="line">    start &amp;= <span class="number">0xfffff000</span>;<span class="comment">//start 调整为其所在页的左边界开始位置</span></span><br><span class="line">    start += get_base (current-&gt;ldt[<span class="number">2</span>]);<span class="comment">// 此时start 变成系统整个线性空间中的地址位置。4k对齐</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>)<span class="comment">//依次验证每一个页是否可写</span></span><br><span class="line">    &#123;</span><br><span class="line">        size -= <span class="number">4096</span>;</span><br><span class="line"><span class="comment">// 写页面验证。若页面不可写，则复制页面。（mm/memory.c）</span></span><br><span class="line">        write_verify (start);</span><br><span class="line">        start += <span class="number">4096</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_verify</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span><span class="comment">//address线性地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断指定地址所对应页目录项的页表是否存在(P)，若不存在(P=0)则返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!((page = *((<span class="type">unsigned</span> <span class="type">long</span>*)((address &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xffc</span>))) &amp; <span class="number">1</span>))<span class="comment">//本来要&gt;&gt;22,再乘以页目录项大小4也就是&lt;&lt;2，这里直接右移20和前面&gt;&gt;22再&lt;&lt;2的区别是会取到页表的前两bit可能不为0，所有&amp;0xffc把低两位置零  页目录表在物理地址0处，head.s里_pg_dir定义的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 取页表的地址，加上指定地址的页面在页表中的页表项偏移值，得对应物理页面的页表项指针。</span></span><br><span class="line">    page &amp;= <span class="number">0xfffff000</span>;<span class="comment">//现在的page是页表在物理内存的基址</span></span><br><span class="line">    page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">//和前面&gt;&gt;20一样，这里是把取到的页内偏移前两bit置零</span></span><br><span class="line"><span class="comment">// 如果该页面不可写(标志R/W 没有置位)，则执行共享检验和复制页面操作（写时复制）。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="type">unsigned</span> <span class="type">long</span> *) page) == <span class="number">1</span>)  <span class="comment">/* 0 1说明 non-writeable, present */</span></span><br><span class="line">        un_wp_page((<span class="type">unsigned</span> <span class="type">long</span> *) page);<span class="comment">//参数page就是页表项基地址，改变他就可以改变映射</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>copy_process() find_empty_process()函数</strong></p>
<p>读之前先看一下fork的系统调用实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">    call _find_empty_process ;// 调用find_empty_process()(kernel/fork.c,135)。</span><br><span class="line">    test eax,eax</span><br><span class="line">    js l2</span><br><span class="line">    push gs</span><br><span class="line">    push esi</span><br><span class="line">    push edi</span><br><span class="line">    push ebp</span><br><span class="line">    push eax</span><br><span class="line">    call _copy_process ;// 调用C 函数copy_process()(kernel/fork.c,68)。</span><br><span class="line">    add esp,20 ;// 丢弃这里所有压栈内容。</span><br><span class="line">l2: ret</span><br></pre></td></tr></table></figure>

<p>find_empty_process里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">repeat:</span><br><span class="line"><span class="keyword">if</span> ((++last_pid) &lt; <span class="number">0</span>)<span class="comment">//当last_pid++到overflow时，置为1</span></span><br><span class="line">    last_pid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_TASKS; i++)</span><br><span class="line">    <span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid)<span class="comment">//得到一个没人用的pid</span></span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NR_TASKS; i++)    <span class="comment">// 任务0 排除在外。</span></span><br><span class="line">    <span class="keyword">if</span> (!task[i])<span class="comment">//得到一个空闲的tastk位置</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>

<p>_copy_process里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;tss.esp0 = PAGE_SIZE + (<span class="type">long</span>) p;    <span class="comment">// 内核堆栈指针（由于是给任务结构p 分配了1 页新内存，所以此时esp0 正好指向该页顶端）。</span></span><br><span class="line">类似于sched.c里下面的<span class="class"><span class="keyword">union</span>结构体</span></span><br><span class="line"><span class="class"><span class="title">union</span> <span class="title">task_union</span></span></span><br><span class="line"><span class="class">&#123;</span>                <span class="comment">// 定义任务联合(任务结构成员和stack 字符数组程序成员)。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span>	<span class="comment">// 因为一个任务数据结构与其堆栈放在同一内存页中，所以</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[PAGE_SIZE];	<span class="comment">// 从堆栈段寄存器ss 可以获得其数据段选择符。</span></span><br><span class="line">&#125;;</span><br><span class="line">p-&gt;tss.eax = <span class="number">0</span>; <span class="comment">//子进程返回0的原因</span></span><br></pre></td></tr></table></figure>

<p>copy_mem函数把nr*64M处线性地址给ldt基址，并把这部分线性基址页表映射到当前进程的物理内存即父进程的物理内存</p>
<h2 id="sys-c"><a href="#sys-c" class="headerlink" title="sys.c"></a>sys.c</h2><p><strong>sys_setregid函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (egid&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((current-&gt;gid == egid) ||<span class="comment">//相当于把current-&gt;egid=current-&gt;gid</span></span><br><span class="line">        (current-&gt;egid == egid) ||<span class="comment">//相当于把current-&gt;egid=egid</span></span><br><span class="line">        (current-&gt;sgid == egid) ||<span class="comment">//current-&gt;egid =current-&gt;sgid</span></span><br><span class="line">        suser())</span><br><span class="line">        current-&gt;egid = egid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>(-EPERM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vsprintf-c"><a href="#vsprintf-c" class="headerlink" title="vsprintf.c"></a>vsprintf.c</h2><p><strong>skip_atoi函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (is_digit (**s))</span><br><span class="line">    i = i * <span class="number">10</span> + *((*s)++) - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//这里i*10，当后面还有数字时会把前面收集到的数字*10</span></span><br></pre></td></tr></table></figure>

<p><strong>do_div函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> do_div(n,base) (&#123; \</span></span><br><span class="line"><span class="meta">int __res; \</span></span><br><span class="line"><span class="meta">__asm__( <span class="string">&quot;divl %4&quot;</span> \</span></span><br><span class="line"><span class="meta">          : \ </span></span><br><span class="line">          <span class="string">&quot;=a&quot;</span> (n), \ 执行后把div的商写回eax</span><br><span class="line">          <span class="string">&quot;=d&quot;</span> (__res)\执行后把div的余数写回__res</span><br><span class="line">          : \</span><br><span class="line">          <span class="string">&quot;0&quot;</span> (n), \ eax=n</span><br><span class="line">          <span class="string">&quot;1&quot;</span> (<span class="number">0</span>), \  edx=<span class="number">0</span></span><br><span class="line">          <span class="string">&quot;r&quot;</span> (base)); \</span><br><span class="line">    __res; &#125;)<span class="comment">//函数返回res 余数</span></span><br></pre></td></tr></table></figure>

<p><strong>number函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>)<span class="comment">//do_div()num写回商 返回余数</span></span><br><span class="line">    tmp[i++] = digits[do_div (num, base)];<span class="comment">//这里转换进制，do_div取出余数，得到倒叙的转换结果</span></span><br></pre></td></tr></table></figure>

<h1 id="kernel-blk-drv"><a href="#kernel-blk-drv" class="headerlink" title="kernel blk_drv"></a>kernel blk_drv</h1><h1 id="mm"><a href="#mm" class="headerlink" title="mm"></a>mm</h1><h2 id="memory-c"><a href="#memory-c" class="headerlink" title="memory.c"></a>memory.c</h2><p>free_page</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem_map[addr]--) <span class="keyword">return</span>;</span><br><span class="line">    mem_map[addr]=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    panic(<span class="string">&quot;trying to free free page&quot;</span>);<span class="comment">//mem_map[addr]原本为0 直接panci</span></span><br></pre></td></tr></table></figure>

<p>int copy_page_tables(unsigned long from,unsigned long to,long size) fork中被调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中from和to都是线性地址 size单位为字节，读的时候要铭记0.11所以进程共用4G的线性地址空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)<span class="comment">//目标页目录项的页表存在panic</span></span><br><span class="line">    panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir))<span class="comment">//源页目录项页表不存在跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">from_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);<span class="comment">//取出页表地址</span></span><br><span class="line"><span class="keyword">if</span> (!(to_page_table = (<span class="type">unsigned</span> <span class="type">long</span> *) get_free_page()))<span class="comment">//get_free_page()找一个空闲物理页当作新页表</span></span><br><span class="line">*to_dir = ((<span class="type">unsigned</span> <span class="type">long</span>) to_page_table) | <span class="number">7</span>;<span class="comment">//页目录项填上新页表位置并把 U/S R/W P 置1 表示用户可读可写且存在物理页表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">    this_page = *from_page_table;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    this_page &amp;= ~<span class="number">2</span>;<span class="comment">//R/W位置0 只读，为了COW</span></span><br><span class="line">    *to_page_table = this_page;<span class="comment">//把P位存在的修改过后的源页表项复制到新页表</span></span><br><span class="line">    <span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">        *from_page_table = this_page;<span class="comment">//如果是用户主内存把源页表项也置位只读</span></span><br><span class="line">        this_page -= LOW_MEM;</span><br><span class="line">        this_page &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">        mem_map[this_page]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unsigned long put_page(unsigned long page,unsigned long address)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//page是主内存区物理地址，address是线性地址</span></span><br><span class="line">主要功能就是把address对应的页目录下里的页表里的页表项里填入物理地址page</span><br></pre></td></tr></table></figure>

<p>void un_wp_page(unsigned long * table_entry)</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">table<span class="built_in">_</span>entry是页表项的物理地址</span><br><span class="line">主要功能就是对于非共享页面(mem<span class="built_in">_</span>map[idx]==1)给予写权限，共享页面申请一个新物理页，填入页表项，并把原本数据复制到新物理页</span><br></pre></td></tr></table></figure>

<p>void do_wp_page(unsigned long error_code,unsigned long address)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//address线性地址</span></span><br><span class="line">un_wp_page((<span class="type">unsigned</span> <span class="type">long</span> *)</span><br><span class="line">        (((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>) + (<span class="number">0xfffff000</span> &amp;<span class="comment">//address页表项在页表里的偏移物理地址</span></span><br><span class="line">        *((<span class="type">unsigned</span> <span class="type">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp;<span class="number">0xffc</span>)))));<span class="comment">//取出address所在页表的物理地址</span></span><br></pre></td></tr></table></figure>

<p>TODO:<strong>do_no_page</strong>从磁盘加载缺页的内容</p>
<h2 id="page-s"><a href="#page-s" class="headerlink" title="page.s"></a>page.s</h2><p>通过判断page fault error code 的最低位P判断是由缺页还是页写保护引起的缺页异常，决定调用do_no_page还是do_wp_page</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20231228231131848.png" alt="image-20231228231131848"></p>
<h1 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h1><h2 id="buffer-c"><a href="#buffer-c" class="headerlink" title="buffer.c"></a>buffer.c</h2><p><strong>remove_from_queues</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(bh-&gt;b_prev_free) || !(bh-&gt;b_next_free))</span><br><span class="line">  panic(<span class="string">&quot;Free block list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>看不懂的话要好好看一下书这里LRU链表得描述</p>
<p><img src="/2024/02/22/RTFSC-linux-11/image-20240227200219711.png" alt="image-20240227200219711"></p>
<p><strong>buffer_init</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( (b = (<span class="type">char</span>*)b - BLOCK_SIZE) &gt;= ((<span class="type">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br></pre></td></tr></table></figure>

<p>头尾相向而行，直到摩擦碰撞，b &#x3D; (char*)b - BLOCK_SIZE) 是下一个缓冲块得位置，h+1是该缓冲块对应得缓冲头</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RTFSC"><span class="toc-number">1.</span> <span class="toc-text">RTFSC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#boot"><span class="toc-number">2.</span> <span class="toc-text">boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bootsect-s"><span class="toc-number">2.1.</span> <span class="toc-text">bootsect.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-s"><span class="toc-number">2.2.</span> <span class="toc-text">setup.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#head-s"><span class="toc-number">2.3.</span> <span class="toc-text">head.s</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init"><span class="toc-number">3.</span> <span class="toc-text">init</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main-c"><span class="toc-number">3.1.</span> <span class="toc-text">main.c</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel"><span class="toc-number">4.</span> <span class="toc-text">kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#asm-s"><span class="toc-number">4.1.</span> <span class="toc-text">asm.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trap-s"><span class="toc-number">4.2.</span> <span class="toc-text">trap.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system-call-s"><span class="toc-number">4.3.</span> <span class="toc-text">system_call.s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sched-c"><span class="toc-number">4.4.</span> <span class="toc-text">sched.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#signal-c"><span class="toc-number">4.5.</span> <span class="toc-text">signal.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exit-c"><span class="toc-number">4.6.</span> <span class="toc-text">exit.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-c"><span class="toc-number">4.7.</span> <span class="toc-text">fork.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys-c"><span class="toc-number">4.8.</span> <span class="toc-text">sys.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vsprintf-c"><span class="toc-number">4.9.</span> <span class="toc-text">vsprintf.c</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel-blk-drv"><span class="toc-number">5.</span> <span class="toc-text">kernel blk_drv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mm"><span class="toc-number">6.</span> <span class="toc-text">mm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-c"><span class="toc-number">6.1.</span> <span class="toc-text">memory.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#page-s"><span class="toc-number">6.2.</span> <span class="toc-text">page.s</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fs"><span class="toc-number">7.</span> <span class="toc-text">fs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer-c"><span class="toc-number">7.1.</span> <span class="toc-text">buffer.c</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&text=linux0.11内核源码阅读"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&is_video=false&description=linux0.11内核源码阅读"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=linux0.11内核源码阅读&body=Check out this article: https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&title=linux0.11内核源码阅读"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&name=linux0.11内核源码阅读&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2024/02/22/RTFSC-linux-11/&t=linux0.11内核源码阅读"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    bxz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
