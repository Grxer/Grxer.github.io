<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="fwrite1size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);  测试程序 12345678#include&lt;stdio.h&gt;int main()&amp;#123;    char data[20]&#x3D;&quot;flag&amp;#123;grxer&amp;#125;&quot;;    FILE*fp&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="IO FILE fwrite">
<meta property="og:url" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/index.html">
<meta property="og:site_name" content="Computer Security">
<meta property="og:description" content="fwrite1size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);  测试程序 12345678#include&lt;stdio.h&gt;int main()&amp;#123;    char data[20]&#x3D;&quot;flag&amp;#123;grxer&amp;#125;&quot;;    FILE*fp&#x3D;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401120543002.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401153712485.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401162158010.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401164402279.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401171509678.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401175400733.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401182422401.png">
<meta property="article:published_time" content="2023-04-01T02:26:11.000Z">
<meta property="article:modified_time" content="2023-04-02T14:44:24.421Z">
<meta property="article:author" content="Grxer">
<meta property="article:tag" content="IO FILE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/image-20230401120543002.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>IO FILE fwrite</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/04/01/IO-FILE-fclose/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/03/31/IO-FILE-fread/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&text=IO FILE fwrite"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&is_video=false&description=IO FILE fwrite"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IO FILE fwrite&body=Check out this article: https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&name=IO FILE fwrite&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&t=IO FILE fwrite"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#fwrite"><span class="toc-number">1.</span> <span class="toc-text">fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#x2F-libio-x2F-iofwrite-c-IO-fwrite"><span class="toc-number">1.1.</span> <span class="toc-text">&#x2F;libio&#x2F;iofwrite.c _IO_fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-IO-sputn%EF%BC%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">进入_IO_sputn，</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%96%87%E4%BB%B6%E6%B5%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%8C%E5%96%84"><span class="toc-number">1.2.</span> <span class="toc-text">申请并初始化缓冲区，文件流结构体完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-libio-x2F-fileops-c-IO-new-file-overflow"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">&#x2F;libio&#x2F;fileops.c _IO_new_file_overflow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%86%B3%E5%AE%9A%E5%BE%80%E7%BC%93%E5%86%B2%E5%8C%BA%E9%87%8C%E5%86%99%E6%95%B0%E6%8D%AE%E6%88%96%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-libio-x2F-fileops-c%E4%B8%AD-IO-new-do-write"><span class="toc-number">1.3.0.0.1.</span> <span class="toc-text">&#x2F;libio&#x2F;fileops.c中**_IO_new_do_write**</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite%E5%86%99%E5%85%A5%E5%A4%A7%E5%B0%8F%E5%8F%82%E6%95%B0%E5%B0%8F%E4%BA%8E%E7%94%B3%E8%AF%B7%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%80%E5%A4%9A%E4%B8%BA4k%EF%BC%8C%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%B8%BA1k"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite%E5%86%99%E5%85%A5%E5%A4%A7%E5%B0%8F%E5%8F%82%E6%95%B0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%94%B3%E8%AF%B7%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%80%E5%A4%9A%E4%B8%BA4k%EF%BC%8C%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%B8%BA1k"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fwrite-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84vtable%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">fwrite 函数调用的vtable函数</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        IO FILE fwrite
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Grxer</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-01T02:26:11.000Z" itemprop="datePublished">2023-04-01</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/IO-FILE/" rel="tag">IO FILE</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* buffer, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>测试程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">20</span>]=<span class="string">&quot;flag&#123;grxer&#125;&quot;</span>;</span><br><span class="line">    FILE*fp=fopen(<span class="string">&quot;./flag1&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(data,<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="x2F-libio-x2F-iofwrite-c-IO-fwrite"><a href="#x2F-libio-x2F-iofwrite-c-IO-fwrite" class="headerlink" title="&#x2F;libio&#x2F;iofwrite.c _IO_fwrite"></a><strong>&#x2F;libio&#x2F;iofwrite.c _IO_fwrite</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t request = size * count;</span><br><span class="line">  _IO_size_t written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CHECK_FILE</strong>检测一下flag的魔数，加锁判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> _IO_fwide(__fp, __mode) \</span></span><br><span class="line"><span class="meta">  (&#123; int __result = (__mode);						      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__result &lt; 0 &amp;&amp; ! _IO_fwide_maybe_incompatible)		      \</span></span><br><span class="line"><span class="meta">       &#123;								      \</span></span><br><span class="line"><span class="meta">	 <span class="keyword">if</span> ((__fp)-&gt;_mode == 0)					      \</span></span><br><span class="line"><span class="meta">	   <span class="comment">/* We know that all we have to do is to set the flag.  */</span>	      \</span></span><br><span class="line"><span class="meta">	   (__fp)-&gt;_mode = -1;						      \</span></span><br><span class="line"><span class="meta">	 __result = (__fp)-&gt;_mode;					      \</span></span><br><span class="line"><span class="meta">       &#125;								      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_constant_p (__mode) &amp;&amp; (__mode) == 0)		      \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide_maybe_incompatible ? -1 : (__fp)-&gt;_mode;	      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">       __result = _IO_fwide (__fp, __result);				      \</span></span><br><span class="line"><span class="meta">     __result; &#125;)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401120543002.png" alt="image-20230401120543002"></p>
<h3 id="进入-IO-sputn，"><a href="#进入-IO-sputn，" class="headerlink" title="进入_IO_sputn，"></a>进入_IO_sputn，</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)</span></span><br></pre></td></tr></table></figure>

<p><mark>&#x3D;&#x3D;调用vtable里**__xsputn<strong>指向的</strong>libio&#x2F;fileops.c里的_IO_new_file_xsputn**函数，传入的参数为文件流结构体_IO_FILE,数据目标地址，读取总字节数&#x3D;&#x3D;<mark></mark></mark></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>

<p>刚fopen完此时大部分字段位NULL</p>
<img src="/2023/04/01/IO-FILE-fwrite/image-20230401153712485.png" alt="image-20230401153712485" style="zoom:80%;">

<p>前面几个if都不成立，来到<code> if (to_do + must_flush &gt; 0)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure>

<p><mark>&#x3D;&#x3D;调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)&#x3D;&#x3D;<mark></mark></mark></p>
<h2 id="申请并初始化缓冲区，文件流结构体完善"><a href="#申请并初始化缓冲区，文件流结构体完善" class="headerlink" title="申请并初始化缓冲区，文件流结构体完善"></a>申请并初始化缓冲区，文件流结构体完善</h2><h4 id="x2F-libio-x2F-fileops-c-IO-new-file-overflow"><a href="#x2F-libio-x2F-fileops-c-IO-new-file-overflow" class="headerlink" title="&#x2F;libio&#x2F;fileops.c _IO_new_file_overflow"></a><strong>&#x2F;libio&#x2F;fileops.c</strong> _IO_new_file_overflow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>

<p>先判断文件流结构体flag是不是有不可写属性返回EOF</p>
<p>检测受否有_IO_CURRENTLY_PUTTING或_IO_write_base是否为空</p>
<blockquote>
<p>IO_CURRENTLY_PUTTING是GNU C库中使用的宏，用于表示FILE流当前写入数据的输出缓冲区位置。它的定义如下：</p>
<p>#define IO_CURRENTLY_PUTTING(fp) ((fp)-&gt;_IO_write_ptr - (fp)-&gt;_IO_write_base)</p>
</blockquote>
<p>IO_write_base为空符合条件调用_IO_doallocbuf分配缓冲区，fwrite分析过</p>
<p><mark>&#x3D;&#x3D;调用虚表中的__doallocate指向的_IO_file_doallocate函数&#x3D;&#x3D;<mark></mark></mark></p>
<img src="/2023/04/01/IO-FILE-fwrite/image-20230401162158010.png" alt="image-20230401162158010" style="zoom: 80%;">

<p>接下来的_IO_setg也在fread里分析过_</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span></span><br><span class="line"><span class="meta">	(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base), (fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base));</span><br></pre></td></tr></table></figure>

<p>_也就是把结构体里的<strong>read</strong>相关的3个指针均初始化为IO_buf_base</p>
<img src="/2023/04/01/IO-FILE-fwrite/image-20230401164402279.png" alt="image-20230401164402279" style="zoom:80%;">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_in_backup(fp) ((fp)-&gt;_flags &amp; _IO_IN_BACKUP)</span></span><br></pre></td></tr></table></figure>

<p>_IO_in_backup这里不成立，来到给fp的write相关指针赋值，并设置_IO_CURRENTLY_PUTTING 属性，用于表示当前正在执行输出操作</p>
<img src="/2023/04/01/IO-FILE-fwrite/image-20230401171509678.png" alt="image-20230401171509678" style="zoom:80%;">

<h2 id="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"><a href="#根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件" class="headerlink" title="根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件"></a>根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件</h2><p>ch&#x3D;EOF(-1),执行_IO_do_write(f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</p>
<h5 id="x2F-libio-x2F-fileops-c中-IO-new-do-write"><a href="#x2F-libio-x2F-fileops-c中-IO-new-do-write" class="headerlink" title="&#x2F;libio&#x2F;fileops.c中**_IO_new_do_write**"></a><strong>&#x2F;libio&#x2F;fileops.c</strong>中**_IO_new_do_write**</h5><p>函数第一个参数_IO_FILE文件流结构体，第二个参数输出缓冲区，第三个参数为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line">_IO_new_do_write (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>todo&#x3D;&#x3D;0成立，直接返回0，回到**_IO_new_file_xsputn**函数</p>
<p><code>if (_IO_OVERFLOW (f, EOF) == EOF)</code>不成立</p>
<p>设置blocksize为申请的缓冲区大小</p>
<p><strong>do_write</strong>根据<code>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</code>赋值</p>
<h4 id="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br></pre></td></tr></table></figure>

<p>调用<strong>libio&#x2F;genops.c</strong>的_IO_default_xsputn第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小size*count</p>
<p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401175400733.png" alt="image-20230401175400733"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_default_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  _IO_size_t more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      _IO_ssize_t i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要输入的数据小于缓冲区大小则把输入大小置为输入真实数据大小，否则按照缓冲区大小</p>
<ul>
<li><p>一次转移大于20时</p>
<ul>
<li>采用memcopy，进行传输</li>
</ul>
</li>
<li><p>一次转移大小小于20时</p>
<ul>
<li>采用for循环进行赋值</li>
</ul>
</li>
</ul>
<p>缓冲区不够时会_IO_OVERFLOW刷新缓冲区</p>
<p><img src="/2023/04/01/IO-FILE-fwrite/image-20230401182422401.png" alt="image-20230401182422401"></p>
<h4 id="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"><a href="#fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k" class="headerlink" title="fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k"></a>fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k</h4><p>do_write为缓冲区大小的倍数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (do_write)&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>libio&#x2F;fileops.c</strong></p>
<p>new_do_write第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span></span><br><span class="line">_IO_size_t</span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, _IO_size_t to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检测_IO_IS_APPENDING标志位它表示文件流的当前位置是否处于文件的末尾，并且文件以”追加模式”打开。</p>
<p>fp-&gt;_IO_read_end !&#x3D; fp-&gt;_IO_write_base不相等时会_IO_SYSSEEK()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)</span></span><br></pre></td></tr></table></figure>

<p><mark>&#x3D;&#x3D;调用虚表里的seek对应的__GI__IO_file_seek&#x3D;&#x3D;<mark></mark></mark></p>
<p>不过条件不成立，直接调用_IO_SYSWRITE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)</span></span><br></pre></td></tr></table></figure>

<p><mark>&#x3D;&#x3D;调用了vtable中__write对应的<code>_IO_new_file_write</code>&#x3D;&#x3D;<mark></mark></mark></p>
<p><strong>libio&#x2F;fileops.c</strong>中**_IO_new_file_write**</p>
<p>第一个参数为文件流结构体，第二个参数为内存数据起始点，第三个为输入大小do_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_write (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">					     &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">			   ? write_not_cancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">			   : write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行系统调用write把数据写入文件，</p>
<p>调用_IO_adjust_column更新文件流结构体中的_cur_column</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure>

<p>朴素的通过检测‘\n’来统计增加的行数</p>
<p>未对齐的数据回到 <strong>_IO_default_xsputn</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用_IO_default_xsputn，和&lt;的一样进入缓冲区</p>
<p><strong>哎呀你干嘛，突然意识到，小于缓冲区的大小的数据只是被送进了缓冲区，没有被写入文件啊。。。别急还有fclose没有分析，谁知道未来的fclose会发生什么呢</strong></p>
<h2 id="fwrite-函数调用的vtable函数"><a href="#fwrite-函数调用的vtable函数" class="headerlink" title="fwrite 函数调用的vtable函数"></a>fwrite 函数调用的vtable函数</h2><ul>
<li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li>
<li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li>
<li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li>
<li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#fwrite"><span class="toc-number">1.</span> <span class="toc-text">fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#x2F-libio-x2F-iofwrite-c-IO-fwrite"><span class="toc-number">1.1.</span> <span class="toc-text">&#x2F;libio&#x2F;iofwrite.c _IO_fwrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5-IO-sputn%EF%BC%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">进入_IO_sputn，</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%96%87%E4%BB%B6%E6%B5%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%8C%E5%96%84"><span class="toc-number">1.2.</span> <span class="toc-text">申请并初始化缓冲区，文件流结构体完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x2F-libio-x2F-fileops-c-IO-new-file-overflow"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">&#x2F;libio&#x2F;fileops.c _IO_new_file_overflow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%86%B3%E5%AE%9A%E5%BE%80%E7%BC%93%E5%86%B2%E5%8C%BA%E9%87%8C%E5%86%99%E6%95%B0%E6%8D%AE%E6%88%96%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">根据处理数据大小和缓冲区大小决定往缓冲区里写数据或直接写入文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-libio-x2F-fileops-c%E4%B8%AD-IO-new-do-write"><span class="toc-number">1.3.0.0.1.</span> <span class="toc-text">&#x2F;libio&#x2F;fileops.c中**_IO_new_do_write**</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite%E5%86%99%E5%85%A5%E5%A4%A7%E5%B0%8F%E5%8F%82%E6%95%B0%E5%B0%8F%E4%BA%8E%E7%94%B3%E8%AF%B7%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%80%E5%A4%9A%E4%B8%BA4k%EF%BC%8C%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%B8%BA1k"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">fwrite写入大小参数小于申请的缓冲区大小，一般最多为4k，本测试为1k</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite%E5%86%99%E5%85%A5%E5%A4%A7%E5%B0%8F%E5%8F%82%E6%95%B0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%94%B3%E8%AF%B7%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%80%E5%A4%9A%E4%B8%BA4k%EF%BC%8C%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%B8%BA1k"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">fwrite写入大小参数大于等于申请的缓冲区大小，一般最多为4k，本测试为1k</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fwrite-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84vtable%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">fwrite 函数调用的vtable函数</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&text=IO FILE fwrite"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&is_video=false&description=IO FILE fwrite"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IO FILE fwrite&body=Check out this article: https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&title=IO FILE fwrite"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&name=IO FILE fwrite&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/01/IO-FILE-fwrite/&t=IO FILE fwrite"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    Grxer
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
