<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="http:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2022&#x2F;slides&#x2F;3.slides# thread.h 简化的线程 API进程是资源分配的基本单位，linux线程其实是通过轻量级进程实现的LWP(light weight process)，所有Linux内核的角度去看线程和进程并没有区别，只不过他和主线程共享一些资源，线程是最小的执行单位，调度的基本单位。同时也是资源竞争的基本单位。 具体的东西之">
<meta property="og:type" content="article">
<meta property="og:title" content="NJUOS:多处理器编程">
<meta property="og:url" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Computer Security">
<meta property="og:description" content="http:&#x2F;&#x2F;jyywiki.cn&#x2F;OS&#x2F;2022&#x2F;slides&#x2F;3.slides# thread.h 简化的线程 API进程是资源分配的基本单位，linux线程其实是通过轻量级进程实现的LWP(light weight process)，所有Linux内核的角度去看线程和进程并没有区别，只不过他和主线程共享一些资源，线程是最小的执行单位，调度的基本单位。同时也是资源竞争的基本单位。 具体的东西之">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215319891.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215306823.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404185540104.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404195902138.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404203402253.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404205339561.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235118554.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235238898.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000115259.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000145046.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405004225147.png">
<meta property="article:published_time" content="2023-04-04T05:03:59.000Z">
<meta property="article:modified_time" content="2023-04-04T17:28:55.959Z">
<meta property="article:author" content="Grxer">
<meta property="article:tag" content="NJUOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215319891.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>NJUOS:多处理器编程</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/04/03/vtable-hijack/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&text=NJUOS:多处理器编程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&is_video=false&description=NJUOS:多处理器编程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=NJUOS:多处理器编程&body=Check out this article: https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&name=NJUOS:多处理器编程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&t=NJUOS:多处理器编程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-h-%E7%AE%80%E5%8C%96%E7%9A%84%E7%BA%BF%E7%A8%8B-API"><span class="toc-number">1.</span> <span class="toc-text">thread.h 简化的线程 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">创建线程使用的是哪个系统调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">gdb调试多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%A0%88%E5%8C%BA"><span class="toc-number">2.</span> <span class="toc-text">线程独立的栈区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">如何改变这个堆栈大小?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread%E6%B5%85%E8%B0%88"><span class="toc-number">2.2.</span> <span class="toc-text">__thread浅谈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">3.</span> <span class="toc-text">原子性的丧失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">4.</span> <span class="toc-text">顺序的丧失</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        NJUOS:多处理器编程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Grxer</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-04T05:03:59.000Z" itemprop="datePublished">2023-04-04</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/NJUOS/" rel="tag">NJUOS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/slides/3.slides#">http://jyywiki.cn/OS/2022/slides/3.slides#</a></p>
<h2 id="thread-h-简化的线程-API"><a href="#thread-h-简化的线程-API" class="headerlink" title="thread.h 简化的线程 API"></a><code>thread.h</code> 简化的线程 API</h2><p>进程是资源分配的基本单位，linux线程其实是通过轻量级进程实现的LWP(light weight process)，所有Linux内核的角度去看线程和进程并没有区别，只不过他和主线程共享一些资源，线程是最小的执行单位，调度的基本单位。同时也是资源竞争的基本单位。</p>
<p>具体的东西之前 <a target="_blank" rel="noopener" href="https://grxer.github.io/2023/03/26/TLS-Hijack/">https://grxer.github.io/2023/03/26/TLS-Hijack/</a> 里有讨论</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREAD 64</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> T_FREE = <span class="number">0</span>, T_LIVE, T_DEAD, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> id, status;</span><br><span class="line">  <span class="type">pthread_t</span> thread;</span><br><span class="line">  <span class="type">void</span> (*entry)(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">tpool</span>[<span class="title">NTHREAD</span>], *<span class="title">tptr</span> =</span> tpool;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">wrapper</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">thread</span> =</span> (<span class="keyword">struct</span> thread *)arg;</span><br><span class="line">  thread-&gt;entry(thread-&gt;id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(<span class="type">void</span> *fn)</span> &#123;</span><br><span class="line">  assert(tptr - tpool &lt; NTHREAD);</span><br><span class="line">  *tptr = (<span class="keyword">struct</span> thread) &#123;</span><br><span class="line">    .id = tptr - tpool + <span class="number">1</span>,</span><br><span class="line">    .status = T_LIVE,</span><br><span class="line">    .entry = fn,</span><br><span class="line">  &#125;;</span><br><span class="line">  pthread_create(&amp;(tptr-&gt;thread), <span class="literal">NULL</span>, wrapper, tptr);</span><br><span class="line">  ++tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NTHREAD; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> &amp;tpool[i];</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;status == T_LIVE) &#123;</span><br><span class="line">      pthread_join(t-&gt;thread, <span class="literal">NULL</span>);</span><br><span class="line">      t-&gt;status = T_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123; </span><br><span class="line">  join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>POSIX线程库进一步做了一层封装，做了个main函数的析构函数阻塞进程等待</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">                 <span class="type">pthread_t</span> * tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr,  <span class="comment">//线程属性</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行,使用参数时我们通常会进行类型强转</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> * arg <span class="comment">//若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span><br><span class="line"><span class="params">                  )</span>;<span class="comment">//创建成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line"><span class="type">void</span>类型的指针配合上类型强转给了我们更多的灵活性和自由性</span><br><span class="line"><span class="type">pthread_t</span>类型的线程tibp，是进程内部，识别标志,两个进程间，这个线程ID允许相同</span><br><span class="line">pthread_create函数创建的线程默认非分离属性的，在非分离的情况下，当一个线程结束的时候，它所占用的系统资源并没有完全真正的释放，也没有真正终止。</span><br><span class="line">只有在pthread_join函数返回时，该线程才会释放自己的资源。或者是设置在分离属性的情况下，一个线程结束会立即释放它所占用的资源。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;分离一个线程，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="comment">//指定等待哪个子线程结束，接收哪个线程的返回值，只能是非分离线程</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> ** retval<span class="comment">//接收参数返回值</span></span></span><br><span class="line"><span class="params">                )</span>;<span class="comment">//成功返回0，否则返回错误信息对应的非0宏</span></span><br><span class="line">一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除。</span><br><span class="line">如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存(系统)空间，这会导致该线程变成了“僵尸线程”。join后我们也必须手动清除程序分配的空间(堆等等)</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>_attribute__关键字主要是用来在函数或数据声明中设置其属性。给函数赋给属性的主要目的在于让编译器进行优化。</p>
</li>
<li><p>使用编译时pthread 库需要加上-lpthread，因为pthread并非Linux系统的默认库</p>
<blockquote>
<p>-lpthread 选项只是告诉编译器在链接时链接 pthread 库。</p>
<p>-pthread 将自动添加必要的编译选项和链接选项，以确保程序正确地使用 pthread 库,编译器会自动将 “-lpthread” 选项添加到链接命令行中，以确保在链接时链接 pthread 库。</p>
</blockquote>
</li>
</ul>
<h3 id="创建线程使用的是哪个系统调用？"><a href="#创建线程使用的是哪个系统调用？" class="headerlink" title="创建线程使用的是哪个系统调用？"></a>创建线程使用的是哪个系统调用？</h3><p>strace了一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mmap(NULL, 8392704, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7ffff73ff000</span><br><span class="line">mprotect(0x7ffff7400000, 8388608, PROT_READ|PROT_WRITE) = 0</span><br><span class="line">getrandom(&quot;\x5c\xf7\x7d\x5a\x8a\x60\xbd\x73&quot;, 8, GRND_NONBLOCK) = 8</span><br><span class="line">brk(NULL)                               = 0x555555559000</span><br><span class="line">brk(0x55555557a000)                     = 0x55555557a000</span><br><span class="line">rt_sigprocmask(SIG_BLOCK, ~[], [], 8)   = 0</span><br><span class="line">clone3(&#123;flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, child_tid=0x7ffff7bff910, parent_tid=0x7ffff7bff910, exit_signal=0, stack=0x7ffff73ff000, stack_size=0x7fff00, tls=0x7ffff7bff640&#125;gr</span><br><span class="line"> =&gt; &#123;parent_tid=[8670]&#125;, 88) = 8670</span><br></pre></td></tr></table></figure>

<p>gdb跟了一下，最后clong3进内核syscall的时候是一个很奇怪未知的调用号</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215319891.png" alt="image-20230404215319891"></p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404215306823.png" alt="image-20230404215306823"></p>
<h3 id="gdb调试多线程"><a href="#gdb调试多线程" class="headerlink" title="gdb调试多线程"></a>gdb调试多线程</h3><p><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/gdb/Threads.html">https://sourceware.org/gdb/onlinedocs/gdb/Threads.html</a></p>
<h2 id="线程独立的栈区"><a href="#线程独立的栈区" class="headerlink" title="线程独立的栈区"></a>线程独立的栈区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objdump to see how thread-local variables are implemented</span></span><br><span class="line">__attribute__((noinline)) <span class="type">void</span> <span class="title function_">set_cur</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123; cur = ptr; &#125;</span><br><span class="line">__attribute__((noinline)) <span class="type">char</span> *<span class="title function_">get_cur</span><span class="params">()</span>         &#123; <span class="keyword">return</span> cur; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stackoverflow</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  set_cur(&amp;n);</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">1024</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sz = base - get_cur();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack size of T%d &gt;= %d KB\n&quot;</span>, id, sz / <span class="number">1024</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stackoverflow(n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tprobe</span><span class="params">(<span class="type">int</span> tid)</span> &#123;</span><br><span class="line">  id = tid;</span><br><span class="line">  base = (<span class="type">void</span> *)&amp;tid;</span><br><span class="line">  stackoverflow(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    create(Tprobe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把输出缓冲区关了，起了四个线程，每个线程都会Tprobe作为入口点，tid在相对高地址栈上，把栈地址给了base，调用StackOverflow</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404185540104.png" alt="image-20230404185540104"></p>
<p>n始终在在栈rbp-0x24偏移处，最后会递归自己，每1024次会计算一次n距离栈底的距离，没有终止条件，栈一直在栈，始终有一天会真正的stackoverflow，我们就可以估计栈的大小</p>
<p>我们可以通过pipe 把结果给sort排序</p>
<p><code>./stack-probe | sort -nk 6</code></p>
<ul>
<li>-k选择一列</li>
<li>-n把某一列当作数字排序</li>
</ul>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404195902138.png" alt="image-20230404195902138"></p>
<p>猜测出栈的大小默认也就是8M</p>
<h3 id="如何改变这个堆栈大小"><a href="#如何改变这个堆栈大小" class="headerlink" title="如何改变这个堆栈大小?"></a>如何改变这个堆栈大小?</h3><blockquote>
<p>可以利用pthread_create第二个参数线程属性在创建线程时做操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure for condition variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is not exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> __size[__SIZEOF_PTHREAD_CONDATTR_T];</span><br><span class="line">  <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_condattr_t</span>;</span><br></pre></td></tr></table></figure>

<p>没有公开类型，但是给我们了api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line">返回值<span class="number">0</span>，<span class="number">-1</span>分别表示成功与失败，这里的stacksize都是以byte为单位</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before:%zu\n&quot;</span>, stacksize);</span><br><span class="line">    res = pthread_attr_setstacksize(&amp;thread_attr,<span class="number">10485760</span>);</span><br><span class="line">    assert(!res);</span><br><span class="line">    res = pthread_attr_getstacksize(&amp;thread_attr, &amp;stacksize);</span><br><span class="line">    assert(!res);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after:%zu\n&quot;</span>, stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; ./test</span><br><span class="line">before:<span class="number">8388608</span></span><br><span class="line">after:<span class="number">10485760</span></span><br></pre></td></tr></table></figure>

<p>我们这样去改造一下<code>thread.h</code>就好</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_attr_t</span> thread_attr;</span><br><span class="line"> <span class="type">int</span> res = pthread_attr_init(&amp;thread_attr);</span><br><span class="line"> assert(!res);</span><br><span class="line"> res = pthread_attr_setstacksize(&amp;thread_attr, <span class="number">10485760</span>);</span><br><span class="line"> assert(!res);</span><br><span class="line"> pthread_create(&amp;(tptr-&gt;thread), &amp;thread_attr, wrapper, tptr);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404203402253.png" alt="image-20230404203402253"></p>
</blockquote>
<h3 id="thread浅谈"><a href="#thread浅谈" class="headerlink" title="__thread浅谈"></a>__thread浅谈</h3><p><strong>Thread Local Storage</strong>，之前劫持过tls来bypass canary，但是对底层理解并不深，这次有了新的体会，但是也只是浅谈，好多东西还没搞懂，要去补补保护模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get_cur</span><br><span class="line">.text:0000000000001388 55                            push    rbp</span><br><span class="line">.text:0000000000001389 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000000138C 64 48 8B 04 25 F0 FF FF FF    mov     rax, fs:0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000001395 5D                            pop     rbp</span><br></pre></td></tr></table></figure>

<p>还是和fs段寄存器有关，其实准确来说，自从8086的实模式过后，cs ss ds es等段寄存器里面存的不再是为了满足20位地址总线的4位基地址，在保护模式下变为了段选择字，现在应该叫段选择器，保护模式下会有用户态不可加的部分，叫做描述符高速缓冲器，由处理器自动使用，而真正的段地址就在这里面</p>
<p><strong>有以下方式去获得fs段地址</strong></p>
<p>&gt;&gt;&gt;通过内联汇编的方式</p>
<p>&gt;&gt;&gt;<a target="_blank" rel="noopener" href="https://www.onitroad.com/jc/linux/man-pages/linux/man2/arch_prctl.2.html">系统调用int arch_prctl(int code, unsigned long *addr)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fs_value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fs_value2;</span><br><span class="line">	<span class="type">pthread_t</span> pid = pthread_self();</span><br><span class="line">	<span class="type">int</span> ret = arch_prctl(ARCH_GET_FS,&amp;fs_value2); </span><br><span class="line">	__asm__ <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (fs_value))</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FS寄存器的值为: 0x%lx\narch_prctl:0x%lx\npid:0x%lx&quot;</span>, fs_value,fs_value2,pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grxer@grxer ~/D/s/N/ctest&gt; ./test</span><br><span class="line">FS寄存器的值为: <span class="number">0x7ffff7fa6740</span></span><br><span class="line">arch_prctl:<span class="number">0x7ffff7fa6740</span></span><br><span class="line">pid:<span class="number">0x7ffff7fa6740</span>⏎   </span><br></pre></td></tr></table></figure>

<p>&gt;&gt;&gt;gdb的<code>fsbase命令</code>或<code>p/x pthread_self()</code>获得这个值</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404205339561.png" alt="image-20230404205339561"></p>
<p>这里才惊奇的发现gdb里可以直接运行c函数</p>
<p>可以看到POSIX线程库的pthread_create返回给我们的tidp是每个线程的fs段地址</p>
<p>观察一下程序里定义的__thread变量和汇编里的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">char</span> *base, *cur; <span class="comment">// thread-local variables</span></span><br><span class="line">__thread <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">base:.text:<span class="number">0000000000001435</span> <span class="number">64</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> F8 FF FF FF       mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFF8h(<span class="number">-8</span>), eax</span><br><span class="line">cur：.text:<span class="number">000000000000138</span>C <span class="number">64</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">04</span> <span class="number">25</span> F0 FF FF FF    mov     rax, fs:<span class="number">0F</span>FFFFFFFFFFFFFF0h(<span class="number">-16</span>)</span><br><span class="line">id：.text:<span class="number">0000000000001441</span> <span class="number">64</span> <span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">25</span> E8 FF FF FF    mov     fs:<span class="number">0F</span>FFFFFFFFFFFFFE8h(<span class="number">-24</span>), rax</span><br></pre></td></tr></table></figure>

<p>在fs-8处开始排列，他的下面也就是我们的之前看的canary和__exit_funcs析构函数组的key，pthread_create去创建一个进程是用mmap一块内存当作堆栈，fs则位于这个堆栈的高地址处，也就是堆栈的底部</p>
<h2 id="原子性的丧失"><a href="#原子性的丧失" class="headerlink" title="原子性的丧失"></a>原子性的丧失</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tsum</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    sum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  create(Tsum);</span><br><span class="line">  create(Tsum);</span><br><span class="line">  join();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就连单处理器并发都得不到正确的结果。<code>taskset -c cpu-cpu &lt;command&gt;</code>限制在单个处理器上运行</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235118554.png" alt="image-20230404235118554"></p>
<p>多处理器线程在并行，偏差更大</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230404235238898.png" alt="image-20230404235238898"></p>
<p>具体来说，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，但是第一个线程并不知道。这可能导致一个线程覆盖了另一个线程的结果，从而导致最终结果错误。</p>
<p>sum++翻译为汇编是三条指令，取出，+1，写回，这也就是我们单处理器为什么会出错原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000145A 48 8B 05 DF 31 00 00          mov     rax, cs:sum</span><br><span class="line">.text:0000000000001461 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001465 48 89 05 D4 31 00 00          mov     cs:sum, rax</span><br></pre></td></tr></table></figure>

<p>我们用内联汇编把sum++改为一句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;add $1,%0&quot;</span>:<span class="string">&quot;+m&quot;</span>(sum))</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000145A 83 05 DF 31 00 00 01          add     dword ptr cs:sum, 1</span><br></pre></td></tr></table></figure>

<p>此时单核处理器没有多处理器乱序的并行，可以正常得到结果</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000115259.png" alt="image-20230405000115259"></p>
<p>多核处理器依旧出差，不过误差低了一点</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405000145046.png" alt="image-20230405000145046"></p>
<h2 id="顺序的丧失"><a href="#顺序的丧失" class="headerlink" title="顺序的丧失"></a>顺序的丧失</h2><ul>
<li>用gcc对程序进行-O1的优化发现每次运行结果都是sum &#x3D; 100000000</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001223</span><br><span class="line">.text:0000000000001223                               ; void __cdecl Tsum()</span><br><span class="line">.text:0000000000001223                               public Tsum</span><br><span class="line">.text:0000000000001223                               Tsum proc near                          ; DATA XREF: main+5↓o</span><br><span class="line">.text:0000000000001223                               ; __unwind &#123;</span><br><span class="line">.text:0000000000001223 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:0000000000001227 48 8B 15 12 2E 00 00          mov     rdx, cs:sum</span><br><span class="line">.text:000000000000122E 48 8D 42 01                   lea     rax, [rdx+1]</span><br><span class="line">.text:0000000000001232 48 81 C2 01 E1 F5 05          add     rdx, 5F5E101h</span><br><span class="line">.text:0000000000001232</span><br><span class="line">.text:0000000000001239</span><br><span class="line">.text:0000000000001239                               loc_1239:                               ; CODE XREF: Tsum+20↓j</span><br><span class="line">.text:0000000000001239 48 89 C1                      mov     rcx, rax</span><br><span class="line">.text:000000000000123C 48 83 C0 01                   add     rax, 1</span><br><span class="line">.text:0000000000001240 48 39 D0                      cmp     rax, rdx</span><br><span class="line">.text:0000000000001243 75 F4                         jnz     short loc_1239</span><br><span class="line">.text:0000000000001243</span><br><span class="line">.text:0000000000001245 48 89 0D F4 2D 00 00          mov     cs:sum, rcx</span><br><span class="line">.text:000000000000124C C3                            retn</span><br></pre></td></tr></table></figure>

<p>-01的优化保留了循环，但是优化了每次写回内存的操作，用rcx寄存器代替</p>
<p><code>mov     cs:sum, rcx</code>最后写回的这一步决定了<code>sum = 100000000</code></p>
<ul>
<li>-O2优化 每次运行结果sum &#x3D; 200000000</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000001290</span>                               ; <span class="type">void</span> __cdecl <span class="title function_">Tsum</span><span class="params">()</span></span><br><span class="line">.text:0000000000001290                               public Tsum</span><br><span class="line">.text:0000000000001290                               Tsum proc near                          ; DATA XREF: main+<span class="number">5</span>↑o</span><br><span class="line">.text:<span class="number">0000000000001290</span>                               ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000001290</span> F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">48</span> <span class="number">81</span> <span class="number">05</span> A1 <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> E1 F5+add     cs:sum, <span class="number">5F</span>5E100h</span><br><span class="line">.text:<span class="number">0000000000001294</span> <span class="number">05</span></span><br><span class="line">.text:<span class="number">000000000000129F</span> C3                            retn</span><br></pre></td></tr></table></figure>

<p>循环也没有了，直接把正确结果一个add，得到正确结果，但是这只是一个假象，和前面一句add汇编一样，当一个线程正在读取sum的值时，另一个线程可能已经修改了sum的值，我们只是两个线程去add，只是错误得几率很小，我们把线程增加到14，14次竞争add就已经有可见概率错误了</p>
<p><img src="/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230405004225147.png" alt="image-20230405004225147"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> done;</span><br><span class="line"><span class="type">void</span> <span class="title function_">join</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一一段代码我们只编译不链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	55                   	push   %rbp</span><br><span class="line">   5:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   8:	90                   	nop</span><br><span class="line">   9:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # f &lt;join+0xf&gt;</span><br><span class="line">   f:	85 c0                	test   %eax,%eax</span><br><span class="line">  11:	74 f6                	je     9 &lt;join+0x9&gt;</span><br><span class="line">  13:	90                   	nop</span><br><span class="line">  14:	90                   	nop</span><br><span class="line">  15:	5d                   	pop    %rbp</span><br><span class="line">  16:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>没加优化，每一次都会把done取出来，判断done是否为0</p>
<p>-O1优化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; gcc -O1 -c test.c</span><br><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;join&gt;:</span><br><span class="line">   <span class="number">0</span>:	f3 <span class="number">0f</span> <span class="number">1</span>e fa          	endbr64 </span><br><span class="line">   <span class="number">4</span>:	<span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    <span class="number">0x0</span>(%rip),%eax        <span class="meta"># a <span class="string">&lt;join+0xa&gt;</span></span></span><br><span class="line">   a:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">   c:	<span class="number">74</span> fc                	je     a &lt;join+<span class="number">0xa</span>&gt;</span><br><span class="line">   e:	c3                   	ret    </span><br></pre></td></tr></table></figure>

<p>只进行了一次取出done，多次判断相当于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(x=done))&#123;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们知道这个done为全局变量，万一被某个线程改掉了呢？就叛变了原本的逻辑</p>
<p>-O2优化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grxer@grxer ~/D/s/N/p3&gt; objdump -d test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;join&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # a &lt;join+0xa&gt;</span><br><span class="line">   a:	85 c0                	test   %eax,%eax</span><br><span class="line">   c:	75 02                	jne    10 &lt;join+0x10&gt;</span><br><span class="line">   e:	eb fe                	jmp    e &lt;join+0xe&gt;</span><br><span class="line">  10:	c3                   	ret   </span><br></pre></td></tr></table></figure>

<p>更离谱了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!done)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决办法</strong></p>
<ul>
<li><p>Memory Barrier</p>
<blockquote>
<p>asm volatile (“” ::: “memory”)</p>
<p>volatile告诉编译器不要对这条指令优化</p>
<p>memory 表示指令以不可预测的方式修改了内存， 强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。</p>
</blockquote>
</li>
<li><p>使用volatile变量</p>
<blockquote>
<p><strong>extern</strong> int <strong>volatile</strong> done;</p>
<p>volatile 指出 done 是随时可能发生变化的，每次使用它的时候必须从 done的地址中读取，</p>
</blockquote>
</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-h-%E7%AE%80%E5%8C%96%E7%9A%84%E7%BA%BF%E7%A8%8B-API"><span class="toc-number">1.</span> <span class="toc-text">thread.h 简化的线程 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">创建线程使用的是哪个系统调用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">gdb调试多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%A0%88%E5%8C%BA"><span class="toc-number">2.</span> <span class="toc-text">线程独立的栈区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E8%BF%99%E4%B8%AA%E5%A0%86%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">如何改变这个堆栈大小?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread%E6%B5%85%E8%B0%88"><span class="toc-number">2.2.</span> <span class="toc-text">__thread浅谈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">3.</span> <span class="toc-text">原子性的丧失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%9A%84%E4%B8%A7%E5%A4%B1"><span class="toc-number">4.</span> <span class="toc-text">顺序的丧失</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&text=NJUOS:多处理器编程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&is_video=false&description=NJUOS:多处理器编程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=NJUOS:多处理器编程&body=Check out this article: https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&title=NJUOS:多处理器编程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&name=NJUOS:多处理器编程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/04/NJUOS-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/&t=NJUOS:多处理器编程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    Grxer
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
