<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="Glibc2.23 exit() source code analysis测试程序 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&amp;#123;    puts(&quot;grxer&quot;);    exit(0);&amp;#125;  用户层面stdlib&#x2F;exit.c中 voidexit (int status)">
<meta property="og:type" content="article">
<meta property="og:title" content="Glibc exit() 源码分析">
<meta property="og:url" content="https://grxer.gitee.io/2023/04/02/exit/index.html">
<meta property="og:site_name" content="Grxer&#39;s Blog">
<meta property="og:description" content="Glibc2.23 exit() source code analysis测试程序 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&amp;#123;    puts(&quot;grxer&quot;);    exit(0);&amp;#125;  用户层面stdlib&#x2F;exit.c中 voidexit (int status)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402194009243.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402210547276.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402211644558.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402211610883.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402211718281.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402212201065.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402224531539.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402224604948.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402224642501.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402230052468.png">
<meta property="article:published_time" content="2023-04-02T08:29:01.000Z">
<meta property="article:modified_time" content="2023-08-29T15:42:39.454Z">
<meta property="article:author" content="bxz">
<meta property="article:tag" content="Exit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2023/04/02/exit/image-20230402194009243.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Glibc exit() 源码分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 lrt">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/04/02/main-return/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/04/01/IO-FILE-fclose/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/02/exit/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/02/exit/&text=Glibc exit() 源码分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/02/exit/&is_video=false&description=Glibc exit() 源码分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Glibc exit() 源码分析&body=Check out this article: https://grxer.gitee.io/2023/04/02/exit/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/02/exit/&name=Glibc exit() 源码分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/02/exit/&t=Glibc exit() 源码分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Glibc2-23-exit-source-code-analysis"><span class="toc-number">1.</span> <span class="toc-text">Glibc2.23 exit() source code analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E9%9D%A2"><span class="toc-number">2.</span> <span class="toc-text">用户层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#run-exit-handlers"><span class="toc-number">2.1.</span> <span class="toc-text">__run_exit_handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-tls-dtors"><span class="toc-number">2.1.1.</span> <span class="toc-text">__call_tls_dtors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">while循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO"><span class="toc-number">2.2.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO-1"><span class="toc-number">2.3.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN-HOOK-libc-atexit"><span class="toc-number">2.4.</span> <span class="toc-text">RUN_HOOK (__libc_atexit, ())</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-flush-all-lockp-o"><span class="toc-number">2.4.1.</span> <span class="toc-text">_IO_flush_all_lockp(o)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-unbuffer-all"><span class="toc-number">2.4.2.</span> <span class="toc-text">_IO_unbuffer_all</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%B1%82%E9%9D%A2"><span class="toc-number">3.</span> <span class="toc-text">内核层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">3.1.</span> <span class="toc-text">_exit()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Glibc exit() 源码分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">bxz</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-02T08:29:01.000Z" itemprop="datePublished">2023-04-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Exit/" rel="tag">Exit</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="Glibc2-23-exit-source-code-analysis"><a href="#Glibc2-23-exit-source-code-analysis" class="headerlink" title="Glibc2.23 exit() source code analysis"></a>Glibc2.23 exit() source code analysis</h2><p>测试程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;grxer&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户层面"><a href="#用户层面" class="headerlink" title="用户层面"></a>用户层面</h2><p>stdlib&#x2F;exit.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure>

<p>__exit_funcs是什么?</p>
<p><img src="/2023/04/02/exit/image-20230402194009243.png" alt="image-20230402194009243"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span><span class="comment">//单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;<span class="comment">//表示已经添加到该结构体中的函数数量。它用于跟踪 fns 数组中的下一个空闲位置。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span><span class="comment">//析构函数结构体数组</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flavor：用于标识退出处理函数的类型,在此结构体中定义了一个枚举类型，该字段应该是该枚举类型的成员之一</span></span><br><span class="line"><span class="comment">    &#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异</span></span><br><span class="line"><span class="comment">       at：一个指向无参数无返回值函数的指针，用于表示一种特殊的退出处理函数，该函数不需要传递任何参数，只需在程序退出时执行即可。</span></span><br><span class="line"><span class="comment">       on：一个带有两个参数的函数指针，第一个参数是退出状态码，第二个参数是一个指针类型，用于传递函数的参数。</span></span><br><span class="line"><span class="comment">       cxa：一个带有三个参数的函数指针，第一个参数是一个指针类型，用于传递函数的参数，第二个参数是退出状态码，第三个参数是一个指向动态共享对象句柄的指针。</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">union</span>//<span class="title">union</span>类型，用于表示上面三种不同类型的析构函数</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">    <span class="type">void</span> (*at) (<span class="type">void</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">      &#125; on;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">        <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">        <span class="type">void</span> *arg;</span><br><span class="line">        <span class="type">void</span> *dso_handle;</span><br><span class="line">      &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> <span class="title">initial</span>;</span>           <span class="comment">//initial定义在libc的可写入段中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *__<span class="title">exit_funcs</span> =</span> &amp;initial; <span class="comment">//exit函数链表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="run-exit-handlers"><a href="#run-exit-handlers" class="headerlink" title="__run_exit_handlers"></a>__run_exit_handlers</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">             <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span></span><br><span class="line">        &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">      <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">          <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">          <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ef_free:</span><br><span class="line">        <span class="keyword">case</span> ef_us:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_on:</span><br><span class="line">          onfct = f-&gt;func.on.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          onfct (status, f-&gt;func.on.arg);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_at:</span><br><span class="line">          atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          atfct ();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ef_cxa:</span><br><span class="line">          cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">          PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          cxafct (f-&gt;func.cxa.arg, status);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">       allocate element.  */</span></span><br><span class="line">    <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="call-tls-dtors"><a href="#call-tls-dtors" class="headerlink" title="__call_tls_dtors()"></a>__call_tls_dtors()</h4><p>stdlib&#x2F;cxa_thread_atexit_impl.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Call the destructors.  This is called either when a thread returns from the</span></span><br><span class="line"><span class="comment">   initial function or when the process exits via the exit function.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ensure that the MAP dereference happens before</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count decrement.  That way, we protect this access from a</span></span><br><span class="line"><span class="comment">     potential DSO unload in _dl_close_worker, which happens when</span></span><br><span class="line"><span class="comment">     l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__call_tls_dtors)</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚，当线程从调用初始函数返回时或进程通过exit函数退出时调用，释放线程局部储存</p>
<p><code>tls_dtor_list</code> 是多线程程序中的线程本地存储析构函数列表。<code>tls_dtor_list</code> 维护了所有需要在线程退出时被调用的析构函数的指针列表。这个列表会在程序运行时动态地进行修改和更新。</p>
<p>我们的示例程序并没有，直接return了</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>没什么好说的，不断遍历去根据类型，利用函数指针去调用__exit_funcs里的析构函数，释放掉结构体内存</p>
<p>不过这里涉及到一个解密操作</p>
<p><img src="/2023/04/02/exit/image-20230402210547276.png" alt="image-20230402210547276"></p>
<p>这个函数地址非常怪，不是正常值</p>
<p>会利用PTR_DEMANGLE这个解密</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)    asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>	      \</span></span><br><span class="line"><span class="meta">                     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>			      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;=r&quot;</span> (var)			      \</span></span><br><span class="line"><span class="meta">                     : <span class="string">&quot;0&quot;</span> (var),			      \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,	      \</span></span><br><span class="line"><span class="meta">                              pointer_guard)))</span></span><br></pre></td></tr></table></figure>

<p>循环右移和异或解密，异或的这个key来自tcbhead_t 0x30偏移处，之前tsl hijack时操作的0x28处的canary</p>
<p><img src="/2023/04/02/exit/image-20230402211644558.png" alt="image-20230402211644558"></p>
<p><img src="/2023/04/02/exit/image-20230402211610883.png" alt="image-20230402211610883"></p>
<p>ror后</p>
<p><img src="/2023/04/02/exit/image-20230402211718281.png" alt="image-20230402211718281"></p>
<p>xor后</p>
<p><img src="/2023/04/02/exit/image-20230402212201065.png" alt="image-20230402212201065"></p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>_dl_fini函数源码分析</p>
<h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p>__exit_funcs是怎么初始化的</p>
<h3 id="RUN-HOOK-libc-atexit"><a href="#RUN-HOOK-libc-atexit" class="headerlink" title="RUN_HOOK (__libc_atexit, ())"></a>RUN_HOOK (__libc_atexit, ())</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">text_set_element(__libc_atexit, _IO_cleanup);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_cleanup (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We do *not* want locking.  Some threads might use streams but</span></span><br><span class="line"><span class="comment">     that is their problem, we flush them underneath them.  */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We currently don&#x27;t have a reliable mechanism for making sure that</span></span><br><span class="line"><span class="comment">     C++ static destructors are executed in the correct order.</span></span><br><span class="line"><span class="comment">     So it is possible that other static destructors might want to</span></span><br><span class="line"><span class="comment">     write to cout - and they&#x27;re supposed to be able to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The following will make the standard streambufs be unbuffered,</span></span><br><span class="line"><span class="comment">     which forces any output from late destructors to be written out. */</span></span><br><span class="line">  _IO_unbuffer_all ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO-flush-all-lockp-o"><a href="#IO-flush-all-lockp-o" class="headerlink" title="_IO_flush_all_lockp(o)"></a>_IO_flush_all_lockp(o)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就开始一个清理区域的操作，并在需要时加锁 list_all_lock</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前 _IO_list_all 的时间戳，从头遍历所有打开的文件指针</span></span><br><span class="line">  last_stamp = _IO_list_all_stamp;</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 保存当前处理的文件指针，如果需要加锁就进行加锁操作</span></span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前文件指针是写模式并且有数据要输出，或者是宽字符模式并且有宽字符数据要输出，就进行输出操作</span></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">           || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">        result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果需要加锁就进行解锁操作，同时清空 run_fp 变量</span></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 _IO_list_all 的时间戳已经改变，说明有新的文件指针被添加进去了，需要重新从头遍历</span></span><br><span class="line">      <span class="keyword">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">          fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">          last_stamp = _IO_list_all_stamp;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        fp = fp-&gt;_chain; <span class="comment">// 否则继续处理下一个文件指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果定义了 _IO_MTSAFE_IO 宏，就解锁 list_all_lock，同时结束清理区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (do_lock)</span><br><span class="line">    _IO_lock_unlock (list_all_lock);</span><br><span class="line">  __libc_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有打开的文件指针的缓冲区中的数据输出，并清空缓冲区。函数的返回值为 <code>0</code> 或 <code>EOF</code>，表示输出是否成功。函数参数 <code>do_lock</code> 表示是否需要对文件指针加锁操作。函数主要采用了循环遍历 _IO_list_all 链表的方式来处理所有打开的文件指针。其中，如果定义了 <code>_IO_MTSAFE_IO</code> 宏，则使用了线程安全的加锁和解锁操作。</p>
<p>函数里调用_IO_OVERFLOW</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure>

<p>调用虚表中的__overflow，即_IO_new_file_overflow函数，第一参数_IO_FILE文件流结构体，第二个参数 EOF(-1)</p>
<p>fwrite分析过，会来到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">  <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">     f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/02/exit/image-20230402224531539.png" alt="image-20230402224531539"></p>
<p><img src="/2023/04/02/exit/image-20230402224604948.png" alt="image-20230402224604948"></p>
<p><img src="/2023/04/02/exit/image-20230402224642501.png" alt="image-20230402224642501"></p>
<p>调用了vtable中__write对应的<code>_IO_new_file_write</code></p>
<p>执行系统调用write把数据写入文件</p>
<p><img src="/2023/04/02/exit/image-20230402230052468.png" alt="image-20230402230052468"></p>
<h4 id="IO-unbuffer-all"><a href="#IO-unbuffer-all" class="headerlink" title="_IO_unbuffer_all"></a>_IO_unbuffer_all</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">      &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">      <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">         stream.  */</span></span><br><span class="line">          __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">        &#123;</span><br><span class="line">          fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">          fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">          freeres_list = fp;</span><br><span class="line">          fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">        _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">        _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">     used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_IO_SETBUF (fp, NULL, 0)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SETBUF(*FP*, *BUFFER*, *LENGTH*) JUMP2 (__setbuf, FP, BUFFER, LENGTH)</span></span><br></pre></td></tr></table></figure>

<p><strong>! (fp-&gt;_flags &amp; _IO_UNBUFFERED) &amp;&amp; fp-&gt;_mode !&#x3D; 0</strong></p>
<p>循环调用每个文件流的<mark>&#x3D;&#x3D;vatble里__setbuf对应的_IO_new_file_setbuf&#x3D;&#x3D;<mark></mark></mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_new_file_setbuf _IO_file_setbuf</span></span><br><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_SYNC(FP) JUMP0 (__sync, FP)</span></span><br></pre></td></tr></table></figure>

<p><mark>&#x3D;&#x3D;vtable __sync 对应的_IO_default_setbuf&#x3D;&#x3D;<mark></mark></mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_default_setbuf (_IO_FILE *fp, <span class="type">char</span> *p, _IO_ssize_t len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">    fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">    _IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (_IO_FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure>

<p>取消所有缓冲区，包括标准I&#x2F;O流和用户打开的文件流，以便文件的所有数据都立即被写入磁盘而不会留在缓冲区中。它遍历所有的_IO_FILE对象，并检查它们是否已被缓冲，如果是，则取消缓冲，并设置_IO_FILE对象的标志以指示它们已被缓冲。它还将_IO_FILE对象的模式设置为-1，以确保不再使用宽字符函数。在多线程环境下，代码使用锁来确保线程安全。</p>
<h2 id="内核层面"><a href="#内核层面" class="headerlink" title="内核层面"></a>内核层面</h2><h3 id="exit"><a href="#exit" class="headerlink" title="_exit()"></a>_exit()</h3><p>最后调用_exit系统调用销毁进程</p>
<ol>
<li><code>_exit</code>会立刻中断当前进程</li>
<li>关闭所有属于该进程的文件</li>
<li>将该进程的所有子进程移交给<code>init</code>进程</li>
<li>给该进程的父进程发送<code>SIGCHLD</code>信号</li>
<li><code>_exit</code>的参数<code>status</code>会被返回给父进程，可以被父进程的<code>wait</code>函数接收。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户层面：释放TLS，需要释放libc中的流缓冲区, 退出前清空下stdout的缓冲区</p>
<p>内核层面：释放掉这个进程打开的文件描述符, 释放掉task结构体,有资源都被释放完毕后, 内核会从调度队列从取出这个任务，然后向父进程发送一个信号, 表示有一个子进程终止，此时这个进程才算是真正结束</p>
<p>进程终止&#x3D;释放所有占有资源+cpu不在分配时间片给</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Glibc2-23-exit-source-code-analysis"><span class="toc-number">1.</span> <span class="toc-text">Glibc2.23 exit() source code analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E9%9D%A2"><span class="toc-number">2.</span> <span class="toc-text">用户层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#run-exit-handlers"><span class="toc-number">2.1.</span> <span class="toc-text">__run_exit_handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-tls-dtors"><span class="toc-number">2.1.1.</span> <span class="toc-text">__call_tls_dtors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">while循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO"><span class="toc-number">2.2.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO-1"><span class="toc-number">2.3.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN-HOOK-libc-atexit"><span class="toc-number">2.4.</span> <span class="toc-text">RUN_HOOK (__libc_atexit, ())</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-flush-all-lockp-o"><span class="toc-number">2.4.1.</span> <span class="toc-text">_IO_flush_all_lockp(o)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-unbuffer-all"><span class="toc-number">2.4.2.</span> <span class="toc-text">_IO_unbuffer_all</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%B1%82%E9%9D%A2"><span class="toc-number">3.</span> <span class="toc-text">内核层面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">3.1.</span> <span class="toc-text">_exit()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/04/02/exit/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/04/02/exit/&text=Glibc exit() 源码分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/04/02/exit/&is_video=false&description=Glibc exit() 源码分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Glibc exit() 源码分析&body=Check out this article: https://grxer.gitee.io/2023/04/02/exit/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/04/02/exit/&title=Glibc exit() 源码分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/04/02/exit/&name=Glibc exit() 源码分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/04/02/exit/&t=Glibc exit() 源码分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    bxz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
