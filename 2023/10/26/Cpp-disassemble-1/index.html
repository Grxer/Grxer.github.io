<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="虚函数编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。编译器还会在类的首部添加一个隐藏数据成员，称为虚表指针。保存着虚表的首地址 #include &lt;stdio.h&gt;class Person &amp;#123;public:  virtual int getAge() &amp;#123;  &#x2F;&#x2F;虚函数定义    return age;  &amp;#125;  v">
<meta property="og:type" content="article">
<meta property="og:title" content="C++反汇编 0x01">
<meta property="og:url" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/index.html">
<meta property="og:site_name" content="Grxer&#39;s Blog">
<meta property="og:description" content="虚函数编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。编译器还会在类的首部添加一个隐藏数据成员，称为虚表指针。保存着虚表的首地址 #include &lt;stdio.h&gt;class Person &amp;#123;public:  virtual int getAge() &amp;#123;  &#x2F;&#x2F;虚函数定义    return age;  &amp;#125;  v">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026094850173.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026120014414.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026123306196.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026124846358.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026125459339.png">
<meta property="article:published_time" content="2023-10-25T16:07:57.000Z">
<meta property="article:modified_time" content="2023-12-05T14:16:31.404Z">
<meta property="article:author" content="bxz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/image-20231026094850173.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>C++反汇编 0x01</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 lrt">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/11/01/Windows-Kernel-X86-api/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/10/24/Cpp-disassemble/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&text=C++反汇编 0x01"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&is_video=false&description=C++反汇编 0x01"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++反汇编 0x01&body=Check out this article: https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&name=C++反汇编 0x01&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&t=C++反汇编 0x01"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">类与父类之间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">虚继承(菱形继承)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sofabed%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">sofabed内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">虚继承子类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%E4%BB%A3%E7%90%86%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">虚继承子类代理析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++反汇编 0x01
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">bxz</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-25T16:07:57.000Z" itemprop="datePublished">2023-10-26</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。编译器还会在类的首部添加一个隐藏数据成员，称为虚表指针。保存着虚表的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;  <span class="comment">//虚函数定义</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  <span class="comment">//虚函数定义</span></span><br><span class="line">    this-&gt;age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Person() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~Person()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person person;</span><br><span class="line">  person.setAge(<span class="number">20</span>);</span><br><span class="line">  Person* ptr=&amp;person;</span><br><span class="line">  ptr-&gt;setAge(<span class="number">22</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, person.getAge());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000001400016E0    ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:00000001400016E0    mov     [rsp+arg_8], rdx</span><br><span class="line">.text:00000001400016E5    mov     [rsp+arg_0], ecx</span><br><span class="line">.text:00000001400016E9    sub     rsp, 48h</span><br><span class="line">.text:00000001400016ED    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:00000001400016F2    call    j_??0Person@@QEAA@XZ            ; Person::Person(void)</span><br><span class="line">.text:00000001400016F2</span><br><span class="line">.text:00000001400016F7    nop</span><br><span class="line">.text:00000001400016F8    mov     edx, 14h                        ; age</span><br><span class="line">.text:00000001400016FD    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:0000000140001702    call    j_?setAge@Person@@UEAAXH@Z      ; Person::setAge(int)</span><br><span class="line">.text:0000000140001702</span><br><span class="line">.text:0000000140001707    lea     rax, [rsp+48h+var_18]</span><br><span class="line">.text:000000014000170C    mov     [rsp+48h+var_20], rax</span><br><span class="line">.text:0000000140001711    mov     rax, [rsp+48h+var_20]           ;rax为this</span><br><span class="line">.text:0000000140001716    mov     rax, [rax]                      ;rax为虚表指针</span><br><span class="line">.text:0000000140001719    mov     edx, 16h                        ;参数:setAge(22)</span><br><span class="line">.text:000000014000171E    mov     rcx, [rsp+48h+var_20]           ;this指针用来寻址age成员</span><br><span class="line">.text:0000000140001723    call    qword ptr [rax+8]               ;利用虚表调用setAge</span><br><span class="line">.text:0000000140001723</span><br><span class="line">.text:0000000140001726    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:000000014000172B    call    j_?getAge@Person@@UEAAHXZ       ; Person::getAge(void)</span><br><span class="line">.text:000000014000172B</span><br><span class="line">.text:0000000140001730    mov     edx, eax</span><br><span class="line">.text:0000000140001732    lea     rcx, aD                         ; &quot;%d\n&quot;</span><br><span class="line">.text:0000000140001739    call    j_printf</span><br><span class="line">.text:0000000140001739</span><br><span class="line">.text:000000014000173E    mov     [rsp+48h+var_28], 0</span><br><span class="line">.text:0000000140001746    lea     rcx, [rsp+48h+var_18]           ; this</span><br><span class="line">.text:000000014000174B    call    j_??1Person@@QEAA@XZ            ; Person::~Person(void)</span><br><span class="line">.text:000000014000174B</span><br><span class="line">.text:0000000140001750    mov     eax, [rsp+48h+var_28]</span><br><span class="line">.text:0000000140001754    add     rsp, 48h</span><br><span class="line">.text:0000000140001758    retn</span><br></pre></td></tr></table></figure>

<p>编译器自动添加构造函数,把类首部赋值为虚表指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.rdata:<span class="number">0000000140007</span>DE8 ??_7Person@@<span class="number">6B</span>@ dq offset j_?getAge@Person@@UEAAHXZ, offset j_?setAge@Person@@UEAAXH@Z, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">.text:<span class="number">0000000140001510</span>  ; <span class="type">void</span> __fastcall <span class="title function_">Person::Person</span><span class="params">(Person *this)</span></span><br><span class="line">.text:0000000140001510  ??0Person@@QEAA@XZ proc near            ; CODE XREF: Person::Person(<span class="type">void</span>)↑j</span><br><span class="line">.text:<span class="number">0000000140001510</span></span><br><span class="line">.text:<span class="number">0000000140001510</span>  arg_0= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000140001510</span></span><br><span class="line">.text:<span class="number">0000000140001510</span>  mov     [rsp+arg_0], rcx</span><br><span class="line">.text:<span class="number">0000000140001515</span>  mov     rax, [rsp+arg_0]</span><br><span class="line">.text:<span class="number">000000014000151</span>A  lea     rcx, ??_7Person@@<span class="number">6B</span>@            ; <span class="type">const</span> Person::`vftable<span class="number">&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001521</span>  mov     [rax], rcx</span><br><span class="line">.text:<span class="number">0000000140001524</span>  mov     rax, [rsp+arg_0]</span><br><span class="line">.text:<span class="number">0000000140001529</span>  retn</span><br></pre></td></tr></table></figure>

<p>析构函数会再次给类首部赋值虚表指针，让其指向自身的虚表首地址，</p>
<p>子类以后可能会被其他类继承成为父类,子类执行完析构函数执行父类的析构，此时this指针处虚表是子类的，如果不修改虚表就会执行到子类析构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001570   ; void __fastcall Person::~Person(Person *this)</span><br><span class="line">.text:0000000140001570   ??1Person@@QEAA@XZ proc near            ; CODE XREF: Person::~Person(void)↑j</span><br><span class="line">.text:0000000140001570                                           ; DATA XREF: .pdata:ExceptionDir↓o</span><br><span class="line">.text:0000000140001570</span><br><span class="line">.text:0000000140001570   arg_0= qword ptr  8</span><br><span class="line">.text:0000000140001570</span><br><span class="line">.text:0000000140001570   mov     [rsp+arg_0], rcx</span><br><span class="line">.text:0000000140001575   sub     rsp, 28h</span><br><span class="line">.text:0000000140001579   mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:000000014000157E   lea     rcx, ??_7Person@@6B@            ; const Person::`vftable&#x27;</span><br><span class="line">.text:0000000140001585   mov     [rax], rcx</span><br><span class="line">.text:0000000140001588   lea     rcx, _Format                    ; &quot;~Person()\n&quot;</span><br><span class="line">.text:000000014000158F   call    j_printf</span><br><span class="line">.text:000000014000158F</span><br><span class="line">.text:0000000140001594   add     rsp, 28h</span><br><span class="line">.text:0000000140001598   retn</span><br></pre></td></tr></table></figure>

<p>同时可以发现直接使用对象调用自身虚函数时，被编译成直接call虚函数，不走虚表，效率高</p>
<p>通过指针或者引用(引用只是在编译期间多了检测的指针)调用虚函数是从虚表取出虚函数指针再调用</p>
<h2 id="类与父类之间关系"><a href="#类与父类之间关系" class="headerlink" title="类与父类之间关系"></a>类与父类之间关系</h2><p>在内存中的数据排列：先安排父类的数据，后安排子类新定义的数据。父类中声明为私有（private）的成员，子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。C++语法规定的访问控制仅限于编译层面，在编译的过程中由编译器进行语法检查</p>
<blockquote>
<p>父类数据在前面方便了使用父类函数，直接传递子类this指针即可</p>
</blockquote>
<p>对于子类无构造析构函数，父类有构造和析构函数，子类会提供默认构造和析构函数</p>
<p>构造：基类→基类的派生类→……→当前类。<br>析构：当前类→基类的派生类→……→基类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span>    <span class="comment">// 基类—&quot; 人 &quot; 类</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;</span><br><span class="line">    showSpeak();</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Person() &#123;</span><br><span class="line">    showSpeak();</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Person\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> :</span> public Person &#123;    <span class="comment">// 中国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  Chinese() &#123;&#125;</span><br><span class="line">  virtual ~Chinese() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;    <span class="comment">// 覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">American</span> :</span> public Person &#123; <span class="comment">//美国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  American() &#123;&#125;</span><br><span class="line">  virtual ~American() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123; <span class="comment">//覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak American\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">German</span> :</span> public Person &#123; <span class="comment">//德国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  German() &#123;&#125;</span><br><span class="line">  virtual ~German() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123; <span class="comment">//覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak German\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">speak</span><span class="params">(Person* person)</span> &#123; <span class="comment">//根据虚表信息获取虚函数首地址并调用</span></span><br><span class="line">  person-&gt;showSpeak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Chinese chinese;</span><br><span class="line">  American american;</span><br><span class="line">  German german;</span><br><span class="line">  speak(&amp;chinese);</span><br><span class="line">  speak(&amp;american);</span><br><span class="line">  speak(&amp;german);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类会按照父类虚函数定义的顺序排列属于自己的虚表</p>
<p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026094850173.png" alt="image-20231026094850173"></p>
<p>调用构造或析构函数第一步都是将虚表指针换为该类的虚表指针，来调用到属于自己的函数</p>
<blockquote>
<p>析构函数没有被定义为虚函数，那么编译器会按指针的类型调用父类的析构函数，从而引发错误</p>
</blockquote>
<p>显式调用析构函数时不能马上释放堆内存，所以在析构函数的代理函数中通过一个参数控制是否释放内存，便于程序员管理析构函数的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span>    <span class="comment">// 基类—&quot; 人 &quot; 类</span></span><br><span class="line">public:</span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line">  virtual ~Person() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> :</span> public Person &#123;    <span class="comment">// 中国人：继承自人类</span></span><br><span class="line">public:</span><br><span class="line">  Chinese() &#123;&#125;</span><br><span class="line">  virtual ~Chinese() &#123;&#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">showSpeak</span><span class="params">()</span> &#123;    <span class="comment">// 覆盖基类虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Speak Chinese\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  Person* p = new Chinese;</span><br><span class="line">  p-&gt;~Person(); <span class="comment">//显式调用析构函数</span></span><br><span class="line">  <span class="comment">//将堆内存中p指向的地址作为Chinese的新对象的首地址，并调用Chinese的构造函数。这</span></span><br><span class="line">  <span class="comment">//样可以重复使用同一个堆内存，以节约内存空间</span></span><br><span class="line">  p = new (p) Chinese();</span><br><span class="line">  delete p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:   p-&gt;~Person(); //显式调用析构函数</span><br><span class="line">0000000140001772  mov         rax,qword ptr [p] ;rax=对象地址</span><br><span class="line">0000000140001777  mov         rax,qword ptr [rax]  ;rax=虚表指针</span><br><span class="line">000000014000177A  xor         edx,edx  ;参数0只调用析构函数不释放</span><br><span class="line">000000014000177C  mov         rcx,qword ptr [p] ;this指针</span><br><span class="line">0000000140001781  call        qword ptr [rax]  ;虚表第一项:代理析构函数</span><br><span class="line">    23:   //将堆内存中p指向的地址作为Chinese的新对象的首地址，并调用Chinese的构造函数。这</span><br><span class="line">    24:   //样可以重复使用同一个堆内存，以节约内存空间</span><br><span class="line">    25:   p = new (p) Chinese();</span><br><span class="line">0000000140001783  mov         rdx,qword ptr [p]  </span><br><span class="line">0000000140001788  mov         ecx,8  </span><br><span class="line">000000014000178D  call        operator new (0140001203h)  </span><br><span class="line">0000000140001792  mov         qword ptr [rsp+48h],rax  </span><br><span class="line">0000000140001797  mov         rcx,qword ptr [rsp+48h];this指针  </span><br><span class="line">000000014000179C  call        Chinese::Chinese (01400011CCh)  </span><br><span class="line">00000001400017A1  mov         qword ptr [p],rax </span><br></pre></td></tr></table></figure>

<p><code>000000014000178D  call        operator new (0140001203h)</code>  这里new也不是完整的new</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   167:         _Writable_bytes_(_Size) void* _Where) noexcept</span><br><span class="line">   168:     &#123;</span><br><span class="line">00000001400015C0 48 89 54 24 10       mov         qword ptr [rsp+10h],rdx  </span><br><span class="line">00000001400015C5 48 89 4C 24 08       mov         qword ptr [rsp+8],rcx  </span><br><span class="line">   169:         (void)_Size;</span><br><span class="line">   170:         return _Where;</span><br><span class="line">00000001400015CA 48 8B 44 24 10       mov         rax,qword ptr [rsp+10h]  </span><br><span class="line">   171:     &#125;</span><br></pre></td></tr></table></figure>

<p>直接把堆返回回来了</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Sofa() &#123;</span><br><span class="line">    color = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Sofa() &#123;    <span class="comment">// 沙发类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~Sofa()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getColor</span><span class="params">()</span> &#123;    <span class="comment">// 获取沙发颜色</span></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">// 沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down and rest your legs\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> color;    <span class="comment">// 沙发类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义床类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Bed() &#123;</span><br><span class="line">    length = <span class="number">4</span>;</span><br><span class="line">    width = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Bed() &#123;  <span class="comment">//床类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~Bed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123; <span class="comment">//获取床面积</span></span><br><span class="line">    <span class="keyword">return</span> length * width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;  <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> length;    <span class="comment">//床类成员变量</span></span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类沙发床定义，派生自 Sofa 类和 Bed 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span> public Sofa, public Bed &#123;</span><br><span class="line">public:</span><br><span class="line">  SofaBed() &#123;</span><br><span class="line">    height = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~SofaBed() &#123;    <span class="comment">//沙发床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;virtual ~SofaBed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sit down on the sofa bed\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;go to sleep on the sofa bed\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  SofaBed sofabed;</span><br><span class="line">  Sofa* sofa = &amp;sofabed;</span><br><span class="line">  Bed* bed = &amp;sofabed;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员的排列顺序由继承父类的顺序决定，从左向右依次排列。</p>
<p>子类中实现的虚函数会在虚表里替换，没实现的依旧是父类虚函数</p>
<p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026120014414.png" alt="image-20231026120014414"></p>
<blockquote>
<p>vs2022里的监视窗口不是真实内存布局，只不过这次凑巧一样,还是要从内存窗口看</p>
</blockquote>
<p>构造函数会把this指针调整到各个父类部分，调用父类的构造函数，然后再把SofaBed的虚表指针赋值到各个父类部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001620    ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:0000000140001620    mov     [rsp+arg_0], rcx</span><br><span class="line">.text:0000000140001625    sub     rsp, 28h</span><br><span class="line">.text:0000000140001629    mov     rcx, [rsp+28h+arg_0]            ; this</span><br><span class="line">.text:000000014000162E    call    j_??0Sofa@@QEAA@XZ              ; Sofa::Sofa(void)</span><br><span class="line">.text:000000014000162E</span><br><span class="line">.text:0000000140001633    nop</span><br><span class="line">.text:0000000140001634    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001639    add     rax, 10h                        ;调整到Bed this位置</span><br><span class="line">.text:000000014000163D    mov     rcx, rax                        ; this</span><br><span class="line">.text:0000000140001640    call    j_??0Bed@@QEAA@XZ               ; Bed::Bed(void)</span><br><span class="line">.text:0000000140001640</span><br><span class="line">.text:0000000140001645    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:000000014000164A    lea     rcx, ??_7SofaBed@@6BSofa@@@     ; const SofaBed::`vftable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:0000000140001651    mov     [rax], rcx</span><br><span class="line">.text:0000000140001654    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001659    lea     rcx, ??_7SofaBed@@6BBed@@@      ; const SofaBed::`vftable&#x27;&#123;for `Bed&#x27;&#125;</span><br><span class="line">.text:0000000140001660    mov     [rax+10h], rcx</span><br><span class="line">.text:0000000140001664    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001669    mov     dword ptr [rax+20h], 6</span><br><span class="line">.text:0000000140001670    mov     rax, [rsp+28h+arg_0]</span><br><span class="line">.text:0000000140001675    add     rsp, 28h</span><br><span class="line">.text:0000000140001679    retn</span><br><span class="line">.text:0000000140001679    ; &#125; // starts at 140001620</span><br></pre></td></tr></table></figure>

<p>析构函数也是一样套路，不过是先把SofaBed的虚表指针赋值到各个父类部分调用析构函数，在把this指针调整到各个父类部分，调用父类的构造函数</p>
<p>指针赋值也是一样的套路</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBase</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  AbstractBase() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AbstractBase()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> = <span class="number">0</span>;    <span class="comment">//定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualChild</span> :</span> public AbstractBase &#123;    <span class="comment">//定义继承抽象类的子类</span></span><br><span class="line">public:</span><br><span class="line">  virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;    <span class="comment">//实现纯虚函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;抽象类分析\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  VirtualChild obj;</span><br><span class="line">  obj.show();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纯虚函数的虚表项为_purecall_0，是编译器保证未定义的纯虚函数被调用提供的用于结束程序的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.rdata:<span class="number">0000000140007B</span>B8 DE <span class="number">15</span> <span class="number">00</span> <span class="number">40</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>+??_7AbstractBase@@<span class="number">6B</span>@ dq offset _purecall_0, <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="虚继承-菱形继承"><a href="#虚继承-菱形继承" class="headerlink" title="虚继承(菱形继承)"></a>虚继承(菱形继承)</h2><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026123306196.png" alt="image-20231026123306196"></p>
<p>从这位大哥:<a target="_blank" rel="noopener" href="https://lonelyenderman.top/archives/723">https://lonelyenderman.top/archives/723</a> 偷来的图，感觉比较有意思</p>
<p>羊和驼都继承了动物的类成员，当羊驼想要使用时，会产生数据冗余和二义性，引出了虚继承</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义家具类，虚基类，等同于类 羊驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Furniture</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  Furniture() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::Furniture()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Furniture() &#123;    <span class="comment">//家具类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::~Furniture()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;    <span class="comment">//获取家具价格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Furniture::getPrice()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> price;    <span class="comment">//家具类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义沙发类，继承自类 Furniture，等同于类 羊</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> :</span> virtual public Furniture &#123;</span><br><span class="line">public:</span><br><span class="line">  Sofa() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::Sofa()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">1</span>;</span><br><span class="line">    color = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Sofa() &#123;    <span class="comment">//沙发类虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::~Sofa()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getColor</span><span class="params">()</span> &#123;    <span class="comment">//获取沙发颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sofa::getColor()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Sofa::sitDown()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> color;    <span class="comment">// 沙发类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义床类，继承自类 Furniture，等同于类 驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bed</span> :</span> virtual public Furniture &#123;</span><br><span class="line">public:</span><br><span class="line">  Bed() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::Bed()\n&quot;</span>);</span><br><span class="line">    price = <span class="number">3</span>;</span><br><span class="line">    length = <span class="number">4</span>;</span><br><span class="line">    width = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual ~Bed() &#123;    <span class="comment">//床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::~Bed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;    <span class="comment">//获取床面积</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bed::getArea()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> length * width;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">printf</span>(<span class="string">&quot;Bed::sleep()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> length;    <span class="comment">//床类成员变量</span></span><br><span class="line">  <span class="type">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类沙发床的定义，派生自类 Sofa 和类 Bed，等同于类 羊驼</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SofaBed</span> :</span> public Sofa, public Bed &#123;</span><br><span class="line">public:</span><br><span class="line">  SofaBed() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::SofaBed()\n&quot;</span>);</span><br><span class="line">    height = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~SofaBed() &#123;    <span class="comment">//沙发床类的虚析构函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::~SofaBed()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sitDown</span><span class="params">()</span> &#123;    <span class="comment">//沙发可以坐下休息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::sitDown()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;    <span class="comment">//床可以用来睡觉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::sleep()\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  virtual <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SofaBed::getHeight()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">  &#125;</span><br><span class="line">protected:</span><br><span class="line">  <span class="type">int</span> height;    <span class="comment">//沙发类的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">  SofaBed sofabed;</span><br><span class="line">  Furniture* p1 = &amp;sofabed;   <span class="comment">//转换成虚基类指针</span></span><br><span class="line">  Sofa* p2 = &amp;sofabed;        <span class="comment">//转换成父类指针</span></span><br><span class="line">  Bed* p3 = &amp;sofabed;         <span class="comment">//转换成父类指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, p1, p2, p3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sofabed内存布局"><a href="#sofabed内存布局" class="headerlink" title="sofabed内存布局"></a>sofabed内存布局</h3><p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026124846358.png" alt="image-20231026124846358"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140003550 ; __int64 __fastcall main(int argc, char **argv)</span><br><span class="line">.text:0000000140003550 main proc near                          ; CODE XREF: main_0↑j</span><br><span class="line">.text:0000000140003550                                         ; DATA XREF: .pdata:000000014000B390↓o</span><br><span class="line">.text:0000000140003550</span><br><span class="line">.text:0000000140003550 var_88= dword ptr -88h</span><br><span class="line">.text:0000000140003550 var_80= qword ptr -80h</span><br><span class="line">.text:0000000140003550 var_78= qword ptr -78h</span><br><span class="line">.text:0000000140003550 var_70= qword ptr -70h</span><br><span class="line">.text:0000000140003550 var_68= qword ptr -68h</span><br><span class="line">.text:0000000140003550 var_60= qword ptr -60h</span><br><span class="line">.text:0000000140003550 SofaBed= SofaBed ptr -58h</span><br><span class="line">.text:0000000140003550 arg_0= dword ptr  8</span><br><span class="line">.text:0000000140003550 arg_8= qword ptr  10h</span><br><span class="line">.text:0000000140003550</span><br><span class="line">.text:0000000140003550 mov     [rsp+arg_8], rdx</span><br><span class="line">.text:0000000140003555 mov     [rsp+arg_0], ecx</span><br><span class="line">.text:0000000140003559 sub     rsp, 0A8h</span><br><span class="line">.text:0000000140003560 mov     edx, 1                          ; 构造虚基类的标志：1构造，0不构造</span><br><span class="line">.text:0000000140003565 lea     rcx, [rsp+0A8h+SofaBed]         ; this</span><br><span class="line">.text:000000014000356A call    j_??0SofaBed@@QEAA@XZ           ; SofaBed::SofaBed(void)</span><br><span class="line">.text:000000014000356A</span><br><span class="line">.text:000000014000356F lea     rax, [rsp+50h]</span><br><span class="line">.text:0000000140003574 test    rax, rax</span><br><span class="line">.text:0000000140003577 jnz     short loc_140003584             </span><br><span class="line">.text:0000000140003577</span><br><span class="line">.text:0000000140003579 mov     [rsp+0A8h+var_80], 0</span><br><span class="line">.text:0000000140003582 jmp     short loc_140003597</span><br><span class="line">.text:0000000140003582</span><br><span class="line">.text:0000000140003584 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000140003584</span><br><span class="line">.text:0000000140003584 loc_140003584:                          ; CODE XREF: main+27↑j</span><br><span class="line">.text:0000000140003584 mov     rax, qword ptr [rsp+0A8h+SofaBed.baseclass_0.gap8] ; 取出对象Sofa虚基类偏移表</span><br><span class="line">.text:0000000140003589 movsxd  rax, dword ptr [rax+4]          ; 取出对象中Sofa类虚基类偏移表第二项，虚基类对象首地址相对于虚基类偏移表的偏移值。</span><br><span class="line">.text:000000014000358D lea     rax, [rsp+rax+0A8h+SofaBed.baseclass_0.gap8] ; 找到虚基类</span><br><span class="line">.text:0000000140003592 mov     [rsp+0A8h+var_80], rax</span><br><span class="line">.text:0000000140003592</span><br><span class="line">.text:0000000140003597</span><br><span class="line">.text:0000000140003597 loc_140003597:                          ; CODE XREF: main+32↑j</span><br><span class="line">.text:0000000140003597 mov     rax, [rsp+0A8h+var_80]</span><br><span class="line">.text:000000014000359C mov     [rsp+0A8h+var_60], rax          ; Furniture* p1 = &amp;sofabed;   //转换成虚基类指针</span><br><span class="line">.text:00000001400035A1 lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035A6 mov     [rsp+0A8h+var_68], rax          ; Sofa* p2 = &amp;sofabed;        //转换成父类指针</span><br><span class="line">.text:00000001400035AB lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035B0 test    rax, rax</span><br><span class="line">.text:00000001400035B3 jz      short loc_1400035C5</span><br><span class="line">.text:00000001400035B3</span><br><span class="line">.text:00000001400035B5 lea     rax, [rsp+0A8h+SofaBed]</span><br><span class="line">.text:00000001400035BA add     rax, 18h                        ; 直接加偏移获取到Bed首地址</span><br><span class="line">.text:00000001400035BE mov     [rsp+0A8h+var_78], rax</span><br><span class="line">.text:00000001400035C3 jmp     short loc_1400035CE</span><br><span class="line">.text:00000001400035C3</span><br><span class="line">.text:00000001400035C5 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000001400035C5</span><br><span class="line">.text:00000001400035C5 loc_1400035C5:                          ; CODE XREF: main+63↑j</span><br><span class="line">.text:00000001400035C5 mov     [rsp+0A8h+var_78], 0</span><br><span class="line">.text:00000001400035C5</span><br><span class="line">.text:00000001400035CE</span><br><span class="line">.text:00000001400035CE loc_1400035CE:                          ; CODE XREF: main+73↑j</span><br><span class="line">.text:00000001400035CE mov     rax, [rsp+0A8h+var_78]</span><br><span class="line">.text:00000001400035D3 mov     [rsp+0A8h+var_70], rax          ; Bed* p3 = &amp;sofabed;         //转换成父类指针</span><br><span class="line">.text:00000001400035D8 mov     r9, [rsp+0A8h+var_70]</span><br><span class="line">.text:00000001400035DD mov     r8, [rsp+0A8h+var_68]</span><br><span class="line">.text:00000001400035E2 mov     rdx, [rsp+0A8h+var_60]</span><br><span class="line">.text:00000001400035E7 lea     rcx, aPPP                       ; &quot;%p %p %p\n&quot;</span><br><span class="line">.text:00000001400035EE call    j_printf</span><br><span class="line">.text:00000001400035EE</span><br><span class="line">.text:00000001400035F3 mov     [rsp+0A8h+var_88], 0</span><br><span class="line">.text:00000001400035FB lea     rcx, [rsp+0A8h+SofaBed]         ; this</span><br><span class="line">.text:0000000140003600 call    j_??_DSofaBed@@QEAAXXZ          ; SofaBed::`vbase destructor&#x27;(void)</span><br><span class="line">.text:0000000140003600</span><br><span class="line">.text:0000000140003605 mov     eax, [rsp+0A8h+var_88]</span><br><span class="line">.text:0000000140003609 add     rsp, 0A8h</span><br><span class="line">.text:0000000140003610 retn</span><br></pre></td></tr></table></figure>

<p>Sofa虚基类偏移表存储两个值-8 和 0x30</p>
<p><img src="/2023/10/26/Cpp-disassemble-1/image-20231026125459339.png" alt="image-20231026125459339"></p>
<ul>
<li>第一项为-8，即虚基类偏移表所属类对应的对象首地址相对于虚基类偏移表的偏移值；</li>
<li>第二项保存的是虚基类对象首地址相对于虚基类偏移表的偏移值。</li>
</ul>
<p>虚基类放到了一个公共的位置，羊和驼类里原本存放动物的位置现在存放虚基偏移表指针，利用偏移来寻址虚基类</p>
<p>多个虚基类时，会在虚基类偏移表中依次记录它们的偏移量。</p>
<h3 id="虚继承子类构造函数"><a href="#虚继承子类构造函数" class="headerlink" title="虚继承子类构造函数"></a>虚继承子类构造函数</h3><p><strong>虚继承子类构造函数传入了参数1:this指针，参数2:构造虚基类的标志：1构造，0不构造,防止重复构造虚基类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000140001860 ; void __fastcall SofaBed::SofaBed(SofaBed *this)</span><br><span class="line">.text:0000000140001860 ??0SofaBed@@QEAA@XZ proc near           ; CODE XREF: SofaBed::SofaBed(void)↑j</span><br><span class="line">.text:0000000140001860                                         ; DATA XREF: .pdata:000000014000B048↓o</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 var_18= dword ptr -18h</span><br><span class="line">.text:0000000140001860 sofabed_this= qword ptr  8</span><br><span class="line">.text:0000000140001860 flag= dword ptr  10h</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 ; FUNCTION CHUNK AT .text:00000001400057E0 SIZE 0000002A BYTES</span><br><span class="line">.text:0000000140001860 ; FUNCTION CHUNK AT .text:0000000140005810 SIZE 0000001C BYTES</span><br><span class="line">.text:0000000140001860</span><br><span class="line">.text:0000000140001860 ; __unwind &#123; // __CxxFrameHandler4_0</span><br><span class="line">.text:0000000140001860 mov     [rsp+flag], edx</span><br><span class="line">.text:0000000140001864 mov     [rsp+sofabed_this], rcx</span><br><span class="line">.text:0000000140001869 sub     rsp, 38h</span><br><span class="line">.text:000000014000186D mov     [rsp+38h+var_18], 0</span><br><span class="line">.text:0000000140001875 cmp     [rsp+38h+flag], 0</span><br><span class="line">.text:000000014000187A jz      short loc_1400018B9             ; 为0不构造虚基类，防止重复构造虚基类</span><br><span class="line">.text:000000014000187A</span><br><span class="line">.text:000000014000187C mov     rax, [rsp+38h+sofabed_this]     ; rax=this指针</span><br><span class="line">.text:0000000140001881 lea     rcx, ??_8SofaBed@@7BSofa@@@     ; const SofaBed::`vbtable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:0000000140001888 mov     [rax+8], rcx                    ; 设置父类Sofa中的虚基类偏移表</span><br><span class="line">.text:000000014000188C mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001891 lea     rcx, ??_7SofaBed@@6BFurniture@@@+10h ; const SofaBed::`vftable&#x27;&#123;for `Furniture&#x27;&#125;</span><br><span class="line">.text:0000000140001898 mov     [rax+20h], rcx                  ; 设置父类Bed中的虚基类偏移</span><br><span class="line">.text:000000014000189C mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018A1 add     rax, 38h ; &#x27;8&#x27;                  ; 调整this指针为虚基类this指针</span><br><span class="line">.text:00000001400018A5 mov     rcx, rax                        ; this</span><br><span class="line">.text:00000001400018A8 call    j_??0Furniture@@QEAA@XZ         ; Furniture::Furniture(void)</span><br><span class="line">.text:00000001400018A8</span><br><span class="line">.text:00000001400018AD nop</span><br><span class="line">.text:00000001400018AE mov     eax, [rsp+38h+var_18]           ; eax=0</span><br><span class="line">.text:00000001400018B2 or      eax, 1                          ; eax=1</span><br><span class="line">.text:00000001400018B5 mov     [rsp+38h+var_18], eax</span><br><span class="line">.text:00000001400018B5</span><br><span class="line">.text:00000001400018B9</span><br><span class="line">.text:00000001400018B9 loc_1400018B9:                          ; CODE XREF: SofaBed::SofaBed(void)+1A↑j</span><br><span class="line">.text:00000001400018B9 xor     edx, edx                        ; 给Sofa传入0,不再构造虚基类，上面已经构造过了</span><br><span class="line">.text:00000001400018BB mov     rcx, [rsp+38h+sofabed_this]     ; this</span><br><span class="line">.text:00000001400018BB</span><br><span class="line">.text:00000001400018C0</span><br><span class="line">.text:00000001400018C0 loc_1400018C0:                          ; CODE XREF: .text:00000001400010DC↑j</span><br><span class="line">.text:00000001400018C0 call    j_??0Sofa@@QEAA@XZ              ; Sofa::Sofa(void)</span><br><span class="line">.text:00000001400018C0</span><br><span class="line">.text:00000001400018C5 nop</span><br><span class="line">.text:00000001400018C6 ;   try &#123;</span><br><span class="line">.text:00000001400018C6 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018CB add     rax, 18h</span><br><span class="line">.text:00000001400018CF xor     edx, edx</span><br><span class="line">.text:00000001400018D1 mov     rcx, rax                        ; this</span><br><span class="line">.text:00000001400018D4 call    j_??0Bed@@QEAA@XZ               ; Bed::Bed(void)</span><br><span class="line">.text:00000001400018D4</span><br><span class="line">.text:00000001400018D9 mov     rax, [rsp+38h+sofabed_this]     ; 下面就是设置各个类的虚表指针</span><br><span class="line">.text:00000001400018DE lea     rcx, ??_7SofaBed@@6BSofa@@@     ; const SofaBed::`vftable&#x27;&#123;for `Sofa&#x27;&#125;</span><br><span class="line">.text:00000001400018E5 mov     [rax], rcx</span><br><span class="line">.text:00000001400018E8 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018ED lea     rcx, ??_7SofaBed@@6BBed@@@      ; const SofaBed::`vftable&#x27;&#123;for `Bed&#x27;&#125;</span><br><span class="line">.text:00000001400018F4 mov     [rax+18h], rcx</span><br><span class="line">.text:00000001400018F8 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:00000001400018FD mov     rax, [rax+8]</span><br><span class="line">.text:0000000140001901 movsxd  rax, dword ptr [rax+4]</span><br><span class="line">.text:0000000140001905 mov     rcx, [rsp+38h+sofabed_this]</span><br><span class="line">.text:000000014000190A lea     rdx, ??_7SofaBed@@6BFurniture@@@ ; const SofaBed::`vftable&#x27;&#123;for `Furniture&#x27;&#125;</span><br><span class="line">.text:0000000140001911 mov     [rcx+rax+8], rdx</span><br><span class="line">.text:0000000140001916 lea     rcx, aSofabedSofabed            ; &quot;SofaBed::SofaBed()\n&quot;</span><br><span class="line">.text:000000014000191D call    j_printf</span><br><span class="line">.text:000000014000191D</span><br><span class="line">.text:0000000140001922 mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001927 mov     dword ptr [rax+30h], 6</span><br><span class="line">.text:0000000140001927 ;   &#125; // starts at 1400018C6</span><br><span class="line">.text:000000014000192E mov     rax, [rsp+38h+sofabed_this]</span><br><span class="line">.text:0000000140001933 add     rsp, 38h</span><br><span class="line">.text:0000000140001937 retn</span><br></pre></td></tr></table></figure>

<h3 id="虚继承子类代理析构函数"><a href="#虚继承子类代理析构函数" class="headerlink" title="虚继承子类代理析构函数"></a>虚继承子类代理析构函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">00000001400019F</span>0 ; <span class="type">void</span> __fastcall SofaBed::`vbase destructor<span class="number">&#x27;</span>(SofaBed *this)</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 ??_DSofaBed@@QEAAXXZ proc near          ; CODE XREF: SofaBed::`vbase destructor<span class="number">&#x27;</span>(<span class="type">void</span>)↑j</span><br><span class="line">.text:<span class="number">00000001400019F</span>0                                         ; DATA XREF: .pdata:<span class="number">000000014000B</span>060↓o</span><br><span class="line">.text:<span class="number">00000001400019F</span>0                                         ; .pdata:<span class="number">000000014000B</span>06C↓o</span><br><span class="line">.text:<span class="number">00000001400019F</span>0</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 sofabed_this= qword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000001400019F</span>0</span><br><span class="line">.text:<span class="number">00000001400019F</span>0 mov     [rsp+sofabed_this], rcx</span><br><span class="line">.text:<span class="number">00000001400019F</span>5 sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000001400019F</span>9 mov     rax, [rsp+<span class="number">28</span>h+sofabed_this]</span><br><span class="line">.text:<span class="number">00000001400019F</span>E add     rax, <span class="number">38</span>h ; <span class="string">&#x27;8&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001</span>A02 mov     rcx, rax                        ; this</span><br><span class="line">.text:<span class="number">0000000140001</span>A05 call    j_??<span class="number">1</span>SofaBed@@UEAA@XZ           ; SofaBed::~SofaBed(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001</span>A05</span><br><span class="line">.text:<span class="number">0000000140001</span>A0A mov     rax, [rsp+<span class="number">28</span>h+sofabed_this]</span><br><span class="line">.text:<span class="number">0000000140001</span>A0F add     rax, <span class="number">38</span>h ; <span class="string">&#x27;8&#x27;</span></span><br><span class="line">.text:<span class="number">0000000140001</span>A13 mov     rcx, rax                        ; this</span><br><span class="line">.text:<span class="number">0000000140001</span>A16 call    j_??<span class="number">1F</span>urniture@@UEAA@XZ         ; Furniture::~Furniture(<span class="type">void</span>)</span><br><span class="line">.text:<span class="number">0000000140001</span>A16</span><br><span class="line">.text:<span class="number">0000000140001</span>A1B add     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000140001</span>A1F retn</span><br></pre></td></tr></table></figure>

<p>先依次执行两个父类Bed和Sofa的析构函数，然后执行虚基类的析构函数</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><strong>C++反汇编与逆向分析技术揭秘</strong></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">类与父类之间关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF-%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">虚继承(菱形继承)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sofabed%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">sofabed内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">虚继承子类构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%AD%90%E7%B1%BB%E4%BB%A3%E7%90%86%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">虚继承子类代理析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">6.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&text=C++反汇编 0x01"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&is_video=false&description=C++反汇编 0x01"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++反汇编 0x01&body=Check out this article: https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&title=C++反汇编 0x01"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&name=C++反汇编 0x01&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/10/26/Cpp-disassemble-1/&t=C++反汇编 0x01"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    bxz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
