<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="baidu-site-verification" content="codeva-ROfYcqLkCh" />
    <meta name="msvalidate.01" content="ECA3E06A0E52A2AC90C4B06F12981FB2" />
    <meta name="description" content="PE(Portable Executable) File ParsingWIN32 PE文件解析 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1SR6IgJ645IBTPWy3PXNQgQ提取码：4veh  RVA：Relative Virtual Address（相对虚拟地址）。RVA 是指相对于映像基址的地址偏移量，在内存中定位特定数据的地址。 RAW：Raw Data（原始数据）。">
<meta property="og:type" content="article">
<meta property="og:title" content="PE文件解析(PE File Parsing)">
<meta property="og:url" content="https://grxer.gitee.io/2023/05/19/PE-FILE/index.html">
<meta property="og:site_name" content="Grxer&#39;s Blog">
<meta property="og:description" content="PE(Portable Executable) File ParsingWIN32 PE文件解析 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1SR6IgJ645IBTPWy3PXNQgQ提取码：4veh  RVA：Relative Virtual Address（相对虚拟地址）。RVA 是指相对于映像基址的地址偏移量，在内存中定位特定数据的地址。 RAW：Raw Data（原始数据）。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230518235342704.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519163927062.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519164252693.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519164805090.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519164941785.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519165226573.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519171519020.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519172810749.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519172307227.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519172921483.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519174316053.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519174410251.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519180741267.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519181813832.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519181542374.png">
<meta property="og:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230519180449954.png">
<meta property="article:published_time" content="2023-05-19T10:47:39.000Z">
<meta property="article:modified_time" content="2024-02-15T14:52:48.654Z">
<meta property="article:author" content="bxz">
<meta property="article:tag" content="PE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://grxer.gitee.io/2023/05/19/PE-FILE/image-20230518235342704.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>PE文件解析(PE File Parsing)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 lrt">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/05/20/2023-5-20/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/05/13/x86-nemu-pa1/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/05/19/PE-FILE/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&text=PE文件解析(PE File Parsing)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&is_video=false&description=PE文件解析(PE File Parsing)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=PE文件解析(PE File Parsing)&body=Check out this article: https://grxer.gitee.io/2023/05/19/PE-FILE/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&name=PE文件解析(PE File Parsing)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/05/19/PE-FILE/&t=PE文件解析(PE File Parsing)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PE-Portable-Executable-File-Parsing"><span class="toc-number">1.</span> <span class="toc-text">PE(Portable Executable) File Parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4"><span class="toc-number">1.1.</span> <span class="toc-text">PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E5%A4%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">DOS头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E5%AD%98%E6%A0%B9-stub"><span class="toc-number">1.1.2.</span> <span class="toc-text">DOS存根(stub)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NT-x2F-PE%E5%A4%B4"><span class="toc-number">1.1.3.</span> <span class="toc-text">NT&#x2F;PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Signature"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Signature</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86PE%E5%A4%B4-IMAGE-FILE-HEADER-FileHeader"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">标准PE头 IMAGE_FILE_HEADER FileHeader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95PE%E5%A4%B4-IMAGE-OPTIONAL-HEADER32-OptionalHeader"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E5%8C%BA%E5%A4%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text">节区头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">导出表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lpPro0cName%E5%8F%82%E6%95%B0%E6%98%AFname%E6%97%B6%EF%BC%88%E5%A4%A7%E4%BA%8E-0x10000%EF%BC%89"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">lpPro0cName参数是name时（大于 0x10000）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lpPro0cName%E5%8F%82%E6%95%B0%E6%98%AF%E5%BA%8F%E5%8F%B7%E6%97%B6%EF%BC%88%E5%B0%8F%E4%BA%8E-0x10000%EF%BC%89"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">lpPro0cName参数是序号时（小于 0x10000）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#some-opertion-about-pe"><span class="toc-number">1.4.</span> <span class="toc-text">some opertion about pe</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        PE文件解析(PE File Parsing)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">bxz</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-05-19T10:47:39.000Z" itemprop="datePublished">2023-05-19</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/PE/" rel="tag">PE</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="PE-Portable-Executable-File-Parsing"><a href="#PE-Portable-Executable-File-Parsing" class="headerlink" title="PE(Portable Executable) File Parsing"></a>PE(Portable Executable) File Parsing</h1><p>WIN32 PE文件解析</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1SR6IgJ645IBTPWy3PXNQgQ">https://pan.baidu.com/s/1SR6IgJ645IBTPWy3PXNQgQ</a><br>提取码：4veh</p>
<ul>
<li>RVA：Relative Virtual Address（相对虚拟地址）。RVA 是指相对于映像基址的地址偏移量，在内存中定位特定数据的地址。</li>
<li>RAW：Raw Data（原始数据）。RAW 是指 PE 文件中未经任何处理或压缩的原始二进制数据，它直接从文件中读取，例如节的原始数据。有的也叫FOA(file offset address)</li>
</ul>
<p><img src="/2023/05/19/PE-FILE/image-20230518235342704.png" alt="image-20230518235342704"></p>
<h2 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>64字节，主要是为了兼容当时比较盛行的DOS系统,我们只关心下面两个</p>
<ul>
<li>e_magic:dos签名 4D5A(MZ)</li>
<li>e_lfanew:NT&#x2F;PE头偏移(IMAGE_NT_HEADERS)<ul>
<li>如果该值为0，则该文件是一个DOS“MZ“可执行文件，Windows会启动DOS子系统来执行它，否则为Windows的PE可执行文件</li>
</ul>
</li>
</ul>
<h3 id="DOS存根-stub"><a href="#DOS存根-stub" class="headerlink" title="DOS存根(stub)"></a>DOS存根(stub)</h3><p>e_lfanew偏移和_IMAGE_DOS_HEADER之间位置</p>
<p>前0xd字节是16位的汇编，输出This program cannot be run in DOS mode.后退出</p>
<p>dos头的e_cs e_ip一般指向这里</p>
<h3 id="NT-x2F-PE头"><a href="#NT-x2F-PE头" class="headerlink" title="NT&#x2F;PE头"></a>NT&#x2F;PE头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>PE签名 0x50450000(“PE00”)</p>
<h4 id="标准PE头-IMAGE-FILE-HEADER-FileHeader"><a href="#标准PE头-IMAGE-FILE-HEADER-FileHeader" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER FileHeader"></a>标准PE头 IMAGE_FILE_HEADER FileHeader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;                <span class="comment">// 目标机器的体系结构类型。</span></span><br><span class="line">    WORD    NumberOfSections;       <span class="comment">// 文件中的节的数量。</span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 文件创建或修改的时间戳。</span></span><br><span class="line">    DWORD   PointerToSymbolTable;   <span class="comment">// COFF符号表的文件偏移量。</span></span><br><span class="line">    DWORD   NumberOfSymbols;        <span class="comment">// COFF符号表中的符号数量。</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;   <span class="comment">// 可选头的大小（以字节为单位）。</span></span><br><span class="line">    WORD    Characteristics;        <span class="comment">// 文件的特性标志。</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<ul>
<li>Machine<ul>
<li>PE文件的目标架构,执行文件所针对的CPU或处理器架构类型</li>
</ul>
</li>
<li>NumberOfSections<ul>
<li>节表数量</li>
</ul>
</li>
<li>TimeDateStamp<ul>
<li>PE文件的创建或修改时间戳</li>
</ul>
</li>
<li>PointerToSymbolTable<ul>
<li>符号表在文件中的偏移量</li>
</ul>
</li>
<li>SizeOfOptionalHeader<ul>
<li>IMAGE_OPTIONAL_HEADER32结构体长度</li>
</ul>
</li>
<li>Characteristics<ul>
<li>标示文件的属性 是否为dll，是否可执行等，bitOR形式</li>
</ul>
</li>
</ul>
<h4 id="扩展PE头-IMAGE-OPTIONAL-HEADER32-OptionalHeader"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER32-OptionalHeader" class="headerlink" title="扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader"></a>扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;     <span class="comment">// 数据目录项在内存中的虚拟地址。</span></span><br><span class="line">    DWORD   Size;               <span class="comment">// 数据目录项的大小（字节数）。</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;                         <span class="comment">// 魔术字段，标识可选头的格式（32位或64位）。</span></span><br><span class="line">    BYTE    MajorLinkerVersion;            <span class="comment">// 链接器的主版本号。</span></span><br><span class="line">    BYTE    MinorLinkerVersion;            <span class="comment">// 链接器的次版本号。</span></span><br><span class="line">  <span class="comment">//下面三个操作系统没用，但是有些软件可能会</span></span><br><span class="line">    DWORD   SizeOfCode;                    <span class="comment">// 代码段的大小，以字节为单位。 </span></span><br><span class="line">    DWORD   SizeOfInitializedData;         <span class="comment">// 已初始化数据段的大小，以字节为单位。</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;       <span class="comment">// 未初始化数据段的大小，以字节为单位。</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;           <span class="comment">// 程序入口点（程序的起始执行地址）相对于映像基址的偏移量。</span></span><br><span class="line">    DWORD   BaseOfCode;                    <span class="comment">// 代码段的起始地址相对于映像基址的偏移量。</span></span><br><span class="line">    DWORD   BaseOfData;                    <span class="comment">// 数据段（仅用于PE32）的起始地址相对于映像基址的偏移量。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;                     <span class="comment">// 程序的首选装载地址（映像基址）。</span></span><br><span class="line">    DWORD   SectionAlignment;              <span class="comment">// 节的内存对齐大小，以字节为单位。</span></span><br><span class="line">    DWORD   FileAlignment;                 <span class="comment">// 文件对齐大小，以字节为单位。</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;   <span class="comment">// 操作系统的主版本号要求。</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;   <span class="comment">// 操作系统的次版本号要求。</span></span><br><span class="line">    WORD    MajorImageVersion;             <span class="comment">// 映像文件的主版本号。</span></span><br><span class="line">    WORD    MinorImageVersion;             <span class="comment">// 映像文件的次版本号。</span></span><br><span class="line">    WORD    MajorSubsystemVersion;         <span class="comment">// 子系统的主版本号要求。</span></span><br><span class="line">    WORD    MinorSubsystemVersion;         <span class="comment">// 子系统的次版本号要求。</span></span><br><span class="line">    DWORD   Win32VersionValue;             <span class="comment">// 保留字段，用于指定Win32运行时版本。</span></span><br><span class="line">    DWORD   SizeOfImage;                   <span class="comment">// 映像的内存大小，包括所有头和节的大小。</span></span><br><span class="line">    DWORD   SizeOfHeaders;                 <span class="comment">// 头的总大小，包括所有头的大小。</span></span><br><span class="line">    DWORD   CheckSum;                      <span class="comment">// 映像文件的校验和。</span></span><br><span class="line">    WORD    Subsystem;                     <span class="comment">// 程序所依赖的子系统类型。</span></span><br><span class="line">    WORD    DllCharacteristics;            <span class="comment">// DLL文件的特性标志。</span></span><br><span class="line">    DWORD   SizeOfStackReserve;            <span class="comment">// 初始化堆栈的保留内存大小。</span></span><br><span class="line">    DWORD   SizeOfStackCommit;             <span class="comment">// 初始化堆栈的提交内存大小。</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;             <span class="comment">// 初始化堆的保留内存大小。</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;              <span class="comment">// 初始化堆的提交内存大小。</span></span><br><span class="line">    DWORD   LoaderFlags;                   <span class="comment">// 加载器标志。</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;           <span class="comment">// 数据目录项的数量。</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];   <span class="comment">// 数据目录数组。</span></span><br><span class="line"></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Magic</p>
<ul>
<li>32位为0x10B，64位为0x20B</li>
</ul>
</li>
<li><p>AddressOfEntryPoint</p>
<ul>
<li>RVA值，程序入口点</li>
</ul>
</li>
<li><p>ImageBase</p>
<ul>
<li>PE文件被加载到内存地址，加载完后，EIP指向ImageBase+AddressOfEntryPoint</li>
</ul>
</li>
<li><p>SizeOfImage</p>
<ul>
<li>PE文件装载到虚拟内存后的大小</li>
</ul>
</li>
<li><p>SizeOfHeaders</p>
<ul>
<li>PE头按照FileAlignment对齐后的大小，包括section head</li>
</ul>
</li>
<li><p>Subsystem</p>
<ul>
<li>区分系统文件和普通可执行文件</li>
<li>系统驱动：drive 窗口：GUI 控制台：CUI 等</li>
</ul>
</li>
<li><p>NumberOfRvaAndSizes</p>
<ul>
<li>DataDirectory数目</li>
</ul>
</li>
<li><p>DataDirectory</p>
<ul>
<li><table>
<thead>
<tr>
<th>数据目录项</th>
<th>索引位置</th>
</tr>
</thead>
<tbody><tr>
<td>导出表（Export Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> (0)</td>
</tr>
<tr>
<td>导入表（Import Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_IMPORT</code> (1)</td>
</tr>
<tr>
<td>资源表（Resource Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_RESOURCE</code> (2)</td>
</tr>
<tr>
<td>异常表（Exception Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_EXCEPTION</code> (3)</td>
</tr>
<tr>
<td>安全表（Security Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_SECURITY</code> (4)</td>
</tr>
<tr>
<td>重定位表（Base Relocation Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_BASERELOC</code> (5)</td>
</tr>
<tr>
<td>调试表（Debug Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_DEBUG</code> (6)</td>
</tr>
<tr>
<td>版本信息（Version Information）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</code> (7)</td>
</tr>
<tr>
<td>全局指针（Global Pointer）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</code> (8)</td>
</tr>
<tr>
<td>TLS表（Thread Local Storage Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_TLS</code> (9)</td>
</tr>
<tr>
<td>载入配置表（Load Configuration Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</code> (10)</td>
</tr>
<tr>
<td>绑定导入表（Bound Import Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</code> (11)</td>
</tr>
<tr>
<td>IAT表（Import Address Table）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_IAT</code> (12)</td>
</tr>
<tr>
<td>延迟导入描述符（Delay Import Descriptor）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</code> (13)</td>
</tr>
<tr>
<td>COM运行时描述符（COM Runtime Descriptor）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</code> (14)</td>
</tr>
<tr>
<td>保留（Reserved）</td>
<td><code>IMAGE_DIRECTORY_ENTRY_RESERVED</code> (15)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];   <span class="comment">// 节名称，最多8个字符（如果名称长度不足8个字符，用空格填充）。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   PhysicalAddress;              <span class="comment">// 在物理地址的上下文中使用的节的物理地址。</span></span><br><span class="line">        DWORD   VirtualSize;                  <span class="comment">// 在内存中分配给节的虚拟大小。</span></span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;                   <span class="comment">// 节的虚拟地址（相对于映像基址的偏移量）。</span></span><br><span class="line">    DWORD   SizeOfRawData;                     <span class="comment">// 节的在文件中占用的大小（以字节为单位）。</span></span><br><span class="line">    DWORD   PointerToRawData;                  <span class="comment">// 节在文件中的偏移量。</span></span><br><span class="line">    <span class="comment">//前四个成员倒着看比较好看：节在文件里的位置和大小拷贝到内存里的位置和大小</span></span><br><span class="line">    DWORD   PointerToRelocations;              <span class="comment">// 重定位表的文件偏移量。</span></span><br><span class="line">    DWORD   PointerToLinenumbers;              <span class="comment">// 行号表的文件偏移量。</span></span><br><span class="line">    WORD    NumberOfRelocations;               <span class="comment">// 重定位项的数量。</span></span><br><span class="line">    WORD    NumberOfLinenumbers;               <span class="comment">// 行号项的数量。</span></span><br><span class="line">    <span class="comment">//上面四项系统不依赖</span></span><br><span class="line">    DWORD   Characteristics;                   <span class="comment">// 节的特性标志。</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>RAW(文件偏移)&#x3D;RVA-VirtualAddress+PointerToRawData</p>
<blockquote>
<p>这个换算有时候是不对的，比如说有未初始化初始的数据节，为了节约磁盘空间，VirtualSize比SizeOfRawData要大，换算后节区会不一样、</p>
</blockquote>
<p>PE头内的话 RAW&#x3D;RVA</p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p>_IMAGE_OPTIONAL_HEADER里DataDirectory的第二项，导入多少个库就有多少个_IMAGE_IMPORT_DESCRIPTOR结构，最后以一个空结构体结尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p><strong>以notepad为例</strong></p>
<p>&gt;&gt;&gt;<strong>Name</strong></p>
<p>就是当前模块依赖模块名字</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519163927062.png" alt="image-20230519163927062"></p>
<p>0x7604是RVA</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519164252693.png" alt="image-20230519164252693"></p>
<p>可以看出0x7604他在第一个section(PE文件的section相比于ELF很少)</p>
<p>RAW&#x3D;RVA-VirtualAddress+PointerToRawData&#x3D;0x7604-0x1000+0x400&#x3D;0x6A04</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519164805090.png" alt="image-20230519164805090"></p>
<p>他的name字段就是0x7AAC，同样位于第一个节区RAW&#x3D;0x7AAC-0x1000+0x400&#x3D;0x6EAC</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519164941785.png" alt="image-20230519164941785"></p>
<p><img src="/2023/05/19/PE-FILE/image-20230519165226573.png" alt="image-20230519165226573"></p>
<p><strong>他的OriginalFirstThunk和FirstThunk分别指向INT(Import Name Table ，导入名称表) 和IAT（Import Address Table ，导入地址表）</strong></p>
<p>&gt;&gt;&gt;<strong>OriginalFirstThunk:INT表</strong>(导入名称表)</p>
<p>指向_IMAGE_THUNK_DATA32数组的RVA</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// 指向转发字符串的指针（PBYTE）。</span></span><br><span class="line">        DWORD Function;             <span class="comment">// 指向函数地址的指针（PDWORD）。</span></span><br><span class="line">        DWORD Ordinal;              <span class="comment">// 导入函数的序号（用于按序号导入）。</span></span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// 指向 IMAGE_IMPORT_BY_NAME 结构的指针（PIMAGE_IMPORT_BY_NAME）。</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;       <span class="comment">// 函数名称的提示（用于加速导入的查找过程）。</span></span><br><span class="line">    CHAR   Name[<span class="number">1</span>];    <span class="comment">// 函数名称（以NULL结尾的ASCII字符串）。</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>u1的最高位为1，去除这个1，其余就是导入函数的序号Ordinal，否则就是AddressOfData	</p>
</blockquote>
<p><img src="/2023/05/19/PE-FILE/image-20230519171519020.png" alt="image-20230519171519020"></p>
<p>RAW&#x3D;0x6D90 0x6D90处就是_IMAGE_THUNK_DATA32数组，同样以NULL结构体结尾</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519172810749.png" alt="image-20230519172810749"></p>
<p>RVA&#x3D;0x7A7A RAW&#x3D;0x6E7A，指向_IMAGE_IMPORT_BY_NAME结构体</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519172307227.png" alt="image-20230519172307227"></p>
<p>0xF为库中函数序号，后面是导入函数名称</p>
<p>后面0x7a5e RAW为0x6e50</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519172921483.png" alt="image-20230519172921483"></p>
<p>&gt;&gt;&gt;<strong>FirstThunk:IAT表</strong>(导入地址表)</p>
<p>同样是指向_IMAGE_THUNK_DATA32数组的RVA</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519174316053.png" alt="image-20230519174316053"></p>
<p>RAW为0x6c4</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519174410251.png" alt="image-20230519174410251"></p>
<p>一堆不明所以的数据</p>
<p>丢到x32dbg看看</p>
<blockquote>
<p>由于可执行文件PE是是进程第一个加载的模块，所以他几乎百分百都能抢到他原来的imagebase(除了开了aslr的情况)，不需要去做重定位，所以这个IAT地址直接就是RVA+ImageBase</p>
</blockquote>
<p>RVA+ImageBase&#x3D;0x10012c4</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519180741267.png" alt="image-20230519180741267"></p>
<p><img src="/2023/05/19/PE-FILE/image-20230519181813832.png" alt="image-20230519181813832"></p>
<p>0x77243e60这个地址就是PageSetupDlgw导入函数地址</p>
<p><img src="/2023/05/19/PE-FILE/image-20230519181542374.png" alt="image-20230519181542374"></p>
<p><img src="/2023/05/19/PE-FILE/image-20230519180449954.png" alt="image-20230519180449954"></p>
<p>类似于ELF里的got表,调用这种导入函数时是一个间接调用call *(iat)</p>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>_IMAGE_OPTIONAL_HEADER里DataDirectory的第一项，导出表只有一个</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;        <span class="comment">// 导出表的特性标志。</span></span><br><span class="line">    DWORD   TimeDateStamp;          <span class="comment">// 导出表的时间戳。</span></span><br><span class="line">    WORD    MajorVersion;           <span class="comment">// 导出表的主要版本号。</span></span><br><span class="line">    WORD    MinorVersion;           <span class="comment">// 导出表的次要版本号。</span></span><br><span class="line">    DWORD   Name;                   <span class="comment">// 模块名称的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   Base;                   <span class="comment">// 导出函数的起始序号。</span></span><br><span class="line">    DWORD   NumberOfFunctions;      <span class="comment">// 导出函数的数量。</span></span><br><span class="line">    DWORD   NumberOfNames;          <span class="comment">// 导出函数名称的数量。</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">// 导出函数地址表的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">// 导出函数名称表的 RVA（相对虚拟地址）。</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">// 导出函数序号表的 RVA（相对虚拟地址）。</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NumberOfFunctions函数，导出时不按序号顺序导出，空余位也计入，比如1，5，2，3 但是NumberOfFunctions&#x3D;5</p>
<p>所以就需要导出函数序号表的将函数地址和名称联系起来</p>
<p>导出函数可以没有名字但是一定要有序号</p>
</blockquote>
<p>看一下GetProcAddress是如何解析的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(HMODULE hModule ,LPCWSTR lpPro0cName)</span></span><br></pre></td></tr></table></figure>

<h4 id="lpPro0cName参数是name时（大于-0x10000）"><a href="#lpPro0cName参数是name时（大于-0x10000）" class="headerlink" title="lpPro0cName参数是name时（大于 0x10000）"></a>lpPro0cName参数是name时（大于 0x10000）</h4><ul>
<li>根据AddressOfNames的RVA找到导出函数名称表(里面时字符串指针的RVA)，利用strcmp比较字符串，找到名称，并记录下该名称在导出函数名称表的named_index，名称表里的指针指向的名字都是A-Za-z排序好的，按照朴素的二分法效率蛮高的 毕竟最多log2(n) 次嘛:)</li>
<li>AddressOfNameOrdinals找到导出函数序号表，根据named_index找到对应的orinal</li>
<li>AddressOfFunctions找到导出函数地址表的(EAT  Export Address Table)，根据orinal找到函数的RVA</li>
</ul>
<h4 id="lpPro0cName参数是序号时（小于-0x10000）"><a href="#lpPro0cName参数是序号时（小于-0x10000）" class="headerlink" title="lpPro0cName参数是序号时（小于 0x10000）"></a>lpPro0cName参数是序号时（小于 0x10000）</h4><ul>
<li>序号减去Base（起始序号）得到index</li>
<li>根据index去函数地址表去找</li>
</ul>
<h2 id="some-opertion-about-pe"><a href="#some-opertion-about-pe" class="headerlink" title="some opertion about pe"></a>some opertion about pe</h2><p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;C:\\Users\\zbx\\Desktop\\notepad.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWNAME <span class="string">&quot;new.exe&quot;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[<span class="number">18</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x6A</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xE8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xE9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> size = <span class="number">18</span>;</span><br><span class="line">DWORD AddNewSectionSize=<span class="number">0x1000</span>;</span><br><span class="line">DWORD ExpandSectionSize = <span class="number">0x1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//*********FiletoImageToFile********</span></span><br><span class="line">    <span class="comment">/*void* Filebuffer;</span></span><br><span class="line"><span class="comment">    void* Imagebuffer;</span></span><br><span class="line"><span class="comment">    void* Newfilebuffer;</span></span><br><span class="line"><span class="comment">    size_t size;</span></span><br><span class="line"><span class="comment">    size = PeCopyToFilebuffer(NAME, &amp;Filebuffer);</span></span><br><span class="line"><span class="comment">    FileToImage(Filebuffer, &amp;Imagebuffer);</span></span><br><span class="line"><span class="comment">    ImageToFile(Imagebuffer, &amp;Newfilebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME, size, Newfilebuffer);</span></span><br><span class="line"><span class="comment">    free(Filebuffer);</span></span><br><span class="line"><span class="comment">    free(Imagebuffer);</span></span><br><span class="line"><span class="comment">    free(Newfilebuffer);</span></span><br><span class="line"><span class="comment">    printf(&quot;get a new one &quot;);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//********GetMessageBoxA********</span></span><br><span class="line">    <span class="comment">/*size_t size;</span></span><br><span class="line"><span class="comment">    void* filebuffer = NULL;</span></span><br><span class="line"><span class="comment">    size = PeCopyToFilebuffer(NAME, &amp;filebuffer);</span></span><br><span class="line"><span class="comment">    AddShellcode(filebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME, size, filebuffer);</span></span><br><span class="line"><span class="comment">    free(filebuffer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//********AddANewSection*********</span></span><br><span class="line">    <span class="comment">/*void* filebuffer=NULL;</span></span><br><span class="line"><span class="comment">    void* newfilebuffer=NULL;</span></span><br><span class="line"><span class="comment">    size_t size = 0;</span></span><br><span class="line"><span class="comment">    size_t newsize = 0;</span></span><br><span class="line"><span class="comment">    size=PeCopyToFilebuffer(NAME,&amp;filebuffer);</span></span><br><span class="line"><span class="comment">    newsize =AddANewSection(filebuffer,size,&amp;newfilebuffer);</span></span><br><span class="line"><span class="comment">    FilebufferCopytoPe(NEWNAME,newsize,newfilebuffer);</span></span><br><span class="line"><span class="comment">    free(filebuffer);</span></span><br><span class="line"><span class="comment">    free(newfilebuffer);*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//***********ExpandTheLastSection*********</span></span><br><span class="line">    <span class="type">void</span>* filebuffer=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* newfilebuffer=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> newsize = <span class="number">0</span>;</span><br><span class="line">    size=PeCopyToFilebuffer(NAME,&amp;filebuffer);</span><br><span class="line">    newsize = ExpandTheLastSection(filebuffer,size,&amp;newfilebuffer);</span><br><span class="line">    FilebufferCopytoPe(NEWNAME,newsize,newfilebuffer);</span><br><span class="line">    <span class="built_in">free</span>(filebuffer);</span><br><span class="line">    <span class="built_in">free</span>(newfilebuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>init.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FileToimagetofile</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FileTOimagetofile</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">DWORD <span class="title function_">PeCopyToFilebuffer</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, OUT <span class="type">void</span>** pointer)</span>;</span><br><span class="line">DWORD <span class="title function_">FileToImage</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Filept, OUT <span class="type">void</span>** Imagept)</span>;</span><br><span class="line">DWORD <span class="title function_">ImageToFile</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Imagept, OUT <span class="type">void</span>** Filept)</span>;</span><br><span class="line">DWORD <span class="title function_">FilebufferCopytoPe</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">void</span>* Filept)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">AddANewSection</span><span class="params">(IN <span class="type">void</span> *filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer,OUT <span class="type">void</span> **newfilebuffer)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AddShellcode</span><span class="params">(IN <span class="type">void</span>* filebuffer)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ExpandTheLastSection</span><span class="params">(IN <span class="type">void</span> * filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer,OUT <span class="type">void</span> **newfilebuffer)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>init.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> shellcode[<span class="number">18</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">extern</span> DWORD AddNewSectionSize;</span><br><span class="line"><span class="keyword">extern</span> DWORD ExpandSectionSize;</span><br><span class="line">DWORD <span class="title function_">PeCopyToFilebuffer</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, OUT <span class="type">void</span>** pointer)</span> &#123;</span><br><span class="line">    FILE* PE = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span>* Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    DWORD fin;</span><br><span class="line">    PE = fopen(name, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == PE) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file open PE %s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(PE, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    size = ftell(PE);</span><br><span class="line">    Filebuffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">    fseek(PE, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    fread(Filebuffer, size, <span class="number">1</span>, PE);</span><br><span class="line">    *pointer = Filebuffer;</span><br><span class="line">    Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    fclose(PE);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">FileToImage</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Filept, OUT <span class="type">void</span>** Imagept)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PimageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeads = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PimageDosHeader = (PIMAGE_DOS_HEADER)Filept;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PimageDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeads = (PIMAGE_NT_HEADERS)((<span class="type">char</span>*)Filept + PimageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)PNtHeads != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)Filept + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader + IMAGE_SIZEOF_FILE_HEADER + <span class="number">4</span>);<span class="comment">//pe头包括标准头（FILEHEADER），可选pe头（OPTIONHEADER）和四个字节的PE标识；</span></span><br><span class="line">    <span class="type">void</span>* PImagetemp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> size = PNtHeads-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">    PImagetemp = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(PImagetemp, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">memcpy</span>(PImagetemp, Filept, PNtHeads-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; i++, PSectionHeader++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;FileToImage%x\n&quot;</span>, PSectionHeader-&gt;VirtualAddress);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)((<span class="type">char</span>*)PImagetemp + PSectionHeader-&gt;VirtualAddress), (<span class="type">void</span>*)((<span class="type">char</span>*)Filept + PSectionHeader-&gt;PointerToRawData), PSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    *Imagept = PImagetemp;</span><br><span class="line">    PImagetemp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> PNtHeads-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">ImageToFile</span><span class="params">(IN <span class="type">const</span> <span class="type">void</span>* Imagept, OUT <span class="type">void</span>** Filept)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span>* Filebuffer;</span><br><span class="line">    PIMAGE_DOS_HEADER PimageDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeads = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PimageDosHeader = (PIMAGE_DOS_HEADER)Imagept;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PimageDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeads = (PIMAGE_NT_HEADERS)((<span class="type">char</span>*)Imagept + PimageDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)PNtHeads != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)Imagept + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">    size = PNtHeads-&gt;OptionalHeader.SizeOfHeaders;</span><br><span class="line">    PIMAGE_SECTION_HEADER tempPsection = PSectionHeader;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; ++tempPsection, ++i) &#123;</span><br><span class="line">        size += tempPsection-&gt;SizeOfRawData;</span><br><span class="line">    &#125;</span><br><span class="line">    Filebuffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(Filebuffer, <span class="number">0</span>, size);</span><br><span class="line">    <span class="built_in">memcpy</span>(Filebuffer, Imagept, PNtHeads-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeads-&gt;FileHeader.NumberOfSections; ++PSectionHeader, ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ImageToFile%x\n&quot;</span>, PSectionHeader-&gt;PointerToRawData);</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)((<span class="type">char</span>*)Filebuffer + PSectionHeader-&gt;PointerToRawData), (<span class="type">void</span>*)((<span class="type">char</span>*)Imagept + PSectionHeader-&gt;VirtualAddress), PSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">    &#125;</span><br><span class="line">    *Filept = Filebuffer;</span><br><span class="line">    Filebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line">DWORD <span class="title function_">FilebufferCopytoPe</span><span class="params">(IN <span class="type">const</span> <span class="type">char</span>* name, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">void</span>* Filept)</span> &#123;</span><br><span class="line">    FILE* tempfp;</span><br><span class="line">    tempfp = fopen(name, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == tempfp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file open PE %s&quot;</span>, name);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(Filept, size, <span class="number">1</span>, tempfp);</span><br><span class="line">    fclose(tempfp);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AddShellcode</span><span class="params">(IN <span class="type">void</span>* filebuffer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">//PSectionHeader = (PIMAGE_SECTION_HEADER)((char*)Filept + PimageDosHeader-&gt;e_lfanew + PNtHeads-&gt;FileHeader.SizeOfOptionalHeader + IMAGE_SIZEOF_FILE_HEADER + 4);</span></span><br><span class="line">    <span class="keyword">if</span> ((PSectionHeader-&gt;SizeOfRawData - *(PDWORD)PSectionHeader) &lt; size) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;to small&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD jmpaddress;</span><br><span class="line">    DWORD calladdress;</span><br><span class="line">    DWORD newenterypointer = PSectionHeader-&gt;VirtualAddress + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PSectionHeader-&gt;PointerToRawData%x\nPSectionHeader-&gt;Misc.VirtualSize%x\n&quot;</span>, PSectionHeader-&gt;PointerToRawData, PSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DWORD newenterypointer = 0x1a723;</span></span><br><span class="line"></span><br><span class="line">    calladdress = <span class="number">0x7672A820</span> - (<span class="number">8</span> + newenterypointer + <span class="number">5</span> + PNtHeaders-&gt;OptionalHeader.ImageBase);</span><br><span class="line">    jmpaddress = PNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint - (PSectionHeader-&gt;VirtualAddress + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span> + <span class="number">8</span> + <span class="number">5</span> + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//addressofneters是在内存中的位置</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call:%x\njmp:%x\n&quot;</span>, calladdress, jmpaddress);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;shellcode[<span class="number">9</span>], &amp;calladdress, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;shellcode[<span class="number">14</span>], &amp;jmpaddress, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//printf(&quot;size:%d\n&quot;, size);</span></span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint = newenterypointer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">char</span>*)(filebuffer)+PSectionHeader-&gt;PointerToRawData + PSectionHeader-&gt;Misc.VirtualSize + <span class="number">1</span>), shellcode, size);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size:%d\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%X  &quot;</span>, shellcode[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, newenterypointer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">AddANewSection</span><span class="params">(IN <span class="type">void</span>* filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer, OUT <span class="type">void</span>** newfilebuffer)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER LastSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    DWORD sectionsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PNtHeaders-&gt;FileHeader.NumberOfSections; ++i) &#123;</span><br><span class="line">        sectionsize += IMAGE_SIZEOF_SECTION_HEADER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((PNtHeaders-&gt;OptionalHeader.SizeOfHeaders - sectionsize - IMAGE_SIZEOF_FILE_HEADER - PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader - PDosHeader-&gt;e_lfanew - <span class="number">4</span>) &lt; (<span class="number">2</span> * IMAGE_SIZEOF_SECTION_HEADER)) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;size too small&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.SizeOfImage += AddNewSectionSize;</span><br><span class="line">    PNtHeaders-&gt;FileHeader.NumberOfSections += <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> newfile_size = sizeoffilebuffer + AddNewSectionSize;</span><br><span class="line">    <span class="type">void</span>* tempnewfilebuffer = <span class="built_in">malloc</span>(newfile_size);<span class="comment">//需要判断是否申请成功，没写；</span></span><br><span class="line">    <span class="built_in">memset</span>(tempnewfilebuffer, <span class="number">0</span>, newfile_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(tempnewfilebuffer, filebuffer, sizeoffilebuffer);</span><br><span class="line">    IMAGE_SECTION_HEADER sectionsource;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sectionsource, PSectionHeader, IMAGE_SIZEOF_SECTION_HEADER);</span><br><span class="line">    PIMAGE_SECTION_HEADER Psectionsource = &amp;sectionsource;</span><br><span class="line">    <span class="comment">//printf(&quot;%p,%p  &quot; ,&amp; sectionsource,Psectionsource);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sectionsource, <span class="string">&quot;.grxer&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;.grxer&quot;</span>));</span><br><span class="line">    <span class="comment">//(char*)Psectionsource = &quot;.grr&quot;;//这种赋值方式给的是常量字符串的地址，lea</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p,%p&quot;, &amp;sectionsource, Psectionsource);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, sectionsource.Name);</span><br><span class="line">    sectionsource.Misc.VirtualSize = AddNewSectionSize;</span><br><span class="line">    <span class="comment">//LastSectionHeader =(PSectionHeader + PNtHeaders-&gt;FileHeader.NumberOfSections - 2);</span></span><br><span class="line">    LastSectionHeader = &amp;PSectionHeader[PNtHeaders-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">    sectionsource.VirtualAddress = LastSectionHeader-&gt;VirtualAddress + LastSectionHeader-&gt;SizeOfRawData;<span class="comment">//there should use the max of SizeOfRawData and VirtualSize</span></span><br><span class="line">    sectionsource.SizeOfRawData = AddNewSectionSize;</span><br><span class="line">    sectionsource.PointerToRawData = LastSectionHeader-&gt;PointerToRawData + LastSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sectionsource.VirtualAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(((<span class="type">char</span>*)tempnewfilebuffer + sectionsize + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew + <span class="number">4</span>), &amp;sectionsource, IMAGE_SIZEOF_SECTION_HEADER);</span><br><span class="line">    *newfilebuffer = tempnewfilebuffer;</span><br><span class="line">    tempnewfilebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newfile_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ExpandTheLastSection</span><span class="params">(IN <span class="type">void</span>* filebuffer, IN <span class="type">size_t</span> sizeoffilebuffer, OUT <span class="type">void</span>** newfilebuffer)</span> &#123;</span><br><span class="line">    PIMAGE_DOS_HEADER PDosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HEADERS PNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HEADER PSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PDosHeader = (PIMAGE_DOS_HEADER)filebuffer;</span><br><span class="line">    PIMAGE_SECTION_HEADER PLastSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(PWORD)PDosHeader != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PNtHeaders = (<span class="type">void</span>*)((<span class="type">char</span>*)filebuffer + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (*(PDWORD)(PNtHeaders) != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;not PE&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PSectionHeader = (PIMAGE_SECTION_HEADER)((<span class="type">char</span>*)filebuffer + <span class="number">4</span> + IMAGE_SIZEOF_FILE_HEADER + PNtHeaders-&gt;FileHeader.SizeOfOptionalHeader + PDosHeader-&gt;e_lfanew);</span><br><span class="line">    PLastSectionHeader = &amp;PSectionHeader[PNtHeaders-&gt;FileHeader.NumberOfSections - <span class="number">1</span>];</span><br><span class="line">    <span class="type">size_t</span> finaddsize = (ExpandSectionSize / PNtHeaders-&gt;OptionalHeader.SectionAlignment) * PNtHeaders-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    <span class="keyword">if</span> ((ExpandSectionSize - finaddsize) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finaddsize += PNtHeaders-&gt;OptionalHeader.SectionAlignment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> newfilebuffersize = sizeoffilebuffer + finaddsize;</span><br><span class="line">    <span class="type">void</span>* tempnewfilebuffer = <span class="built_in">malloc</span>(newfilebuffersize);</span><br><span class="line">    <span class="built_in">memset</span>(tempnewfilebuffer, <span class="number">0</span>, newfilebuffersize);</span><br><span class="line">    <span class="comment">// 最后节表改大小注意对齐</span></span><br><span class="line">    PLastSectionHeader-&gt;SizeOfRawData += finaddsize;</span><br><span class="line">    PLastSectionHeader-&gt;Misc.VirtualSize += finaddsize;</span><br><span class="line">    <span class="comment">// 改sizeofiimage</span></span><br><span class="line">    PNtHeaders-&gt;OptionalHeader.SizeOfImage += finaddsize;</span><br><span class="line">    <span class="comment">//改属性</span></span><br><span class="line">    PLastSectionHeader-&gt;Characteristics |= PSectionHeader-&gt;Characteristics;</span><br><span class="line">    <span class="comment">//copy</span></span><br><span class="line">    <span class="built_in">memcpy</span>(tempnewfilebuffer, filebuffer, newfilebuffersize);</span><br><span class="line">    *newfilebuffer = tempnewfilebuffer;</span><br><span class="line">    tempnewfilebuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add %x byte&quot;</span>, finaddsize);</span><br><span class="line">    <span class="keyword">return</span> newfilebuffersize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/tags/">Tag</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PE-Portable-Executable-File-Parsing"><span class="toc-number">1.</span> <span class="toc-text">PE(Portable Executable) File Parsing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4"><span class="toc-number">1.1.</span> <span class="toc-text">PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E5%A4%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">DOS头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS%E5%AD%98%E6%A0%B9-stub"><span class="toc-number">1.1.2.</span> <span class="toc-text">DOS存根(stub)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NT-x2F-PE%E5%A4%B4"><span class="toc-number">1.1.3.</span> <span class="toc-text">NT&#x2F;PE头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Signature"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Signature</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86PE%E5%A4%B4-IMAGE-FILE-HEADER-FileHeader"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">标准PE头 IMAGE_FILE_HEADER FileHeader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95PE%E5%A4%B4-IMAGE-OPTIONAL-HEADER32-OptionalHeader"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">扩展PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E5%8C%BA%E5%A4%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text">节区头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">导入表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">导出表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lpPro0cName%E5%8F%82%E6%95%B0%E6%98%AFname%E6%97%B6%EF%BC%88%E5%A4%A7%E4%BA%8E-0x10000%EF%BC%89"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">lpPro0cName参数是name时（大于 0x10000）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lpPro0cName%E5%8F%82%E6%95%B0%E6%98%AF%E5%BA%8F%E5%8F%B7%E6%97%B6%EF%BC%88%E5%B0%8F%E4%BA%8E-0x10000%EF%BC%89"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">lpPro0cName参数是序号时（小于 0x10000）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#some-opertion-about-pe"><span class="toc-number">1.4.</span> <span class="toc-text">some opertion about pe</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://grxer.gitee.io/2023/05/19/PE-FILE/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&text=PE文件解析(PE File Parsing)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&is_video=false&description=PE文件解析(PE File Parsing)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=PE文件解析(PE File Parsing)&body=Check out this article: https://grxer.gitee.io/2023/05/19/PE-FILE/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&title=PE文件解析(PE File Parsing)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://grxer.gitee.io/2023/05/19/PE-FILE/&name=PE文件解析(PE File Parsing)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://grxer.gitee.io/2023/05/19/PE-FILE/&t=PE文件解析(PE File Parsing)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2024
    bxz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

  <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a22ef0bec4e4a9c7337bea6e37ff55c1";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
        </script>

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
